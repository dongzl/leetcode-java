<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第三章 on LeetCode Cookbook</title>
    <link>https://dongzl.github.io/leetcode-java/02.Template/</link>
    <description>Recent content in 第三章 on LeetCode Cookbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://dongzl.github.io/leetcode-java/02.Template/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并查集</title>
      <link>https://dongzl.github.io/leetcode-java/02.Template/UnionFind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/02.Template/UnionFind/</guid>
      <description>并查集 UnionFind #  package template // UnionFind defind // 路径压缩 + 秩优化 type UnionFind struct { parent, rank []int count int } // Init define func (uf *UnionFind) Init(n int) { uf.count = n uf.parent = make([]int, n) uf.rank = make([]int, n) for i := range uf.parent { uf.parent[i] = i } } // Find define func (uf *UnionFind) Find(p int) int { root := p for root != uf.</description>
    </item>
    
    <item>
      <title>线段树</title>
      <link>https://dongzl.github.io/leetcode-java/02.Template/Segment_Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/02.Template/Segment_Tree/</guid>
      <description>线段树 Segment Tree #  package template // SegmentTree define type SegmentTree struct { data, tree, lazy []int left, right int merge func(i, j int) int } // Init define func (st *SegmentTree) Init(nums []int, oper func(i, j int) int) { st.merge = oper data, tree, lazy := make([]int, len(nums)), make([]int, 4*len(nums)), make([]int, 4*len(nums)) for i := 0; i &amp;lt; len(nums); i++ { data[i] = nums[i] } st.data, st.tree, st.lazy = data, tree, lazy if len(nums) &amp;gt; 0 { st.</description>
    </item>
    
  </channel>
</rss>