<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第四章 on LeetCode Cookbook</title>
    <link>https://dongzl.github.io/leetcode-java/04_Leetcode/</link>
    <description>Recent content in 第四章 on LeetCode Cookbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://dongzl.github.io/leetcode-java/04_Leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0001.Two-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0001.Two-Sum/</guid>
      <description>1. 两数之和 #  Difficulty: 简单
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题解 #  解法一：暴力求解 #  class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; for(int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0002.Add-Two-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0002.Add-Two-Numbers/</guid>
      <description>2. 两数相加 #  Difficulty: 中等
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出：7 -&amp;gt; 0 -&amp;gt; 8 原因：342 + 465 = 807 题解 #  解法一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode first = l1; ListNode second = l2; ListNode current = dummyHead; int carry = 0; while (first !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0003.Longest-Substring-Without-Repeating-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0003.Longest-Substring-Without-Repeating-Characters/</guid>
      <description>3. Longest Substring Without Repeating Characters #  题目 #  Given a string, find the length of the longest substring without repeating characters.
Example 1:
 Input: &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. Example 2:
 Input: &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1. Example 3:
 Input: &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0004.Median-of-Two-Sorted-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0004.Median-of-Two-Sorted-Arrays/</guid>
      <description>4. Median of Two Sorted Arrays #  题目 #  There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1:
nums1 = [1, 3] nums2 = [2] The median is 2.0  Example 2:
nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0007.Reverse-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0007.Reverse-Integer/</guid>
      <description>7. Reverse Integer #  题目 #  Given a 32-bit signed integer, reverse digits of an integer.
Example 1:
Input: 123 Output: 321  Example 2:
Input: -123 Output: -321  Example 3:
Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0009.Palindrome-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0009.Palindrome-Number/</guid>
      <description>9. Palindrome Number #  题目 #  Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.
Example 1:
Input: 121 Output: true Example 2:
Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:
Input: 10 Output: false Explanation: Reads 01 from right to left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0011.Container-With-Most-Water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0011.Container-With-Most-Water/</guid>
      <description>11. Container With Most Water #  题目 #  Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0013.Roman-to-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0013.Roman-to-Integer/</guid>
      <description>13. Roman to Integer #  题目 #  Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0015.3Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0015.3Sum/</guid>
      <description>15. 3Sum #  题目 #  Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
 Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 题目大意 #  给定一个数组，要求在这个数组中找出 3 个数之和为 0 的所有组合。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0016.3Sum-Closest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0016.3Sum-Closest/</guid>
      <description>16. 3Sum Closest #  题目 #  Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
 Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0017.Letter-Combinations-of-a-Phone-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0017.Letter-Combinations-of-a-Phone-Number/</guid>
      <description>17. Letter Combinations of a Phone Number #  题目 #  Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
 Example:
 Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]. Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0018.4Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0018.4Sum/</guid>
      <description>18. 4Sum #  题目 #  Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
 Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0019.Remove-Nth-Node-From-End-of-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0019.Remove-Nth-Node-From-End-of-List/</guid>
      <description>19. Remove Nth Node From End of List #  题目 #  Given a linked list, remove the n-th node from the end of list and return its head.
Example:
 Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. 题目大意 #  删除链表中倒数第 n 个结点。
解题思路 #  这道题比较简单，先循环一次拿到链表的总长度，然后循环到要删除的结点的前一个结点开始删除操作。需要注意的一个特例是，有可能要删除头结点，要单独处理。
这道题有一种特别简单的解法。设置 2 个指针，一个指针距离前一个指针 n 个距离。同时移动 2 个指针，2 个指针都移动相同的距离。当一个指针移动到了终点，那么前一个指针就是倒数第 n 个节点了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0020.Valid-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0020.Valid-Parentheses/</guid>
      <description>20. Valid Parentheses #  题目 #  Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.
Example 1:
 Input: &amp;quot;()&amp;quot; Output: true Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0021.Merge-Two-Sorted-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0021.Merge-Two-Sorted-Lists/</guid>
      <description>21. Merge Two Sorted Lists #  题目 #  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
 Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 题目大意 #  合并 2 个有序链表
解题思路 #  按照题意做即可。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0022.Generate-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0022.Generate-Parentheses/</guid>
      <description>22. Generate Parentheses #  题目 #  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ]  题目大意 #  给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
解题思路 #   这道题乍一看需要判断括号是否匹配的问题，如果真的判断了，那时间复杂度就到 O(n * 2^n)了，虽然也可以 AC，但是时间复杂度巨高。 这道题实际上不需要判断括号是否匹配的问题。因为在 DFS 回溯的过程中，会让 ( 和 ) 成对的匹配上的。  代码 #  package leetcode func generateParenthesis(n int) []string { if n == 0 { return []string{} } res := []string{} findGenerateParenthesis(n, n, &amp;#34;&amp;#34;, &amp;amp;res) return res } func findGenerateParenthesis(lindex, rindex int, str string, res *[]string) { if lindex == 0 &amp;amp;&amp;amp; rindex == 0 { *res = append(*res, str) return } if lindex &amp;gt; 0 { findGenerateParenthesis(lindex-1, rindex, str+&amp;#34;(&amp;#34;, res) } if rindex &amp;gt; 0 &amp;amp;&amp;amp; lindex &amp;lt; rindex { findGenerateParenthesis(lindex, rindex-1, str+&amp;#34;)&amp;#34;, res) } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0023.Merge-k-Sorted-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0023.Merge-k-Sorted-Lists/</guid>
      <description>23. Merge k Sorted Lists #  题目 #  Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
Example:
 Input: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 题目大意 #  合并 K 个有序链表
解题思路 #  借助分治的思想，把 K 个有序链表两两合并即可。相当于是第 21 题的加强版。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { length := len(lists) if length &amp;lt; 1 { return nil } if length == 1 { return lists[0] } num := length / 2 left := mergeKLists(lists[:num]) right := mergeKLists(lists[num:]) return mergeTwoLists1(left, right) } func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0024.Swap-Nodes-in-Pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0024.Swap-Nodes-in-Pairs/</guid>
      <description>24. 两两交换链表中的节点 #  Difficulty: 中等
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1：
 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2：
输入：head = [] 输出：[] 示例 3：
输入：head = [1] 输出：[1] 提示：
 链表中节点的数目在范围 [0, 100] 内 0 &amp;lt;= Node.val &amp;lt;= 100  题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode pre = new ListNode(-1); pre.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0025.Reverse-Nodes-in-k-Group/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0025.Reverse-Nodes-in-k-Group/</guid>
      <description>25. Reverse Nodes in k-Group #  题目 #  Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0026.Remove-Duplicates-from-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0026.Remove-Duplicates-from-Sorted-Array/</guid>
      <description>26. Remove Duplicates from Sorted Array #  题目 #  Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
 Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0027.Remove-Element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0027.Remove-Element/</guid>
      <description>27. Remove Element #  题目 #  Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
 Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0028.Implement-strStr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0028.Implement-strStr/</guid>
      <description>28. Implement strStr() #  题目 #  Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
 Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2 Example 2:
 Input: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; Output: -1 Clarification:
What should we return when needle is an empty string? This is a great question to ask during an interview.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0029.Divide-Two-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0029.Divide-Two-Integers/</guid>
      <description>29. Divide Two Integers #  题目 #  Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.
Return the quotient after dividing dividend by divisor.
The integer division should truncate toward zero.
Example 1:
Input: dividend = 10, divisor = 3 Output: 3  Example 2:
Input: dividend = 7, divisor = -3 Output: -2  Note:
 Both dividend and divisor will be 32-bit signed integers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0030.Substring-with-Concatenation-of-All-Words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0030.Substring-with-Concatenation-of-All-Words/</guid>
      <description>30. Substring with Concatenation of All Words #  题目 #  You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
Example 1:
 Input: s = &amp;quot;barfoothefoobarman&amp;quot;, words = [&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &amp;quot;barfoor&amp;quot; and &amp;quot;foobar&amp;quot; respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0033.Search-in-Rotated-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0033.Search-in-Rotated-Sorted-Array/</guid>
      <description>33. Search in Rotated Sorted Array #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/</guid>
      <description>34. Find First and Last Position of Element in Sorted Array #  题目 #  Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0035.Search-Insert-Position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0035.Search-Insert-Position/</guid>
      <description>35. Search Insert Position #  题目 #  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You may assume no duplicates in the array.
Example 1:
Input: [1,3,5,6], 5 Output: 2  Example 2:
Input: [1,3,5,6], 2 Output: 1  Example 3:
Input: [1,3,5,6], 7 Output: 4  Example 4:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0036.Valid-Sudoku/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0036.Valid-Sudoku/</guid>
      <description>36. Valid Sudoku #  题目 #  Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
 Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0037.Sudoku-Solver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0037.Sudoku-Solver/</guid>
      <description>37. Sudoku Solver #  题目 #  Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
 Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0039.Combination-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0039.Combination-Sum/</guid>
      <description>39. Combination Sum #  题目 #  Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
 All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0040.Combination-Sum-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0040.Combination-Sum-II/</guid>
      <description>40. Combination Sum II #  题目 #  Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note:
 All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0041.First-Missing-Positive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0041.First-Missing-Positive/</guid>
      <description>41. First Missing Positive #  题目 #  Given an unsorted integer array, find the smallest missing positive integer.
Example 1:
 Input: [1,2,0] Output: 3 Example 2:
 Input: [3,4,-1,1] Output: 2 Example 3:
 Input: [7,8,9,11,12] Output: 1 Note:
Your algorithm should run in O(n) time and uses constant extra space.
题目大意 #  找到缺失的第一个正整数。
解题思路 #  为了减少时间复杂度，可以把 input 数组都装到 map 中，然后 i 循环从 1 开始，依次比对 map 中是否存在 i，只要不存在 i 就立即返回结果，即所求。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0042.Trapping-Rain-Water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0042.Trapping-Rain-Water/</guid>
      <description>42. Trapping Rain Water #  题目 #  Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
 The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
Example:
 Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 题目大意 #  从 x 轴开始，给出一个数组，数组里面的数字代表从 (0,0) 点开始，宽度为 1 个单位，高度为数组元素的值。如果下雨了，问这样一个容器能装多少单位的水？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0046.Permutations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0046.Permutations/</guid>
      <description>46. Permutations #  题目 #  Given a collection of distinct integers, return all possible permutations.
Example:
Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  题目大意 #  给定一个没有重复数字的序列，返回其所有可能的全排列。
解题思路 #   求出一个数组的排列组合中的所有排列，用 DFS 深搜即可。  代码 #  package leetcode func permute(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} generatePermutation(nums, 0, p, &amp;amp;res, &amp;amp;used) return res } func generatePermutation(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) return } for i := 0; i &amp;lt; len(nums); i++ { if !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0047.Permutations-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0047.Permutations-II/</guid>
      <description>47. Permutations II #  题目 #  Given a collection of numbers that might contain duplicates, return all possible unique permutations.
Example:
Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ]  题目大意 #  给定一个可包含重复数字的序列，返回所有不重复的全排列。
解题思路 #   这一题是第 46 题的加强版，第 46 题中求数组的排列，数组中元素不重复，但是这一题中，数组元素会重复，所以需要最终排列出来的结果需要去重。 去重的方法是经典逻辑，将数组排序以后，判断重复元素再做逻辑判断。 其他思路和第 46 题完全一致，DFS 深搜即可。  代码 #  package leetcode import &amp;#34;sort&amp;#34; func permuteUnique(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} sort.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0048.Rotate-Image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0048.Rotate-Image/</guid>
      <description>48. Rotate Image #  题目 #  You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image  in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0049.Group-Anagrams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0049.Group-Anagrams/</guid>
      <description>49. Group Anagrams #  题目 #  Given an array of strings, group anagrams together.
Example:
 Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] Note:
 All inputs will be in lowercase. The order of your output does not matter.  题目大意 #  给出一个字符串数组，要求对字符串数组里面有 Anagrams 关系的字符串进行分组。Anagrams 关系是指两个字符串的字符完全相同，顺序不同，两者是由排列组合组成。
解题思路 #  这道题可以将每个字符串都排序，排序完成以后，相同 Anagrams 的字符串必然排序结果一样。把排序以后的字符串当做 key 存入到 map 中。遍历数组以后，就能得到一个 map，key 是排序以后的字符串，value 对应的是这个排序字符串以后的 Anagrams 字符串集合。最后再将这些 value 对应的字符串数组输出即可。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0050.Powx-n/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0050.Powx-n/</guid>
      <description>50. Pow(x, n) #  题目 #  Implement pow(x, n), which calculates x raised to the power n (xn).
Example 1:
Input: 2.00000, 10 Output: 1024.00000  Example 2:
Input: 2.10000, 3 Output: 9.26100  Example 3:
Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:
 -100.0 &amp;lt; x &amp;lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31− 1]  题目大意 #  实现 pow(x, n) ，即计算 x 的 n 次幂函数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0051.N-Queens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0051.N-Queens/</guid>
      <description>51. N-Queens #  题目 #  The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
 Given an integer n, return all distinct solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively.
Example:
Input: 4 Output: [ [&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0052.N-Queens-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0052.N-Queens-II/</guid>
      <description>52. N-Queens II #  题目 #  The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
 Given an integer n, return the number of distinct solutions to the n-queens puzzle.
Example:
Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0053.Maximum-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0053.Maximum-Subarray/</guid>
      <description>53. Maximum Subarray #  题目 #  Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example:
Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
题目大意 #  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0054.Spiral-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0054.Spiral-Matrix/</guid>
      <description>54. Spiral Matrix #  题目 #  Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
Example 1:
Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2:
Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  题目大意 #  给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0055.Jump-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0055.Jump-Game/</guid>
      <description>55. Jump Game #  题目 #  Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
Example 1:
Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0056.Merge-Intervals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0056.Merge-Intervals/</guid>
      <description>56. Merge Intervals #  题目 #  Given a collection of intervals, merge all overlapping intervals.
Example 1:
 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:
 Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. 题目大意 #  合并给的多个区间，区间有重叠的要进行区间合并。
解题思路 #  先按照区间起点进行排序。然后从区间起点小的开始扫描，依次合并每个有重叠的区间。
代码 #  package leetcode /** * Definition for an interval. * type Interval struct { *	Start int *	End int * } */ // Interval define type Interval struct { Start int End int } func merge56(intervals []Interval) []Interval { if len(intervals) == 0 { return intervals } quickSort(intervals, 0, len(intervals)-1) res := make([]Interval, 0) res = append(res, intervals[0]) curIndex := 0 for i := 1; i &amp;lt; len(intervals); i++ { if intervals[i].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0057.Insert-Interval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0057.Insert-Interval/</guid>
      <description>57. Insert Interval #  题目 #  Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
 Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:
 Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0059.Spiral-Matrix-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0059.Spiral-Matrix-II/</guid>
      <description>59. Spiral Matrix II #  题目 #  Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.
Example:
Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]  题目大意 #  给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
解题思路 #   给出一个数组 n，要求输出一个 n * n 的二维数组，里面元素是 1 - n*n，且数组排列顺序是螺旋排列的 这一题是第 54 题的加强版，没有需要注意的特殊情况，直接模拟即可。  代码 #  package leetcode func generateMatrix(n int) [][]int { if n == 0 { return [][]int{} } if n == 1 { return [][]int{[]int{1}} } res, visit, round, x, y, spDir := make([][]int, n), make([][]int, n), 0, 0, 0, [][]int{ []int{0, 1}, // 朝右 	[]int{1, 0}, // 朝下 	[]int{0, -1}, // 朝左 	[]int{-1, 0}, // 朝上 	} for i := 0; i &amp;lt; n; i++ { visit[i] = make([]int, n) res[i] = make([]int, n) } visit[x][y] = 1 res[x][y] = 1 for i := 0; i &amp;lt; n*n; i++ { x += spDir[round%4][0] y += spDir[round%4][1] if (x == 0 &amp;amp;&amp;amp; y == n-1) || (x == n-1 &amp;amp;&amp;amp; y == n-1) || (y == 0 &amp;amp;&amp;amp; x == n-1) { round++ } if x &amp;gt; n-1 || y &amp;gt; n-1 || x &amp;lt; 0 || y &amp;lt; 0 { return res } if visit[x][y] == 0 { visit[x][y] = 1 res[x][y] = i + 2 } switch round % 4 { case 0: if y+1 &amp;lt;= n-1 &amp;amp;&amp;amp; visit[x][y+1] == 1 { round++ continue } case 1: if x+1 &amp;lt;= n-1 &amp;amp;&amp;amp; visit[x+1][y] == 1 { round++ continue } case 2: if y-1 &amp;gt;= 0 &amp;amp;&amp;amp; visit[x][y-1] == 1 { round++ continue } case 3: if x-1 &amp;gt;= 0 &amp;amp;&amp;amp; visit[x-1][y] == 1 { round++ continue } } } return res } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0060.Permutation-Sequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0060.Permutation-Sequence/</guid>
      <description>60. Permutation Sequence #  题目 #  The set [1,2,3,...,*n*] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:
 &amp;quot;123&amp;quot; &amp;quot;132&amp;quot; &amp;quot;213&amp;quot; &amp;quot;231&amp;quot; &amp;quot;312&amp;quot; &amp;quot;321&amp;quot;  Given n and k, return the kth permutation sequence.
Note:
 Given n will be between 1 and 9 inclusive. Given k will be between 1 and n!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0061.Rotate-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0061.Rotate-List/</guid>
      <description>61. 旋转链表 #  Difficulty: 中等
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
示例 1:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL 解释: 向右旋转 1 步: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL 向右旋转 2 步: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL 示例 2:
输入: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 输出: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL 解释: 向右旋转 1 步: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL 向右旋转 2 步: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL 向右旋转 3 步: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL 向右旋转 4 步: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL 题解 #  题解一： #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0062.Unique-Paths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0062.Unique-Paths/</guid>
      <description>62. Unique Paths #  题目 #  A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
 Above is a 7 x 3 grid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0063.Unique-Paths-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0063.Unique-Paths-II/</guid>
      <description>63. Unique Paths II #  题目 #  A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
Now consider if some obstacles are added to the grids.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0064.Minimum-Path-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0064.Minimum-Path-Sum/</guid>
      <description>64. Minimum Path Sum #  题目 #  Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.  题目大意 #  给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0066.Plus-One/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0066.Plus-One/</guid>
      <description>66. Plus One #  题目 #  Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0067.Add-Binary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0067.Add-Binary/</guid>
      <description>67. Add Binary #  题目 #  Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
Example 1:
Input: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; Output: &amp;quot;100&amp;quot; Example 2:
Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; Output: &amp;quot;10101&amp;quot; 题目大意 #  给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。
解题思路 #   要求输出 2 个二进制数的和，结果也用二进制表示。 简单题。按照二进制的加法规则做加法即可。  代码 #  package leetcode import ( &amp;#34;strconv&amp;#34; &amp;#34;strings&amp;#34; ) func addBinary(a string, b string) string { if len(b) &amp;gt; len(a) { a, b = b, a } res := make([]string, len(a)+1) i, j, k, c := len(a)-1, len(b)-1, len(a), 0 for i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0 { ai, _ := strconv.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0069.Sqrtx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0069.Sqrtx/</guid>
      <description>69. Sqrt(x) #  题目 #  Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1:
Input: 4 Output: 2  Example 2:
Input: 8 Output: 2 Explanation: The square root of 8 is 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0070.Climbing-Stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0070.Climbing-Stairs/</guid>
      <description>70. Climbing Stairs #  题目 #  You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0071.Simplify-Path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0071.Simplify-Path/</guid>
      <description>71. Simplify Path #  题目 #  Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.
In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix
Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0074.Search-a-2D-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0074.Search-a-2D-Matrix/</guid>
      <description>74. Search a 2D Matrix #  题目 #  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1:
Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0075.Sort-Colors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0075.Sort-Colors/</guid>
      <description>75. Sort Colors #  题目 #  Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note: You are not suppose to use the library&amp;rsquo;s sort function for this problem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0076.Minimum-Window-Substring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0076.Minimum-Window-Substring/</guid>
      <description>76. Minimum Window Substring #  题目 #  Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
Example:
 Input: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot; Note:
 If there is no such window in S that covers all characters in T, return the empty string &amp;ldquo;&amp;rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0077.Combinations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0077.Combinations/</guid>
      <description>77. Combinations #  题目 #  Given two integers n and k, return all possible combinations of k numbers out of 1 &amp;hellip; n.
Example:
Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]  题目大意 #  给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。
解题思路 #   计算排列组合中的组合，用 DFS 深搜即可，注意剪枝  代码 #   package leetcode func combine(n int, k int) [][]int { if n &amp;lt;= 0 || k &amp;lt;= 0 || k &amp;gt; n { return [][]int{} } c, res := []int{}, [][]int{} generateCombinations(n, k, 1, c, &amp;amp;res) return res } func generateCombinations(n, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0078.Subsets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0078.Subsets/</guid>
      <description>78. Subsets #  题目 #  Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  题目大意 #  给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。
解题思路 #   找出一个集合中的所有子集，空集也算是子集。且数组中的数字不会出现重复。用 DFS 暴力枚举即可。 这一题和第 90 题，第 491 题类似，可以一起解答和复习。  代码 #  package leetcode import &amp;#34;sort&amp;#34; // 解法一 func subsets(nums []int) [][]int { c, res := []int{}, [][]int{} for k := 0; k &amp;lt;= len(nums); k++ { generateSubsets(nums, k, 0, c, &amp;amp;res) } return res } func generateSubsets(nums []int, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0079.Word-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0079.Word-Search/</guid>
      <description>79. Word Search #  题目 #  Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example:
board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0080.Remove-Duplicates-from-Sorted-Array-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0080.Remove-Duplicates-from-Sorted-Array-II/</guid>
      <description>80. Remove Duplicates from Sorted Array II #  题目 #  Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
 Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0081.Search-in-Rotated-Sorted-Array-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0081.Search-in-Rotated-Sorted-Array-II/</guid>
      <description>81. Search in Rotated Sorted Array II #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0082.Remove-Duplicates-from-Sorted-List-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0082.Remove-Duplicates-from-Sorted-List-II/</guid>
      <description>82. Remove Duplicates from Sorted List II #  题目 #  Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
 Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5 Example 2:
 Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3 题目大意 #  删除链表中重复的结点，只要是有重复过的结点，全部删除。
解题思路 #  按照题意做即可。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 func deleteDuplicates1(head *ListNode) *ListNode { if head == nil { return nil } if head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0083.Remove-Duplicates-from-Sorted-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0083.Remove-Duplicates-from-Sorted-List/</guid>
      <description>83. Remove Duplicates from Sorted List #  题目 #  Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1:
 Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2:
 Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 题目大意 #  删除链表中重复的结点，以保障每个结点只出现一次。
解题思路 #  按照题意做即可。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { cur := head if head == nil { return nil } if head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0084.Largest-Rectangle-in-Histogram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0084.Largest-Rectangle-in-Histogram/</guid>
      <description>84. Largest Rectangle in Histogram #  题目 #  Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
 The largest rectangle is shown in the shaded area, which has area = 10 unit.
Example:
 Input: [2,1,5,6,2,3] Output: 10 题目大意 #  给出每个直方图的高度，要求在这些直方图之中找到面积最大的矩形，输出矩形的面积。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0086.Partition-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0086.Partition-List/</guid>
      <description>86. Partition List #  题目 #  Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
Example:
 Input: head = 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;2, x = 3 Output: 1-&amp;gt;2-&amp;gt;2-&amp;gt;4-&amp;gt;3-&amp;gt;5 题目大意 #  给定一个数 x，比 x 大或等于的数字都要排列在比 x 小的数字后面，并且相对位置不能发生变化。由于相对位置不能发生变化，所以不能用类似冒泡排序的思想。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0088.Merge-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0088.Merge-Sorted-Array/</guid>
      <description>88. Merge Sorted Array #  题目 #  Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
 The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.  Example:
Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  Constraints:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0089.Gray-Code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0089.Gray-Code/</guid>
      <description>89. Gray Code #  题目 #  The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
Example 1:
Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0090.Subsets-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0090.Subsets-II/</guid>
      <description>90. Subsets II #  题目 #  Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]  题目大意 #  给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。
解题思路 #   这一题是第 78 题的加强版，比第 78 题多了一个条件，数组中的数字会出现重复。 解题方法依旧是 DFS，需要在回溯的过程中加上一些判断。 这一题和第 78 题，第 491 题类似，可以一起解答和复习。  代码 #  package leetcode import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func subsetsWithDup(nums []int) [][]int { c, res := []int{}, [][]int{} sort.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0091.Decode-Ways/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0091.Decode-Ways/</guid>
      <description>91. Decode Ways #  题目 #  A message containing letters from A-Z is being encoded to numbers using the following mapping:
&#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26  Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1:
Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12).  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0092.Reverse-Linked-List-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0092.Reverse-Linked-List-II/</guid>
      <description>92. Reverse Linked List II #  题目 #  Reverse a linked list from position m to n. Do it in one-pass.
Note: 1 ≤ m ≤ n ≤ length of list.
Example:
 Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 题目大意 #  给定 2 个链表中结点的位置 m, n，反转这个两个位置区间内的所有结点。
解题思路 #  由于有可能整个链表都被反转，所以构造一个新的头结点指向当前的头。之后的处理方法是：找到第一个需要反转的结点的前一个结点 p，从这个结点开始，依次把后面的结点用“头插”法，插入到 p 结点的后面。循环次数用 n-m 来控制。
这一题结点可以原地变化，更改各个结点的 next 指针就可以。不需要游标 p 指针。因为每次逆序以后，原有结点的相对位置就发生了变化，相当于游标指针已经移动了，所以不需要再有游标 p = p.Next 的操作了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0093.Restore-IP-Addresses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0093.Restore-IP-Addresses/</guid>
      <description>93. Restore IP Addresses #  题目 #  Given a string containing only digits, restore it by returning all possible valid IP address combinations.
Example:
Input: &amp;quot;25525511135&amp;quot; Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;]  题目大意 #  给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
解题思路 #   DFS 深搜 需要注意的点是 IP 的规则，以 0 开头的数字和超过 255 的数字都为非法的。  代码 #  package leetcode import ( &amp;#34;strconv&amp;#34; ) func restoreIPAddresses(s string) []string { if s == &amp;#34;&amp;#34; { return []string{} } res, ip := []string{}, []int{} dfs(s, 0, ip, &amp;amp;res) return res } func dfs(s string, index int, ip []int, res *[]string) { if index == len(s) { if len(ip) == 4 { *res = append(*res, getString(ip)) } return } if index == 0 { num, _ := strconv.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0094.Binary-Tree-Inorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0094.Binary-Tree-Inorder-Traversal/</guid>
      <description>94. 二叉树的中序遍历 #  Difficulty: 中等
给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1：
 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：
输入：root = [] 输出：[] 示例 3：
输入：root = [1] 输出：[1] 示例 4：
 输入：root = [1,2] 输出：[2,1] 示例 5：
 输入：root = [1,null,2] 输出：[1,2] 提示：
 树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  进阶: 递归算法很简单，你可以通过迭代算法完成吗？
题解 #  解法一：递归中序遍历 #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0095.Unique-Binary-Search-Trees-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0095.Unique-Binary-Search-Trees-II/</guid>
      <description>95. Unique Binary Search Trees II #  题目 #  Given an integer n, generate all structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n.
Example:
Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&#39;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  题目大意 #  给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的二叉搜索树。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0096.Unique-Binary-Search-Trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0096.Unique-Binary-Search-Trees/</guid>
      <description>96. 不同的二叉搜索树 #  Difficulty: 中等
给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？
示例:
输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \  / / / \  \  3 2 1 1 3 2 / / \  \  2 1 2 3 题解 #  题解一：DP（动态规划） #  class Solution { public int numTrees(int n) { int[] result = new int[n + 1]; result[0] = 1; result[1] = 1; for (int i = 2; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= i; j++) { result[i] += result[j - 1] * result[i - j]; } } return result[n]; } } 复杂度分析</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0098.Validate-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0098.Validate-Binary-Search-Tree/</guid>
      <description>98. Validate Binary Search Tree #  题目 #  Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
 The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0099.Recover-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0099.Recover-Binary-Search-Tree/</guid>
      <description>99. Recover Binary Search Tree #  题目 #  Two elements of a binary search tree (BST) are swapped by mistake.
Recover the tree without changing its structure.
Example 1:
Input: [1,3,null,null,2] 1 / 3 \ 2 Output: [3,1,null,null,2] 3 / 1 \ 2  Example 2:
Input: [3,1,4,null,null,2] 3 / \ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \ 1 4 / 3  Follow up:
 A solution using O(n) space is pretty straight forward.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0100.Same-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0100.Same-Tree/</guid>
      <description>100. Same Tree #  题目 #  Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
 Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2:
 Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0101.Symmetric-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0101.Symmetric-Tree/</guid>
      <description>101. Symmetric Tree #  题目 #  Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3 Note:
Bonus points if you could solve it both recursively and iteratively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0102.Binary-Tree-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0102.Binary-Tree-Level-Order-Traversal/</guid>
      <description>102. Binary Tree Level Order Traversal #  题目 #  Given a binary tree, return the level order traversal of its nodes&#39; values. (ie, from left to right, level by level).
For Example:
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its level order traversal as:
 [ [3], [9,20], [15,7] ] 题目大意 #  按层序从上到下遍历一颗树。
解题思路 #  用一个队列即可实现。
代码 #  package leetcode /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</guid>
      <description>103. 二叉树的锯齿形层次遍历 #  Difficulty: 中等
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 返回锯齿形层次遍历如下：
[ [3], [20,9], [15,7] ] 题解 #  题解一：BFS（广度优先遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } Deque&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0104.Maximum-Depth-of-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0104.Maximum-Depth-of-Binary-Tree/</guid>
      <description>104. Maximum Depth of Binary Tree #  题目 #  Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its depth = 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</guid>
      <description>105. Construct Binary Tree from Preorder and Inorder Traversal #  题目 #  Given preorder and inorder traversal of a tree, construct the binary tree.
Note:You may assume that duplicates do not exist in the tree.
For example, given
preorder = [3,9,20,15,7] inorder = [9,3,15,20,7]  Return the following binary tree:
 3 / \ 9 20 / \ 15 7  题目大意 #  根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
解题思路 #   给出 2 个数组，根据 preorder 和 inorder 数组构造一颗树。 利用递归思想，从 preorder 可以得到根节点，从 inorder 中得到左子树和右子树。只剩一个节点的时候即为根节点。不断的递归直到所有的树都生成完成。  代码 #  package leetcode /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</guid>
      <description>106. Construct Binary Tree from Inorder and Postorder Traversal #  题目 #  Given inorder and postorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.
For example, given
inorder = [9,3,15,20,7] postorder = [9,15,7,20,3]  Return the following binary tree:
 3 / \ 9 20 / \ 15 7  题目大意 #  根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0107.Binary-Tree-Level-Order-Traversal-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0107.Binary-Tree-Level-Order-Traversal-II/</guid>
      <description>107. Binary Tree Level Order Traversal II #  题目 #  Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root).
For Example:
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as:
 [ [15,7], [9,20], [3] ] 题目大意 #  按层序从下到上遍历一颗树。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</guid>
      <description>108. Convert Sorted Array to Binary Search Tree #  题目 #  Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  题目大意 #  将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0109.Convert-Sorted-List-to-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0109.Convert-Sorted-List-to-Binary-Search-Tree/</guid>
      <description>109. Convert Sorted List to Binary Search Tree #  题目 #  Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
 Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 题目大意 #  将链表转化为高度平衡的二叉搜索树。高度平衡的定义：每个结点的 2 个子结点的深度不能相差超过 1 。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0110.Balanced-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0110.Balanced-Binary-Tree/</guid>
      <description>110. 平衡二叉树 #  Difficulty: 简单
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
 一个二叉树 每个节点 的左右两个子树的高度差的绝对值不超过 1 。
 示例 1：
 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：
 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：
输入：root = [] 输出：true 提示：
 树中的节点数在范围 [0, 5000] 内 $-10^4$ &amp;lt;= Node.val &amp;lt;= $10^4$  题解 #  解法一：递归求解（自顶向下） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0111.Minimum-Depth-of-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0111.Minimum-Depth-of-Binary-Tree/</guid>
      <description>111. Minimum Depth of Binary Tree #  题目 #  Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its minimum depth = 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0112.Path-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0112.Path-Sum/</guid>
      <description>112. 路径总和 #  Difficulty: 简单
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
示例: 给定如下二叉树，以及目标和 sum = 22，
 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&amp;gt;4-&amp;gt;11-&amp;gt;2。
题解 #  题解一：递归求解 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0113.Path-Sum-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0113.Path-Sum-II/</guid>
      <description>113. Path Sum II #  题目 #  Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
Note: A leaf is a node with no children.
Example:
Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1  Return:
[ [5,4,11,2], [5,8,4,5] ]  题目大意 #  给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0114.Flatten-Binary-Tree-to-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0114.Flatten-Binary-Tree-to-Linked-List/</guid>
      <description>114. 二叉树展开为链表 #  Difficulty: 中等
给定一个二叉树，将它展开为一个单链表。
例如，给定二叉树
 1 / \ 2 5 / \ \ 3 4 6 将其展开为：
1 \ 2 \ 3 \ 4 \ 5 \ 6 题解 #  题解一：二叉树前序遍历（DFS） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0118.Pascals-Triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0118.Pascals-Triangle/</guid>
      <description>118. Pascal&amp;rsquo;s Triangle #  题目 #  Given a non-negative integer numRows, generate the first numRows of Pascal&amp;rsquo;s triangle.
 Note: In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example:
Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 题目大意 #  给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。
解题思路 #   给定一个 n，要求打印杨辉三角的前 n 行。 简单题。按照杨辉三角的生成规则循环打印即可。  代码 #  package leetcode func generate(numRows int) [][]int { result := [][]int{} for i := 0; i &amp;lt; numRows; i++ { row := []int{} for j := 0; j &amp;lt; i+1; j++ { if j == 0 || j == i { row = append(row, 1) } else if i &amp;gt; 1 { row = append(row, result[i-1][j-1]+result[i-1][j]) } } result = append(result, row) } return result } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0120.Triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0120.Triangle/</guid>
      <description>120. 三角形最小路径和 #  Difficulty: 中等
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
例如，给定三角形：
[ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
说明：
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
题解 #  题解一 #  class Solution { public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int n = triangle.size(); int[] dp = new int[n + 1]; for (int i = n - 1; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt;= i; j++) { dp[j] = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/</guid>
      <description>121. Best Time to Buy and Sell Stock #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0122.Best-Time-to-Buy-and-Sell-Stock-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0122.Best-Time-to-Buy-and-Sell-Stock-II/</guid>
      <description>122. Best Time to Buy and Sell Stock II #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0124.Binary-Tree-Maximum-Path-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0124.Binary-Tree-Maximum-Path-Sum/</guid>
      <description>124. Binary Tree Maximum Path Sum #  题目 #  Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0125.Valid-Palindrome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0125.Valid-Palindrome/</guid>
      <description>125. Valid Palindrome #  题目 #  Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
 &amp;quot;A man, a plan, a canal: Panama&amp;quot; is a palindrome. &amp;quot;race a car&amp;quot; is not a palindrome. Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.
For the purpose of this problem, we define empty string as valid palindrome.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0126.Word-Ladder-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0126.Word-Ladder-II/</guid>
      <description>126. Word Ladder II #  题目 #  Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
 Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:
 Return an empty list if there is no such transformation sequence.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0127.Word-Ladder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0127.Word-Ladder/</guid>
      <description>127. Word Ladder #  题目 #  Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
 Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:
 Return 0 if there is no such transformation sequence.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0128.Longest-Consecutive-Sequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0128.Longest-Consecutive-Sequence/</guid>
      <description>128. Longest Consecutive Sequence #  题目 #  Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example:
Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  题目大意 #  给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。
解题思路 #   给出一个数组，要求找出最长连续序列，输出这个最长的长度。要求时间复杂度为 O(n)。 这一题可以先用暴力解决解决，代码见解法三。思路是把每个数都存在 map 中，先删去 map 中没有前一个数 nums[i]-1 也没有后一个数 nums[i]+1 的数 nums[i]，这种数前后都不连续。然后在 map 中找到前一个数 nums[i]-1 不存在，但是后一个数 nums[i]+1 存在的数，这种数是连续序列的起点，那么不断的往后搜，直到序列“断”了。最后输出最长序列的长度。 这一题最优的解法是解法一，针对每一个 map 中不存在的数 n，插入进去都做 2 件事情。第一件事，先查看 n - 1 和 n + 1 是否都存在于 map 中，如果都存在，代表存在连续的序列，那么就更新 left，right 边界。那么 n 对应的这个小的子连续序列长度为 sum = left + right + 1。第二件事就是更新 left 和 right 左右边界对应的 length = sum。 这一题还可以用并查集解决，见解法二。利用每个数在 nums 中的下标，把下标和下标进行 union()，具体做法是看前一个数 nums[i]-1 和后一个数 nums[i]+1 在 map 中是否存在，如果存在就 union()，最终输出整个并查集中包含最多元素的那个集合的元素总数。  代码 #  package leetcode import ( &amp;#34;github.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0129.Sum-Root-to-Leaf-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0129.Sum-Root-to-Leaf-Numbers/</guid>
      <description>129. 求根到叶子节点数字之和 #  Difficulty: 中等
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。
计算从根到叶子节点生成的所有数字之和。
说明: 叶子节点是指没有子节点的节点。
示例 1:
输入: [1,2,3] 1 / \  2 3 输出: 25 解释: 从根到叶子节点路径 1-&amp;gt;2 代表数字 12. 从根到叶子节点路径 1-&amp;gt;3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2:
输入: [4,9,0,5,1] 4 / \  9 0 / \ 5 1 输出: 1026 解释: 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495. 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491. 从根到叶子节点路径 4-&amp;gt;0 代表数字 40.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0130.Surrounded-Regions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0130.Surrounded-Regions/</guid>
      <description>130. Surrounded Regions #  题目 #  Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;.
A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.
Example:
X X X X X O O X X X O X X O X X  After running your function, the board should be:
X X X X X X X X X X X X X O X X  Explanation:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0131.Palindrome-Partitioning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0131.Palindrome-Partitioning/</guid>
      <description>131. Palindrome Partitioning #  题目 #  Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
Example:
Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ]  题目大意 #  给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
解题思路 #   要求输出一个字符串可以被拆成回文串的所有解，DFS 递归求解即可。  代码 #  package leetcode // 解法一 func partition131(s string) [][]string { if s == &amp;#34;&amp;#34; { return [][]string{} } res, pal := [][]string{}, []string{} findPalindrome(s, 0, &amp;#34;&amp;#34;, true, pal, &amp;amp;res) return res } func findPalindrome(str string, index int, s string, isPal bool, pal []string, res *[][]string) { if index == len(str) { if isPal { tmp := make([]string, len(pal)) copy(tmp, pal) *res = append(*res, tmp) } return } if index == 0 { s = string(str[index]) pal = append(pal, s) findPalindrome(str, index+1, s, isPal &amp;amp;&amp;amp; isPalindrome131(s), pal, res) } else { temp := pal[len(pal)-1] s = pal[len(pal)-1] + string(str[index]) pal[len(pal)-1] = s findPalindrome(str, index+1, s, isPalindrome131(s), pal, res) pal[len(pal)-1] = temp if isPalindrome131(temp) { pal = append(pal, string(str[index])) findPalindrome(str, index+1, temp, isPal &amp;amp;&amp;amp; isPalindrome131(temp), pal, res) pal = pal[:len(pal)-1] } } return } func isPalindrome131(s string) bool { slen := len(s) for i, j := 0, slen-1; i &amp;lt; j; i, j = i+1, j-1 { if s[i] !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0136.Single-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0136.Single-Number/</guid>
      <description>136. Single Number #  题目 #  Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1  Example 2:
Input: [4,1,2,1,2] Output: 4  题目大意 #  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 #   题目要求不能使用辅助空间，并且时间复杂度只能是线性的。 题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现依次的数字，因为那些出现两次的数字全部在异或中抵消掉了。于是最终做法是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。利用的性质是 x^x = 0。  代码 #  package leetcode func singleNumber(nums []int) int { result := 0 for i := 0; i &amp;lt; len(nums); i++ { result ^= nums[i] } return result } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0137.Single-Number-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0137.Single-Number-II/</guid>
      <description>137. Single Number II #  题目 #  Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3  Example 2:
Input: [0,1,0,1,0,1,99] Output: 99  题目大意 #  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 #   这一题是第 136 题的加强版。这类题也可以扩展，在数组中每个元素都出现 5 次，找出只出现 1 次的数。 本题中要求找出只出现 1 次的数，出现 3 次的数都要被消除。第 136 题是消除出现 2 次的数。这一题也会相当相同的解法，出现 3 次的数也要被消除。定义状态，00、10、01，这 3 个状态。当一个数出现 3 次，那么它每个位置上的 1 出现的次数肯定是 3 的倍数，所以当 1 出现 3 次以后，就归零清除。如何能做到这点呢？仿造三进制(00，10，01) 就可以做到。 变量 ones 中记录遍历中每个位上出现 1 的个数。将它与 A[i] 进行异或，目的是：  每位上两者都是 1 的，表示历史统计结果 ones 出现1次、A[i]中又出现1次，则是出现 2 次，需要进位到 twos 变量中。 每位上两者分别为 0、1 的，加入到 ones 统计结果中。 最后还要 &amp;amp; ^twos ，是为了能做到三进制，出现 3 次就清零。例如 ones = x，那么 twos = 0，当 twos = x，那么 ones = 0；   变量 twos 中记录遍历中每个位上出现 1 ，2次 的个数。与 A[i] 进行异或的目的和上述描述相同，不再赘述。   在 golang 中，&amp;amp;^ 表示 AND NOT 的意思。这里的 ^ 作为一元操作符，表示按位取反 (^0001 0100 = 1110 1011)，X &amp;amp;^ Y 的意思是将 X 中与 Y 相异的位保留，相同的位清零。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0141.Linked-List-Cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0141.Linked-List-Cycle/</guid>
      <description>141. Linked List Cycle #  题目 #  Given a linked list, determine if it has a cycle in it.
Follow up:
Can you solve it without using extra space?
题目大意 #  判断链表是否有环，不能使用额外的空间。
解题思路 #  给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。
代码 #  package leetcode /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ func hasCycle(head *ListNode) bool { fast := head slow := head for slow !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0142.Linked-List-Cycle-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0142.Linked-List-Cycle-II/</guid>
      <description>142. Linked List Cycle II #  题目 #  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Note: Do not modify the linked list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0143.Reorder-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0143.Reorder-List/</guid>
      <description>143. Reorder List #  题目 #  Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example 1:
 Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2:
 Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. 题目大意 #  按照指定规则重新排序链表：第一个元素和最后一个元素排列在一起，接着第二个元素和倒数第二个元素排在一起，接着第三个元素和倒数第三个元素排在一起。
解题思路 #  最近简单的方法是先把链表存储到数组里，然后找到链表中间的结点，按照规则拼接即可。这样时间复杂度是 O(n)，空间复杂度是 O(n)。
更好的做法是结合之前几道题的操作：链表逆序，找中间结点。
先找到链表的中间结点，然后利用逆序区间的操作，如 第 92 题 里的 reverseBetween() 操作，只不过这里的反转区间是从中点一直到末尾。最后利用 2 个指针，一个指向头结点，一个指向中间结点，开始拼接最终的结果。这种做法的时间复杂度是 O(n)，空间复杂度是 O(1)。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0144.Binary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0144.Binary-Tree-Preorder-Traversal/</guid>
      <description>144. Binary Tree Preorder Traversal #  题目 #  Given a binary tree, return the preorder traversal of its nodes&#39; values.
Example:
 Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 #  先根遍历一颗树。
解题思路 #  两种递归的实现方法，见代码。
代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 递归 func preorderTraversal(root *TreeNode) []int { res := []int{} if root !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0145.Binary-Tree-Postorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0145.Binary-Tree-Postorder-Traversal/</guid>
      <description>145. Binary Tree Postorder Traversal #  题目 #  Given a binary tree, return the postorder traversal of its nodes&#39; values.
Example:
 Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 #  后根遍历一颗树。
解题思路 #  递归的实现方法，见代码。
代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func postorderTraversal(root *TreeNode) []int { var result []int postorder(root, &amp;amp;result) return result } func postorder(root *TreeNode, output *[]int) { if root !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0147.Insertion-Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0147.Insertion-Sort-List/</guid>
      <description>147. Insertion Sort List #  题目 #  Sort a linked list using insertion sort.
 A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
Algorithm of Insertion Sort:
Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0148.Sort-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0148.Sort-List/</guid>
      <description>148. Sort List #  题目 #  Sort a linked list in O(n log n) time using constant space complexity.
Example 1:
 Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2:
 Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 题目大意 #  链表的排序，要求时间复杂度必须是 O(n log n)，空间复杂度是 O(1)
解题思路 #  这道题只能用归并排序才能符合要求。归并排序需要的 2 个操作在其他题目已经出现过了，取中间点是第 876 题，合并 2 个有序链表是第 21 题。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { length := 0 cur := head for cur !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0150.Evaluate-Reverse-Polish-Notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0150.Evaluate-Reverse-Polish-Notation/</guid>
      <description>150. Evaluate Reverse Polish Notation #  题目 #  Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Note:
 Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&amp;rsquo;t be any divide by zero operation.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0151.Reverse-Words-in-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0151.Reverse-Words-in-a-String/</guid>
      <description>151. Reverse Words in a String #  题目 #  Given an input string, reverse the string word by word.
Example 1:
Input: &amp;quot;the sky is blue&amp;quot; Output: &amp;quot;blue is sky the&amp;quot;  Example 2:
Input: &amp;quot; hello world! &amp;quot; Output: &amp;quot;world! hello&amp;quot; Explanation: Your reversed string should not contain leading or trailing spaces.  Example 3:
Input: &amp;quot;a good example&amp;quot; Output: &amp;quot;example good a&amp;quot; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0152.Maximum-Product-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0152.Maximum-Product-Subarray/</guid>
      <description>152. Maximum Product Subarray #  题目 #  Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.
Example 1:
Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2:
Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  题目大意 #  给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/</guid>
      <description>153. Find Minimum in Rotated Sorted Array #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1  Example 2:
Input: [4,5,6,7,0,1,2] Output: 0  题目大意 #  假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。
你可以假设数组中不存在重复元素。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</guid>
      <description>154. Find Minimum in Rotated Sorted Array II #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
The array may contain duplicates.
Example 1:
Input: [1,3,5] Output: 1  Example 2:
Input: [2,2,2,0,1] Output: 0  Note:
 This is a follow up problem to Find Minimum in Rotated Sorted Array.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0155.Min-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0155.Min-Stack/</guid>
      <description>155. Min Stack #  题目 #  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. getMin() &amp;ndash; Retrieve the minimum element in the stack.
Example:
 MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0160.Intersection-of-Two-Linked-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0160.Intersection-of-Two-Linked-Lists/</guid>
      <description>160. Intersection of Two Linked Lists #  题目 #  Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
 begin to intersect at node c1.
Example 1:
  Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0162.Find-Peak-Element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0162.Find-Peak-Element/</guid>
      <description>162. Find Peak Element #  题目 #  A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0164.Maximum-Gap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0164.Maximum-Gap/</guid>
      <description>164. Maximum Gap #  题目 #  Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Return 0 if the array contains less than 2 elements.
Example 1:
 Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2:
 Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0167.Two-Sum-II-Input-array-is-sorted/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0167.Two-Sum-II-Input-array-is-sorted/</guid>
      <description>167. Two Sum II - Input array is sorted #  题目 #  Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note:
 Your returned answers (both index1 and index2) are not zero-based.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0168.Excel-Sheet-Column-Title/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0168.Excel-Sheet-Column-Title/</guid>
      <description>168. Excel Sheet Column Title #  题目 #  Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
	1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... Example 1:
Input: 1 Output: &amp;quot;A&amp;quot; Example 2:
Input: 28 Output: &amp;quot;AB&amp;quot; Example 3:
Input: 701 Output: &amp;quot;ZY&amp;quot; 题目大意 #  给定一个正整数，返回它在 Excel 表中相对应的列名称。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0169.Majority-Element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0169.Majority-Element/</guid>
      <description>169. Majority Element #  题目 #  Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3  Example 2:
Input: [2,2,1,1,1,2,2] Output: 2  题目大意 #  给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0171.Excel-Sheet-Column-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0171.Excel-Sheet-Column-Number/</guid>
      <description>171. Excel Sheet Column Number #  题目 #  Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
 A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... Example 1:
Input: &amp;quot;A&amp;quot; Output: 1 Example 2:
Input: &amp;quot;AB&amp;quot; Output: 28 Example 3:
Input: &amp;quot;ZY&amp;quot; Output: 701 题目大意 #  给定一个 Excel 表格中的列名称，返回其相应的列序号。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0172.Factorial-Trailing-Zeroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0172.Factorial-Trailing-Zeroes/</guid>
      <description>172. Factorial Trailing Zeroes #  题目 #  Given an integer n, return the number of trailing zeroes in n!.
Example 1:
Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero.  Example 2:
Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero.  Note: Your solution should be in logarithmic time complexity.
题目大意 #  给定一个整数 n，返回 n! 结果尾数中零的数量。说明: 你算法的时间复杂度应为 O(log n) 。
解题思路 #   给出一个数 n，要求 n！末尾 0 的个数。 这是一道数学题。计算 N 的阶乘有多少个后缀 0，即计算 N!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0173.Binary-Search-Tree-Iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0173.Binary-Search-Tree-Iterator/</guid>
      <description>173. Binary Search Tree Iterator #  题目 #  Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Example:
 BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0174.Dungeon-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0174.Dungeon-Game/</guid>
      <description>174. Dungeon Game #  题目 #  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.
The knight has an initial health point represented by a positive integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0179.Largest-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0179.Largest-Number/</guid>
      <description>179. Largest Number #  题目 #  Given a list of non negative integers, arrange them such that they form the largest number.
Example 1:
 Input: [10,2] Output: &amp;quot;210&amp;quot; Example 2:
 Input: [3,30,34,5,9] Output: &amp;quot;9534330&amp;quot; Note:
The result may be very large, so you need to return a string instead of an integer.
题目大意 #  给出一个数组，要求排列这些数组里的元素，使得最终排列出来的数字是最大的。
解题思路 #  这一题很容易想到把数字都转化为字符串，利用字符串比较，来排序，这样 9 开头的一定排在最前面。不过这样做有一个地方是错误的，比如：&amp;ldquo;3&amp;rdquo; 和 &amp;ldquo;30&amp;rdquo; 比较，&amp;ldquo;30&amp;rdquo; 比 &amp;ldquo;3&amp;rdquo; 的字符序要大，这样排序以后就出错了。实际上就这道题而言， &amp;ldquo;3&amp;rdquo; 应该排在 &amp;ldquo;30&amp;rdquo; 前面。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0187.Repeated-DNA-Sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0187.Repeated-DNA-Sequences/</guid>
      <description>187. Repeated DNA Sequences #  题目 #  All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for Example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
Example:
Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]  题目大意 #  所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0190.Reverse-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0190.Reverse-Bits/</guid>
      <description>190. Reverse Bits #  题目 #  Reverse bits of a given 32 bits unsigned integer.
Example 1:
Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.  Example 2:
Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0191.Number-of-1-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0191.Number-of-1-Bits/</guid>
      <description>191. Number of 1 Bits #  题目 #  Write a function that takes an unsigned integer and return the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Example 1:
Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.  Example 2:
Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0198.House-Robber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0198.House-Robber/</guid>
      <description>198. House Robber #  题目 #  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0199.Binary-Tree-Right-Side-View/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0199.Binary-Tree-Right-Side-View/</guid>
      <description>199. Binary Tree Right Side View #  题目 #  Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
 Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 题目大意 #  从右边看一个树，输出看到的数字。注意有遮挡。
解题思路 #   这一题是按层序遍历的变种题。按照层序把每层的元素都遍历出来，然后依次取每一层的最右边的元素即可。用一个队列即可实现。 第 102 题和第 107 题都是按层序遍历的。  代码 #  package leetcode /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0200.Number-of-Islands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0200.Number-of-Islands/</guid>
      <description>200. Number of Islands #  题目 #  Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: 11110 11010 11000 00000 Output: 1  Example 2:
Input: 11000 11000 00100 00011 Output: 3  题目大意 #  给定一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0201.Bitwise-AND-of-Numbers-Range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0201.Bitwise-AND-of-Numbers-Range/</guid>
      <description>201. Bitwise AND of Numbers Range #  题目 #  Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
Example 1:
Input: [5,7] Output: 4  Example 2:
Input: [0,1] Output: 0  题目大意 #  给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
解题思路 #    这一题要求输出 [m,n] 区间内所有数的 AND 与操作之后的结果。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0202.Happy-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0202.Happy-Number/</guid>
      <description>202. Happy Number #  题目 #  Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0203.Remove-Linked-List-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0203.Remove-Linked-List-Elements/</guid>
      <description>203. 移除链表元素 #  Difficulty: 简单
删除链表中等于给定值 **_val _**的所有节点。
示例:
输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 题解 #  题解一：哨兵节点 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode sential = new ListNode(0); sential.next = head; ListNode prev = sential, curr = head; while (curr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0204.Count-Primes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0204.Count-Primes/</guid>
      <description>204. Count Primes #  题目 #  Count the number of prime numbers less than a non-negative number, n.
Example:
Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  题目大意 #  统计所有小于非负整数 n 的质数的数量。
解题思路 #   给出一个数字 n，要求输出小于 n 的所有素数的个数总和。简单题。  代码 #  package leetcode func countPrimes(n int) int { isNotPrime := make([]bool, n) for i := 2; i*i &amp;lt; n; i++ { if isNotPrime[i] { continue } for j := i * i; j &amp;lt; n; j = j + i { isNotPrime[j] = true } } count := 0 for i := 2; i &amp;lt; n; i++ { if !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0205.Isomorphic-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0205.Isomorphic-Strings/</guid>
      <description>205. Isomorphic Strings #  题目 #  Given two strings s and t, determine if they are isomorphic.
Two strings are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.
Example 1:
 Input: s = &amp;quot;egg&amp;quot;, t = &amp;quot;add&amp;quot; Output: true Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0206.Reverse-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0206.Reverse-Linked-List/</guid>
      <description>206. Reverse Linked List #  题目 #  Reverse a singly linked list.
题目大意 #  翻转单链表
解题思路 #  按照题意做即可。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // ListNode define type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { var behind *ListNode for head != nil { next := head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0207.Course-Schedule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0207.Course-Schedule/</guid>
      <description>207. Course Schedule #  题目 #  There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0208.Implement-Trie-Prefix-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0208.Implement-Trie-Prefix-Tree/</guid>
      <description>208. Implement Trie (Prefix Tree) #  题目 #  Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // returns true trie.search(&amp;quot;app&amp;quot;); // returns false trie.startsWith(&amp;quot;app&amp;quot;); // returns true trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // returns true  Note:
 You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.  题目大意 #  实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0209.Minimum-Size-Subarray-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0209.Minimum-Size-Subarray-Sum/</guid>
      <description>209. Minimum Size Subarray Sum #  题目 #  Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead.
Example 1:
 Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0210.Course-Schedule-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0210.Course-Schedule-II/</guid>
      <description>210. Course Schedule II #  题目 #  There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0211.Add-and-Search-Word-Data-structure-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0211.Add-and-Search-Word-Data-structure-design/</guid>
      <description>211. Add and Search Word - Data structure design #  题目 #  Design a data structure that supports the following two operations:
void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
Example:
addWord(&amp;quot;bad&amp;quot;) addWord(&amp;quot;dad&amp;quot;) addWord(&amp;quot;mad&amp;quot;) search(&amp;quot;pad&amp;quot;) -&amp;gt; false search(&amp;quot;bad&amp;quot;) -&amp;gt; true search(&amp;quot;.ad&amp;quot;) -&amp;gt; true search(&amp;quot;b..&amp;quot;) -&amp;gt; true  Note: You may assume that all words are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0212.Word-Search-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0212.Word-Search-II/</guid>
      <description>212. Word Search II #  题目 #  Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example:
Input: board = [ [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;], [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;], [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;], [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;] ] words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;] Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;]  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0213.House-Robber-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0213.House-Robber-II/</guid>
      <description>213. House Robber II #  题目 #  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0215.Kth-Largest-Element-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0215.Kth-Largest-Element-in-an-Array/</guid>
      <description>215. Kth Largest Element in an Array #  题目 #  Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Example 1:
 Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2:
 Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:
You may assume k is always valid, 1 ≤ k ≤ array&amp;rsquo;s length.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0216.Combination-Sum-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0216.Combination-Sum-III/</guid>
      <description>216. Combination Sum III #  题目 #  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
 All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1:
Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0217.Contains-Duplicate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0217.Contains-Duplicate/</guid>
      <description>217. Contains Duplicate #  题目 #  Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example 1:
 Input: [1,2,3,1] Output: true Example 2:
 Input: [1,2,3,4] Output: false Example 3:
 Input: [1,1,1,3,3,4,3,2,4,2] Output: true 题目大意 #  这是一道简单题，如果数组里面有重复数字就输出 true，否则输出 flase。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0218.The-Skyline-Problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0218.The-Skyline-Problem/</guid>
      <description>218. The Skyline Problem #  题目 #  A city&amp;rsquo;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).
  The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0219.Contains-Duplicate-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0219.Contains-Duplicate-II/</guid>
      <description>219. 存在重复元素 II #  Difficulty: 简单
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] ，并且 i 和 j 的差的 绝对值 至多为 k。
示例 1:
输入: nums = [1,2,3,1], k = 3 输出: true 示例 2:
输入: nums = [1,0,1,1], k = 1 输出: true 示例 3:
输入: nums = [1,2,3,1,2,3], k = 2 输出: false 题解 #  题解一：哈希表结构 #  class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0220.Contains-Duplicate-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0220.Contains-Duplicate-III/</guid>
      <description>220. Contains Duplicate III #  题目 #  Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.
Example 1:
Input: nums = [1,2,3,1], k = 3, t = 0 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0222.Count-Complete-Tree-Nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0222.Count-Complete-Tree-Nodes/</guid>
      <description>222. 完全二叉树的节点个数 #  Difficulty: 中等
给出一个完全二叉树，求出该树的节点个数。
说明：
的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
示例：
输入: 1 / \ 2 3 / \ / 4 5 6 输出: 6 题解 #  解法一：递归遍历（前、中、后序遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int countNodes(TreeNode root) { List&amp;lt;TreeNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); helper(root, list); return list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0223.Rectangle-Area/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0223.Rectangle-Area/</guid>
      <description>223. Rectangle Area #  题目 #  Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.
 Example:
Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0224.Basic-Calculator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0224.Basic-Calculator/</guid>
      <description>224. Basic Calculator #  题目 #  Implement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .
Example 1:
Input: &amp;quot;1 + 1&amp;quot; Output: 2  Example 2:
Input: &amp;quot; 2-1 + 2 &amp;quot; Output: 3  Example 3:
Input: &amp;quot;(1+(4+5+2)-3)+(6+8)&amp;quot; Output: 23  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0225.Implement-Stack-using-Queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0225.Implement-Stack-using-Queues/</guid>
      <description>225. Implement Stack using Queues #  题目 #  Implement the following operations of a stack using queues.
 push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. empty() &amp;ndash; Return whether the stack is empty.  Example:
 MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0226.Invert-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0226.Invert-Binary-Tree/</guid>
      <description>226. Invert Binary Tree #  题目 #  Invert a binary tree.
Example:
Input:
 4 / \ 2 7 / \ / \ 1 3 6 9 Output:
 4 / \ 7 2 / \ / \ 9 6 3 1 Trivia:
This problem was inspired by this original tweet by Max Howell:
 Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0228.Summary-Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0228.Summary-Ranges/</guid>
      <description>228. 汇总区间 #  Difficulty: 简单
给定一个无重复元素的有序整数数组 nums 。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。
列表中的每个区间范围 [a,b] 应该按如下格式输出：
 &amp;quot;a-&amp;gt;b&amp;quot; ，如果 a != b &amp;quot;a&amp;quot; ，如果 a == b  示例 1：
输入：nums = [0,1,2,4,5,7] 输出：[&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;] 解释：区间范围是： [0,2] --&amp;gt; &amp;quot;0-&amp;gt;2&amp;quot; [4,5] --&amp;gt; &amp;quot;4-&amp;gt;5&amp;quot; [7,7] --&amp;gt; &amp;quot;7&amp;quot; 示例 2：
输入：nums = [0,2,3,4,6,8,9] 输出：[&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;] 解释：区间范围是： [0,0] --&amp;gt; &amp;quot;0&amp;quot; [2,4] --&amp;gt; &amp;quot;2-&amp;gt;4&amp;quot; [6,6] --&amp;gt; &amp;quot;6&amp;quot; [8,9] --&amp;gt; &amp;quot;8-&amp;gt;9&amp;quot; 示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0229.Majority-Element-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0229.Majority-Element-II/</guid>
      <description>229. Majority Element II #  题目 #  Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Note: The algorithm should run in linear time and in O(1) space.
Example 1:
Input: [3,2,3] Output: [3]  Example 2:
Input: [1,1,1,3,3,2,2,2] Output: [1,2]  题目大意 #  给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。
解题思路 #   这一题是第 169 题的加强版。Boyer-Moore Majority Vote algorithm 算法的扩展版。 题目要求找出数组中出现次数大于 ⌊ n/3 ⌋ 次的数。要求空间复杂度为 O(1)。简单题。 这篇文章写的不错，可参考： https://gregable.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0230.Kth-Smallest-Element-in-a-BST/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0230.Kth-Smallest-Element-in-a-BST/</guid>
      <description>230. Kth Smallest Element in a BST #  题目 #  Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;rsquo;s total elements.
Example 1:
Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1  Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3  Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0231.Power-of-Two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0231.Power-of-Two/</guid>
      <description>231. Power of Two #  题目 #  Given an integer, write a function to determine if it is a power of two.
Example 1:
Input: 1 Output: true Explanation: 2^0 = 1  Example 2:
Input: 16 Output: true Explanation: 2^4 = 16  Example 3:
Input: 218 Output: false  题目大意 #  给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
解题思路 #   判断一个数是不是 2 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。这一题和第 326 题是一样的思路。  代码 #  package leetcode // 解法一 二进制位操作法 func isPowerOfTwo(num int) bool { return (num &amp;gt; 0 &amp;amp;&amp;amp; ((num &amp;amp; (num - 1)) == 0)) } // 解法二 数论 func isPowerOfTwo1(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; (1073741824%num == 0) } // 解法三 打表法 func isPowerOfTwo2(num int) bool { allPowerOfTwoMap := map[int]int{1: 1, 2: 2, 4: 4, 8: 8, 16: 16, 32: 32, 64: 64, 128: 128, 256: 256, 512: 512, 1024: 1024, 2048: 2048, 4096: 4096, 8192: 8192, 16384: 16384, 32768: 32768, 65536: 65536, 131072: 131072, 262144: 262144, 524288: 524288, 1048576: 1048576, 2097152: 2097152, 4194304: 4194304, 8388608: 8388608, 16777216: 16777216, 33554432: 33554432, 67108864: 67108864, 134217728: 134217728, 268435456: 268435456, 536870912: 536870912, 1073741824: 1073741824} _, ok := allPowerOfTwoMap[num] return ok } // 解法四 循环 func isPowerOfTwo3(num int) bool { for num &amp;gt;= 2 { if num%2 == 0 { num = num / 2 } else { return false } } return num == 1 } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0232.Implement-Queue-using-Stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0232.Implement-Queue-using-Stacks/</guid>
      <description>232. Implement Queue using Stacks #  题目 #  Implement the following operations of a queue using stacks.
 push(x) &amp;ndash; Push element x to the back of queue. pop() &amp;ndash; Removes the element from in front of queue. peek() &amp;ndash; Get the front element. empty() &amp;ndash; Return whether the queue is empty.  Example:
 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0234.Palindrome-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0234.Palindrome-Linked-List/</guid>
      <description>234. Palindrome Linked List #  题目 #  Given a singly linked list, determine if it is a palindrome.
Example 1:
 Input: 1-&amp;gt;2 Output: false Example 2:
 Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true Follow up:
Could you do it in O(n) time and O(1) space?
题目大意 #  判断一个链表是否是回文链表。要求时间复杂度 O(n)，空间复杂度 O(1)。
解题思路 #  这道题只需要在第 143 题上面改改就可以了。思路是完全一致的。先找到中间结点，然后反转中间结点后面到结尾的所有结点。最后一一判断头结点开始的结点和中间结点往后开始的结点是否相等。如果一直相等，就是回文链表，如果有不相等的，直接返回不是回文链表。
代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 此题和 143 题 Reorder List 思路基本一致 func isPalindrome234(head *ListNode) bool { if head == nil || head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0235.Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0235.Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</guid>
      <description>235. Lowest Common Ancestor of a Binary Search Tree #  题目 #  Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0236.Lowest-Common-Ancestor-of-a-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0236.Lowest-Common-Ancestor-of-a-Binary-Tree/</guid>
      <description>236. Lowest Common Ancestor of a Binary Tree #  题目 #  Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0237.Delete-Node-in-a-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0237.Delete-Node-in-a-Linked-List/</guid>
      <description>237. Delete Node in a Linked List #  题目 #  Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Given linked list &amp;ndash; head = [4,5,1,9], which looks like following:
 Example 1:
 Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0239.Sliding-Window-Maximum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0239.Sliding-Window-Maximum/</guid>
      <description>239. Sliding Window Maximum #  题目 #  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
Example:
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0240.Search-a-2D-Matrix-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0240.Search-a-2D-Matrix-II/</guid>
      <description>240. Search a 2D Matrix II #  题目 #  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example:
Consider the following matrix:
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]  Given target = 5, return true.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0242.Valid-Anagram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0242.Valid-Anagram/</guid>
      <description>242. Valid Anagram #  题目 #  Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
 Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2:
 Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note:
You may assume the string contains only lowercase alphabets.
Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0257.Binary-Tree-Paths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0257.Binary-Tree-Paths/</guid>
      <description>257. Binary Tree Paths #  题目 #  Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3  题目大意 #  给定一个二叉树，返回所有从根节点到叶子节点的路径。说明: 叶子节点是指没有子节点的节点。
解题思路 #   Google 的面试题，考察递归  代码 #  package leetcode import ( &amp;#34;strconv&amp;#34; ) /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0258.Add-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0258.Add-Digits/</guid>
      <description>258. Add Digits #  题目 #  Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
Example:
Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime?
题目大意 #  给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0260.Single-Number-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0260.Single-Number-III/</guid>
      <description>260. Single Number III #  题目 #  Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
Example:
Input: [1,2,1,3,2,5] Output: [3,5]  Note:
 The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0263.Ugly-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0263.Ugly-Number/</guid>
      <description>263. Ugly Number #  题目 #  Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
Example 1:
 Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2:
Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3:
 Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0268.Missing-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0268.Missing-Number/</guid>
      <description>268. 丢失的数字 #  Difficulty: 简单
给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
进阶：
 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?  示例 1：
输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2：
输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3：
输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0274.H-Index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0274.H-Index/</guid>
      <description>274. H-Index #  题目 #  Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0275.H-Index-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0275.H-Index-II/</guid>
      <description>275. H-Index II #  题目 #  Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0283.Move-Zeroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0283.Move-Zeroes/</guid>
      <description>283. Move Zeroes #  题目 #  Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Example 1:
 Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:
 You must do this in-place without making a copy of the array. Minimize the total number of operations.  题目大意 #  题目要求不能采用额外的辅助空间，将数组中 0 元素都移动到数组的末尾，并且维持所有非 0 元素的相对位置。
解题思路 #  这一题可以只扫描数组一遍，不断的用 i，j 标记 0 和非 0 的元素，然后相互交换，最终到达题目的目的。与这一题相近的题目有第 26 题，第 27 题，第 80 题。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0287.Find-the-Duplicate-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0287.Find-the-Duplicate-Number/</guid>
      <description>287. Find the Duplicate Number #  题目 #  Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Example 1:
 Input: [1,3,4,2,2] Output: 2 Example 2:
 Input: [3,1,3,4,2] Output: 3 Note:
 You must not modify the array (assume the array is read only).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0290.Word-Pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0290.Word-Pattern/</guid>
      <description>290. Word Pattern #  题目 #  Given a pattern and a string str, find if str follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.
Example 1:
 Input: pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat dog&amp;quot; Output: true Example 2:
 Input:pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat fish&amp;quot; Output: false Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0297.Serialize-And-Deserialize-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0297.Serialize-And-Deserialize-Binary-Tree/</guid>
      <description>297. 二叉树的序列化与反序列化 #  Difficulty: 困难
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
**示例: **
你可以将以下二叉树： 1 / \ 2 3 / \ 4 5 序列化为 &amp;quot;[1,2,3,null,null,4,5]&amp;quot; **提示: **这与 LeetCode 目前使用的方式一致，详情请参阅 。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
**说明: **不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。
题解 #  题解一：DFS（深度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0300.Longest-Increasing-Subsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0300.Longest-Increasing-Subsequence/</guid>
      <description>300. Longest Increasing Subsequence #  题目 #  Given an unsorted array of integers, find the length of longest increasing subsequence.
Example:
Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:
 There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n^2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0303.Range-Sum-Query-Immutable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0303.Range-Sum-Query-Immutable/</guid>
      <description>303. Range Sum Query - Immutable #  题目 #  Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
Example:
Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3  Note:
 You may assume that the array does not change. There are many calls to sumRange function.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0306.Additive-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0306.Additive-Number/</guid>
      <description>306. Additive Number #  题目 #  Additive number is a string whose digits can form additive sequence.
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.
Given a string containing only digits &#39;0&#39;-&#39;9&#39;, write a function to determine if it&amp;rsquo;s an additive number.
Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0307.Range-Sum-Query-Mutable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0307.Range-Sum-Query-Mutable/</guid>
      <description>307. Range Sum Query - Mutable #  题目 #  Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
The update(i, val) function modifies nums by updating the element at index i to val.
Example:
Given nums = [1, 3, 5] sumRange(0, 2) -&amp;gt; 9 update(1, 2) sumRange(0, 2) -&amp;gt; 8  Note:
 The array is only modifiable by the update function.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</guid>
      <description>309. Best Time to Buy and Sell Stock with Cooldown #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
 You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0315.Count-of-Smaller-Numbers-After-Self/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0315.Count-of-Smaller-Numbers-After-Self/</guid>
      <description>315. Count of Smaller Numbers After Self #  题目 #  You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].
Example:
Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0318.Maximum-Product-of-Word-Lengths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0318.Maximum-Product-of-Word-Lengths/</guid>
      <description>318. Maximum Product of Word Lengths #  题目 #  Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.
Example 1:
Input: [&amp;quot;abcw&amp;quot;,&amp;quot;baz&amp;quot;,&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;xtfn&amp;quot;,&amp;quot;abcdef&amp;quot;] Output: 16 Explanation: The two words can be &amp;quot;abcw&amp;quot;, &amp;quot;xtfn&amp;quot;.  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0322.Coin-Change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0322.Coin-Change/</guid>
      <description>322. Coin Change #  题目 #  You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1:
Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0324.Wiggle-Sort-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0324.Wiggle-Sort-II/</guid>
      <description>324. Wiggle Sort II #  题目 #  Given an unsorted array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;.
Example 1:
 Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2:
 Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0326.Power-of-Three/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0326.Power-of-Three/</guid>
      <description>326. Power of Three #  题目 #  Given an integer, write a function to determine if it is a power of three.
Example 1:
Input: 27 Output: true  Example 2:
Input: 0 Output: false  Example 3:
Input: 9 Output: true  Example 4:
Input: 45 Output: false  Follow up:
Could you do it without using any loop / recursion?
题目大意 #  给定一个整数，写一个函数来判断它是否是 3 的幂次方。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0327.Count-of-Range-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0327.Count-of-Range-Sum/</guid>
      <description>327. Count of Range Sum #  题目 #  Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.
Note:A naive algorithm of O(n2) is trivial. You MUST do better than that.
Example:
Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3 Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0328.Odd-Even-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0328.Odd-Even-Linked-List/</guid>
      <description>328. Odd Even Linked List #  题目 #  Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
Example 1:
 Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0329.Longest-Increasing-Path-in-a-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0329.Longest-Increasing-Path-in-a-Matrix/</guid>
      <description>329. Longest Increasing Path in a Matrix #  题目 #  Given an integer matrix, find the length of the longest increasing path.
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).
Example 1:
Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</guid>
      <description>331. Verify Preorder Serialization of a Binary Tree #  题目 #  One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as #.
 _9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # # For example, the above binary tree can be serialized to the string &amp;ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;rdquo;, where # represents a null node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0337.House-Robber-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0337.House-Robber-III/</guid>
      <description>337. House Robber III #  题目 #  The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;ldquo;root.&amp;rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;ldquo;all houses in this place forms a binary tree&amp;rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0338.Counting-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0338.Counting-Bits/</guid>
      <description>338. Counting Bits #  题目 #  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.
Example 1:
Input: 2 Output: [0,1,1]  Example 2:
Input: 5 Output: [0,1,1,2,1,2]  Follow up:
 It is very easy to come up with a solution with run time O(n*sizeof(integer)).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0342.Power-of-Four/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0342.Power-of-Four/</guid>
      <description>342. Power of Four #  题目 #  Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
Example 1:
Input: 16 Output: true  Example 2:
Input: 5 Output: false  Follow up: Could you solve it without loops/recursion?
题目大意 #  给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。
解题思路 #   判断一个数是不是 4 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。 证明 (4^n - 1) % 3 == 0，(1) 4^n - 1 = (2^n + 1) * (2^n - 1)(2) 在任何连续的 3 个数中 (2^n-1)，(2^n)，(2^n+1)，一定有一个数是 3 的倍数。(2^n) 肯定不是 3 的倍数，那么 (2^n-1) 或者 (2^n+1) 中一定有一个是 3 的倍数。所以 4^n-1 一定是 3 的倍数。  代码 #  package leetcode // 解法一 数论 func isPowerOfFour(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; (num&amp;amp;(num-1)) == 0 &amp;amp;&amp;amp; (num-1)%3 == 0 } // 解法二 循环 func isPowerOfFour1(num int) bool { for num &amp;gt;= 4 { if num%4 == 0 { num = num / 4 } else { return false } } return num == 1 } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0343.Integer-Break/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0343.Integer-Break/</guid>
      <description>343. Integer Break #  题目 #  Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.
Example 1:
Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2:
Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0344.Reverse-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0344.Reverse-String/</guid>
      <description>344. Reverse String #  题目 #  Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
 Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
 Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;] 题目大意 #  题目要求我们反转一个字符串。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0345.Reverse-Vowels-of-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0345.Reverse-Vowels-of-a-String/</guid>
      <description>345. Reverse Vowels of a String #  题目 #  Write a function that takes a string as input and reverse only the vowels of a string.
Example 1:
 Input: &amp;quot;hello&amp;quot; Output: &amp;quot;holle&amp;quot; Example 2:
 Input: &amp;quot;leetcode&amp;quot; Output: &amp;quot;leotcede&amp;quot; 题目大意 #  题目要求我们反转字符串中的元音字母。需要注意字母大小写。
解题思路 #  这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。这一题和第 344 题思路一样。
代码 #  package leetcode func reverseVowels(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &amp;lt; j; { if isVowels(b[i]) &amp;amp;&amp;amp; isVowels(b[j]) { b[i], b[j] = b[j], b[i] i++ j-- } else if isVowels(b[i]) &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0347.Top-K-Frequent-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0347.Top-K-Frequent-Elements/</guid>
      <description>347. Top K Frequent Elements #  题目 #  Given a non-empty array of integers, return the k most frequent elements.
Example 1:
 Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
 Input: nums = [1], k = 1 Output: [1] Note:
 You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0349.Intersection-of-Two-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0349.Intersection-of-Two-Arrays/</guid>
      <description>349. Intersection of Two Arrays #  题目 #  Given two arrays, write a function to compute their intersection.
Example 1:
 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2:
 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note:
 Each element in the result must be unique. The result can be in any order.  题目大意 #  找到两个数组的交集元素，如果交集元素同一个数字出现了多次，只输出一次。
解题思路 #  把数组一的每个数字都存进字典中，然后在数组二中依次判断字典中是否存在，如果存在，在字典中删除它(因为输出要求只输出一次)。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0350.Intersection-of-Two-Arrays-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0350.Intersection-of-Two-Arrays-II/</guid>
      <description>350. Intersection of Two Arrays II #  题目 #  Given two arrays, write a function to compute their intersection.
Example 1:
 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:
 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note:
 Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0354.Russian-Doll-Envelopes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0354.Russian-Doll-Envelopes/</guid>
      <description>354. Russian Doll Envelopes #  题目 #  You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.
What is the maximum number of envelopes can you Russian doll? (put one inside other)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0357.Count-Numbers-with-Unique-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0357.Count-Numbers-with-Unique-Digits/</guid>
      <description>357. Count Numbers with Unique Digits #  题目 #  Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &amp;lt; 10n.
Example:
Input: 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &amp;lt; 100, excluding 11,22,33,44,55,66,77,88,99  题目大意 #  给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &amp;lt; 10^n 。
解题思路 #   输出 n 位数中不出现重复数字的数字的个数 这道题摸清楚规律以后，可以直接写出最终所有答案，答案只有 11 个。 考虑不重复数字是如生成的。如果只是一位数，不存在重复的数字，结果是 10 。如果是二位数，第一位一定不能取 0，那么第一位有 1-9，9种取法，第二位为了和第一位不重复，只能有 0-9，10种取法中减去第一位取的数字，那么也是 9 种取法。以此类推，如果是三位数，第三位是 8 种取法；四位数，第四位是 7 种取法；五位数，第五位是 6 种取法；六位数，第六位是 5 种取法；七位数，第七位是 4 种取法；八位数，第八位是 3 种取法；九位数，第九位是 2 种取法；十位数，第十位是 1 种取法；十一位数，第十一位是 0 种取法；十二位数，第十二位是 0 种取法；那么第 11 位数以后，每个数都是重复数字的数字。知道这个规律以后，可以累积上面的结果，把结果直接存在数组里面，暴力打表即可。O(1) 的时间复杂度。  代码 #  package leetcode // 暴力打表法 func countNumbersWithUniqueDigits1(n int) int { res := []int{1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691} if n &amp;gt;= 10 { return res[10] } return res[n] } // 打表方法 func countNumbersWithUniqueDigits(n int) int { if n == 0 { return 1 } res, uniqueDigits, availableNumber := 10, 9, 9 for n &amp;gt; 1 &amp;amp;&amp;amp; availableNumber &amp;gt; 0 { uniqueDigits = uniqueDigits * availableNumber res += uniqueDigits availableNumber-- n-- } return res } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0367.Valid-Perfect-Square/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0367.Valid-Perfect-Square/</guid>
      <description>367. Valid Perfect Square #  题目 #  Given a positive integer num, write a function which returns True if num is a perfect square else False.
Note: Do not use any built-in library function such as sqrt.
Example 1:
Input: 16 Output: true  Example 2:
Input: 14 Output: false  题目大意 #  给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。
说明：不要使用任何内置的库函数，如 sqrt。
解题思路 #   给出一个数，要求判断这个数是不是完全平方数。 可以用二分搜索来解答这道题。判断完全平方数，根据它的定义来，是否能被开根号，即找到一个数的平方是否可以等于待判断的数字。从 [1, n] 区间内进行二分，若能找到则返回 true，找不到就返回 false 。  代码 #  package leetcode func isPerfectSquare(num int) bool { low, high := 1, num for low &amp;lt;= high { mid := low + (high-low)&amp;gt;&amp;gt;1 if mid*mid == num { return true } else if mid*mid &amp;lt; num { low = mid + 1 } else { high = mid - 1 } } return false } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0371.Sum-of-Two-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0371.Sum-of-Two-Integers/</guid>
      <description>371. Sum of Two Integers #  题目 #  Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2 Output: 3  Example 2:
Input: a = -2, b = 3 Output: 1  题目大意 #  不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
解题思路 #   要求不用加法和减法运算符计算 a+b。这一题需要用到 ^ 和 &amp;amp; 运算符的性质，两个数 ^ 可以实现两个数不带进位的二进制加法。这里需要实现加法，肯定需要进位。所以如何找到进位是本题的关键。 在二进制中，只有 1 和 1 加在一起才会进位，0 和 0，0 和 1，1 和 0，这三种情况都不会进位，规律就是 a &amp;amp; b 为 0 的时候就不用进位，为 1 的时候代表需要进位。进位是往前进一位，所以还需要左移操作，所以加上的进位为 (a&amp;amp;b)&amp;lt;&amp;lt;1。  代码 #  package leetcode func getSum(a int, b int) int { if a == 0 { return b } if b == 0 { return a } // (a &amp;amp; b)&amp;lt;&amp;lt;1 计算的是进位 	// a ^ b 计算的是不带进位的加法 	return getSum((a&amp;amp;b)&amp;lt;&amp;lt;1, a^b) } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0372.Super-Pow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0372.Super-Pow/</guid>
      <description>372. Super Pow #  题目 #  Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.
Example 1:
Input: a = 2, b = [3] Output: 8  Example 2:
Input: a = 2, b = [1,0] Output: 1024  题目大意 #  你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0373.Find-K-Pairs-with-Smallest-Sums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0373.Find-K-Pairs-with-Smallest-Sums/</guid>
      <description>373. Find K Pairs with Smallest Sums #  题目 #  You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.
Define a pair (u,v) which consists of one element from the first array and one element from the second array.
Find the k pairs (u1,v1),(u2,v2) &amp;hellip;(uk,vk) with the smallest sums.
Example 1:
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</guid>
      <description>378. Kth Smallest Element in a Sorted Matrix #  题目 #  Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
Example:
matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0385.Mini-Parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0385.Mini-Parser/</guid>
      <description>385. Mini Parser #  题目 #  Given a nested list of integers represented as a string, implement a parser to deserialize it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Note: You may assume that the string is well-formed:
 String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0386.Lexicographical-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0386.Lexicographical-Numbers/</guid>
      <description>386. Lexicographical Numbers #  题目 #  Given an integer n, return 1 - n in lexicographical order.
For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].
Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.
题目大意 #  给定一个整数 n, 返回从 1 到 n 的字典顺序。例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。
请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。
解题思路 #   给出一个数字 n ，要求按照字典序对 1-n 这 n 个数排序。 DFS 暴力求解即可。  代码 #  package leetcode func lexicalOrder(n int) []int { res := make([]int, 0, n) dfs386(1, n, &amp;amp;res) return res } func dfs386(x, n int, res *[]int) { limit := (x + 10) / 10 * 10 for x &amp;lt;= n &amp;amp;&amp;amp; x &amp;lt; limit { *res = append(*res, x) if x*10 &amp;lt;= n { dfs386(x*10, n, res) } x++ } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0387.First-Unique-Character-in-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0387.First-Unique-Character-in-a-String/</guid>
      <description>387. First Unique Character in a String #  题目 #  Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2.  Note: You may assume the string contain only lowercase letters.
题目大意 #  给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
解题思路 #   简单题，要求输出第一个没有重复的字符。  代码 #  package leetcode func firstUniqChar(s string) int { result := make([]int, 26) for i := 0; i &amp;lt; len(s); i++ { result[s[i]-&amp;#39;a&amp;#39;]++ } for i := 0; i &amp;lt; len(s); i++ { if result[s[i]-&amp;#39;a&amp;#39;] == 1 { return i } } return -1 } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0389.Find-the-Difference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0389.Find-the-Difference/</guid>
      <description>389. Find the Difference #  题目 #  Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
Example:
Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; Output: e Explanation: &#39;e&#39; is the letter that was added.  题目大意 #  给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0392.Is-Subsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0392.Is-Subsequence/</guid>
      <description>392. Is Subsequence #  题目 #  Given a string s and a string t, check if s is subsequence of t.
You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&amp;lt;=100).
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0393.UTF-8-Validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0393.UTF-8-Validation/</guid>
      <description>393. UTF-8 Validation #  题目 #  A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
 For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one&amp;rsquo;s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0394.Decode-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0394.Decode-String/</guid>
      <description>394. Decode String #  题目 #  Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0397.Integer-Replacement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0397.Integer-Replacement/</guid>
      <description>397. Integer Replacement #  题目 #  Given a positive integer n and you can do operations as follow:
 If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.  What is the minimum number of replacements needed for n to become 1?
Example 1:
Input: 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0399.Evaluate-Division/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0399.Evaluate-Division/</guid>
      <description>399. Evaluate Division #  题目 #  Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.
Example:
Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0401.Binary-Watch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0401.Binary-Watch/</guid>
      <description>401. Binary Watch #  题目 #  A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.
 For example, the above binary watch reads &amp;ldquo;3:25&amp;rdquo;.
Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0402.Remove-K-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0402.Remove-K-Digits/</guid>
      <description>402. Remove K Digits #  题目 #  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:
 Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0404.Sum-of-Left-Leaves/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0404.Sum-of-Left-Leaves/</guid>
      <description>404. Sum of Left Leaves #  题目 #  Find the sum of all left leaves in a given binary tree.
Example:
 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.  题目大意 #  计算给定二叉树的所有左叶子之和。
解题思路 #   这一题是微软的面试题。递归求解即可  代码 #  package leetcode /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0405.Convert-a-Number-to-Hexadecimal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0405.Convert-a-Number-to-Hexadecimal/</guid>
      <description>405. Convert a Number to Hexadecimal #  题目 #  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.
Note:
 All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0409.Longest-Palindrome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0409.Longest-Palindrome/</guid>
      <description>409. Longest Palindrome #  题目 #  Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
This is case sensitive, for example &amp;quot;Aa&amp;quot; is not considered a palindrome here.
Note:Assume the length of given string will not exceed 1,010.
Example:
Input: &amp;quot;abccccdd&amp;quot; Output: 7 Explanation: One longest palindrome that can be built is &amp;quot;dccaccd&amp;quot;, whose length is 7.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0410.Split-Array-Largest-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0410.Split-Array-Largest-Sum/</guid>
      <description>410. Split Array Largest Sum #  题目 #  Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
Note:If n is the length of array, assume the following constraints are satisfied:
 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  Examples:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0412.Fizz-Buzz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0412.Fizz-Buzz/</guid>
      <description>412. Fizz Buzz #  题目 #  Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15, Return: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ] 题目大意 #  3的倍数输出 &amp;ldquo;Fizz&amp;rdquo;，5的倍数输出 &amp;ldquo;Buzz&amp;rdquo;，15的倍数输出 &amp;ldquo;FizzBuzz&amp;rdquo;，其他时候都输出原本的数字。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0414.Third-Maximum-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0414.Third-Maximum-Number/</guid>
      <description>414. Third Maximum Number #  题目 #  Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
Example 1:
Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.  Example 2:
Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0416.Partition-Equal-Subset-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0416.Partition-Equal-Subset-Sum/</guid>
      <description>416. Partition Equal Subset Sum #  题目 #  Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
Note:
 Each of the array element will not exceed 100. The array size will not exceed 200.  Example 1:
Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0421.Maximum-XOR-of-Two-Numbers-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0421.Maximum-XOR-of-Two-Numbers-in-an-Array/</guid>
      <description>421. Maximum XOR of Two Numbers in an Array #  题目 #  Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &amp;lt; 231.
Find the maximum result of ai XOR aj, where 0 ≤ i, j &amp;lt; n.
Could you do this in O(n) runtime?
Example:
Input: [3, 10, 5, 25, 2, 8] Output: 28 Explanation: The maximum result is 5 ^ 25 = 28.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0424.Longest-Repeating-Character-Replacement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0424.Longest-Repeating-Character-Replacement/</guid>
      <description>424. Longest Repeating Character Replacement #  题目 #  Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.
Note:
Both the string&amp;rsquo;s length and k will not exceed 10^4.
Example 1:
 Input: s = &amp;quot;ABAB&amp;quot;, k = 2 Output: 4 Explanation: Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0433.Minimum-Genetic-Mutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0433.Minimum-Genetic-Mutation/</guid>
      <description>433. Minimum Genetic Mutation #  题目 #  A gene string can be represented by an 8-character long string, with choices from &amp;quot;A&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;T&amp;quot;.
Suppose we need to investigate about a mutation (mutation from &amp;ldquo;start&amp;rdquo; to &amp;ldquo;end&amp;rdquo;), where ONE mutation is defined as ONE single character changed in the gene string.
For example, &amp;quot;AACCGGTT&amp;quot; -&amp;gt; &amp;quot;AACCGGTA&amp;quot; is 1 mutation.
Also, there is a given gene &amp;ldquo;bank&amp;rdquo;, which records all the valid gene mutations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0435.Non-overlapping-Intervals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0435.Non-overlapping-Intervals/</guid>
      <description>435. Non-overlapping Intervals #  题目 #  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Note:
 You may assume the interval&amp;rsquo;s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders &amp;ldquo;touching&amp;rdquo; but they don&amp;rsquo;t overlap each other.  Example 1:
Input: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0436.Find-Right-Interval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0436.Find-Right-Interval/</guid>
      <description>436. Find Right Interval #  题目 #  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the &amp;ldquo;right&amp;rdquo; of i.
For any interval i, you need to store the minimum interval j&amp;rsquo;s index, which means that the interval j has the minimum start point to build the &amp;ldquo;right&amp;rdquo; relationship for interval i.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0437.Path-Sum-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0437.Path-Sum-III/</guid>
      <description>437. Path Sum III #  题目 #  You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0438.Find-All-Anagrams-in-a-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0438.Find-All-Anagrams-in-a-String/</guid>
      <description>438. Find All Anagrams in a String #  题目 #  Given a string s and a non-empty string p, find all the start indices of p&amp;rsquo;s anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
 Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0441.Arranging-Coins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0441.Arranging-Coins/</guid>
      <description>441. Arranging Coins #  题目 #  You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.
Given n, find the total number of full staircase rows that can be formed.
n is a non-negative integer and fits within the range of a 32-bit signed integer.
Example 1:
n = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0445.Add-Two-Numbers-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0445.Add-Two-Numbers-II/</guid>
      <description>445. Add Two Numbers II #  题目 #  You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Follow up: What if you cannot modify the input lists?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0447.Number-of-Boomerangs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0447.Number-of-Boomerangs/</guid>
      <description>447. Number of Boomerangs #  题目 #  Given n points in the plane that are all pairwise distinct, a &amp;ldquo;boomerang&amp;rdquo; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0448.Find-All-Numbers-Disappeared-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0448.Find-All-Numbers-Disappeared-in-an-Array/</guid>
      <description>448. Find All Numbers Disappeared in an Array #  题目 #  Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0450.Delete-Node-In-A-Bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0450.Delete-Node-In-A-Bst/</guid>
      <description>450. 删除二叉搜索树中的节点 #  Difficulty: 中等
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：
 首先找到需要删除的节点； 如果找到了，删除它。  说明： 要求算法时间复杂度为 O(h)，h 为树的高度。
示例:
root = [5,3,6,2,4,null,7] key = 3 5 / \ 3 6 / \ \ 2 4 7 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \ 4 6 / \ 2 7 另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \ 2 6 \ \ 4 7 题解 #  题解一： #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0451.Sort-Characters-By-Frequency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0451.Sort-Characters-By-Frequency/</guid>
      <description>451. Sort Characters By Frequency #  题目 #  Given a string, sort it in decreasing order based on the frequency of characters.
Example 1:
 Input: &amp;quot;tree&amp;quot; Output: &amp;quot;eert&amp;quot; Explanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once. So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &amp;quot;eetr&amp;quot; is also a valid answer. Example 2:
 Input: &amp;quot;cccaaa&amp;quot; Output: &amp;quot;cccaaa&amp;quot; Explanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so &amp;quot;aaaccc&amp;quot; is also a valid answer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0453.Minimum-Moves-to-Equal-Array-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0453.Minimum-Moves-to-Equal-Array-Elements/</guid>
      <description>453. Minimum Moves to Equal Array Elements #  题目 #  Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
Example:
Input: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4] 题目大意 #  给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0454.4Sum-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0454.4Sum-II/</guid>
      <description>454. 4Sum II #  题目 #  Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0455.Assign-Cookies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0455.Assign-Cookies/</guid>
      <description>455. Assign Cookies #  题目 #  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0456.132-Pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0456.132-Pattern/</guid>
      <description>456. 132 Pattern #  题目 #  Given a sequence of n integers a1, a2, &amp;hellip;, an, a 132 pattern is a subsequence ai, aj, ak such that i &amp;lt; j &amp;lt; k and ai &amp;lt; ak &amp;lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.
Note: n will be less than 15,000.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0457.Circular-Array-Loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0457.Circular-Array-Loop/</guid>
      <description>457. Circular Array Loop #  题目 #  You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it&amp;rsquo;s negative (-k), move backward k steps. Since the array is circular, you may assume that the last element&amp;rsquo;s next element is the first element, and the first element&amp;rsquo;s previous element is the last element.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0461.Hamming-Distance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0461.Hamming-Distance/</guid>
      <description>461. Hamming Distance #  题目 #  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Note: 0 ≤ x, y &amp;lt; 231.
Example:
Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0463.Island-Perimeter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0463.Island-Perimeter/</guid>
      <description>463. Island Perimeter #  题目 #  You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0470.Implement-Rand10-Using-Rand7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0470.Implement-Rand10-Using-Rand7/</guid>
      <description>470. Implement Rand10() Using Rand7() #  题目 #  Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.
Do NOT use system&amp;rsquo;s Math.random().
Example 1:
Input: 1 Output: [7]  Example 2:
Input: 2 Output: [8,4]  Example 3:
Input: 3 Output: [8,1,10]  Note:
 rand7 is predefined.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0474.Ones-and-Zeroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0474.Ones-and-Zeroes/</guid>
      <description>474. Ones and Zeroes #  题目 #  In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.
Now your task is to find the maximum number of strings that you can form with given m0s and n 1s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0475.Heaters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0475.Heaters/</guid>
      <description>475. Heaters #  题目 #  Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.
Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.
So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0476.Number-Complement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0476.Number-Complement/</guid>
      <description>476. Number Complement #  题目 #  Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
Note:
 The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.  Example 1:
Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0477.Total-Hamming-Distance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0477.Total-Hamming-Distance/</guid>
      <description>477. Total Hamming Distance #  题目 #  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Now your job is to find the total Hamming distance between all pairs of the given numbers.
Example:
Input: 4, 14, 2 Output: 6 Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0480.Sliding-Window-Median/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0480.Sliding-Window-Median/</guid>
      <description>480. Sliding Window Median #  题目 #  Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
Examples:
[2,3,4] , the median is 3
[2,3], the median is (2 + 3) / 2 = 2.5
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0483.Smallest-Good-Base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0483.Smallest-Good-Base/</guid>
      <description>483. Smallest Good Base #  题目 #  For an integer n, we call k&amp;gt;=2 a good base of n, if all digits of n base k are 1.
Now given a string representing n, you should return the smallest good base of n in string format.
Example 1:
Input: &amp;quot;13&amp;quot; Output: &amp;quot;3&amp;quot; Explanation: 13 base 3 is 111.  Example 2:
Input: &amp;quot;4681&amp;quot; Output: &amp;quot;8&amp;quot; Explanation: 4681 base 8 is 11111.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0485.Max-Consecutive-Ones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0485.Max-Consecutive-Ones/</guid>
      <description>485. Max Consecutive Ones #  题目 #  Given a binary array, find the maximum number of consecutive 1s in this array.
Example 1:
Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note:
 The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000  题目大意 #  给定一个二进制数组， 计算其中最大连续1的个数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0491.Increasing-Subsequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0491.Increasing-Subsequences/</guid>
      <description>491. Increasing Subsequences #  题目 #  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.
Example:
Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]  Note:
 The length of the given array will not exceed 15.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0493.Reverse-Pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0493.Reverse-Pairs/</guid>
      <description>493. Reverse Pairs #  题目 #  Given an array nums, we call (i, j) an important reverse pair if i &amp;lt; j and nums[i] &amp;gt; 2*nums[j].
You need to return the number of important reverse pairs in the given array.
Example1:
Input: [1,3,2,3,1] Output: 2  Example2:
Input: [2,4,3,5,1] Output: 3  Note:
 The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0494.Target-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0494.Target-Sum/</guid>
      <description>494. Target Sum #  题目 #  You are given a list of non-negative integers, a1, a2, &amp;hellip;, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.
Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0496.Next-Greater-Element-I/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0496.Next-Greater-Element-I/</guid>
      <description>496. Next Greater Element I #  题目 #  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1&amp;rsquo;s elements in the corresponding places of nums2.
The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0497.Random-Point-in-Non-overlapping-Rectangles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0497.Random-Point-in-Non-overlapping-Rectangles/</guid>
      <description>497. Random Point in Non-overlapping Rectangles #  题目 #  Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles.
Note:
 An integer point is a point that has integer coordinates. A point on the perimeter of a rectangle is included in the space covered by the rectangles. ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0498.Diagonal-Traverse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0498.Diagonal-Traverse/</guid>
      <description>498. Diagonal Traverse #  题目 #  Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.
Example:
Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,4,7,5,3,6,8,9] Explanation:   Note:
The total number of elements of the given matrix will not exceed 10,000.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0500.Keyboard-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0500.Keyboard-Row/</guid>
      <description>500. Keyboard Row #  题目 #  Given a List of words, return the words that can be typed using letters of alphabet on only one row&amp;rsquo;s of American keyboard like the image below.
 Example:
Input: [&amp;quot;Hello&amp;quot;, &amp;quot;Alaska&amp;quot;, &amp;quot;Dad&amp;quot;, &amp;quot;Peace&amp;quot;] Output: [&amp;quot;Alaska&amp;quot;, &amp;quot;Dad&amp;quot;]  Note:
 You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0503.Next-Greater-Element-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0503.Next-Greater-Element-II/</guid>
      <description>503. Next Greater Element II #  题目 #  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&amp;rsquo;t exist, output -1 for this number.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0507.Perfect-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0507.Perfect-Number/</guid>
      <description>507. Perfect Number #  题目 #  We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.
Now, given an
integer
n, write a function that returns true when it is a perfect number and false when it is not.
Example:
Input: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14 Note: The input number n will not exceed 100,000,000.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0508.Most-Frequent-Subtree-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0508.Most-Frequent-Subtree-Sum/</guid>
      <description>508. Most Frequent Subtree Sum #  题目 #  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0509.Fibonacci-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0509.Fibonacci-Number/</guid>
      <description>509. Fibonacci Number #  题目 #  The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1.  Given N, calculate F(N).
Example 1:
Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0513.Find-Bottom-Left-Tree-Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0513.Find-Bottom-Left-Tree-Value/</guid>
      <description>513. Find Bottom Left Tree Value #  题目 #  Given a binary tree, find the leftmost value in the last row of the tree.
Example 1:
Input: 2 / \ 1 3 Output: 1  Example 2:
Input: 1 / \ 2 3 / / \ 4 5 6 / 7 Output: 7  Note: You may assume the tree (i.e., the given root node) is not NULL.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0515.Find-Largest-Value-in-Each-Tree-Row/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0515.Find-Largest-Value-in-Each-Tree-Row/</guid>
      <description>515. Find Largest Value in Each Tree Row #  题目 #  You need to find the largest value in each row of a binary tree.
Example:
Input: 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9]  题目大意 #  求在二叉树的每一行中找到最大的值。
解题思路 #   给出一个二叉树，要求依次输出每行的最大值 用 BFS 层序遍历，将每层排序取出最大值。改进的做法是遍历中不断更新每层的最大值。  代码 #  package leetcode import ( &amp;#34;math&amp;#34; &amp;#34;sort&amp;#34; ) /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0524.Longest-Word-in-Dictionary-through-Deleting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0524.Longest-Word-in-Dictionary-through-Deleting/</guid>
      <description>524. Longest Word in Dictionary through Deleting #  题目 #  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.
Example 1:
 Input: s = &amp;quot;abpcplea&amp;quot;, d = [&amp;quot;ale&amp;quot;,&amp;quot;apple&amp;quot;,&amp;quot;monkey&amp;quot;,&amp;quot;plea&amp;quot;] Output: &amp;quot;apple&amp;quot; Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0526.Beautiful-Arrangement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0526.Beautiful-Arrangement/</guid>
      <description>526. Beautiful Arrangement #  题目 #  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 &amp;lt;= i &amp;lt;= N) in this array:
 The number at the i position is divisible by i.th i is divisible by the number at the i position.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0528.Random-Pick-with-Weight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0528.Random-Pick-with-Weight/</guid>
      <description>528. Random Pick with Weight #  题目 #  Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.
Note:
 1 &amp;lt;= w.length &amp;lt;= 10000 1 &amp;lt;= w[i] &amp;lt;= 10^5 pickIndex will be called at most 10000 times.  Example 1:
Input: [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;] [[[1]],[]] Output: [null,0]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0529.Minesweeper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0529.Minesweeper/</guid>
      <description>529. Minesweeper #  题目 #  Let&amp;rsquo;s play the minesweeper game ( Wikipedia, online game)!
You are given a 2D char matrix representing the game board. &amp;lsquo;M&amp;rsquo; represents an unrevealed mine, &amp;lsquo;E&amp;rsquo; represents an unrevealed empty square, &amp;lsquo;B&amp;rsquo; represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (&amp;lsquo;1&amp;rsquo; to &amp;lsquo;8&amp;rsquo;) represents how many mines are adjacent to this revealed square, and finally &amp;lsquo;X&amp;rsquo; represents a revealed mine.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0532.K-diff-Pairs-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0532.K-diff-Pairs-in-an-Array/</guid>
      <description>532. K-diff Pairs in an Array #  题目 #  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
Example 1:
 Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0537.Complex-Number-Multiplication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0537.Complex-Number-Multiplication/</guid>
      <description>537. Complex Number Multiplication #  题目 #  Given two strings representing two complex numbers.
You need to return a string representing their multiplication. Note i2 = -1 according to the definition.
Example 1:
Input: &amp;quot;1+1i&amp;quot;, &amp;quot;1+1i&amp;quot; Output: &amp;quot;0+2i&amp;quot; Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0541.Reverse-String-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0541.Reverse-String-II/</guid>
      <description>541. Reverse String II #  题目 #  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0542.01-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0542.01-Matrix/</guid>
      <description>542. 01 Matrix #  题目 #  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Example 1:
Input: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]]  Example 2:
Input: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]]  Note:
 The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0547.Friend-Circles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0547.Friend-Circles/</guid>
      <description>547. Friend Circles #  题目 #  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a directfriend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0557.Reverse-Words-in-a-String-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0557.Reverse-Words-in-a-String-III/</guid>
      <description>557. Reverse Words in a String III #  题目 #  Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
Example 1:
Input: &amp;quot;Let&#39;s take LeetCode contest&amp;quot; Output: &amp;quot;s&#39;teL ekat edoCteeL tsetnoc&amp;quot;  Note: In the string, each word is separated by single space and there will not be any extra space in the string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0561.Array-Partition-I/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0561.Array-Partition-I/</guid>
      <description>561. Array Partition I #  题目 #  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), &amp;hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
Example 1:
Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0563.Binary-Tree-Tilt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0563.Binary-Tree-Tilt/</guid>
      <description>563. 二叉树的坡度 #  Difficulty: 简单
给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
示例 1：
 输入：root = [1,2,3] 输出：1 解释： 节点 2 的坡度：|0-0| = 0（没有子节点） 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ） 坡度总和：0 + 0 + 1 = 1 示例 2：
 输入：root = [4,2,9,3,5,null,7] 输出：15 解释： 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 5 的坡度：|0-0| = 0（没有子节点） 节点 7 的坡度：|0-0| = 0（没有子节点） 节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ） 节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ） 节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ） 坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0566.Reshape-the-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0566.Reshape-the-Matrix/</guid>
      <description>566. Reshape the Matrix #  题目 #  In MATLAB, there is a very useful function called &amp;lsquo;reshape&amp;rsquo;, which can reshape a matrix into a new one with different size but keep its original data.
You&amp;rsquo;re given a matrix represented by a two-dimensional array, and two positive integers r and crepresenting the row number and column number of the wanted reshaped matrix, respectively.
The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0567.Permutation-in-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0567.Permutation-in-String/</guid>
      <description>567. Permutation in String #  题目 #  Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string&amp;rsquo;s permutations is the substring of the second string.
Example 1:
 Input:s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; Output:True Explanation: s2 contains one permutation of s1 (&amp;quot;ba&amp;quot;). Example 2:
 Input:s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; Output: False Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0572.Subtree-of-Another-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0572.Subtree-of-Another-Tree/</guid>
      <description>572. Subtree of Another Tree #  题目 #  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node&amp;rsquo;s descendants. The tree s could also be considered as a subtree of itself.
Example 1:
Given tree s:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0575.Distribute-Candies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0575.Distribute-Candies/</guid>
      <description>575. Distribute Candies #  题目 #  Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.
Example 1:
Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0589.N-Ary-Tree-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0589.N-Ary-Tree-Preorder-Traversal/</guid>
      <description>589. N叉树的前序遍历 #  Difficulty: 简单
给定一个 N 叉树，返回其节点值的_前序遍历_。
例如，给定一个 3叉树 :
 返回其前序遍历: [1,3,5,6,2,4]。
说明： 递归法很简单，你可以使用迭代法完成此题吗?
题解 #  解法一：递归求解 #  /* // Definition for a Node. class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } }; */ class Solution { public List&amp;lt;Integer&amp;gt; preorder(Node root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); helper(root, result); return result; } private void helper(Node node, List&amp;lt;Integer&amp;gt; result) { if (node == null) { return; } result.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0594.Longest-Harmonious-Subsequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0594.Longest-Harmonious-Subsequence/</guid>
      <description>594. Longest Harmonious Subsequence #  题目 #  We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.
Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.
Example 1:
Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].  Note: The length of the input array will not exceed 20,000.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0598.Range-Addition-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0598.Range-Addition-II/</guid>
      <description>598. Range Addition II #  题目 #  Given an m * n matrix M initialized with all 0&amp;rsquo;s and several update operations.
Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &amp;lt;= i &amp;lt; a and 0 &amp;lt;= j &amp;lt; b.
You need to count and return the number of maximum integers in the matrix after performing all the operations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0599.Minimum-Index-Sum-of-Two-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0599.Minimum-Index-Sum-of-Two-Lists/</guid>
      <description>599. Minimum Index Sum of Two Lists #  题目 #  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.
You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0606.Construct-String-From-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0606.Construct-String-From-Binary-Tree/</guid>
      <description>606. 根据二叉树创建字符串 #  Difficulty: 简单
你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。
空节点则用一对空括号 &amp;ldquo;()&amp;rdquo; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
示例 1:
输入: 二叉树: [1,2,3,4] 1 / \  2 3 / 4 输出: &amp;#34;1(2(4))(3)&amp;#34; 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2:
输入: 二叉树: [1,2,3,null,4] 1 / \  2 3 \  4 输出: &amp;#34;1(2()(4))(3)&amp;#34; 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public String tree2str(TreeNode t) { if (t == null) { return &amp;#34;&amp;#34;; } if (t.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0617.Merge-Two-Binary-Trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0617.Merge-Two-Binary-Trees/</guid>
      <description>617. 合并二叉树 #  Difficulty: 简单
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为 **NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。
题解 #  题解一：递归 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null &amp;amp;&amp;amp; t2 == null) { return null; } if (t1 == null) { return t2; } if (t2 == null) { return t1; } TreeNode node = new TreeNode(t1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0628.Maximum-Product-of-Three-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0628.Maximum-Product-of-Three-Numbers/</guid>
      <description>628. 三个数的最大乘积 #  Difficulty: 简单
给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。
示例 1:
输入: [1,2,3] 输出: 6 示例 2:
输入: [1,2,3,4] 输出: 24 注意:
 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。  题解 #  题解一：排序 #  class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); } } 复杂度分析 #    时间复杂度：O(NlogN)，其中 N 是数组的长度。
  空间复杂度：O(logN)，为排序使用的空间。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0632.Smallest-Range-Covering-Elements-from-K-Lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0632.Smallest-Range-Covering-Elements-from-K-Lists/</guid>
      <description>632. Smallest Range Covering Elements from K Lists #  题目 #  You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.
We define the range [a,b] is smaller than range [c,d] if b-a &amp;lt; d-c or a &amp;lt; c if b-a == d-c.
Example 1:
Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0633.Sum-of-Square-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0633.Sum-of-Square-Numbers/</guid>
      <description>633. Sum of Square Numbers #  题目 #  Given a non-negative integer c, your task is to decide whether there&amp;rsquo;re two integers a and b such that a^2 + b^2 = c.
Example 1:
Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5  Example 2:
Input: 3 Output: False  题目大意 #  给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0636.Exclusive-Time-of-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0636.Exclusive-Time-of-Functions/</guid>
      <description>636. Exclusive Time of Functions #  题目 #  On a single threaded CPU, we execute some functions. Each function has a unique id between 0 and N-1.
We store logs in timestamp order that describe when a function is entered or exited.
Each log is a string with this format: &amp;quot;{function_id}:{&amp;quot;start&amp;quot; | &amp;quot;end&amp;quot;}:{timestamp}&amp;quot;. For example, &amp;quot;0:start:3&amp;quot; means the function with id 0 started at the beginning of timestamp 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0637.Average-of-Levels-in-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0637.Average-of-Levels-in-Binary-Tree/</guid>
      <description>637. Average of Levels in Binary Tree #  题目 #  Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.
Example 1:
 Input: 3 / \ 9 20 / \ 15 7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0638.Shopping-Offers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0638.Shopping-Offers/</guid>
      <description>638. Shopping Offers #  题目 #  In LeetCode Store, there are some kinds of items to sell. Each item has a price.
However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.
You are given the each item&amp;rsquo;s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0645.Set-Mismatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0645.Set-Mismatch/</guid>
      <description>645. Set Mismatch #  题目 #  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.
Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0648.Replace-Words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0648.Replace-Words/</guid>
      <description>648. Replace Words #  题目 #  In English, we have a concept called root, which can be followed by some other words to form another longer word - let&amp;rsquo;s call this word successor. For example, the root an, followed by other, which can form another word another.
Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0653.Two-Sum-IV-Input-is-a-BST/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0653.Two-Sum-IV-Input-is-a-BST/</guid>
      <description>653. Two Sum IV - Input is a BST #  题目 #  Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.
Example 1:
Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 9 Output: True  Example 2:
Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 28 Output: False  题目大意 #  给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0658.Find-K-Closest-Elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0658.Find-K-Closest-Elements/</guid>
      <description>658. Find K Closest Elements #  题目 #  Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.
Example 1:
Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]  Example 2:
Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]  Note:
 The value k is positive and will always be smaller than the length of the sorted array.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0661.Image-Smoother/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0661.Image-Smoother/</guid>
      <description>661. Image Smoother #  题目 #  Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.
Example 1:
Input: [[1,1,1], [1,0,1], [1,1,1]] Output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0662.Maximum-Width-of-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0662.Maximum-Width-of-Binary-Tree/</guid>
      <description>662. Maximum Width of Binary Tree #  题目 #  Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.
The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0668.Kth-Smallest-Number-in-Multiplication-Table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0668.Kth-Smallest-Number-in-Multiplication-Table/</guid>
      <description>668. Kth Smallest Number in Multiplication Table #  题目 #  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?
Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.
Example 1:
Input: m = 3, n = 3, k = 5 Output: Explanation: The Multiplication Table: 1	2	3 2	4	6 3	6	9 The 5-th smallest number is 3 (1, 2, 2, 3, 3).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0676.Implement-Magic-Dictionary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0676.Implement-Magic-Dictionary/</guid>
      <description>676. Implement Magic Dictionary #  题目 #  Implement a magic directory with buildDict, and search methods.
For the method buildDict, you&amp;rsquo;ll be given a list of non-repetitive words to build a dictionary.
For the method search, you&amp;rsquo;ll be given a word, and judge whether if you modify exactly one character into anothercharacter in this word, the modified word is in the dictionary you just built.
Example 1:
Input: buildDict([&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]), Output: Null Input: search(&amp;quot;hello&amp;quot;), Output: False Input: search(&amp;quot;hhllo&amp;quot;), Output: True Input: search(&amp;quot;hell&amp;quot;), Output: False Input: search(&amp;quot;leetcoded&amp;quot;), Output: False  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0682.Baseball-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0682.Baseball-Game/</guid>
      <description>682. Baseball Game #  题目 #  You&amp;rsquo;re now a baseball game point recorder.
Given a list of strings, each string can be one of the 4 following types:
 Integer (one round&amp;rsquo;s score): Directly represents the number of points you get in this round. &amp;ldquo;+&amp;rdquo; (one round&amp;rsquo;s score): Represents that the points you get in this round are the sum of the last two valid round&amp;rsquo;s points. &amp;ldquo;D&amp;rdquo; (one round&amp;rsquo;s score): Represents that the points you get in this round are the doubled data of the last valid round&amp;rsquo;s points.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0684.Redundant-Connection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0684.Redundant-Connection/</guid>
      <description>684. Redundant Connection #  题目 #  In this problem, a tree is an undirected graph that is connected and has no cycles.
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, &amp;hellip;, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0685.Redundant-Connection-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0685.Redundant-Connection-II/</guid>
      <description>685. Redundant Connection II #  题目 #  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.
The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, &amp;hellip;, N), with one additional directed edge added.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0690.Employee-Importance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0690.Employee-Importance/</guid>
      <description>690. 员工的重要性 #  Difficulty: 简单
给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。
比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。
示例 1:
输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出: 11 解释: 员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。 注意:
 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。  题解 #  题解一：DFS（深度优先遍历） #  /* // Definition for Employee. class Employee { public int id; public int importance; public List&amp;lt;Integer&amp;gt; subordinates; }; */ class Solution { int result = 0; public int getImportance(List&amp;lt;Employee&amp;gt; employees, int id) { Map&amp;lt;Integer, Employee&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (Employee e : employees) { map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0693.Binary-Number-with-Alternating-Bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0693.Binary-Number-with-Alternating-Bits/</guid>
      <description>693. Binary Number with Alternating Bits #  题目 #  Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
Example 1:
Input: 5 Output: True Explanation: The binary representation of 5 is: 101  Example 2:
Input: 7 Output: False Explanation: The binary representation of 7 is: 111.  Example 3:
Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0695.Max-Area-of-Island/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0695.Max-Area-of-Island/</guid>
      <description>695. Max Area of Island #  题目 #  Given a non-empty 2D array grid of 0&amp;rsquo;s and 1&amp;rsquo;s, an island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0697.Degree-of-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0697.Degree-of-an-Array/</guid>
      <description>697. Degree of an Array #  题目 #  Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.
Example 1:
Input: [1, 2, 2, 3, 1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0699.Falling-Squares/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0699.Falling-Squares/</guid>
      <description>699. Falling Squares #  题目 #  On an infinite number line (x-axis), we drop given squares in the order they are given.
The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].
The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0704.Binary-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0704.Binary-Search/</guid>
      <description>704. Binary Search #  题目 #  Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4  Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0705.Design-HashSet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0705.Design-HashSet/</guid>
      <description>705. Design HashSet #  题目 #  Design a HashSet without using any built-in hash table libraries.
To be specific, your design should include these functions:
 add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.  Example:
MyHashSet hashSet = new MyHashSet(); hashSet.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0706.Design-HashMap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0706.Design-HashMap/</guid>
      <description>706. Design HashMap #  题目 #  Design a HashMap without using any built-in hash table libraries.
To be specific, your design should include these functions:
 put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0707.Design-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0707.Design-Linked-List/</guid>
      <description>707. Design Linked List #  题目 #  Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0710.Random-Pick-with-Blacklist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0710.Random-Pick-with-Blacklist/</guid>
      <description>710. Random Pick with Blacklist #  题目 #  Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B.
Optimize it such that it minimizes the call to system’s Math.random().
Note:
 1 &amp;lt;= N &amp;lt;= 1000000000 0 &amp;lt;= B.length &amp;lt; min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0713.Subarray-Product-Less-Than-K/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0713.Subarray-Product-Less-Than-K/</guid>
      <description>713. Subarray Product Less Than K #  题目 #  Your are given an array of positive integers nums.
Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.
Example 1:
 Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/</guid>
      <description>714. Best Time to Buy and Sell Stock with Transaction Fee #  题目 #  Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.
You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0715.Range-Module/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0715.Range-Module/</guid>
      <description>715. Range Module #  题目 #  A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.
 addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0717.1-bit-and-2-bit-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0717.1-bit-and-2-bit-Characters/</guid>
      <description>717. 1-bit and 2-bit Characters #  题目: #  We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).
Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.
Example 1:
Input: bits = [1, 0, 0] Output: True Explanation: The only way to decode it is two-bit character and one-bit character.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0718.Maximum-Length-of-Repeated-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0718.Maximum-Length-of-Repeated-Subarray/</guid>
      <description>718. Maximum Length of Repeated Subarray #  题目 #  Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
Example 1:
Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1].  Note:
 1 &amp;lt;= len(A), len(B) &amp;lt;= 1000 0 &amp;lt;= A[i], B[i] &amp;lt; 100  题目大意 #  给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0719.Find-K-th-Smallest-Pair-Distance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0719.Find-K-th-Smallest-Pair-Distance/</guid>
      <description>719. Find K-th Smallest Pair Distance #  题目 #  Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.
Example 1:
Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&amp;gt; 2 (1,1) -&amp;gt; 0 (3,1) -&amp;gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0720.Longest-Word-in-Dictionary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0720.Longest-Word-in-Dictionary/</guid>
      <description>720. Longest Word in Dictionary #  题目 #  Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.
If there is no answer, return the empty string.
Example 1:
Input: words = [&amp;quot;w&amp;quot;,&amp;quot;wo&amp;quot;,&amp;quot;wor&amp;quot;,&amp;quot;worl&amp;quot;, &amp;quot;world&amp;quot;] Output: &amp;quot;world&amp;quot; Explanation: The word &amp;quot;world&amp;quot; can be built one character at a time by &amp;quot;w&amp;quot;, &amp;quot;wo&amp;quot;, &amp;quot;wor&amp;quot;, and &amp;quot;worl&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0721.Accounts-Merge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0721.Accounts-Merge/</guid>
      <description>721. 账户合并 #  Difficulty: 中等
给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。
现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。
合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。
例子 1:
Input: accounts = [[&amp;#34;John&amp;#34;, &amp;#34;johnsmith@mail.com&amp;#34;, &amp;#34;john00@mail.com&amp;#34;], [&amp;#34;John&amp;#34;, &amp;#34;johnnybravo@mail.com&amp;#34;], [&amp;#34;John&amp;#34;, &amp;#34;johnsmith@mail.com&amp;#34;, &amp;#34;john_newyork@mail.com&amp;#34;], [&amp;#34;Mary&amp;#34;, &amp;#34;mary@mail.com&amp;#34;]] Output: [[&amp;#34;John&amp;#34;, &amp;#39;john00@mail.com&amp;#39;, &amp;#39;john_newyork@mail.com&amp;#39;, &amp;#39;johnsmith@mail.com&amp;#39;], [&amp;#34;John&amp;#34;, &amp;#34;johnnybravo@mail.com&amp;#34;], [&amp;#34;Mary&amp;#34;, &amp;#34;mary@mail.com&amp;#34;]] Explanation: 第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &amp;#34;johnsmith@mail.com&amp;#34;。 第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。 我们可以以任何顺序返回这些列表，例如答案[[&amp;#39;Mary&amp;#39;，&amp;#39;mary@mail.com&amp;#39;]，[&amp;#39;John&amp;#39;，&amp;#39;johnnybravo@mail.com&amp;#39;]， [&amp;#39;John&amp;#39;，&amp;#39;john00@mail.com&amp;#39;，&amp;#39;john_newyork@mail.com&amp;#39;，&amp;#39;johnsmith@mail.com&amp;#39;]]仍然会被接受。 注意：
 accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。  题解 #  题解一：DFS（深度优先搜索） #  class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; accountsMerge(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; accounts) { Map&amp;lt;String, String&amp;gt; emailToName = new HashMap(); Map&amp;lt;String, ArrayList&amp;lt;String&amp;gt;&amp;gt; graph = new HashMap(); for (List&amp;lt;String&amp;gt; account: accounts) { String name = &amp;#34;&amp;#34;; for (String email : account) { if (name == &amp;#34;&amp;#34;) { name = email; continue; } graph.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0724.Find-Pivot-Index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0724.Find-Pivot-Index/</guid>
      <description>724. Find Pivot Index #  题目 #  Given an array of integers nums, write a method that returns the &amp;ldquo;pivot&amp;rdquo; index of this array.
We define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.
If no such index exists, we should return -1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0725.Split-Linked-List-in-Parts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0725.Split-Linked-List-in-Parts/</guid>
      <description>725. Split Linked List in Parts #  题目 #  Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list &amp;ldquo;parts&amp;rdquo;.
The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.
The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0726.Number-of-Atoms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0726.Number-of-Atoms/</guid>
      <description>726. Number of Atoms #  题目 #  Given a chemical formula (given as a string), return the count of each atom.
An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.
1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0729.My-Calendar-I/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0729.My-Calendar-I/</guid>
      <description>729. My Calendar I #  题目 #  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.
Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &amp;lt;= x &amp;lt; end.
A double booking happens when two events have some non-empty intersection (ie.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0732.My-Calendar-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0732.My-Calendar-III/</guid>
      <description>732. My Calendar III #  题目 #  Implement a MyCalendarThree class to store your events. A new event can always be added.
Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &amp;lt;= x &amp;lt; end.
A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0733.Flood-Fill/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0733.Flood-Fill/</guid>
      <description>733. Flood Fill #  题目 #  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).
Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;ldquo;flood fill&amp;rdquo; the image.
To perform a &amp;ldquo;flood fill&amp;rdquo;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0735.Asteroid-Collision/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0735.Asteroid-Collision/</guid>
      <description>735. Asteroid Collision #  题目 #  We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0739.Daily-Temperatures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0739.Daily-Temperatures/</guid>
      <description>739. Daily Temperatures #  题目 #  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.
For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0744.Find-Smallest-Letter-Greater-Than-Target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0744.Find-Smallest-Letter-Greater-Than-Target/</guid>
      <description>744. Find Smallest Letter Greater Than Target #  题目 #  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.
Letters also wrap around. For example, if the target is target = &#39;z&#39; and letters = [&#39;a&#39;, &#39;b&#39;], the answer is &#39;a&#39;.
Examples:
Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;a&amp;quot; Output: &amp;quot;c&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;c&amp;quot; Output: &amp;quot;f&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;d&amp;quot; Output: &amp;quot;f&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;g&amp;quot; Output: &amp;quot;j&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;j&amp;quot; Output: &amp;quot;c&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;k&amp;quot; Output: &amp;quot;c&amp;quot;  Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0745.Prefix-and-Suffix-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0745.Prefix-and-Suffix-Search/</guid>
      <description>745. Prefix and Suffix Search #  题目 #  Given many words, words[i] has weight i.
Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.
Examples:
Input: WordFilter([&amp;quot;apple&amp;quot;]) WordFilter.f(&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;) // returns 0 WordFilter.f(&amp;quot;b&amp;quot;, &amp;quot;&amp;quot;) // returns -1  Note:
 words has length in range [1, 15000].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0746.Min-Cost-Climbing-Stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0746.Min-Cost-Climbing-Stairs/</guid>
      <description>746. Min Cost Climbing Stairs #  题目 #  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.
Example 1:
Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0748.Shortest-Completing-Word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0748.Shortest-Completing-Word/</guid>
      <description>748. Shortest Completing Word #  题目 #  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate
Here, for letters we ignore case. For example, &amp;quot;P&amp;quot; on the licensePlate still matches &amp;quot;p&amp;quot; on the word.
It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0753.Cracking-the-Safe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0753.Cracking-the-Safe/</guid>
      <description>753. Cracking the Safe #  题目 #  There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1.
While entering a password, the last n digits entered will automatically be matched against the correct password.
For example, assuming the correct password is &amp;quot;345&amp;quot;, if you type &amp;quot;012345&amp;quot;, the box will open because the correct password matches the suffix of the entered password.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0756.Pyramid-Transition-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0756.Pyramid-Transition-Matrix/</guid>
      <description>756. Pyramid Transition Matrix #  题目 #  We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.
We are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple.
We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0762.Prime-Number-of-Set-Bits-in-Binary-Representation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0762.Prime-Number-of-Set-Bits-in-Binary-Representation/</guid>
      <description>762. Prime Number of Set Bits in Binary Representation #  题目 #  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.
(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0763.Partition-Labels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0763.Partition-Labels/</guid>
      <description>763. Partition Labels #  题目 #  A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.
Example 1:
 Input: S = &amp;quot;ababcbacadefegdehijhklij&amp;quot; Output: [9,7,8] Explanation: The partition is &amp;quot;ababcbaca&amp;quot;, &amp;quot;defegde&amp;quot;, &amp;quot;hijhklij&amp;quot;. This is a partition so that each letter appears in at most one part.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0765.Couples-Holding-Hands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0765.Couples-Holding-Hands/</guid>
      <description>765. Couples Holding Hands #  题目 #  N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.
The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0766.Toeplitz-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0766.Toeplitz-Matrix/</guid>
      <description>766. Toeplitz Matrix #  题目 #  A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.
Now given an M x N matrix, return True if and only if the matrix is Toeplitz.
Example 1:
Input: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: &amp;quot;[9]&amp;quot;, &amp;quot;[5, 5]&amp;quot;, &amp;quot;[1, 1, 1]&amp;quot;, &amp;quot;[2, 2, 2]&amp;quot;, &amp;quot;[3, 3]&amp;quot;, &amp;quot;[4]&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0767.Reorganize-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0767.Reorganize-String/</guid>
      <description>767. Reorganize String #  题目 #  Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.
If possible, output any possible result. If not possible, return the empty string.
Example 1:
 Input: S = &amp;quot;aab&amp;quot; Output: &amp;quot;aba&amp;quot; Example 2:
 Input: S = &amp;quot;aaab&amp;quot; Output: &amp;quot;&amp;quot; Note:
S will consist of lowercase letters and have length in range [1, 500].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0771.Jewels-and-Stones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0771.Jewels-and-Stones/</guid>
      <description>771. Jewels and Stones #  题目 #  You&amp;rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &amp;quot;a&amp;quot; is considered a different type of stone from &amp;quot;A&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0778.Swim-in-Rising-Water/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0778.Swim-in-Rising-Water/</guid>
      <description>778. Swim in Rising Water #  题目 #  On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).
Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0781.Rabbits-in-Forest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0781.Rabbits-in-Forest/</guid>
      <description>781. Rabbits in Forest #  题目 #  In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.
Return the minimum number of rabbits that could be in the forest.
Examples:
Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered &amp;quot;1&amp;quot; could both be the same color, say red.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0784.Letter-Case-Permutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0784.Letter-Case-Permutation/</guid>
      <description>784. Letter Case Permutation #  题目 #  Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.
Examples:
Input: S = &amp;quot;a1b2&amp;quot; Output: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;] Input: S = &amp;quot;3z4&amp;quot; Output: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;] Input: S = &amp;quot;12345&amp;quot; Output: [&amp;quot;12345&amp;quot;]  Note:
 S will be a string with length between 1 and 12.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0785.Is-Graph-Bipartite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0785.Is-Graph-Bipartite/</guid>
      <description>785. Is Graph Bipartite? #  题目 #  Given an undirected graph, return true if and only if it is bipartite.
Recall that a graph is bipartite if we can split it&amp;rsquo;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.
The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0786.K-th-Smallest-Prime-Fraction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0786.K-th-Smallest-Prime-Fraction/</guid>
      <description>786. K-th Smallest Prime Fraction #  题目 #  A sorted list A contains 1, plus some number of primes. Then, for every p &amp;lt; q in the list, we consider the fraction p/q.
What is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.
Examples:
Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0793.Preimage-Size-of-Factorial-Zeroes-Function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0793.Preimage-Size-of-Factorial-Zeroes-Function/</guid>
      <description>793. Preimage Size of Factorial Zeroes Function #  题目 #  Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)
For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0802.Find-Eventual-Safe-States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0802.Find-Eventual-Safe-States/</guid>
      <description>802. Find Eventual Safe States #  题目 #  In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.
Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0803.Bricks-Falling-When-Hit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0803.Bricks-Falling-When-Hit/</guid>
      <description>803. Bricks Falling When Hit #  题目 #  We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.
We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0811.Subdomain-Visit-Count/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0811.Subdomain-Visit-Count/</guid>
      <description>811. Subdomain Visit Count #  题目 #  A website domain like &amp;ldquo;discuss.leetcode.com&amp;rdquo; consists of various subdomains. At the top level, we have &amp;ldquo;com&amp;rdquo;, at the next level, we have &amp;ldquo;leetcode.com&amp;rdquo;, and at the lowest level, &amp;ldquo;discuss.leetcode.com&amp;rdquo;. When we visit a domain like &amp;ldquo;discuss.leetcode.com&amp;rdquo;, we will also visit the parent domains &amp;ldquo;leetcode.com&amp;rdquo; and &amp;ldquo;com&amp;rdquo; implicitly.
Now, call a &amp;ldquo;count-paired domain&amp;rdquo; to be a count (representing the number of visits this domain received), followed by a space, followed by the address.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0812.Largest-Triangle-Area/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0812.Largest-Triangle-Area/</guid>
      <description>812. Largest Triangle Area #  题目 #  You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.
Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation: The five points are show in the figure below. The red triangle is the largest.  Notes:
 3 &amp;lt;= points.length &amp;lt;= 50. No points will be duplicated.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0814.Binary-Tree-Pruning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0814.Binary-Tree-Pruning/</guid>
      <description>814. 二叉树剪枝 #  Difficulty: 中等
给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。
返回移除了所有不包含 1 的子树的原二叉树。
( 节点 X 的子树为 X 本身，以及所有 X 的后代。)
示例1: 输入: [1,null,0,0,1] 输出: [1,null,0,null,1] 解释: 只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。  示例2: 输入: [1,0,1,0,0,0,1] 输出: [1,null,1,null,1]  示例3: 输入: [1,1,0,1,1,0,1,0] 输出: [1,1,0,1,1,null,1]  说明:
 给定的二叉树最多有 100 个节点。 每个节点的值只会为 0 或 1 。  题解 #  解法一：递归求解 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0815.Bus-Routes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0815.Bus-Routes/</guid>
      <description>815. Bus Routes #  题目 #  We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;&amp;hellip; forever.
We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0817.Linked-List-Components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0817.Linked-List-Components/</guid>
      <description>817. Linked List Components #  题目 #  We are given head, the head node of a linked list containing unique integer values.
We are also given the list G, a subset of the values in the linked list.
Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.
Example 1:
 Input: head: 0-&amp;gt;1-&amp;gt;2-&amp;gt;3 G = [0, 1, 3] Output: 2 Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0819.Most-Common-Word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0819.Most-Common-Word/</guid>
      <description>819. Most Common Word #  题目 #  Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique.
Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0826.Most-Profit-Assigning-Work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0826.Most-Profit-Assigning-Work/</guid>
      <description>826. Most Profit Assigning Work #  题目 #  We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.
Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].
Every worker can be assigned at most one job, but one job can be completed multiple times.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0828.COPYRIGHT-PROBLEM-XXX/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0828.COPYRIGHT-PROBLEM-XXX/</guid>
      <description>828. Unique Letter String #  题目 #  THIS PROBLEM COPYRIGHT BELONGS TO CODILITY.COM
Example 1:
Example 2:
题目大意 #  如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。例如，在字符串 S = &amp;ldquo;LETTER&amp;rdquo; 中，&amp;ldquo;L&amp;rdquo; 和 &amp;ldquo;R&amp;rdquo; 可以被称为独特字符。我们再定义 UNIQ(S) 作为字符串 S 中独特字符的个数。那么，在 S = &amp;ldquo;LETTER&amp;rdquo; 中， UNIQ(&amp;ldquo;LETTER&amp;rdquo;) = 2。
对于给定字符串 S，计算其所有非空子串的独特字符的个数（即 UNIQ(substring)）之和。如果在 S 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。考虑到答案可能会非常大，规定返回格式为：结果 mod 10 ^ 9 + 7。
解题思路 #   这一题可以先用暴力解法尝试解题，不过提交以后会发现判题结果是超时。出错的一组数据是一个有 10000 个字符的字符串。暴力解法中间由于遍历了太多的子区间，导致了超时。 这道题换一个角度思考问题。当子字符串中字符 X 出现了 2 次以上，那么它就对最终结果没有任何影响，所以只有当某个字符只出现一次的时候才会影响最终结果。再者，一个子字符串中不重复的字符的总个数，也就是这个子字符串 UNIQ 值。例如，“ABC”，这个子字符串的 UNIQ 值是 3，可以这样计算，它属于 A 的独特的字符串，也属于 B 的独特的字符串，也属于 C 的独特的字符串，那么计算这个子字符串的问题可以分解成计算 A 有多少个独特的子字符串，B 有多少个独特的子字符串，C 有多少个独特的子字符串的问题。在计算 A 有多少个子字符串的问题的时候，里面肯定会包含 &amp;ldquo;ABC&amp;rdquo; 这个子字符串的。所以原问题就转换成了分别计算给出的字符串中每个字符出现在独特字符串中的总数之和。 假设原字符串是 BAABBABBBAAABA，这个字符串中出现了很多 A 和很多 B，假设我们当前计算到了第 3 个 A 的位置了(index = 5)，即标红色的那个 A。如何计算这个 A 在哪些子字符串中是独特的呢？由于子字符串题目中要求必须是连续的区间，所以这个问题很简单。找到这个 A 前一个 A 的下标位置(index = 2)，再找到这个 A 后一个 A 的下标位置(index = 9)，即 BAABBABBBAAABA，第一个 A 和当前计算的 A 中间区间有 2 个字符，第三个 A 和当前计算的 A 中间有 3 个字符。那么当前计算的 A 出现在 (2 + 1) * (3 + 1) = 12 个子字符串中是独特的，这 12 个字符串是：A，BA，BBA，AB，ABB，ABBB，BAB，BABB，BABBB，BBAB，BBABB，BBABBB。计算方法，假设当前待计算的字符的下标是 i ，找到当前字符前一次出现的下标位置 left，再找到当前字符后一次出现的下标位置 right，那么左边区间 (left,i) 的开区间内包含的字符数是 i - left - 1，右边区间 (i,right) 的开区间内包含的字符数是 right - i - 1。左右两边都还需要考虑空字符串的情况，即左右两边都可以不取任何字符，那么对应的就是只有中间这个待计算的字符 A。所以左右两边都还需要再加上空串的情况，左边 i - left - 1 + 1 = i - left，右边 right - i - 1 + 1 = right - i。左右两边的情况进行排列组合，即 (i - left) * (right - i)。针对字符串的每个字符都计算这样的值，最后累积的总和就是题目中要求的总 UNIQ 值。  代码 #  package leetcode func uniqueLetterString(S string) int { res, left, right := 0, 0, 0 for i := 0; i &amp;lt; len(S); i++ { left = i - 1 for left &amp;gt;= 0 &amp;amp;&amp;amp; S[left] !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0832.Flipping-an-Image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0832.Flipping-an-Image/</guid>
      <description>832. Flipping an Image #  题目 #  Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.
To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].
To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0834.Sum-of-Distances-in-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0834.Sum-of-Distances-in-Tree/</guid>
      <description>834. Sum of Distances in Tree #  题目 #  An undirected, connected tree with N nodes labelled 0...N-1 and N-1edges are given.
The ith edge connects nodes edges[i][0] and edges[i][1] together.
Return a list ans, where ans[i] is the sum of the distances between node iand all other nodes.
Example 1:
Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation: Here is a diagram of the given tree: 0 / \ 1 2 /|\ 3 4 5 We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0836.Rectangle-Overlap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0836.Rectangle-Overlap/</guid>
      <description>836. Rectangle Overlap #  题目 #  A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.
Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.
Given two (axis-aligned) rectangles, return whether they overlap.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0838.Push-Dominoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0838.Push-Dominoes/</guid>
      <description>838. Push Dominoes #  题目 #  There are N dominoes in a line, and we place each domino vertically upright.
In the beginning, we simultaneously push some of the dominoes either to the left or to the right.
 After each second, each domino that is falling to the left pushes the adjacent domino on the left.
Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0839.Similar-String-Groups/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0839.Similar-String-Groups/</guid>
      <description>839. Similar String Groups #  题目 #  Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.
For example, &amp;quot;tars&amp;quot; and &amp;quot;rats&amp;quot; are similar (swapping at positions 0 and 2), and &amp;quot;rats&amp;quot; and &amp;quot;arts&amp;quot; are similar, but &amp;quot;star&amp;quot; is not similar to &amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, or &amp;quot;arts&amp;quot;.
Together, these form two connected groups by similarity: {&amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, &amp;quot;arts&amp;quot;} and {&amp;quot;star&amp;quot;}.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0841.Keys-and-Rooms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0841.Keys-and-Rooms/</guid>
      <description>841. Keys and Rooms #  题目 #  There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.
Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0842.Split-Array-into-Fibonacci-Sequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0842.Split-Array-into-Fibonacci-Sequence/</guid>
      <description>842. Split Array into Fibonacci Sequence #  题目 #  Given a string S of digits, such as S = &amp;quot;123456579&amp;quot;, we can split it into a Fibonacci-like sequence [123, 456, 579].
Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:
 0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length &amp;gt;= 3; and F[i] + F[i+1] = F[i+2] for all 0 &amp;lt;= i &amp;lt; F.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0844.Backspace-String-Compare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0844.Backspace-String-Compare/</guid>
      <description>844. Backspace String Compare #  题目 #  Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.
Example 1:
 Input: S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot; Output: true Explanation: Both S and T become &amp;quot;ac&amp;quot;. Example 2:
 Input: S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot; Output: true Explanation: Both S and T become &amp;quot;&amp;quot;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0845.Longest-Mountain-in-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0845.Longest-Mountain-in-Array/</guid>
      <description>845. Longest Mountain in Array #  题目 #  Let&amp;rsquo;s call any (contiguous) subarray B (of A) a mountain if the following properties hold:
 B.length &amp;gt;= 3 There exists some 0 &amp;lt; i &amp;lt; B.length - 1 such that B[0] &amp;lt; B[1] &amp;lt; &amp;hellip; B[i-1] &amp;lt; B[i] &amp;gt; B[i+1] &amp;gt; &amp;hellip; &amp;gt; B[B.length - 1] (Note that B could be any subarray of A, including the entire array A.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0850.Rectangle-Area-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0850.Rectangle-Area-II/</guid>
      <description>850. Rectangle Area II #  题目 #  We are given a list of (axis-aligned) rectangles. Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.
Find the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 10^9 + 7.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0851.Loud-and-Rich/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0851.Loud-and-Rich/</guid>
      <description>851. Loud and Rich #  题目 #  In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.
For convenience, we&amp;rsquo;ll call the person with label x, simply &amp;ldquo;person x&amp;rdquo;.
We&amp;rsquo;ll say that richer[i] = [x, y] if person x definitely has more money than person y. Note that richer may only be a subset of valid observations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0852.Peak-Index-in-a-Mountain-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0852.Peak-Index-in-a-Mountain-Array/</guid>
      <description>852. Peak Index in a Mountain Array #  题目 #  Let&amp;rsquo;s call an array A a mountain if the following properties hold:
 A.length &amp;gt;= 3 There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] &amp;lt; A[1] &amp;lt; .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0853.Car-Fleet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0853.Car-Fleet/</guid>
      <description>853. Car Fleet #  题目 #  N cars are going to the same destination along a one lane road. The destination is target miles away.
Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.
A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0856.Score-of-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0856.Score-of-Parentheses/</guid>
      <description>856. Score of Parentheses #  题目 #  Given a balanced parentheses string S, compute the score of the string based on the following rule:
() has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.
Example 1:
 Input: &amp;quot;()&amp;quot; Output: 1 Example 2:
 Input: &amp;quot;(())&amp;quot; Output: 2 Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0862.Shortest-Subarray-with-Sum-at-Least-K/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0862.Shortest-Subarray-with-Sum-at-Least-K/</guid>
      <description>862. Shortest Subarray with Sum at Least K #  题目 #  Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.
If there is no non-empty subarray with sum at least K, return -1.
Example 1:
Input: A = [1], K = 1 Output: 1 Example 2:
Input: A = [1,2], K = 4 Output: -1 Example 3:
Input: A = [2,-1,2], K = 3 Output: 3 Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0863.All-Nodes-Distance-K-in-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0863.All-Nodes-Distance-K-in-Binary-Tree/</guid>
      <description>863. All Nodes Distance K in Binary Tree #  题目 #  We are given a binary tree (with root node root), a target node, and an integer value K.
Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order.
Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 Output: [7,4,1] Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0864.Shortest-Path-to-Get-All-Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0864.Shortest-Path-to-Get-All-Keys/</guid>
      <description>864. Shortest Path to Get All Keys #  题目 #  We are given a 2-dimensional grid. &amp;quot;.&amp;quot; is an empty cell, &amp;quot;#&amp;quot; is a wall, &amp;quot;@&amp;quot; is the starting point, (&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;hellip;) are keys, and (&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;hellip;) are locks.
We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions. We cannot walk outside the grid, or walk into a wall.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0865.Smallest-Subtree-With-All-The-Deepest-Nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0865.Smallest-Subtree-With-All-The-Deepest-Nodes/</guid>
      <description>865. 具有所有最深节点的最小子树 #  Difficulty: 中等
给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。
如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。
一个节点的 子树 是该节点加上它的所有后代的集合。
返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。
**注意：**本题与力扣 1123 重复：
示例 1：
 输入：root = [3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。 示例 2：
输入：root = [1] 输出：[1] 解释：根节点是树中最深的节点。 示例 3：
输入：root = [0,1,3,null,2] 输出：[2] 解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。 提示：
 树中节点的数量介于 1 和 500 之间。 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0867.Transpose-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0867.Transpose-Matrix/</guid>
      <description>867. 转置矩阵 #  Difficulty: 简单
给定一个矩阵 A， 返回 A 的转置矩阵。
矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。
示例 1：
输入：[[1,2,3],[4,5,6],[7,8,9]] 输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2：
输入：[[1,2,3],[4,5,6]] 输出：[[1,4],[2,5],[3,6]] 提示：
 1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[0].length &amp;lt;= 1000  题解 #  题解一：直接复制 #  class Solution { public int[][] transpose(int[][] A) { int first = A.length; int second = A[0].length; int[][] result = new int[second][first]; for (int i = 0; i &amp;lt; second; i++) { for (int j = 0; j &amp;lt; first; j++) { result[i][j] = A[j][i]; } } return result; } } 复杂度分析 #    时间复杂度：O(R * C)，其中 R 和 C 是给定矩阵 A 的行数和列数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0872.Leaf-Similar-Trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0872.Leaf-Similar-Trees/</guid>
      <description>872. 叶子相似的树 #  Difficulty: 简单
请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。
 举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。
如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 _叶相似 _的。
如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。
示例 1：
 输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] 输出：true 示例 2：
输入：root1 = [1], root2 = [1] 输出：true 示例 3：
输入：root1 = [1], root2 = [2] 输出：false 示例 4：
输入：root1 = [1,2], root2 = [2,2] 输出：true 示例 5：
 输入：root1 = [1,2,3], root2 = [1,3,2] 输出：false 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0875.Koko-Eating-Bananas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0875.Koko-Eating-Bananas/</guid>
      <description>875. Koko Eating Bananas #  题目 #  Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours.
Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won&amp;rsquo;t eat any more bananas during this hour.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0876.Middle-of-the-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0876.Middle-of-the-Linked-List/</guid>
      <description>876. 链表的中间结点 #  Difficulty: 简单
给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：
输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：
 给定链表的结点数介于 1 和 100 之间。  题解 #  题解一：单指针解法 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode temp = head; int length = 1; while (temp.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0878.Nth-Magical-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0878.Nth-Magical-Number/</guid>
      <description>878. Nth Magical Number #  题目 #  A positive integer is magical if it is divisible by either A or B.
Return the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7.
Example 1:
Input: N = 1, A = 2, B = 3 Output: 2  Example 2:
Input: N = 4, A = 2, B = 3 Output: 6  Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0880.Decoded-String-at-Index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0880.Decoded-String-at-Index/</guid>
      <description>880. Decoded String at Index #  题目 #  An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:
If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0881.Boats-to-Save-People/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0881.Boats-to-Save-People/</guid>
      <description>881. Boats to Save People #  题目 #  The i-th person has weight people[i], and each boat can carry a maximum weight of limit.
Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.
Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0884.Uncommon-Words-from-Two-Sentences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0884.Uncommon-Words-from-Two-Sentences/</guid>
      <description>884. Uncommon Words from Two Sentences #  题目 #  We are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.)
A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.
Return a list of all uncommon words.
You may return the list in any order.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0885.Spiral-Matrix-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0885.Spiral-Matrix-III/</guid>
      <description>885. Spiral Matrix III #  题目 #  On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.
Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.
Now, we walk in a clockwise spiral shape to visit every position in this grid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0887.Super-Egg-Drop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0887.Super-Egg-Drop/</guid>
      <description>887. Super Egg Drop #  题目 #  You are given K eggs, and you have access to a building with N floors from 1 to N.
Each egg is identical in function, and if an egg breaks, you cannot drop it again.
You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0888.Fair-Candy-Swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0888.Fair-Candy-Swap/</guid>
      <description>888. Fair Candy Swap #  题目 #  Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.
Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0891.Sum-of-Subsequence-Widths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0891.Sum-of-Subsequence-Widths/</guid>
      <description>891. Sum of Subsequence Widths #  题目 #  Given an array of integers A, consider all non-empty subsequences of A.
For any sequence S, let the width of S be the difference between the maximum and minimum element of S.
Return the sum of the widths of all subsequences of A.
As the answer may be very large, return the answer modulo 10^9 + 7.
Example 1:
 Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0892.Surface-Area-of-3D-Shapes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0892.Surface-Area-of-3D-Shapes/</guid>
      <description>892. Surface Area of 3D Shapes #  题目 #  On a N * N grid, we place some 1 * 1 * 1 cubes.
Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).
Return the total surface area of the resulting shapes.
Example 1:
Input: [[2]] Output: 10 Example 2:
Input: [[1,2],[3,4]] Output: 34 Example 3:
Input: [[1,0],[0,2]] Output: 16 Example 4:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0895.Maximum-Frequency-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0895.Maximum-Frequency-Stack/</guid>
      <description>895. Maximum Frequency Stack #  题目 #  Implement FreqStack, a class which simulates the operation of a stack-like data structure.
FreqStack has two functions:
push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.
If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0896.Monotonic-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0896.Monotonic-Array/</guid>
      <description>896. Monotonic Array #  题目 #  An array is monotonic if it is either monotone increasing or monotone decreasing.
An array A is monotone increasing if for all i &amp;lt;= j, A[i] &amp;lt;= A[j]. An array A is monotone decreasing if for all i &amp;lt;= j, A[i] &amp;gt;= A[j].
Return true if and only if the given array A is monotonic.
Example 1:
Input: [1,2,2,3] Output: true Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0897.Increasing-Order-Search-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0897.Increasing-Order-Search-Tree/</guid>
      <description>897. 递增顺序查找树 #  Difficulty: 简单
给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。
示例 ：
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 提示：
 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。  题解 #  解法一：中序遍历 + 构造新的树 #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0898.Bitwise-ORs-of-Subarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0898.Bitwise-ORs-of-Subarrays/</guid>
      <description>898. Bitwise ORs of Subarrays #  题目 #  We have an array A of non-negative integers.
For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i &amp;lt;= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].
Return the number of possible results. (Results that occur more than once are only counted once in the final answer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0901.Online-Stock-Span/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0901.Online-Stock-Span/</guid>
      <description>901. Online Stock Span #  题目 #  Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;rsquo;s price for the current day.
The span of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;rsquo;s price.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0904.Fruit-Into-Baskets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0904.Fruit-Into-Baskets/</guid>
      <description>904. Fruit Into Baskets #  题目 #  In a row of trees, the i-th tree produces fruit with type tree[i].
You start at any tree of your choice, then repeatedly perform the following steps:
 Add one piece of fruit from this tree to your baskets. If you cannot, stop. Move to the next tree to the right of the current tree. If there is no tree to the right, stop.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0907.Sum-of-Subarray-Minimums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0907.Sum-of-Subarray-Minimums/</guid>
      <description>907. Sum of Subarray Minimums #  题目 #  Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.
Since the answer may be large, return the answer modulo 10^9 + 7.
Example 1:
 Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0911.Online-Election/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0911.Online-Election/</guid>
      <description>911. Online Election #  题目 #  In an election, the i-th vote was cast for persons[i] at time times[i].
Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.
Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0914.X-of-a-Kind-in-a-Deck-of-Cards/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0914.X-of-a-Kind-in-a-Deck-of-Cards/</guid>
      <description>914. X of a Kind in a Deck of Cards #  题目 #  In a deck of cards, each card has an integer written on it.
Return true if and only if you can choose X &amp;gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:
 Each group has exactly X cards. All the cards in each group have the same integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0918.Maximum-Sum-Circular-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0918.Maximum-Sum-Circular-Subarray/</guid>
      <description>918. Maximum Sum Circular Subarray #  题目 #  Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length, and C[i+A.length] = C[i] when i &amp;gt;= 0.)
Also, a subarray may only include each element of the fixed buffer A at most once.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0919.Complete-Binary-Tree-Inserter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0919.Complete-Binary-Tree-Inserter/</guid>
      <description>919. 完全二叉树插入器 #  Difficulty: 中等
完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。
设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：
 CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值； CBTInserter.get_root() 将返回树的头节点。  示例 1：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1]],[2],[]] 输出：[null,1,[1,2]] 示例 2：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] 输出：[null,3,4,[1,2,3,4,5,6,7,8]] 提示：
 最初给定的树是完全二叉树，且包含 1 到 1000 个节点。 每个测试用例最多调用 CBTInserter.insert 操作 10000 次。 给定节点或插入节点的每个值都在 0 到 5000 之间。  题解 #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0920.Number-of-Music-Playlists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0920.Number-of-Music-Playlists/</guid>
      <description>920. Number of Music Playlists #  题目 #  Your music player contains N different songs and she wants to listen to L ****(not necessarily different) songs during your trip. You create a playlist so that:
 Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists. As the answer can be very large, return it modulo 10^9 + 7.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0921.Minimum-Add-to-Make-Parentheses-Valid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0921.Minimum-Add-to-Make-Parentheses-Valid/</guid>
      <description>921. Minimum Add to Make Parentheses Valid #  题目 #  Given a string S of &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo; parentheses, we add the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, and in any positions ) so that the resulting parentheses string is valid.
Formally, a parentheses string is valid if and only if:
 It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0922.Sort-Array-By-Parity-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0922.Sort-Array-By-Parity-II/</guid>
      <description>922. Sort Array By Parity II #  题目 #  Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.
Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.
You may return any answer array that satisfies this condition.
Example 1:
 Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0923.3Sum-With-Multiplicity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0923.3Sum-With-Multiplicity/</guid>
      <description>923. 3Sum With Multiplicity #  题目 #  Given an integer array A, and an integer target, return the number of tuples i, j, k such that i &amp;lt; j &amp;lt; k and A[i] + A[j] + A[k] == target.
As the answer can be very large, return it modulo 10^9 + 7.
Example 1:
 Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0924.Minimize-Malware-Spread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0924.Minimize-Malware-Spread/</guid>
      <description>924. Minimize Malware Spread #  题目 #  In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0925.Long-Pressed-Name/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0925.Long-Pressed-Name/</guid>
      <description>925. Long Pressed Name #  题目 #  Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.
You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0927.Three-Equal-Parts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0927.Three-Equal-Parts/</guid>
      <description>927. Three Equal Parts #  题目 #  Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.
If it is possible, return any [i, j] with i+1 &amp;lt; j, such that:
 A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0928.Minimize-Malware-Spread-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0928.Minimize-Malware-Spread-II/</guid>
      <description>928. Minimize Malware Spread II #  题目 #  (This problem is the same as Minimize Malware Spread, with the differences bolded.)
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0930.Binary-Subarrays-With-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0930.Binary-Subarrays-With-Sum/</guid>
      <description>930. Binary Subarrays With Sum #  题目 #  In an array A of 0s and 1s, how many non-empty subarrays have sum S?
Example 1:
 Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Note:
 A.length &amp;lt;= 30000 0 &amp;lt;= S &amp;lt;= A.length A[i] is either 0 or 1.  题目大意 #  给定一个数组，数组里面的元素只有 0 和 1 两种。问这个数组有多少个和为 S 的子数组。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0933.Number-of-Recent-Calls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0933.Number-of-Recent-Calls/</guid>
      <description>933. Number of Recent Calls #  题目 #  Write a class RecentCounter to count recent requests.
It has only one method: ping(int t), where t represents some time in milliseconds.
Return the number of pings that have been made from 3000 milliseconds ago until now.
Any ping with time in [t - 3000, t] will count, including the current ping.
It is guaranteed that every call to ping uses a strictly larger value of t than before.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0938.Range-Sum-Of-Bst/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0938.Range-Sum-Of-Bst/</guid>
      <description>938.二叉搜索树的范围和 #  Difficulty: 简单
给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
示例 1：
 输入：root = [10,5,15,3,7,null,18], low = 7, high = 15 输出：32 示例 2：
 输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 输出：23 提示：
 树中节点数目在范围 [1, 2 * 10&amp;lt;sup&amp;gt;4&amp;lt;/sup&amp;gt;] 内 1 &amp;lt;= Node.val &amp;lt;= 10&amp;lt;sup&amp;gt;5&amp;lt;/sup&amp;gt; 1 &amp;lt;= low &amp;lt;= high &amp;lt;= 10&amp;lt;sup&amp;gt;5&amp;lt;/sup&amp;gt; 所有 Node.val 互不相同  题解一 #  暴力解法（DFS） #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0942.DI-String-Match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0942.DI-String-Match/</guid>
      <description>942. DI String Match #  题目 #  Given a string S that only contains &amp;ldquo;I&amp;rdquo; (increase) or &amp;ldquo;D&amp;rdquo; (decrease), let N = S.length.
Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:
 If S[i] == &amp;quot;I&amp;quot;, then A[i] &amp;lt; A[i+1] If S[i] == &amp;quot;D&amp;quot;, then A[i] &amp;gt; A[i+1]  Example 1:
Input: &amp;quot;IDID&amp;quot; Output: [0,4,1,3,2]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0946.Validate-Stack-Sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0946.Validate-Stack-Sequences/</guid>
      <description>946. Validate Stack Sequences #  题目 #  Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.
Example 1:
 Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0947.Most-Stones-Removed-with-Same-Row-or-Column/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0947.Most-Stones-Removed-with-Same-Row-or-Column/</guid>
      <description>947. Most Stones Removed with Same Row or Column #  题目 #  On a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most one stone.
Now, a move consists of removing a stone that shares a column or row with another stone on the grid.
What is the largest possible number of moves we can make?
Example 1:
Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0949.Largest-Time-for-Given-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0949.Largest-Time-for-Given-Digits/</guid>
      <description>949. Largest Time for Given Digits #  题目 #  Given an array of 4 digits, return the largest 24 hour time that can be made.
The smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight.
Return the answer as a string of length 5. If no valid time can be made, return an empty string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0952.Largest-Component-Size-by-Common-Factor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0952.Largest-Component-Size-by-Common-Factor/</guid>
      <description>952. Largest Component Size by Common Factor #  题目 #  Given a non-empty array of unique positive integers A, consider the following graph:
 There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i]and A[j] share a common factor greater than 1.  Return the size of the largest connected component in the graph.
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0953.Verifying-an-Alien-Dictionary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0953.Verifying-an-Alien-Dictionary/</guid>
      <description>953. Verifying an Alien Dictionary #  题目 #  In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The orderof the alphabet is some permutation of lowercase letters.
Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0959.Regions-Cut-By-Slashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0959.Regions-Cut-By-Slashes/</guid>
      <description>959. Regions Cut By Slashes #  题目 #  In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space. These characters divide the square into contiguous regions.
(Note that backslash characters are escaped, so a \ is represented as &amp;quot;\\&amp;quot;.)
Return the number of regions.
Example 1:
Input: [ &amp;quot; /&amp;quot;, &amp;quot;/ &amp;quot; ] Output: 2 Explanation: The 2x2 grid is as follows:   Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0961.N-Repeated-Element-in-Size-2N-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0961.N-Repeated-Element-in-Size-2N-Array/</guid>
      <description>961. N-Repeated Element in Size 2N Array #  题目 #  In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.
Return the element repeated N times.
Example 1:
Input: [1,2,3,3] Output: 3  Example 2:
Input: [2,1,2,5,3,2] Output: 2  Example 3:
Input: [5,1,5,2,5,3,5,4] Output: 5  Note:
 4 &amp;lt;= A.length &amp;lt;= 10000 0 &amp;lt;= A[i] &amp;lt; 10000 A.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0968.Binary-Tree-Cameras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0968.Binary-Tree-Cameras/</guid>
      <description>968. Binary Tree Cameras #  题目 #  Given a binary tree, we install cameras on the nodes of the tree.
Each camera at a node can monitor its parent, itself, and its immediate children.
Calculate the minimum number of cameras needed to monitor all nodes of the tree.
Example 1:
 Input: [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown.  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0969.Pancake-Sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0969.Pancake-Sorting/</guid>
      <description>969. Pancake Sorting #  题目 #  Given an array A, we can perform a pancake flip: We choose some positive integer k &amp;lt;= A.length, then reverse the order of the first k elements of A. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.
Return the k-values corresponding to a sequence of pancake flips that sort A.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0970.Powerful-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0970.Powerful-Integers/</guid>
      <description>970. Powerful Integers #  题目 #  Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &amp;gt;= 0 and j &amp;gt;= 0.
Return a list of all powerful integers that have value less than or equal to bound.
You may return the answer in any order. In your answer, each value should occur at most once.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0973.K-Closest-Points-to-Origin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0973.K-Closest-Points-to-Origin/</guid>
      <description>973. K Closest Points to Origin #  题目 #  We have a list of points on the plane. Find the K closest points to the origin (0, 0).
(Here, the distance between two points on a plane is the Euclidean distance.)
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)
Example 1:
 Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0976.Largest-Perimeter-Triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0976.Largest-Perimeter-Triangle/</guid>
      <description>976. Largest Perimeter Triangle #  题目 #  Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.
If it is impossible to form any triangle of non-zero area, return 0.
Example 1:
 Input: [2,1,2] Output: 5 Example 2:
 Input: [1,2,1] Output: 0 Example 3:
 Input: [3,2,3,4] Output: 10 Example 4:
 Input: [3,6,2,3] Output: 8 Note:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0977.Squares-of-a-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0977.Squares-of-a-Sorted-Array/</guid>
      <description>977. Squares of a Sorted Array #  题目 #  Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.
Example 1:
 Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2:
 Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note:
 1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A is sorted in non-decreasing order.  题目大意 #  给一个已经有序的数组，返回的数组也必须是有序的，且数组中的每个元素是由原数组中每个数字的平方得到的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0978.Longest-Turbulent-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0978.Longest-Turbulent-Subarray/</guid>
      <description>978. Longest Turbulent Subarray #  题目 #  A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:
 For i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1] when k is odd, and A[k] &amp;lt; A[k+1] when k is even; OR, for i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1] when k is even, and A[k] &amp;lt; A[k+1] when k is odd.  That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0979.Distribute-Coins-in-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0979.Distribute-Coins-in-Binary-Tree/</guid>
      <description>979. 在二叉树中分配硬币 #  Difficulty: 中等
给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
返回使每个结点上只有一枚硬币所需的移动次数。
示例 1：
 
输入：[3,0,0] 输出：2 解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2：
 
输入：[0,3,0] 输出：3 解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3：
 
输入：[1,0,2] 输出：2 示例 4：
 
输入：[1,0,0,null,3] 输出：4 提示：
 1&amp;lt;= N &amp;lt;= 100 0 &amp;lt;= node.val &amp;lt;= N  题解 #  题解一：DFS（深度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0980.Unique-Paths-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0980.Unique-Paths-III/</guid>
      <description>980. Unique Paths III #  题目 #  On a 2-dimensional grid, there are 4 types of squares:
 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over.  Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0981.Time-Based-Key-Value-Store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0981.Time-Based-Key-Value-Store/</guid>
      <description>981. Time Based Key-Value Store #  题目 #  Create a timebased key-value store class TimeMap, that supports two operations.
1. set(string key, string value, int timestamp)
 Stores the key and value, along with the given timestamp.  2. get(string key, int timestamp)
 Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &amp;lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0984.String-Without-AAA-or-BBB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0984.String-Without-AAA-or-BBB/</guid>
      <description>984. String Without AAA or BBB #  题目 #  Given two integers A and B, return any string S such that:
 S has length A + B and contains exactly A &#39;a&#39; letters, and exactly B &#39;b&#39;letters; The substring &#39;aaa&#39; does not occur in S; The substring &#39;bbb&#39; does not occur in S.  Example 1:
Input: A = 1, B = 2 Output: &amp;quot;abb&amp;quot; Explanation: &amp;quot;abb&amp;quot;, &amp;quot;bab&amp;quot; and &amp;quot;bba&amp;quot; are all correct answers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0985.Sum-of-Even-Numbers-After-Queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0985.Sum-of-Even-Numbers-After-Queries/</guid>
      <description>985. Sum of Even Numbers After Queries #  题目 #  We have an array A of integers, and an array queries of queries.
For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index]. Then, the answer to the i-th query is the sum of the even values of A.
(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0986.Interval-List-Intersections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0986.Interval-List-Intersections/</guid>
      <description>986. Interval List Intersections #  题目 #  Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.
Return the intersection of these two interval lists.
(Formally, a closed interval [a, b] (with a &amp;lt;= b) denotes the set of real numbers x with a &amp;lt;= x &amp;lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0990.Satisfiability-of-Equality-Equations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0990.Satisfiability-of-Equality-Equations/</guid>
      <description>990. Satisfiability of Equality Equations #  题目 #  Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: &amp;quot;a==b&amp;quot; or &amp;quot;a!=b&amp;quot;. Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.
Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0992.Subarrays-with-K-Different-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0992.Subarrays-with-K-Different-Integers/</guid>
      <description>992. Subarrays with K Different Integers #  题目 #  Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.
(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)
Return the number of good subarrays of A.
Example 1:
 Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0993.Cousins-in-Binary-Tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0993.Cousins-in-Binary-Tree/</guid>
      <description>993. 二叉树的堂兄弟节点 #  Difficulty: 简单
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但父节点不同，则它们是一对_堂兄弟节点_。
我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。
示例 1：

输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2：

输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3：
 
输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示：
 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。  题解 #  题解一：DFS（广度优先搜索） #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0995.Minimum-Number-of-K-Consecutive-Bit-Flips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0995.Minimum-Number-of-K-Consecutive-Bit-Flips/</guid>
      <description>995. Minimum Number of K Consecutive Bit Flips #  题目 #  In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0996.Number-of-Squareful-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0996.Number-of-Squareful-Arrays/</guid>
      <description>996. Number of Squareful Arrays #  题目 #  Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.
Return the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].
Example 1:
Input: [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0997.Squares-Of-A-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0997.Squares-Of-A-Sorted-Array/</guid>
      <description>977. 有序数组的平方 #  Difficulty: 简单
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
示例 1：
输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：
输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示：
 1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A 已按非递减顺序排序。  题解 #  题解一：直接排序 #  class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; for (int i = 0; i &amp;lt; nums.length; i++) { result[i] = nums[i] * nums[i]; } Arrays.sort(result); return result; } } 复杂度分析 #    时间复杂度：O(nlogn)，其中 n 是数组 A 的长度。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0998.Maximum-Binary-Tree-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0998.Maximum-Binary-Tree-II/</guid>
      <description>998. 最大二叉树 II #  Difficulty: 中等
最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。
给出最大树的根节点 root。
就像那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：
 如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]]) root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) 返回 root  请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).
假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。
返回 Construct(B)。
示例 1：
 
输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2] 解释：A = [1,4,2,3], B = [1,4,2,3,5] 示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/0999.Available-Captures-for-Rook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/0999.Available-Captures-for-Rook/</guid>
      <description>999. Available Captures for Rook #  题目 #  On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters &amp;lsquo;R&amp;rsquo;, &amp;lsquo;.&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, and &amp;lsquo;p&amp;rsquo; respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.
The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1002.Find-Common-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1002.Find-Common-Characters/</guid>
      <description>1002. Find Common Characters #  题目 #  Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.
You may return the answer in any order.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1003.Check-If-Word-Is-Valid-After-Substitutions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1003.Check-If-Word-Is-Valid-After-Substitutions/</guid>
      <description>1003. Check If Word Is Valid After Substitutions #  题目 #  We are given that the string &amp;ldquo;abc&amp;rdquo; is valid.
From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + &amp;ldquo;abc&amp;rdquo; + Y is also valid.
If for example S = &amp;ldquo;abc&amp;rdquo;, then examples of valid strings are: &amp;ldquo;abc&amp;rdquo;, &amp;ldquo;aabcbc&amp;rdquo;, &amp;ldquo;abcabc&amp;rdquo;, &amp;ldquo;abcabcababcc&amp;rdquo;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1004.Max-Consecutive-Ones-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1004.Max-Consecutive-Ones-III/</guid>
      <description>1004. Max Consecutive Ones III #  题目 #  Given an array A of 0s and 1s, we may change up to K values from 0 to 1.
Return the length of the longest (contiguous) subarray that contains only 1s.
Example 1:
 Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1005.Maximize-Sum-Of-Array-After-K-Negations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1005.Maximize-Sum-Of-Array-After-K-Negations/</guid>
      <description>1005. Maximize Sum Of Array After K Negations #  题目 #  Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total. (We may choose the same index i multiple times.)
Return the largest possible sum of the array after modifying it in this way.
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1011.Capacity-To-Ship-Packages-Within-D-Days/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1011.Capacity-To-Ship-Packages-Within-D-Days/</guid>
      <description>1011. Capacity To Ship Packages Within D Days #  题目 #  A conveyor belt has packages that must be shipped from one port to another within D days.
The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1017.Convert-to-Base-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1017.Convert-to-Base-2/</guid>
      <description>1017. Convert to Base -2 #  题目 #  Given a number N, return a string consisting of &amp;quot;0&amp;quot;s and &amp;quot;1&amp;quot;s that represents its value in base -2 (negative two).
The returned string must have no leading zeroes, unless the string is &amp;quot;0&amp;quot;.
Example 1:
Input: 2 Output: &amp;quot;110&amp;quot; Explantion: (-2) ^ 2 + (-2) ^ 1 = 2  Example 2:
Input: 3 Output: &amp;quot;111&amp;quot; Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3  Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1019.Next-Greater-Node-In-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1019.Next-Greater-Node-In-Linked-List/</guid>
      <description>1019. Next Greater Node In Linked List #  题目 #  We are given a linked list with head as the first node. Let&amp;rsquo;s number the nodes in the list: node_1, node_2, node_3, &amp;hellip; etc.
Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j &amp;gt; i, node_j.val &amp;gt; node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1020.Number-of-Enclaves/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1020.Number-of-Enclaves/</guid>
      <description>1020. Number of Enclaves #  题目 #  Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)
A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.
Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1021.Remove-Outermost-Parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1021.Remove-Outermost-Parentheses/</guid>
      <description>1021. Remove Outermost Parentheses #  题目 #  A valid parentheses string is either empty (&amp;quot;&amp;quot;), &amp;ldquo;(&amp;rdquo; + A + &amp;ldquo;)&amp;rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &amp;ldquo;&amp;rdquo;, &amp;ldquo;()&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, and &amp;ldquo;(()(()))&amp;rdquo; are all valid parentheses strings.
A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1022.Sum-Of-Root-To-Leaf-Binary-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1022.Sum-Of-Root-To-Leaf-Binary-Numbers/</guid>
      <description>1022. 从根到叶的二进制数之和 #  Difficulty: 简单
给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1，那么它表示二进制数 01101，也就是 13 。
对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
返回这些数字之和。题目数据保证答案是一个 32 位 整数。
示例 1：
 输入：root = [1,0,1,0,1,0,1] 输出：22 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 示例 2：
输入：root = [0] 输出：0 示例 3：
输入：root = [1] 输出：1 示例 4：
输入：root = [1,1] 输出：3 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1025.Divisor-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1025.Divisor-Game/</guid>
      <description>1025. Divisor Game #  题目 #  Alice and Bob take turns playing a game, with Alice starting first.
Initially, there is a number N on the chalkboard. On each player&amp;rsquo;s turn, that player makes a move consisting of:
 Choosing any x with 0 &amp;lt; x &amp;lt; N and N % x == 0. Replacing the number N on the chalkboard with N - x.  Also, if a player cannot make a move, they lose the game.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1026.Maximum-Difference-Between-Node-and-Ancestor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1026.Maximum-Difference-Between-Node-and-Ancestor/</guid>
      <description>1026. Maximum Difference Between Node and Ancestor #  题目 #  Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.
(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1028.Recover-a-Tree-From-Preorder-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1028.Recover-a-Tree-From-Preorder-Traversal/</guid>
      <description>1028. Recover a Tree From Preorder Traversal #  题目 #  We run a preorder depth first search on the root of a binary tree.
At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. (If the depth of a node is D, the depth of its immediate child is D+1. The depth of the root node is 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1030.Matrix-Cells-in-Distance-Order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1030.Matrix-Cells-in-Distance-Order/</guid>
      <description>1030. Matrix Cells in Distance Order #  题目 #  We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &amp;lt;= r &amp;lt; R and 0 &amp;lt;= c &amp;lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1037.Valid-Boomerang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1037.Valid-Boomerang/</guid>
      <description>1037. Valid Boomerang #  题目 #  A boomerang is a set of 3 points that are all distinct and not in a straight line.
Given a list of three points in the plane, return whether these points are a boomerang.
Example 1:
Input: [[1,1],[2,3],[3,2]] Output: true Example 2:
Input: [[1,1],[2,2],[3,3]] Output: false Note:
 points.length == 3 points[i].length == 2 0 &amp;lt;= points[i][j] &amp;lt;= 100  题目大意 #  回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1040.Moving-Stones-Until-Consecutive-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1040.Moving-Stones-Until-Consecutive-II/</guid>
      <description>1040. Moving Stones Until Consecutive II #  题目 #  On an infinite number line, the position of the i-th stone is given by stones[i]. Call a stone an endpoint stone if it has the smallest or largest position.
Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.
In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1047.Remove-All-Adjacent-Duplicates-In-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1047.Remove-All-Adjacent-Duplicates-In-String/</guid>
      <description>1047. Remove All Adjacent Duplicates In String #  题目 #  Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.
We repeatedly make duplicate removals on S until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique.
Example 1:
 Input: &amp;quot;abbaca&amp;quot; Output: &amp;quot;ca&amp;quot; Explanation: For example, in &amp;quot;abbaca&amp;quot; we could remove &amp;quot;bb&amp;quot; since the letters are adjacent and equal, and this is the only possible move.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1049.Last-Stone-Weight-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1049.Last-Stone-Weight-II/</guid>
      <description>1049. Last Stone Weight II #  题目 #  We have a collection of rocks, each rock has a positive integer weight.
Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x &amp;lt;= y. The result of this smash is:
 If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight yhas new weight y-x.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1051.Height-Checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1051.Height-Checker/</guid>
      <description>1051. Height Checker #  题目 #  Students are asked to stand in non-decreasing order of heights for an annual photo.
Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.
Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1052.Grumpy-Bookstore-Owner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1052.Grumpy-Bookstore-Owner/</guid>
      <description>1052. Grumpy Bookstore Owner #  题目 #  Today, the bookstore owner has a store open for customers.lengthminutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.
On some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1054.Distant-Barcodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1054.Distant-Barcodes/</guid>
      <description>1054. Distant Barcodes #  题目 #  In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].
Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.
Example 1:
Input: [1,1,1,2,2,2] Output: [2,1,2,1,2,1]  Example 2:
Input: [1,1,1,1,2,2,3,3] Output: [1,3,1,3,2,1,2,1]  Note:
 1 &amp;lt;= barcodes.length &amp;lt;= 10000 1 &amp;lt;= barcodes[i] &amp;lt;= 10000  题目大意 #  在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1073.Adding-Two-Negabinary-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1073.Adding-Two-Negabinary-Numbers/</guid>
      <description>1073. Adding Two Negabinary Numbers #  题目 #  Given two numbers arr1 and arr2 in base -2, return the result of adding them together.
Each number is given in array format: as an array of 0s and 1s, from most significant bit to least significant bit. For example, arr = [1,1,0,1]represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3. A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1074.Number-of-Submatrices-That-Sum-to-Target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1074.Number-of-Submatrices-That-Sum-to-Target/</guid>
      <description>1074. Number of Submatrices That Sum to Target #  题目 #  Given a matrix, and a target, return the number of non-empty submatrices that sum to target.
A submatrix x1, y1, x2, y2 is the set of all cells matrix[y] with x1 &amp;lt;= x &amp;lt;= x2 and y1 &amp;lt;= y &amp;lt;= y2.
Two submatrices (x1, y1, x2, y2) and (x1&#39;, y1&#39;, x2&#39;, y2&#39;) are different if they have some coordinate that is different: for example, if x1 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1078.Occurrences-After-Bigram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1078.Occurrences-After-Bigram/</guid>
      <description>1078. Occurrences After Bigram #  题目 #  Given words first and second, consider occurrences in some text of the form &amp;ldquo;first second third&amp;rdquo;, where second comes immediately after first, and thirdcomes immediately after second.
For each such occurrence, add &amp;ldquo;third&amp;rdquo; to the answer, and return the answer.
Example 1:
Input: text = &amp;quot;alice is a good girl she is a good student&amp;quot;, first = &amp;quot;a&amp;quot;, second = &amp;quot;good&amp;quot; Output: [&amp;quot;girl&amp;quot;,&amp;quot;student&amp;quot;]  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1079.Letter-Tile-Possibilities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1079.Letter-Tile-Possibilities/</guid>
      <description>1079. Letter Tile Possibilities #  题目 #  You have a set of tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make.
Example 1:
Input: &amp;quot;AAB&amp;quot; Output: 8 Explanation: The possible sequences are &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;AA&amp;quot;, &amp;quot;AB&amp;quot;, &amp;quot;BA&amp;quot;, &amp;quot;AAB&amp;quot;, &amp;quot;ABA&amp;quot;, &amp;quot;BAA&amp;quot;.  Example 2:
Input: &amp;quot;AAABBC&amp;quot; Output: 188  Note:
 1 &amp;lt;= tiles.length &amp;lt;= 7 tiles consists of uppercase English letters.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1089.Duplicate-Zeros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1089.Duplicate-Zeros/</guid>
      <description>1089. Duplicate Zeros #  题目 #  Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.
Note that elements beyond the length of the original array are not written.
Do the above modifications to the input array in place, do not return anything from your function.
Example 1:
Input: [1,0,2,3,0,4,5,0] Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1093.Statistics-from-a-Large-Sample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1093.Statistics-from-a-Large-Sample/</guid>
      <description>1093. Statistics from a Large Sample #  题目 #  We sampled integers between 0 and 255, and stored the results in an array count: count[k] is the number of integers we sampled equal to k.
Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers. The mode is guaranteed to be unique.
(Recall that the median of a sample is:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1105.Filling-Bookcase-Shelves/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1105.Filling-Bookcase-Shelves/</guid>
      <description>1105. Filling Bookcase Shelves #  题目 #  We have a sequence of books: the i-th book has thickness books[i][0]and height books[i][1].
We want to place these books in order onto bookcase shelves that have total width shelf_width.
We choose some of the books to place on this shelf (such that the sum of their thickness is &amp;lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1108.Defanging-an-IP-Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1108.Defanging-an-IP-Address/</guid>
      <description>1108. Defanging an IP Address #  题目 #  Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period &amp;quot;.&amp;quot; with &amp;quot;[.]&amp;quot;.
Example 1:
Input: address = &amp;quot;1.1.1.1&amp;quot; Output: &amp;quot;1[.]1[.]1[.]1&amp;quot;  Example 2:
Input: address = &amp;quot;255.100.50.0&amp;quot; Output: &amp;quot;255[.]100[.]50[.]0&amp;quot;  Constraints:
 The given address is a valid IPv4 address.  题目大意 #  给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 &amp;ldquo;[.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1110.Delete-Nodes-And-Return-Forest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1110.Delete-Nodes-And-Return-Forest/</guid>
      <description>1110. Delete Nodes And Return Forest #  题目 #  Given the root of a binary tree, each node in the tree has a distinct value.
After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).
Return the roots of the trees in the remaining forest. You may return the result in any order.
Example 1:
 Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Constraints:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1111.Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1111.Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings/</guid>
      <description>1111. Maximum Nesting Depth of Two Valid Parentheses Strings #  题目 #  A string is a valid parentheses string (denoted VPS) if and only if it consists of &amp;quot;(&amp;quot; and &amp;quot;)&amp;quot; characters only, and:
 It is the empty string, or It can be written as AB (A concatenated with B), where A and B are VPS&amp;rsquo;s, or It can be written as (A), where A is a VPS.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1122.Relative-Sort-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1122.Relative-Sort-Array/</guid>
      <description>1122. Relative Sort Array #  题目 #  Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.
Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that don&amp;rsquo;t appear in arr2 should be placed at the end of arr1 in ascending order.
Example 1:
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19]  Constraints:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1123.Lowest-Common-Ancestor-of-Deepest-Leaves/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1123.Lowest-Common-Ancestor-of-Deepest-Leaves/</guid>
      <description>1123. Lowest Common Ancestor of Deepest Leaves #  题目 #  Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.
Recall that:
 The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1128.Number-of-Equivalent-Domino-Pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1128.Number-of-Equivalent-Domino-Pairs/</guid>
      <description>1128. Number of Equivalent Domino Pairs #  题目 #  Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.
Return the number of pairs (i, j) for which 0 &amp;lt;= i &amp;lt; j &amp;lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1137.N-th-Tribonacci-Number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1137.N-th-Tribonacci-Number/</guid>
      <description>1137. N-th Tribonacci Number #  题目 #  The Tribonacci sequence Tn is defined as follows:
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1145.Binary-Tree-Coloring-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1145.Binary-Tree-Coloring-Game/</guid>
      <description>1145. Binary Tree Coloring Game #  题目 #  Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.
Initially, the first player names a value x with 1 &amp;lt;= x &amp;lt;= n, and the second player names a value y with 1 &amp;lt;= y &amp;lt;= n and y !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1154.Day-of-the-Year/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1154.Day-of-the-Year/</guid>
      <description>1154. Day of the Year #  题目 #  Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.
Example 1:
Input: date = &amp;quot;2019-01-09&amp;quot; Output: 9 Explanation: Given date is the 9th day of the year in 2019.  Example 2:
Input: date = &amp;quot;2019-02-10&amp;quot; Output: 41  Example 3:
Input: date = &amp;quot;2003-03-01&amp;quot; Output: 60  Example 4:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1157.Online-Majority-Element-In-Subarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1157.Online-Majority-Element-In-Subarray/</guid>
      <description>1157. Online Majority Element In Subarray #  题目 #  Implementing the class MajorityChecker, which has the following API:
 MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr; int query(int left, int right, int threshold) has arguments such that:  0 &amp;lt;= left &amp;lt;= right &amp;lt; arr.length representing a subarray of arr; 2 * threshold &amp;gt; right - left + 1, ie. the threshold is always a strict majority of the length of the subarray    Each query(.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1160.Find-Words-That-Can-Be-Formed-by-Characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1160.Find-Words-That-Can-Be-Formed-by-Characters/</guid>
      <description>1160. Find Words That Can Be Formed by Characters #  题目 #  You are given an array of strings words and a string chars.
A string is good if it can be formed by characters from chars (each character can only be used once).
Return the sum of lengths of all good strings in words.
Example 1:
Input: words = [&amp;quot;cat&amp;quot;,&amp;quot;bt&amp;quot;,&amp;quot;hat&amp;quot;,&amp;quot;tree&amp;quot;], chars = &amp;quot;atach&amp;quot; Output: 6 Explanation: The strings that can be formed are &amp;quot;cat&amp;quot; and &amp;quot;hat&amp;quot; so the answer is 3 + 3 = 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1170.Compare-Strings-by-Frequency-of-the-Smallest-Character/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1170.Compare-Strings-by-Frequency-of-the-Smallest-Character/</guid>
      <description>1170. Compare Strings by Frequency of the Smallest Character #  题目 #  Let&amp;rsquo;s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = &amp;quot;dcce&amp;quot; then f(s) = 2 because the smallest character is &amp;quot;c&amp;quot; and its frequency is 2.
Now, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) &amp;lt; f(W), where W is a word in words.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1171.Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1171.Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</guid>
      <description>1171. Remove Zero Sum Consecutive Nodes from Linked List #  题目 #  Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.
After doing so, return the head of the final linked list. You may return any such answer.
(Note that in the examples below, all sequences are serializations of ListNode objects.)
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1175.Prime-Arrangements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1175.Prime-Arrangements/</guid>
      <description>1175. Prime Arrangements #  题目 #  Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)
(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)
Since the answer may be large, return the answer modulo 10^9 + 7.
Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1184.Distance-Between-Bus-Stops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1184.Distance-Between-Bus-Stops/</guid>
      <description>1184. Distance Between Bus Stops #  题目 #  A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.
The bus goes along both directions i.e. clockwise and counterclockwise.
Return the shortest distance between the given start and destination stops.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1185.Day-of-the-Week/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1185.Day-of-the-Week/</guid>
      <description>1185. Day of the Week #  题目 #  Given a date, return the corresponding day of the week for that date.
The input is given as three integers representing the day, month and year respectively.
Return the answer as one of the following values {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}.
Example 1:
Input: day = 31, month = 8, year = 2019 Output: &amp;quot;Saturday&amp;quot;  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1189.Maximum-Number-of-Balloons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1189.Maximum-Number-of-Balloons/</guid>
      <description>1189. Maximum Number of Balloons #  题目 #  Given a string text, you want to use the characters of text to form as many instances of the word &amp;ldquo;balloon&amp;rdquo; as possible.
You can use each character in text at most once. Return the maximum number of instances that can be formed.
Example 1:
 Input: text = &amp;quot;nlaebolko&amp;quot; Output: 1  Example 2:
 Input: text = &amp;quot;loonbalxballpoon&amp;quot; Output: 2  Example 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1200.Minimum-Absolute-Difference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1200.Minimum-Absolute-Difference/</guid>
      <description>1200. Minimum Absolute Difference #  题目 #  Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.
Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows
 a, b are from arr a &amp;lt; b b - a equals to the minimum absolute difference of any two elements in arr  Example 1:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1201.Ugly-Number-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1201.Ugly-Number-III/</guid>
      <description>1201. Ugly Number III #  题目 #  Write a program to find the n-th ugly number.
Ugly numbers are positive integers which are divisible by a or b or c.
Example 1:
Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.  Example 2:
Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1202.Smallest-String-With-Swaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1202.Smallest-String-With-Swaps/</guid>
      <description>1202. Smallest String With Swaps #  题目 #  You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.
You can swap the characters at any pair of indices in the given pairs any number of times.
Return the lexicographically smallest string that s can be changed to after using the swaps.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1207.Unique-Number-of-Occurrences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1207.Unique-Number-of-Occurrences/</guid>
      <description>1207. Unique Number of Occurrences #  题目 #  Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.
Example 1:
Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.  Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1208.Get-Equal-Substrings-Within-Budget/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1208.Get-Equal-Substrings-Within-Budget/</guid>
      <description>1208. Get Equal Substrings Within Budget #  题目 #  You are given two strings s and t of the same length. You want to change s to t. Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.
You are also given an integer maxCost.
Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1217.Play-with-Chips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1217.Play-with-Chips/</guid>
      <description>1217. Play with Chips #  题目 #  There are some chips, and the i-th chip is at position chips[i].
You can perform any of the two following types of moves any number of times (possibly zero) on any chip:
 Move the i-th chip by 2 units to the left or to the right with a cost of 0. Move the i-th chip by 1 unit to the left or to the right with a cost of 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1221.Split-a-String-in-Balanced-Strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1221.Split-a-String-in-Balanced-Strings/</guid>
      <description>1221. Split a String in Balanced Strings #  题目 #  Balanced strings are those who have equal quantity of &amp;lsquo;L&amp;rsquo; and &amp;lsquo;R&amp;rsquo; characters.
Given a balanced string s split it in the maximum amount of balanced strings.
Return the maximum amount of splitted balanced strings.
Example 1:
Input: s = &amp;quot;RLRRLLRLRL&amp;quot; Output: 4 Explanation: s can be split into &amp;quot;RL&amp;quot;, &amp;quot;RRLL&amp;quot;, &amp;quot;RL&amp;quot;, &amp;quot;RL&amp;quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1232.Check-If-It-Is-a-Straight-Line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1232.Check-If-It-Is-a-Straight-Line/</guid>
      <description>1232. Check If It Is a Straight Line #  题目 #  You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.
Example 1:
 Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true  Example 2:
 Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false  Constraints:
 2 &amp;lt;= coordinates.length &amp;lt;= 1000 coordinates[i].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1234.Replace-the-Substring-for-Balanced-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1234.Replace-the-Substring-for-Balanced-String/</guid>
      <description>1234. Replace the Substring for Balanced String #  题目 #  You are given a string containing only 4 kinds of characters &#39;Q&#39;, &#39;W&#39;, &#39;E&#39; and &#39;R&#39;.
A string is said to be balanced **if each of its characters appears n/4 times where n is the length of the string.
Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1235.Maximum-Profit-in-Job-Scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1235.Maximum-Profit-in-Job-Scheduling/</guid>
      <description>1235. Maximum Profit in Job Scheduling #  题目 #  We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1252.Cells-with-Odd-Values-in-a-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1252.Cells-with-Odd-Values-in-a-Matrix/</guid>
      <description>1252. Cells with Odd Values in a Matrix #  题目 #  Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.
Return the number of cells with odd values in the matrix after applying the increment to all indices.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1254.Number-of-Closed-Islands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1254.Number-of-Closed-Islands/</guid>
      <description>1254. Number of Closed Islands #  题目 #  Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.
Return the number of closed islands.
Example 1:
 Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1260.Shift-2D-Grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1260.Shift-2D-Grid/</guid>
      <description>1260. Shift 2D Grid #  题目 #  Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
 Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0].  Return the 2D grid after applying shift operation k times.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1266.Minimum-Time-Visiting-All-Points/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1266.Minimum-Time-Visiting-All-Points/</guid>
      <description>1266. Minimum Time Visiting All Points #  题目 #  On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.
You can move according to the next rules:
 In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1275.Find-Winner-on-a-Tic-Tac-Toe-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1275.Find-Winner-on-a-Tic-Tac-Toe-Game/</guid>
      <description>1275. Find Winner on a Tic Tac Toe Game #  题目 #  Tic-tac-toe is played by two players A and B on a 3 x 3 grid.
Here are the rules of Tic-Tac-Toe:
 Players take turns placing characters into empty squares (&amp;quot; &amp;ldquo;). The first player A always places &amp;ldquo;X&amp;rdquo; characters, while the second player B always places &amp;ldquo;O&amp;rdquo; characters. &amp;ldquo;X&amp;rdquo; and &amp;ldquo;O&amp;rdquo; characters are always placed into empty squares, never on filled ones.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1281.Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1281.Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/</guid>
      <description>1281. Subtract the Product and Sum of Digits of an Integer #  题目 #  Given an integer number n, return the difference between the product of its digits and the sum of its digits.
Example 1:
Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1283.Find-the-Smallest-Divisor-Given-a-Threshold/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1283.Find-the-Smallest-Divisor-Given-a-Threshold/</guid>
      <description>1283. Find the Smallest Divisor Given a Threshold #  题目 #  Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.
Each result of division is rounded to the nearest integer greater than or equal to that element.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1287.Element-Appearing-More-Than-25-In-Sorted-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1287.Element-Appearing-More-Than-25-In-Sorted-Array/</guid>
      <description>1287. Element Appearing More Than 25% In Sorted Array #  题目 #  Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time.
Return that integer.
Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Constraints:
 1 &amp;lt;= arr.length &amp;lt;= 10^4 0 &amp;lt;= arr[i] &amp;lt;= 10^5  题目大意 #  给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数。
提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1290.Convert-Binary-Number-in-a-Linked-List-to-Integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1290.Convert-Binary-Number-in-a-Linked-List-to-Integer/</guid>
      <description>1290. Convert Binary Number in a Linked List to Integer #  题目 #  Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.
Return the decimal value of the number in the linked list.
Example 1:
 Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1295.Find-Numbers-with-Even-Number-of-Digits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1295.Find-Numbers-with-Even-Number-of-Digits/</guid>
      <description>1295. Find Numbers with Even Number of Digits #  题目 #  Given an array nums of integers, return how many of them contain an even number of digits.
Example 1:
Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1299.Replace-Elements-with-Greatest-Element-on-Right-Side/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1299.Replace-Elements-with-Greatest-Element-on-Right-Side/</guid>
      <description>1299. Replace Elements with Greatest Element on Right Side #  题目 #  Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.
After doing so, return the array.
Example 1:
Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Constraints:
 1 &amp;lt;= arr.length &amp;lt;= 10^4 1 &amp;lt;= arr[i] &amp;lt;= 10^5  题目大意 #  给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。完成所有替换操作后，请你返回这个数组。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1300.Sum-of-Mutated-Array-Closest-to-Target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1300.Sum-of-Mutated-Array-Closest-to-Target/</guid>
      <description>1300. Sum of Mutated Array Closest to Target #  题目 #  Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.
In case of a tie, return the minimum such integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1302.Deepest-Leaves-Sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1302.Deepest-Leaves-Sum/</guid>
      <description>1302. Deepest Leaves Sum #  题目 #  Given a binary tree, return the sum of values of its deepest leaves.
Example 1:
 Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Constraints:
 The number of nodes in the tree is between 1 and 10^4. The value of nodes is between 1 and 100.  题目大意 #  给你一棵二叉树，请你返回层数最深的叶子节点的和。
提示：
 树中节点数目在 1 到 10^4 之间。 每个节点的值在 1 到 100 之间。  解题思路 #   给你一棵二叉树，请你返回层数最深的叶子节点的和。 这一题不难，DFS 遍历把最底层的叶子节点和都加起来即可。  代码 #  func deepestLeavesSum(root *TreeNode) int { maxLevel, sum := 0, 0 dfsDeepestLeavesSum(root, 0, &amp;amp;maxLevel, &amp;amp;sum) return sum } func dfsDeepestLeavesSum(root *TreeNode, level int, maxLevel, sum *int) { if root == nil { return } if level &amp;gt; *maxLevel { *maxLevel, *sum = level, root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1304.Find-N-Unique-Integers-Sum-up-to-Zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1304.Find-N-Unique-Integers-Sum-up-to-Zero/</guid>
      <description>1304. Find N Unique Integers Sum up to Zero #  题目 #  Given an integer n, return any array containing n unique integers such that they add up to 0.
Example 1:
Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2:
Input: n = 3 Output: [-1,0,1] Example 3:
Input: n = 1 Output: [0] Constraints:
 1 &amp;lt;= n &amp;lt;= 1000  题目大意 #  给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1305.All-Elements-in-Two-Binary-Search-Trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1305.All-Elements-in-Two-Binary-Search-Trees/</guid>
      <description>1305. All Elements in Two Binary Search Trees #  题目 #  Given two binary search trees root1 and root2.
Return a list containing all the integers from both trees sorted in ascending order.
Example 1:
 Input: root1 = [2,1,4], root2 = [1,0,3] Output: [0,1,1,2,3,4] Example 2:
Input: root1 = [0,-10,10], root2 = [5,1,7,0,2] Output: [-10,0,0,1,2,5,7,10] Example 3:
Input: root1 = [], root2 = [5,1,7,0,2] Output: [0,1,2,5,7] Example 4:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1306.Jump-Game-III/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1306.Jump-Game-III/</guid>
      <description>1306. Jump Game III #  题目 #  Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
Notice that you can not jump outside of the array at any time.
Example 1:
Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1313.Decompress-Run-Length-Encoded-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1313.Decompress-Run-Length-Encoded-List/</guid>
      <description>1313. Decompress Run-Length Encoded List #  题目 #  We are given a list nums of integers representing a list compressed with run-length encoding.
Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i &amp;gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.
Return the decompressed list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1317.Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1317.Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/</guid>
      <description>1317. Convert Integer to the Sum of Two No-Zero Integers #  题目 #  Given an integer n. No-Zero integer is a positive integer which doesn&amp;rsquo;t contain any 0 in its decimal representation.
Return a list of two integers [A, B] where:
 A and B are No-Zero integers. A + B = n  It&amp;rsquo;s guarateed that there is at least one valid solution. If there are many valid solutions you can return any of them.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1380.Lucky-Numbers-in-a-Matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1380.Lucky-Numbers-in-a-Matrix/</guid>
      <description>1380. Lucky Numbers in a Matrix #  题目 #  Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
Example 1:
Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1385.Find-the-Distance-Value-Between-Two-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1385.Find-the-Distance-Value-Between-Two-Arrays/</guid>
      <description>1385. Find the Distance Value Between Two Arrays #  题目 #  Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.
The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| &amp;lt;= d.
Example 1:
Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 &amp;gt; d=2 |4-9|=5 &amp;gt; d=2 |4-1|=3 &amp;gt; d=2 |4-8|=4 &amp;gt; d=2 For arr1[1]=5 we have: |5-10|=5 &amp;gt; d=2 |5-9|=4 &amp;gt; d=2 |5-1|=4 &amp;gt; d=2 |5-8|=3 &amp;gt; d=2 For arr1[2]=8 we have: |8-10|=2 &amp;lt;= d=2 |8-9|=1 &amp;lt;= d=2 |8-1|=7 &amp;gt; d=2 |8-8|=0 &amp;lt;= d=2 Example 2:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1389.Create-Target-Array-in-the-Given-Order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1389.Create-Target-Array-in-the-Given-Order/</guid>
      <description>1389. Create Target Array in the Given Order #  题目 #  Given two arrays of integers nums and index. Your task is to create target array under the following rules:
 Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1455.Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1455.Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</guid>
      <description>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence #  题目 #  Given a sentence that consists of some words separated by a single space, and a searchWord.
You have to check if searchWord is a prefix of any word in sentence.
Return the index of the word in sentence where searchWord is a prefix of this word (1-indexed).
If searchWord is a prefix of more than one word, return the index of the first word (minimum index).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1464.Maximum-Product-of-Two-Elements-in-an-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1464.Maximum-Product-of-Two-Elements-in-an-Array/</guid>
      <description>1464. Maximum Product of Two Elements in an Array #  题目 #  Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
Example 1:
Input: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1470.Shuffle-the-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1470.Shuffle-the-Array/</guid>
      <description>1470. Shuffle the Array #  题目 #  Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].
Return the array in the form [x1,y1,x2,y2,...,xn,yn].
Example 1:
Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2:
Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3:
Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] Constraints:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1476.Subrectangle-Queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1476.Subrectangle-Queries/</guid>
      <description>1476. 子矩形查询 #  Difficulty: 中等
请你实现一个类 SubrectangleQueries ，它的构造函数的参数是一个 rows x cols 的矩形（这里用整数矩阵表示），并支持以下两种操作：
1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
 用 newValue 更新以 (row1,col1) 为左上角且以 (row2,col2) 为右下角的子矩形。  2. getValue(int row, int col)
 返回矩形中坐标 (row,col) 的当前值。  示例 1：
输入： [&amp;quot;SubrectangleQueries&amp;quot;,&amp;quot;getValue&amp;quot;,&amp;quot;updateSubrectangle&amp;quot;,&amp;quot;getValue&amp;quot;,&amp;quot;getValue&amp;quot;,&amp;quot;updateSubrectangle&amp;quot;,&amp;quot;getValue&amp;quot;,&amp;quot;getValue&amp;quot;] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] 输出： [null,1,null,5,5,null,10,5] 解释： SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // 初始的 (4x3) 矩形如下： // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1480.Running-Sum-of-1d-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1480.Running-Sum-of-1d-Array/</guid>
      <description>1480. Running Sum of 1d Array #  题目 #  Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
Example 1:
Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2:
Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1512.Number-of-Good-Pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1512.Number-of-Good-Pairs/</guid>
      <description>1512. Number of Good Pairs #  题目 #  Given an array of integers nums.
A pair (i,j) is called good if nums[i] == nums[j] and i &amp;lt; j.
Return the number of good pairs.
Example 1:
Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2:
Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1530.Number-Of-Good-Leaf-Nodes-Pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1530.Number-Of-Good-Leaf-Nodes-Pairs/</guid>
      <description>1530. 好叶子节点对的数量 #  Difficulty: 中等
给你二叉树的根节点 root 和一个整数 distance 。
如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。
返回树中 好叶子节点对的数量 。
示例 1：
 输入：root = [1,2,3,null,4], distance = 3 输出：1 解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。 示例 2：
 输入：root = [1,2,3,4,5,6,7], distance = 3 输出：2 解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。 示例 3：
输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 输出：1 解释：唯一的好叶子节点对是 [2,5] 。 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1535.Find-The-Winner-Of-An-Array-Game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1535.Find-The-Winner-Of-An-Array-Game/</guid>
      <description>1535. 找出数组游戏的赢家 #  Difficulty: 中等
给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
返回赢得比赛的整数。
题目数据 保证 游戏存在赢家。
示例 1：
输入：arr = [2,1,3,5,4,6,7], k = 2 输出：5 解释：一起看一下本场游戏每回合的情况：  因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。 示例 2：
输入：arr = [3,2,1], k = 10 输出：3 解释：3 将会在前 10 个回合中连续获胜。 示例 3：
输入：arr = [1,9,8,2,3,7,6,4,5], k = 7 输出：9 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1550.Three-Consecutive-Odds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1550.Three-Consecutive-Odds/</guid>
      <description>1550. 存在连续三个奇数的数组 #  Difficulty: 简单
给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。
示例 1：
输入：arr = [2,6,4,1] 输出：false 解释：不存在连续三个元素都是奇数的情况。 示例 2：
输入：arr = [1,2,34,3,4,5,7,23,12] 输出：true 解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。 提示：
 1 &amp;lt;= arr.length &amp;lt;= 1000 1 &amp;lt;= arr[i] &amp;lt;= 1000  题解 #  题解一：枚举 #  class Solution { public boolean threeConsecutiveOdds(int[] arr) { boolean result = false; for (int i = 0; i &amp;lt; arr.length - 2; i++) { result = (arr[i] % 2 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1646.Get-Maximum-in-Generated-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1646.Get-Maximum-in-Generated-Array/</guid>
      <description>1646. Get Maximum in Generated Array #  题目 #  You are given an integer n. An array nums of length n + 1 is generated in the following way:
 nums[0] = 0 nums[1] = 1 nums[2 * i] = nums[i] when 2 &amp;lt;= 2 * i &amp;lt;= n nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &amp;lt;= 2 * i + 1 &amp;lt;= n  Return ****the maximum integer in the array nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1647.Minimum-Deletions-to-Make-Character-Frequencies-Unique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1647.Minimum-Deletions-to-Make-Character-Frequencies-Unique/</guid>
      <description>1647. Minimum Deletions to Make Character Frequencies Unique #  题目 #  A string s is called good if there are no two different characters in s that have the same frequency.
Given a string s, return the minimum number of characters you need to delete to make s good.
The frequency of a character in a string is the number of times it appears in the string. For example, in the string &amp;quot;aab&amp;quot;, the frequency of &#39;a&#39; is 2, while the frequency of &#39;b&#39; is 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1648.Sell-Diminishing-Valued-Colored-Balls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1648.Sell-Diminishing-Valued-Colored-Balls/</guid>
      <description>1648. Sell Diminishing-Valued Colored Balls #  题目 #  You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.
The customer weirdly values the colored balls. Each colored ball&amp;rsquo;s value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1649.Create-Sorted-Array-through-Instructions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1649.Create-Sorted-Array-through-Instructions/</guid>
      <description>1649. Create Sorted Array through Instructions #  题目 #  Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:
 The number of elements currently in nums that are strictly less than instructions[i].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1656.Design-an-Ordered-Stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1656.Design-an-Ordered-Stream/</guid>
      <description>1656. Design an Ordered Stream #  题目 #  There is a stream of n (id, value) pairs arriving in an arbitrary order, where id is an integer between 1 and n and value is a string. No two pairs have the same id.
Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1657.Determine-if-Two-Strings-Are-Close/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1657.Determine-if-Two-Strings-Are-Close/</guid>
      <description>1657. Determine if Two Strings Are Close #  题目 #  Two strings are considered close if you can attain one from the other using the following operations:
 Operation 1: Swap any two existing characters.  For example, abcde -&amp;gt; aecdb   Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.  For example, aacabb -&amp;gt; bbcbaa (all a&amp;rsquo;s turn into b&amp;rsquo;s, and all b&amp;rsquo;s turn into a&amp;rsquo;s)    You can use the operations on either string as many times as necessary.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1658.Minimum-Operations-to-Reduce-X-to-Zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1658.Minimum-Operations-to-Reduce-X-to-Zero/</guid>
      <description>1658. Minimum Operations to Reduce X to Zero #  题目 #  You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it&amp;rsquo;s possible, otherwise, return 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1659.Maximize-Grid-Happiness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1659.Maximize-Grid-Happiness/</guid>
      <description>1659. Maximize Grid Happiness #  题目 #  You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.
You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1662.Check-If-Two-String-Arrays-are-Equivalent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1662.Check-If-Two-String-Arrays-are-Equivalent/</guid>
      <description>1662. Check If Two String Arrays are Equivalent #  题目 #  Given two string arrays word1 and word2, return **true if the two arrays represent the same string, and false otherwise.
A string is represented by an array if the array elements concatenated in order forms the string.
Example 1:
Input: word1 = [&amp;quot;ab&amp;quot;, &amp;quot;c&amp;quot;], word2 = [&amp;quot;a&amp;quot;, &amp;quot;bc&amp;quot;] Output: true Explanation: word1 represents string &amp;quot;ab&amp;quot; + &amp;quot;c&amp;quot; -&amp;gt; &amp;quot;abc&amp;quot; word2 represents string &amp;quot;a&amp;quot; + &amp;quot;bc&amp;quot; -&amp;gt; &amp;quot;abc&amp;quot; The strings are the same, so return true.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1663.Smallest-String-With-A-Given-Numeric-Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1663.Smallest-String-With-A-Given-Numeric-Value/</guid>
      <description>1663. Smallest String With A Given Numeric Value #  题目 #  The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.
The numeric value of a string consisting of lowercase characters is defined as the sum of its characters&#39; numeric values.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1664.Ways-to-Make-a-Fair-Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1664.Ways-to-Make-a-Fair-Array/</guid>
      <description>1664. Ways to Make a Fair Array #  题目 #  You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.
For example, if nums = [6,1,7,4,1]:
 Choosing to remove index 1 results in nums = [6,7,4,1]. Choosing to remove index 2 results in nums = [6,1,4,1]. Choosing to remove index 4 results in nums = [6,1,7,4].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/1665.Minimum-Initial-Energy-to-Finish-Tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/1665.Minimum-Initial-Energy-to-Finish-Tasks/</guid>
      <description>1665. Minimum Initial Energy to Finish Tasks #  题目 #  You are given an array tasks where tasks[i] = [actuali, minimumi]:
 actuali is the actual amount of energy you spend to finish the ith task. minimumi is the minimum amount of energy you require to begin the ith task.  For example, if the task is [10, 12] and your current energy is 11, you cannot start this task.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.02.02.Kth-Node-From-End-Of-List-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.02.02.Kth-Node-From-End-Of-List-Lcci/</guid>
      <description>面试题 02.02. 返回倒数第 k 个节点 #  Difficulty: 简单
实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
**注意：**本题相对原题稍作改动
示例：
输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出： 4 说明：
给定的 k 保证是有效的。
题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int kthToLast(ListNode head, int k) { int length = 0; ListNode temp = head; while (temp !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.02.03.Delete-Middle-Node-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.02.03.Delete-Middle-Node-Lcci/</guid>
      <description>面试题 02.03. 删除中间节点 #  Difficulty: 简单
实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。
示例：
输入：单向链表a-&amp;gt;b-&amp;gt;c-&amp;gt;d-&amp;gt;e-&amp;gt;f中的节点c 结果：不返回任何数据，但该链表变为a-&amp;gt;b-&amp;gt;d-&amp;gt;e-&amp;gt;f 题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 复杂度分析
  时间复杂度：O(1)。
  空间复杂度：O(1)。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.03.List-Of-Depth-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.03.List-Of-Depth-Lcci/</guid>
      <description>面试题 04.03. 特定深度节点链表 #  Difficulty: 中等
给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。
示例：
输入：[1,2,3,4,5,null,7,8] 1 / \ 2 3 / \ \ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]] 题解 #  题解一：BFS 二叉树层序遍历（Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.05.Legal-Binary-Search-Tree-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.05.Legal-Binary-Search-Tree-Lcci/</guid>
      <description>面试题 04.05. 合法二叉搜索树 #  Difficulty: 中等
实现一个函数，检查一棵二叉树是否为二叉搜索树。
示例 1:
输入: 2 / \ 1 3输出: true 示例 2:
输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 题解 #  题解一：BSF 遍历（Stack 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isValidBST(TreeNode root) { Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;TreeNode&amp;gt;(); Integer currValue = null; TreeNode curr = root; while (curr !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.12.Paths-With-Sum-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.12.Paths-With-Sum-Lcci/</guid>
      <description>面试题 04.12. 求和路径 #  Difficulty: 中等
给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
示例:
给定如下二叉树，以及目标和 sum = 22，
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7] 提示：
 节点总数 &amp;lt;= 10000  题解 #  题解一：BSF + DFS（BSF 使用 Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int result; public int pathSum(TreeNode root, int sum) { if (root == null) { return 0; } Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.17.Find-Majority-Element-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.04.17.Find-Majority-Element-Lcci/</guid>
      <description>面试题 17.10. 主要元素 #  Difficulty: 简单
数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。
示例 1：
输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2：
输入：[3,2] 输出：-1 示例 3：
输入：[2,2,1,1,1,2,2] 输出：2 说明：
你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？
题解 #  题解一：线性法 + 哈希 #  class Solution { public int majorityElement(int[] nums) { int length = nums.length; Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; length; i++) { Integer count = map.getOrDefault(nums[i], 0); if (count + 1 &amp;gt; length / 2) { return nums[i]; } else { map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.16.19.Pond-Sizes-Lcci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Interview.16.19.Pond-Sizes-Lcci/</guid>
      <description>面试题 16.19. 水域大小 #  Difficulty: 中等
你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。
示例：
输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：
 0 &amp;lt; len(land) &amp;lt;= 1000 0 &amp;lt; len(land[i]) &amp;lt;= 1000  题解 #  题解一：DFS（广度优先搜索） #  class Solution { public int[] pondSizes(int[][] land) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); if(land.length == 0) { return new int [0]; } int temp = 0; for(int i = 0; i &amp;lt; land.length; i++) { for(int j = 0; j &amp;lt; land[0].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.22.Lian-Biao-Zhong-Dao-Shu-Di-Kge-Jie-Dian-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.22.Lian-Biao-Zhong-Dao-Shu-Di-Kge-Jie-Dian-Lcof/</guid>
      <description>剑指 Offer 22. 链表中倒数第k个节点 #  Difficulty: 简单
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回链表 4-&amp;gt;5. 题解 #  题解一：两次遍历 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode getKthFromEnd(ListNode head, int k) { int length = 0; ListNode temp = head; while (temp !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.26.Shu-De-Zi-Jie-Gou-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.26.Shu-De-Zi-Jie-Gou-Lcof/</guid>
      <description>剑指 Offer 26. 树的子结构 #  Difficulty: 中等
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如:
给定的树 A:
 3 / \ 4 5 / \ 1 2
给定的树 B：
 4 / 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：
输入：A = [1,2,3], B = [3,1] 输出：false 示例 2：
输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 10000
题解 #  题解一： #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.27.Er-Cha-Shu-De-Jing-Xiang-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.27.Er-Cha-Shu-De-Jing-Xiang-Lcof/</guid>
      <description>剑指 Offer 27.二叉树的镜像 #  Difficulty: 简单
请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
 4 / \ 2 7 / \ / \ 1 3 6 9` 镜像输出：
 4 / \ 7 2 / \ / \ 9 6 3 1 示例 1：
输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：
题解 #  DFS #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mirrorTree(TreeNode root) { if (root == null) { return null; } TreeNode temp = root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.28.Dui-Cheng-De-Er-Cha-Shu-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.28.Dui-Cheng-De-Er-Cha-Shu-Lcof/</guid>
      <description>剑指 Offer 28. 对称的二叉树 #  Difficulty: 简单
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：
题解 #  题解一：递归 #  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.32.II.Cong-Shang-Dao-Xia-Da-Yin-Er-Cha-Shu-II-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.32.II.Cong-Shang-Dao-Xia-Da-Yin-Er-Cha-Shu-II-Lcof/</guid>
      <description>剑指 Offer 32 - II. 从上到下打印二叉树 II #  Difficulty: 简单
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [9,20], [15,7] ] 提示：
 节点总数 &amp;lt;= 1000  注意：本题与主站 102 题相同：
题解 #  解法一：BFS 广度优先遍历（Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; allResult = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return allResult; } Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.54.Er-Cha-Sou-Suo-Shu-De-Di-Kda-Jie-Dian-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.54.Er-Cha-Sou-Suo-Shu-De-Di-Kda-Jie-Dian-Lcof/</guid>
      <description>剑指 Offer 54. 二叉搜索树的第k大节点 #  Difficulty: 简单
给定一棵二叉搜索树，请找出其中第k大的节点。
示例 1:
输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 输出: 4 示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 输出: 4 限制：
1 ≤ k ≤ 二叉搜索树元素个数
题解 #  题解一：递归方法（二叉树的中序遍历变型（右根左遍历）） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int kthLargest(TreeNode root, int k) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); inOrder(root, list); return list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.55.I.Er-Cha-Shu-De-Shen-Du-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.55.I.Er-Cha-Shu-De-Shen-Du-Lcof/</guid>
      <description>剑指 Offer 55 - I. 二叉树的深度 #  Difficulty: 简单
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
3 / \  9 20 / \  15 7 返回它的最大深度 3 。
提示：
 节点总数 &amp;lt;= 10000  注意：本题与主站 104 题相同：
题解 #  题解一：DFS（广度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { if(root == null) { return 0; } return Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.55.II.Ping-Heng-Er-Cha-Shu-Lcof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dongzl.github.io/leetcode-java/04_Leetcode/Offer.55.II.Ping-Heng-Er-Cha-Shu-Lcof/</guid>
      <description>剑指 Offer 55 - II. 平衡二叉树 #  Difficulty: 简单
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1:
给定二叉树 [3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7 返回 true 。
示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
 1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：
 1 &amp;lt;= 树的结点个数 &amp;lt;= 10000  注意：本题与主站 110 题相同：
题解 #  题解一： #  /** * Definition for a binary tree node.</description>
    </item>
    
  </channel>
</rss>
