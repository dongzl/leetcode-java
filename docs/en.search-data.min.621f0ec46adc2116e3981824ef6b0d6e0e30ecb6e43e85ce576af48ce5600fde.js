'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/leetcode-java/docs/example/','title':"Example Site",'section':"Docs",'content':"Introduction #  Ferre hinnitibus erat accipitrem dixi Troiae tollens #  Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad #  Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol #  Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque #  Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"});index.add({'id':1,'href':'/leetcode-java/docs/example/table-of-contents/with-toc/','title':"With ToC",'section':"Table of Contents",'content':"Caput vino delphine in tamen vias #  Cognita laeva illo fracta #  Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere #  Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit #  Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua #  Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta #  Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"});index.add({'id':2,'href':'/leetcode-java/docs/example/table-of-contents/without-toc/','title':"Without ToC",'section':"Table of Contents",'content':"At me ipso nepotibus nunc celebratior genus #  Tanto oblite #  Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius #  Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae #  Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"});index.add({'id':3,'href':'/leetcode-java/docs/example/table-of-contents/','title':"Table of Contents",'section':"Example Site",'content':"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':4,'href':'/leetcode-java/docs/example/collapsed/','title':"Collapsed",'section':"Example Site",'content':"Collapsed Level of Menu #  Cognita laeva illo fracta #  Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':6,'href':'/leetcode-java/04_Leetcode/0001.Two-Sum/','title':"0001. Two Sum",'section':"第四章",'content':"1. 两数之和 #  Difficulty: 简单\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题解 #  解法一：暴力求解 #  class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; for(int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { if ((nums[i] + nums[j]) == target) { result[0] = i; result[1] = j; break; } } } return result; } }  时间复杂度：O(n2) 空间复杂度：O(1)  解法二：哈希表 #  class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int temp = target - nums[i]; if (map.containsKey(temp)) { return new int[]{map.get(temp), i}; } map.put(nums[i], i); } return new int[]{}; } }  时间复杂度：O(n) 空间复杂度：O(n)  "});index.add({'id':7,'href':'/leetcode-java/04_Leetcode/0002.Add-Two-Numbers/','title':"0002. Add Two Numbers",'section':"第四章",'content':"2. 两数相加 #  Difficulty: 中等\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) 输出：7 -\u0026gt; 0 -\u0026gt; 8 原因：342 + 465 = 807 题解 #  解法一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode first = l1; ListNode second = l2; ListNode current = dummyHead; int carry = 0; while (first != null || second != null) { int firstVal = (first != null) ? first.val : 0; int secondVal = (second != null) ? second.val : 0; int sum = carry + firstVal + secondVal; carry = sum / 10; current.next = new ListNode(sum % 10); current = current.next; first = first != null ? first.next : null; second = second != null ? second.next : null; } if (carry \u0026gt; 0) { current.next = new ListNode(carry); } return dummyHead.next; } } "});index.add({'id':8,'href':'/leetcode-java/04_Leetcode/0003.Longest-Substring-Without-Repeating-Characters/','title':"0003. Longest Substring Without Repeating Characters",'section':"第四章",'content':"3. Longest Substring Without Repeating Characters #  题目 #  Given a string, find the length of the longest substring without repeating characters.\nExample 1:\n Input: \u0026quot;abcabcbb\u0026quot; Output: 3 Explanation: The answer is \u0026quot;abc\u0026quot;, with the length of 3. Example 2:\n Input: \u0026quot;bbbbb\u0026quot; Output: 1 Explanation: The answer is \u0026quot;b\u0026quot;, with the length of 1. Example 3:\n Input: \u0026quot;pwwkew\u0026quot; Output: 3 Explanation: The answer is \u0026quot;wke\u0026quot;, with the length of 3. Note that the answer must be a substring, \u0026quot;pwke\u0026quot; is a subsequence and not a substring. 题目大意 #  在一个字符串重寻找没有重复字母的最长子串。\n解题思路 #  这一题和第 438 题，第 3 题，第 76 题，第 567 题类似，用的思想都是\u0026quot;滑动窗口\u0026quot;。\n滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。\n代码 #  package leetcode // 解法一 位图 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } var bitSet [256]bool result, left, right := 0, 0, 0 for left \u0026lt; len(s) { // 右侧字符对应的 bitSet 被标记 true，说明此字符在 X 位置重复，需要左侧向前移动，直到将X标记为 false \tif bitSet[s[right]] { bitSet[s[left]] = false left++ } else { bitSet[s[right]] = true right++ } if result \u0026lt; right-left { result = right - left } if left+result \u0026gt;= len(s) || right \u0026gt;= len(s) { break } } return result } // 解法二 滑动窗口 func lengthOfLongestSubstring_(s string) int { if len(s) == 0 { return 0 } var freq [256]int result, left, right := 0, 0, -1 for left \u0026lt; len(s) { if right+1 \u0026lt; len(s) \u0026amp;\u0026amp; freq[s[right+1]-\u0026#39;a\u0026#39;] == 0 { freq[s[right+1]-\u0026#39;a\u0026#39;]++ right++ } else { freq[s[left]-\u0026#39;a\u0026#39;]-- left++ } result = max(result, right-left+1) } return result } func max(a int, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':9,'href':'/leetcode-java/04_Leetcode/0004.Median-of-Two-Sorted-Arrays/','title':"0004. Median of Two Sorted Arrays",'section':"第四章",'content':"4. Median of Two Sorted Arrays #  题目 #  There are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty.\nExample 1:\nnums1 = [1, 3] nums2 = [2] The median is 2.0  Example 2:\nnums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5  题目大意 #  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n解题思路 #    给出两个有序数组，要求找出这两个数组合并以后的有序数组中的中位数。要求时间复杂度为 O(log (m+n))。\n  这一题最容易想到的办法是把两个数组合并，然后取出中位数。但是合并有序数组的操作是 O(max(n,m)) 的，不符合题意。看到题目给的 log 的时间复杂度，很容易联想到二分搜索。\n  由于要找到最终合并以后数组的中位数，两个数组的总大小也知道，所以中间这个位置也是知道的。只需要二分搜索一个数组中切分的位置，另一个数组中切分的位置也能得到。为了使得时间复杂度最小，所以二分搜索两个数组中长度较小的那个数组。\n  关键的问题是如何切分数组 1 和数组 2 。其实就是如何切分数组 1 。先随便二分产生一个 midA，切分的线何时算满足了中位数的条件呢？即，线左边的数都小于右边的数，即，nums1[midA-1] ≤ nums2[midB] \u0026amp;\u0026amp; nums2[midB-1] ≤ nums1[midA] 。如果这些条件都不满足，切分线就需要调整。如果 nums1[midA] \u0026lt; nums2[midB-1]，说明 midA 这条线划分出来左边的数小了，切分线应该右移；如果 nums1[midA-1] \u0026gt; nums2[midB]，说明 midA 这条线划分出来左边的数大了，切分线应该左移。经过多次调整以后，切分线总能找到满足条件的解。\n  假设现在找到了切分的两条线了，数组 1 在切分线两边的下标分别是 midA - 1 和 midA。数组 2 在切分线两边的下标分别是 midB - 1 和 midB。最终合并成最终数组，如果数组长度是奇数，那么中位数就是 max(nums1[midA-1], nums2[midB-1])。如果数组长度是偶数，那么中间位置的两个数依次是：max(nums1[midA-1], nums2[midB-1]) 和 min(nums1[midA], nums2[midB])，那么中位数就是 (max(nums1[midA-1], nums2[midB-1]) + min(nums1[midA], nums2[midB])) / 2。图示见下图：\n   代码 #  package leetcode func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { // 假设 nums1 的长度小 \tif len(nums1) \u0026gt; len(nums2) { return findMedianSortedArrays(nums2, nums1) } low, high, k, nums1Mid, nums2Mid := 0, len(nums1), (len(nums1)+len(nums2)+1)\u0026gt;\u0026gt;1, 0, 0 for low \u0026lt;= high { // nums1: ……………… nums1[nums1Mid-1] | nums1[nums1Mid] …………………… \t// nums2: ……………… nums2[nums2Mid-1] | nums2[nums2Mid] …………………… \tnums1Mid = low + (high-low)\u0026gt;\u0026gt;1 // 分界限右侧是 mid，分界线左侧是 mid - 1 \tnums2Mid = k - nums1Mid if nums1Mid \u0026gt; 0 \u0026amp;\u0026amp; nums1[nums1Mid-1] \u0026gt; nums2[nums2Mid] { // nums1 中的分界线划多了，要向左边移动 \thigh = nums1Mid - 1 } else if nums1Mid != len(nums1) \u0026amp;\u0026amp; nums1[nums1Mid] \u0026lt; nums2[nums2Mid-1] { // nums1 中的分界线划少了，要向右边移动 \tlow = nums1Mid + 1 } else { // 找到合适的划分了，需要输出最终结果了 \t// 分为奇数偶数 2 种情况 \tbreak } } midLeft, midRight := 0, 0 if nums1Mid == 0 { midLeft = nums2[nums2Mid-1] } else if nums2Mid == 0 { midLeft = nums1[nums1Mid-1] } else { midLeft = max(nums1[nums1Mid-1], nums2[nums2Mid-1]) } if (len(nums1)+len(nums2))\u0026amp;1 == 1 { return float64(midLeft) } if nums1Mid == len(nums1) { midRight = nums2[nums2Mid] } else if nums2Mid == len(nums2) { midRight = nums1[nums1Mid] } else { midRight = min(nums1[nums1Mid], nums2[nums2Mid]) } return float64(midLeft+midRight) / 2 } "});index.add({'id':10,'href':'/leetcode-java/04_Leetcode/0007.Reverse-Integer/','title':"0007. Reverse Integer",'section':"第四章",'content':"7. Reverse Integer #  题目 #  Given a 32-bit signed integer, reverse digits of an integer.\nExample 1:\nInput: 123 Output: 321  Example 2:\nInput: -123 Output: -321  Example 3:\nInput: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n题目大意 #  给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n解题思路 #   这一题是简单题，要求反转 10 进制数。类似的题目有第 190 题。 这一题只需要注意一点，反转以后的数字要求在 [−2^31, 2^31 − 1]范围内，超过这个范围的数字都要输出 0 。  代码 #  package leetcode func reverse7(x int) int { tmp := 0 for x != 0 { tmp = tmp*10 + x%10 x = x / 10 } if tmp \u0026gt; 1\u0026lt;\u0026lt;31-1 || tmp \u0026lt; -(1\u0026lt;\u0026lt;31) { return 0 } return tmp } "});index.add({'id':11,'href':'/leetcode-java/04_Leetcode/0009.Palindrome-Number/','title':"0009. Palindrome Number",'section':"第四章",'content':"9. Palindrome Number #  题目 #  Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\nExample 1:\nInput: 121 Output: true Example 2:\nInput: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:\nInput: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up:\nCoud you solve it without converting the integer to a string?\n题目大意 #  判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n解题思路 #   判断一个整数是不是回文数。 简单题。注意会有负数的情况，负数，个位数，10 都不是回文数。其他的整数再按照回文的规则判断。  代码 #  package leetcode import \u0026#34;strconv\u0026#34; func isPalindrome(x int) bool { if x \u0026lt; 0 { return false } if x \u0026lt; 10 { return true } s := strconv.Itoa(x) length := len(s) for i := 0; i \u0026lt;= length/2; i++ { if s[i] != s[length-1-i] { return false } } return true } "});index.add({'id':12,'href':'/leetcode-java/04_Leetcode/0011.Container-With-Most-Water/','title':"0011. Container With Most Water",'section':"第四章",'content':"11. Container With Most Water #  题目 #  Given n non-negative integers a1, a2, \u0026hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote: You may not slant the container and n is at least 2.\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\nExample 1:\n Input: [1,8,6,2,5,4,8,3,7] Output: 49 题目大意 #  给出一个非负整数数组 a1，a2，a3，…… an，每个整数标识一个竖立在坐标轴 x 位置的一堵高度为 ai 的墙，选择两堵墙，和 x 轴构成的容器可以容纳最多的水。\n解题思路 #  这一题也是对撞指针的思路。首尾分别 2 个指针，每次移动以后都分别判断长宽的乘积是否最大。\n代码 #  package leetcode func maxArea(height []int) int { max, start, end := 0, 0, len(height)-1 for start \u0026lt; end { width := end - start high := 0 if height[start] \u0026lt; height[end] { high = height[start] start++ } else { high = height[end] end-- } temp := width * high if temp \u0026gt; max { max = temp } } return max } "});index.add({'id':13,'href':'/leetcode-java/04_Leetcode/0013.Roman-to-Integer/','title':"0013. Roman to Integer",'section':"第四章",'content':"13. Roman to Integer #  题目 #  Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one\u0026rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\nInput: \u0026quot;III\u0026quot; Output: 3 Example 2:\nInput: \u0026quot;IV\u0026quot; Output: 4 Example 3:\nInput: \u0026quot;IX\u0026quot; Output: 9 Example 4:\nInput: \u0026quot;LVIII\u0026quot; Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5:\nInput: \u0026quot;MCMXCIV\u0026quot; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 题目大意 #  罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n解题思路 #   给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 简单题。按照题目中罗马数字的字符数值，计算出对应罗马数字的十进制数即可。  代码 #  package leetcode var roman = map[string]int{ \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, } func romanToInt(s string) int { if s == \u0026#34;\u0026#34; { return 0 } num, lastint, total := 0, 0, 0 for i := 0; i \u0026lt; len(s); i++ { char := s[len(s)-(i+1) : len(s)-i] num = roman[char] if num \u0026lt; lastint { total = total - num } else { total = total + num } lastint = num } return total } "});index.add({'id':14,'href':'/leetcode-java/04_Leetcode/0015.3Sum/','title':"0015.3 Sum",'section':"第四章",'content':"15. 3Sum #  题目 #  Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nExample:\n Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 题目大意 #  给定一个数组，要求在这个数组中找出 3 个数之和为 0 的所有组合。\n解题思路 #  用 map 提前计算好任意 2 个数字之和，保存起来，可以将时间复杂度降到 O(n^2)。这一题比较麻烦的一点在于，最后输出解的时候，要求输出不重复的解。数组中同一个数字可能出现多次，同一个数字也可能使用多次，但是最后输出解的时候，不能重复。例如 [-1，-1，2] 和 [2, -1, -1]、[-1, 2, -1] 这 3 个解是重复的，即使 -1 可能出现 100 次，每次使用的 -1 的数组下标都是不同的。\n这里就需要去重和排序了。map 记录每个数字出现的次数，然后对 map 的 key 数组进行排序，最后在这个排序以后的数组里面扫，找到另外 2 个数字能和自己组成 0 的组合。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func threeSum(nums []int) [][]int { res := [][]int{} counter := map[int]int{} for _, value := range nums { counter[value]++ } uniqNums := []int{} for key := range counter { uniqNums = append(uniqNums, key) } sort.Ints(uniqNums) for i := 0; i \u0026lt; len(uniqNums); i++ { if (uniqNums[i]*3 == 0) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt;= 3 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[i]}) } for j := i + 1; j \u0026lt; len(uniqNums); j++ { if (uniqNums[i]*2+uniqNums[j] == 0) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[j]}) } if (uniqNums[j]*2+uniqNums[i] == 0) \u0026amp;\u0026amp; counter[uniqNums[j]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[j], uniqNums[j]}) } c := 0 - uniqNums[i] - uniqNums[j] if c \u0026gt; uniqNums[j] \u0026amp;\u0026amp; counter[c] \u0026gt; 0 { res = append(res, []int{uniqNums[i], uniqNums[j], c}) } } } return res } "});index.add({'id':15,'href':'/leetcode-java/04_Leetcode/0016.3Sum-Closest/','title':"0016.3 Sum Closest",'section':"第四章",'content':"16. 3Sum Closest #  题目 #  Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nExample:\n Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 题目大意 #  给定一个数组，要求在这个数组中找出 3 个数之和离 target 最近。\n解题思路 #  这一题看似和第 15 题和第 18 题很像，都是求 3 或者 4 个数之和的问题，但是这一题的做法和 15，18 题完全不同。\n这一题的解法是用两个指针夹逼的方法。先对数组进行排序，i 从头开始往后面扫。这里同样需要注意数组中存在多个重复数字的问题。具体处理方法很多，可以用 map 计数去重。这里笔者简单的处理，i 在循环的时候和前一个数进行比较，如果相等，i 继续往后移，直到移到下一个和前一个数字不同的位置。j，k 两个指针开始一前一后夹逼。j 为 i 的下一个数字，k 为数组最后一个数字，由于经过排序，所以 k 的数字最大。j 往后移动，k 往前移动，逐渐夹逼出最接近 target 的值。\n这道题还可以用暴力解法，三层循环找到距离 target 最近的组合。具体见代码。\n代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) // 解法一 O(n^2) func threeSumClosest(nums []int, target int) int { n, res, diff := len(nums), 0, math.MaxInt32 if n \u0026gt; 2 { sort.Ints(nums) for i := 0; i \u0026lt; n-2; i++ { for j, k := i+1, n-1; j \u0026lt; k; { sum := nums[i] + nums[j] + nums[k] if abs(sum-target) \u0026lt; diff { res, diff = sum, abs(sum-target) } if sum == target { return res } else if sum \u0026gt; target { k-- } else { j++ } } } } return res } // 解法二 暴力解法 O(n^3) func threeSumClosest1(nums []int, target int) int { res, difference := 0, math.MaxInt16 for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { for k := j + 1; k \u0026lt; len(nums); k++ { if abs(nums[i]+nums[j]+nums[k]-target) \u0026lt; difference { difference = abs(nums[i] + nums[j] + nums[k] - target) res = nums[i] + nums[j] + nums[k] } } } } return res } func abs(a int) int { if a \u0026gt; 0 { return a } return -a } "});index.add({'id':16,'href':'/leetcode-java/04_Leetcode/0017.Letter-Combinations-of-a-Phone-Number/','title':"0017. Letter Combinations of a Phone Number",'section':"第四章",'content':"17. Letter Combinations of a Phone Number #  题目 #  Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n Example:\n Input: \u0026quot;23\u0026quot; Output: [\u0026quot;ad\u0026quot;, \u0026quot;ae\u0026quot;, \u0026quot;af\u0026quot;, \u0026quot;bd\u0026quot;, \u0026quot;be\u0026quot;, \u0026quot;bf\u0026quot;, \u0026quot;cd\u0026quot;, \u0026quot;ce\u0026quot;, \u0026quot;cf\u0026quot;]. Note:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\n题目大意 #  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n解题思路 #   DFS 递归深搜即可  代码 #  package leetcode var ( letterMap = []string{ \u0026#34; \u0026#34;, //0 \t\u0026#34;\u0026#34;, //1 \t\u0026#34;abc\u0026#34;, //2 \t\u0026#34;def\u0026#34;, //3 \t\u0026#34;ghi\u0026#34;, //4 \t\u0026#34;jkl\u0026#34;, //5 \t\u0026#34;mno\u0026#34;, //6 \t\u0026#34;pqrs\u0026#34;, //7 \t\u0026#34;tuv\u0026#34;, //8 \t\u0026#34;wxyz\u0026#34;, //9 \t} res = []string{} final = 0 ) // 解法一 DFS func letterCombinations(digits string) []string { if digits == \u0026#34;\u0026#34; { return []string{} } res = []string{} findCombination(\u0026amp;digits, 0, \u0026#34;\u0026#34;) return res } func findCombination(digits *string, index int, s string) { if index == len(*digits) { res = append(res, s) return } num := (*digits)[index] letter := letterMap[num-\u0026#39;0\u0026#39;] for i := 0; i \u0026lt; len(letter); i++ { findCombination(digits, index+1, s+string(letter[i])) } return } // 解法二 非递归 func letterCombinations_(digits string) []string { if digits == \u0026#34;\u0026#34; { return []string{} } index := digits[0] - \u0026#39;0\u0026#39; letter := letterMap[index] tmp := []string{} for i := 0; i \u0026lt; len(letter); i++ { if len(res) == 0 { res = append(res, \u0026#34;\u0026#34;) } for j := 0; j \u0026lt; len(res); j++ { tmp = append(tmp, res[j]+string(letter[i])) } } res = tmp final++ letterCombinations(digits[1:]) final-- if final == 0 { tmp = res res = []string{} } return tmp } // 解法三 回溯（参考回溯模板，类似DFS） var result []string var dict = map[string][]string{ \u0026#34;2\u0026#34; : []string{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;}, \u0026#34;3\u0026#34; : []string{\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;}, \u0026#34;4\u0026#34; : []string{\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;}, \u0026#34;5\u0026#34; : []string{\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;}, \u0026#34;6\u0026#34; : []string{\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;7\u0026#34; : []string{\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;}, \u0026#34;8\u0026#34; : []string{\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;}, \u0026#34;9\u0026#34; : []string{\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;}, } func letterCombinationsBT(digits string) []string { result = []string{} if digits == \u0026#34;\u0026#34; { return result } letterFunc(\u0026#34;\u0026#34;, digits) return result } func letterFunc(res string, digits string) { if digits == \u0026#34;\u0026#34; { result = append(result, res) return } k := digits[0:1] digits = digits[1:] for i := 0; i \u0026lt; len(dict[k]); i++ { res += dict[k][i] letterFunc(res, digits) res = res[0 : len(res)-1] } } "});index.add({'id':17,'href':'/leetcode-java/04_Leetcode/0018.4Sum/','title':"0018.4 Sum",'section':"第四章",'content':"18. 4Sum #  题目 #  Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote:\nThe solution set must not contain duplicate quadruplets.\nExample:\n Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 题目大意 #  给定一个数组，要求在这个数组中找出 4 个数之和为 0 的所有组合。\n解题思路 #  用 map 提前计算好任意 3 个数字之和，保存起来，可以将时间复杂度降到 O(n^3)。这一题比较麻烦的一点在于，最后输出解的时候，要求输出不重复的解。数组中同一个数字可能出现多次，同一个数字也可能使用多次，但是最后输出解的时候，不能重复。例如 [-1，1，2, -2] 和 [2, -1, -2, 1]、[-2, 2, -1, 1] 这 3 个解是重复的，即使 -1, -2 可能出现 100 次，每次使用的 -1, -2 的数组下标都是不同的。\n这一题是第 15 题的升级版，思路都是完全一致的。这里就需要去重和排序了。map 记录每个数字出现的次数，然后对 map 的 key 数组进行排序，最后在这个排序以后的数组里面扫，找到另外 3 个数字能和自己组成 0 的组合。\n第 15 题和第 18 题的解法一致。\n代码 #  package leetcode import \u0026#34;sort\u0026#34; func fourSum(nums []int, target int) [][]int { res := [][]int{} counter := map[int]int{} for _, value := range nums { counter[value]++ } uniqNums := []int{} for key := range counter { uniqNums = append(uniqNums, key) } sort.Ints(uniqNums) for i := 0; i \u0026lt; len(uniqNums); i++ { if (uniqNums[i]*4 == target) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt;= 4 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[i], uniqNums[i]}) } for j := i + 1; j \u0026lt; len(uniqNums); j++ { if (uniqNums[i]*3+uniqNums[j] == target) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt; 2 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[i], uniqNums[j]}) } if (uniqNums[j]*3+uniqNums[i] == target) \u0026amp;\u0026amp; counter[uniqNums[j]] \u0026gt; 2 { res = append(res, []int{uniqNums[i], uniqNums[j], uniqNums[j], uniqNums[j]}) } if (uniqNums[j]*2+uniqNums[i]*2 == target) \u0026amp;\u0026amp; counter[uniqNums[j]] \u0026gt; 1 \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[j], uniqNums[j]}) } for k := j + 1; k \u0026lt; len(uniqNums); k++ { if (uniqNums[i]*2+uniqNums[j]+uniqNums[k] == target) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[i], uniqNums[j], uniqNums[k]}) } if (uniqNums[j]*2+uniqNums[i]+uniqNums[k] == target) \u0026amp;\u0026amp; counter[uniqNums[j]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[j], uniqNums[j], uniqNums[k]}) } if (uniqNums[k]*2+uniqNums[i]+uniqNums[j] == target) \u0026amp;\u0026amp; counter[uniqNums[k]] \u0026gt; 1 { res = append(res, []int{uniqNums[i], uniqNums[j], uniqNums[k], uniqNums[k]}) } c := target - uniqNums[i] - uniqNums[j] - uniqNums[k] if c \u0026gt; uniqNums[k] \u0026amp;\u0026amp; counter[c] \u0026gt; 0 { res = append(res, []int{uniqNums[i], uniqNums[j], uniqNums[k], c}) } } } } return res } "});index.add({'id':18,'href':'/leetcode-java/04_Leetcode/0019.Remove-Nth-Node-From-End-of-List/','title':"0019. Remove Nth Node From End of List",'section':"第四章",'content':"19. Remove Nth Node From End of List #  题目 #  Given a linked list, remove the n-th node from the end of list and return its head.\nExample:\n Given linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5. 题目大意 #  删除链表中倒数第 n 个结点。\n解题思路 #  这道题比较简单，先循环一次拿到链表的总长度，然后循环到要删除的结点的前一个结点开始删除操作。需要注意的一个特例是，有可能要删除头结点，要单独处理。\n这道题有一种特别简单的解法。设置 2 个指针，一个指针距离前一个指针 n 个距离。同时移动 2 个指针，2 个指针都移动相同的距离。当一个指针移动到了终点，那么前一个指针就是倒数第 n 个节点了。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 func removeNthFromEnd(head *ListNode, n int) *ListNode { var fast, slow *ListNode fast = head slow = head for i := 0; i \u0026lt; n; i++ { fast = fast.Next } if fast == nil { head = head.Next return head } for fast.Next != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return head } // 解法二 func removeNthFromEnd1(head *ListNode, n int) *ListNode { if head == nil { return nil } if n \u0026lt;= 0 { return head } current := head len := 0 for current != nil { len++ current = current.Next } if n \u0026gt; len { return head } if n == len { current := head head = head.Next current.Next = nil return head } current = head i := 0 for current != nil { if i == len-n-1 { deleteNode := current.Next current.Next = current.Next.Next deleteNode.Next = nil break } i++ current = current.Next } return head } "});index.add({'id':19,'href':'/leetcode-java/04_Leetcode/0020.Valid-Parentheses/','title':"0020. Valid Parentheses",'section':"第四章",'content':"20. Valid Parentheses #  题目 #  Given a string containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.\nExample 1:\n Input: \u0026quot;()\u0026quot; Output: true Example 2:\n Input: \u0026quot;()[]{}\u0026quot; Output: true Example 3:\n Input: \u0026quot;(]\u0026quot; Output: false Example 4:\n Input: \u0026quot;([)]\u0026quot; Output: false Example 5:\n Input: \u0026quot;{[]}\u0026quot; Output: true 题目大意 #  括号匹配问题。\n解题思路 #  遇到左括号就进栈push，遇到右括号并且栈顶为与之对应的左括号，就把栈顶元素出栈。最后看栈里面还有没有其他元素，如果为空，即匹配。\n需要注意，空字符串是满足括号匹配的，即输出 true。\n代码 #  package leetcode func isValid(s string) bool { // 空字符串直接返回 true \tif len(s) == 0 { return true } stack := make([]rune, 0) for _, v := range s { if (v == \u0026#39;[\u0026#39;) || (v == \u0026#39;(\u0026#39;) || (v == \u0026#39;{\u0026#39;) { stack = append(stack, v) } else if ((v == \u0026#39;]\u0026#39;) \u0026amp;\u0026amp; len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || ((v == \u0026#39;)\u0026#39;) \u0026amp;\u0026amp; len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || ((v == \u0026#39;}\u0026#39;) \u0026amp;\u0026amp; len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { return false } } return len(stack) == 0 } "});index.add({'id':20,'href':'/leetcode-java/04_Leetcode/0021.Merge-Two-Sorted-Lists/','title':"0021. Merge Two Sorted Lists",'section':"第四章",'content':"21. Merge Two Sorted Lists #  题目 #  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\nExample:\n Input: 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 题目大意 #  合并 2 个有序链表\n解题思路 #  按照题意做即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } l2.Next = mergeTwoLists(l1, l2.Next) return l2 } "});index.add({'id':21,'href':'/leetcode-java/04_Leetcode/0022.Generate-Parentheses/','title':"0022. Generate Parentheses",'section':"第四章",'content':"22. Generate Parentheses #  题目 #  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[ \u0026quot;((()))\u0026quot;, \u0026quot;(()())\u0026quot;, \u0026quot;(())()\u0026quot;, \u0026quot;()(())\u0026quot;, \u0026quot;()()()\u0026quot; ]  题目大意 #  给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n解题思路 #   这道题乍一看需要判断括号是否匹配的问题，如果真的判断了，那时间复杂度就到 O(n * 2^n)了，虽然也可以 AC，但是时间复杂度巨高。 这道题实际上不需要判断括号是否匹配的问题。因为在 DFS 回溯的过程中，会让 ( 和 ) 成对的匹配上的。  代码 #  package leetcode func generateParenthesis(n int) []string { if n == 0 { return []string{} } res := []string{} findGenerateParenthesis(n, n, \u0026#34;\u0026#34;, \u0026amp;res) return res } func findGenerateParenthesis(lindex, rindex int, str string, res *[]string) { if lindex == 0 \u0026amp;\u0026amp; rindex == 0 { *res = append(*res, str) return } if lindex \u0026gt; 0 { findGenerateParenthesis(lindex-1, rindex, str+\u0026#34;(\u0026#34;, res) } if rindex \u0026gt; 0 \u0026amp;\u0026amp; lindex \u0026lt; rindex { findGenerateParenthesis(lindex, rindex-1, str+\u0026#34;)\u0026#34;, res) } } "});index.add({'id':22,'href':'/leetcode-java/04_Leetcode/0023.Merge-k-Sorted-Lists/','title':"0023. Merge K Sorted Lists",'section':"第四章",'content':"23. Merge k Sorted Lists #  题目 #  Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\nExample:\n Input: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 题目大意 #  合并 K 个有序链表\n解题思路 #  借助分治的思想，把 K 个有序链表两两合并即可。相当于是第 21 题的加强版。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { length := len(lists) if length \u0026lt; 1 { return nil } if length == 1 { return lists[0] } num := length / 2 left := mergeKLists(lists[:num]) right := mergeKLists(lists[num:]) return mergeTwoLists1(left, right) } func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists1(l1.Next, l2) return l1 } l2.Next = mergeTwoLists1(l1, l2.Next) return l2 } "});index.add({'id':23,'href':'/leetcode-java/04_Leetcode/0024.Swap-Nodes-in-Pairs/','title':"0024. Swap Nodes in Pairs",'section':"第四章",'content':"24. 两两交换链表中的节点 #  Difficulty: 中等\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1：\n 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2：\n输入：head = [] 输出：[] 示例 3：\n输入：head = [1] 输出：[1] 提示：\n 链表中节点的数目在范围 [0, 100] 内 0 \u0026lt;= Node.val \u0026lt;= 100  题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode pre = new ListNode(-1); pre.next = head; ListNode temp = pre; while(temp.next != null \u0026amp;\u0026amp; temp.next.next != null) { ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; end.next = start; temp = start; } return pre.next; } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  题解二：递归求解 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(n)。\n  "});index.add({'id':24,'href':'/leetcode-java/04_Leetcode/0025.Reverse-Nodes-in-k-Group/','title':"0025. Reverse Nodes in K Group",'section':"第四章",'content':"25. Reverse Nodes in k-Group #  题目 #  Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\nExample:\n Given this linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 For k = 2, you should return: 2-\u0026gt;1-\u0026gt;4-\u0026gt;3-\u0026gt;5 For k = 3, you should return: 3-\u0026gt;2-\u0026gt;1-\u0026gt;4-\u0026gt;5 Note:\n Only constant extra memory is allowed. You may not alter the values in the list\u0026rsquo;s nodes, only nodes itself may be changed.  题目大意 #  按照每 K 个元素翻转的方式翻转链表。如果不满足 K 个元素的就不翻转。\n解题思路 #  这一题是 problem 24 的加强版，problem 24 是两两相邻的元素，翻转链表。而 problem 25 要求的是 k 个相邻的元素，翻转链表，problem 相当于是 k = 2 的特殊情况。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { node := head for i := 0; i \u0026lt; k; i++ { if node == nil { return head } node = node.Next } newHead := reverse(head, node) head.Next = reverseKGroup(node, k) return newHead } func reverse(first *ListNode, last *ListNode) *ListNode { prev := last for first != last { tmp := first.Next first.Next = prev prev = first first = tmp } return prev } "});index.add({'id':25,'href':'/leetcode-java/04_Leetcode/0026.Remove-Duplicates-from-Sorted-Array/','title':"0026. Remove Duplicates From Sorted Array",'section':"第四章",'content':"26. Remove Duplicates from Sorted Array #  题目 #  Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2:\n Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. Clarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 题目大意 #  给定一个有序数组 nums，对数组中的元素进行去重，使得原数组中的每个元素只有一个。最后返回去重以后数组的长度值。\n解题思路 #  这道题和第 27 题很像。这道题和第 283 题，第 27 题基本一致，283 题是删除 0，27 题是删除指定元素，这一题是删除重复元素，实质是一样的。\n这里数组的删除并不是真的删除，只是将删除的元素移动到数组后面的空间内，然后返回数组实际剩余的元素个数，OJ 最终判断题目的时候会读取数组剩余个数的元素进行输出。\n代码 #  package leetcode // 解法一 func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } last, finder := 0, 0 for last \u0026lt; len(nums)-1 { for nums[finder] == nums[last] { finder++ if finder == len(nums) { return last + 1 } } nums[last+1] = nums[finder] last++ } return last + 1 } // 解法二 func removeDuplicates1(nums []int) int { if len(nums) == 0 { return 0 } length := len(nums) lastNum := nums[length-1] i := 0 for i = 0; i \u0026lt; length-1; i++ { if nums[i] == lastNum { break } if nums[i+1] == nums[i] { removeElement1(nums, i+1, nums[i]) // fmt.Printf(\u0026#34;此时 num = %v length = %v\\n\u0026#34;, nums, length) \t} } return i + 1 } func removeElement1(nums []int, start, val int) int { if len(nums) == 0 { return 0 } j := start for i := start; i \u0026lt; len(nums); i++ { if nums[i] != val { if i != j { nums[i], nums[j] = nums[j], nums[i] j++ } else { j++ } } } return j } "});index.add({'id':26,'href':'/leetcode-java/04_Leetcode/0027.Remove-Element/','title':"0027. Remove Element",'section':"第四章",'content':"27. Remove Element #  题目 #  Given an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\nExample 1:\n Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2:\n Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 题目大意 #  给定一个数组 nums 和一个数值 val，将数组中所有等于 val 的元素删除，并返回剩余的元素个数。\n解题思路 #  这道题和第 283 题很像。这道题和第 283 题基本一致，283 题是删除 0，这一题是给定的一个 val，实质是一样的。\n这里数组的删除并不是真的删除，只是将删除的元素移动到数组后面的空间内，然后返回数组实际剩余的元素个数，OJ 最终判断题目的时候会读取数组剩余个数的元素进行输出。\n代码 #  package leetcode func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } j := 0 for i := 0; i \u0026lt; len(nums); i++ { if nums[i] != val { if i != j { nums[i], nums[j] = nums[j], nums[i] } j++ } } return j } "});index.add({'id':27,'href':'/leetcode-java/04_Leetcode/0028.Implement-strStr/','title':"0028. Implement Str Str",'section':"第四章",'content':"28. Implement strStr() #  题目 #  Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\n Input: haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot; Output: 2 Example 2:\n Input: haystack = \u0026quot;aaaaa\u0026quot;, needle = \u0026quot;bba\u0026quot; Output: -1 Clarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C\u0026rsquo;s strstr() and Java\u0026rsquo;s indexOf().\n题目大意 #  实现一个查找 substring 的函数。如果在母串中找到了子串，返回子串在母串中出现的下标，如果没有找到，返回 -1，如果子串是空串，则返回 0 。\n解题思路 #  这一题比较简单，直接写即可。\n代码 #  package leetcode import \u0026#34;strings\u0026#34; // 解法一 func strStr(haystack string, needle string) int { for i := 0; ; i++ { for j := 0; ; j++ { if j == len(needle) { return i } if i+j == len(haystack) { return -1 } if needle[j] != haystack[i+j] { break } } } } // 解法二 func strStr1(haystack string, needle string) int { return strings.Index(haystack, needle) } "});index.add({'id':28,'href':'/leetcode-java/04_Leetcode/0029.Divide-Two-Integers/','title':"0029. Divide Two Integers",'section':"第四章",'content':"29. Divide Two Integers #  题目 #  Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero.\nExample 1:\nInput: dividend = 10, divisor = 3 Output: 3  Example 2:\nInput: dividend = 7, divisor = -3 Output: -2  Note:\n Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.  题目大意 #  给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。\n说明:\n 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。  解题思路 #   给出除数和被除数，要求计算除法运算以后的商。注意值的取值范围在 [−2^31, 2^31 − 1] 之中。超过范围的都按边界计算。 这一题可以用二分搜索来做。要求除法运算之后的商，把商作为要搜索的目标。商的取值范围是 [0, dividend]，所以从 0 到被除数之间搜索。利用二分，找到(商 + 1 ) * 除数 \u0026gt; 被除数并且 商 * 除数 ≤ 被除数 或者 (商+1)* 除数 ≥ 被除数并且商 * 除数 \u0026lt; 被除数的时候，就算找到了商，其余情况继续二分即可。最后还要注意符号和题目规定的 Int32 取值范围。 二分的写法常写错的 3 点：  low ≤ high (注意二分循环退出的条件是小于等于) mid = low + (high-low)\u0026raquo;1 (防止溢出) low = mid + 1 ; high = mid - 1 (注意更新 low 和 high 的值，如果更新不对就会死循环)    代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) // 解法一 递归版的二分搜索 func divide(dividend int, divisor int) int { sign, res := -1, 0 // low, high := 0, abs(dividend) \tif dividend == 0 { return 0 } if divisor == 1 { return dividend } if dividend == math.MinInt32 \u0026amp;\u0026amp; divisor == -1 { return math.MaxInt32 } if dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0 { sign = 1 } if dividend \u0026gt; math.MaxInt32 { dividend = math.MaxInt32 } // 如果把递归改成非递归，可以改成下面这段代码 \t// for low \u0026lt;= high { \t// quotient := low + (high-low)\u0026gt;\u0026gt;1 \t// if ((quotient+1)*abs(divisor) \u0026gt; abs(dividend) \u0026amp;\u0026amp; quotient*abs(divisor) \u0026lt;= abs(dividend)) || ((quotient+1)*abs(divisor) \u0026gt;= abs(dividend) \u0026amp;\u0026amp; quotient*abs(divisor) \u0026lt; abs(dividend)) { \t// if (quotient+1)*abs(divisor) == abs(dividend) { \t// res = quotient + 1 \t// break \t// } \t// res = quotient \t// break \t// } \t// if (quotient+1)*abs(divisor) \u0026gt; abs(dividend) \u0026amp;\u0026amp; quotient*abs(divisor) \u0026gt; abs(dividend) { \t// high = quotient - 1 \t// } \t// if (quotient+1)*abs(divisor) \u0026lt; abs(dividend) \u0026amp;\u0026amp; quotient*abs(divisor) \u0026lt; abs(dividend) { \t// low = quotient + 1 \t// } \t// } \tres = binarySearchQuotient(0, abs(dividend), abs(divisor), abs(dividend)) if res \u0026gt; math.MaxInt32 { return sign * math.MaxInt32 } if res \u0026lt; math.MinInt32 { return sign * math.MinInt32 } return sign * res } func binarySearchQuotient(low, high, val, dividend int) int { quotient := low + (high-low)\u0026gt;\u0026gt;1 if ((quotient+1)*val \u0026gt; dividend \u0026amp;\u0026amp; quotient*val \u0026lt;= dividend) || ((quotient+1)*val \u0026gt;= dividend \u0026amp;\u0026amp; quotient*val \u0026lt; dividend) { if (quotient+1)*val == dividend { return quotient + 1 } return quotient } if (quotient+1)*val \u0026gt; dividend \u0026amp;\u0026amp; quotient*val \u0026gt; dividend { return binarySearchQuotient(low, quotient-1, val, dividend) } if (quotient+1)*val \u0026lt; dividend \u0026amp;\u0026amp; quotient*val \u0026lt; dividend { return binarySearchQuotient(quotient+1, high, val, dividend) } return 0 } // 解法二 非递归版的二分搜索 func divide1(divided int, divisor int) int { if divided == math.MinInt32 \u0026amp;\u0026amp; divisor == -1 { return math.MaxInt32 } result := 0 sign := -1 if divided \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || divided \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0 { sign = 1 } dvd, dvs := abs(divided), abs(divisor) for dvd \u0026gt;= dvs { temp := dvs m := 1 for temp\u0026lt;\u0026lt;1 \u0026lt;= dvd { temp \u0026lt;\u0026lt;= 1 m \u0026lt;\u0026lt;= 1 } dvd -= temp result += m } return sign * result } "});index.add({'id':29,'href':'/leetcode-java/04_Leetcode/0030.Substring-with-Concatenation-of-All-Words/','title':"0030. Substring With Concatenation of All Words",'section':"第四章",'content':"30. Substring with Concatenation of All Words #  题目 #  You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\nExample 1:\n Input: s = \u0026quot;barfoothefoobarman\u0026quot;, words = [\u0026quot;foo\u0026quot;,\u0026quot;bar\u0026quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \u0026quot;barfoor\u0026quot; and \u0026quot;foobar\u0026quot; respectively. The output order does not matter, returning [9,0] is fine too. Example 2:\n Input: s = \u0026quot;wordgoodgoodgoodbestword\u0026quot;, words = [\u0026quot;word\u0026quot;,\u0026quot;good\u0026quot;,\u0026quot;best\u0026quot;,\u0026quot;word\u0026quot;] Output: [] 题目大意 #  给定一个源字符串 s，再给一个字符串数组，要求在源字符串中找到由字符串数组各种组合组成的连续串的起始下标，如果存在多个，在结果中都需要输出。\n解题思路 #  这一题看似很难，但是有 2 个限定条件也导致这题不是特别难。1. 字符串数组里面的字符串长度都是一样的。2. 要求字符串数组中的字符串都要连续连在一起的，前后顺序可以是任意排列组合。\n解题思路，先将字符串数组里面的所有字符串都存到 map 中，并累计出现的次数。然后从源字符串从头开始扫，每次判断字符串数组里面的字符串时候全部都用完了(计数是否为 0)，如果全部都用完了，并且长度正好是字符串数组任意排列组合的总长度，就记录下这个组合的起始下标。如果不符合，就继续考察源字符串的下一个字符，直到扫完整个源字符串。\n代码 #  package leetcode func findSubstring(s string, words []string) []int { if len(words) == 0 { return []int{} } res := []int{} counter := map[string]int{} for _, w := range words { counter[w]++ } length, totalLen, tmpCounter := len(words[0]), len(words[0])*len(words), copyMap(counter) for i, start := 0, 0; i \u0026lt; len(s)-length+1 \u0026amp;\u0026amp; start \u0026lt; len(s)-length+1; i++ { //fmt.Printf(\u0026#34;sub = %v i = %v lenght = %v start = %v tmpCounter = %v totalLen = %v\\n\u0026#34;, s[i:i+length], i, length, start, tmpCounter, totalLen) \tif tmpCounter[s[i:i+length]] \u0026gt; 0 { tmpCounter[s[i:i+length]]-- //fmt.Printf(\u0026#34;******sub = %v i = %v lenght = %v start = %v tmpCounter = %v totalLen = %v\\n\u0026#34;, s[i:i+length], i, length, start, tmpCounter, totalLen) \tif checkWords(tmpCounter) \u0026amp;\u0026amp; (i+length-start == totalLen) { res = append(res, start) continue } i = i + length - 1 } else { start++ i = start - 1 tmpCounter = copyMap(counter) } } return res } func checkWords(s map[string]int) bool { flag := true for _, v := range s { if v \u0026gt; 0 { flag = false break } } return flag } func copyMap(s map[string]int) map[string]int { c := map[string]int{} for k, v := range s { c[k] = v } return c } "});index.add({'id':30,'href':'/leetcode-java/04_Leetcode/0033.Search-in-Rotated-Sorted-Array/','title':"0033. Search in Rotated Sorted Array",'section':"第四章",'content':"33. Search in Rotated Sorted Array #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nYour algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n).\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  题目大意 #  假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。\n你的算法时间复杂度必须是 O(log n) 级别。\n解题思路 #   给出一个数组，数组中本来是从小到大排列的，并且数组中没有重复数字。但是现在把后面随机一段有序的放到数组前面，这样形成了前后两端有序的子序列。在这样的一个数组里面查找一个数，设计一个 O(log n) 的算法。如果找到就输出数组的小标，如果没有找到，就输出 -1 。 由于数组基本有序，虽然中间有一个“断开点”，还是可以使用二分搜索的算法来实现。现在数组前面一段是数值比较大的数，后面一段是数值偏小的数。如果 mid 落在了前一段数值比较大的区间内了，那么一定有 nums[mid] \u0026gt; nums[low]，如果是落在后面一段数值比较小的区间内，nums[mid] ≤ nums[low] 。如果 mid 落在了后一段数值比较小的区间内了，那么一定有 nums[mid] \u0026lt; nums[high]，如果是落在前面一段数值比较大的区间内，nums[mid] ≤ nums[high] 。还有 nums[low] == nums[mid] 和 nums[high] == nums[mid] 的情况，单独处理即可。最后找到则输出 mid，没有找到则输出 -1 。  代码 #  package leetcode func search33(nums []int, target int) int { if len(nums) == 0 { return -1 } low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] == target { return mid } else if nums[mid] \u0026gt; nums[low] { // 在数值大的一部分区间里 \tif nums[low] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { high = mid - 1 } else { low = mid + 1 } } else if nums[mid] \u0026lt; nums[high] { // 在数值小的一部分区间里 \tif nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[high] { low = mid + 1 } else { high = mid - 1 } } else { if nums[low] == nums[mid] { low++ } if nums[high] == nums[mid] { high-- } } } return -1 } "});index.add({'id':31,'href':'/leetcode-java/04_Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/','title':"0034. Find First and Last Position of Element in Sorted Array",'section':"第四章",'content':"34. Find First and Last Position of Element in Sorted Array #  题目 #  Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nYour algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n).\nIf the target is not found in the array, return [-1, -1].\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:\nInput: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  题目大意 #  给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。\n解题思路 #    给出一个有序数组 nums 和一个数 target，要求在数组中找到第一个和这个元素相等的元素下标，最后一个和这个元素相等的元素下标。\n  这一题是经典的二分搜索变种题。二分搜索有 4 大基础变种题：\n 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素  这一题的解题思路可以分别利用变种 1 和变种 2 的解法就可以做出此题。或者用一次变种 1 的方法，然后循环往后找到最后一个与给定值相等的元素。不过后者这种方法可能会使时间复杂度下降到 O(n)，因为有可能数组中 n 个元素都和给定元素相同。(4 大基础变种的实现见代码)\n  代码 #  package leetcode func searchRange(nums []int, target int) []int { return []int{searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)} } // 二分查找第一个与 target 相等的元素，时间复杂度 O(logn) func searchFirstEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) if nums[mid] \u0026gt; target { high = mid - 1 } else if nums[mid] \u0026lt; target { low = mid + 1 } else { if (mid == 0) || (nums[mid-1] != target) { // 找到第一个与 target 相等的元素 \treturn mid } high = mid - 1 } } return -1 } // 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn) func searchLastEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) if nums[mid] \u0026gt; target { high = mid - 1 } else if nums[mid] \u0026lt; target { low = mid + 1 } else { if (mid == len(nums)-1) || (nums[mid+1] != target) { // 找到最后一个与 target 相等的元素 \treturn mid } low = mid + 1 } } return -1 } // 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn) func searchFirstGreaterElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) if nums[mid] \u0026gt;= target { if (mid == 0) || (nums[mid-1] \u0026lt; target) { // 找到第一个大于等于 target 的元素 \treturn mid } high = mid - 1 } else { low = mid + 1 } } return -1 } // 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn) func searchLastLessElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) if nums[mid] \u0026lt;= target { if (mid == len(nums)-1) || (nums[mid+1] \u0026gt; target) { // 找到最后一个小于等于 target 的元素 \treturn mid } low = mid + 1 } else { high = mid - 1 } } return -1 } "});index.add({'id':32,'href':'/leetcode-java/04_Leetcode/0035.Search-Insert-Position/','title':"0035. Search Insert Position",'section':"第四章",'content':"35. Search Insert Position #  题目 #  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nExample 1:\nInput: [1,3,5,6], 5 Output: 2  Example 2:\nInput: [1,3,5,6], 2 Output: 1  Example 3:\nInput: [1,3,5,6], 7 Output: 4  Example 4:\nInput: [1,3,5,6], 0 Output: 0  题目大意 #  给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n解题思路 #   给出一个已经从小到大排序后的数组，要求在数组中找到插入 target 元素的位置。 这一题是经典的二分搜索的变种题，在有序数组中找到最后一个比 target 小的元素。  代码 #  package leetcode func searchInsert(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] \u0026gt;= target { high = mid - 1 } else { if (mid == len(nums)-1) || (nums[mid+1] \u0026gt;= target) { return mid + 1 } low = mid + 1 } } return 0 } "});index.add({'id':33,'href':'/leetcode-java/04_Leetcode/0036.Valid-Sudoku/','title':"0036. Valid Sudoku",'section':"第四章",'content':"36. Valid Sudoku #  题目 #  Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid.\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\nExample 1:\nInput: [ [\u0026quot;5\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;], [\u0026quot;4\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;], [\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;5\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;9\u0026quot;] ] Output: true  Example 2:\nInput: [ [\u0026quot;8\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;], [\u0026quot;4\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;], [\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;5\u0026quot;], [\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;9\u0026quot;] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:\n A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.  题目大意 #  判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  解题思路 #   给出一个数独的棋盘，要求判断这个棋盘当前是否满足数独的要求：即行列是否都只包含 1-9，每个九宫格里面是否也只包含 1-9 。 注意这题和第 37 题是不同的，这一题是判断当前棋盘状态是否满足数独的要求，而第 37 题是要求求解数独。本题中的棋盘有些是无解的，但是棋盘状态是满足题意的。  代码 #  package leetcode import \u0026#34;strconv\u0026#34; // 解法一 暴力遍历，时间复杂度 O(n^3) func isValidSudoku(board [][]byte) bool { // 判断行 row \tfor i := 0; i \u0026lt; 9; i++ { tmp := [10]int{} for j := 0; j \u0026lt; 9; j++ { cellVal := board[i][j : j+1] if string(cellVal) != \u0026#34;.\u0026#34; { index, _ := strconv.Atoi(string(cellVal)) if index \u0026gt; 9 || index \u0026lt; 1 { return false } if tmp[index] == 1 { return false } tmp[index] = 1 } } } // 判断列 column \tfor i := 0; i \u0026lt; 9; i++ { tmp := [10]int{} for j := 0; j \u0026lt; 9; j++ { cellVal := board[j][i] if string(cellVal) != \u0026#34;.\u0026#34; { index, _ := strconv.Atoi(string(cellVal)) if index \u0026gt; 9 || index \u0026lt; 1 { return false } if tmp[index] == 1 { return false } tmp[index] = 1 } } } // 判断 9宫格 3X3 cell \tfor i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { tmp := [10]int{} for ii := i * 3; ii \u0026lt; i*3+3; ii++ { for jj := j * 3; jj \u0026lt; j*3+3; jj++ { cellVal := board[ii][jj] if string(cellVal) != \u0026#34;.\u0026#34; { index, _ := strconv.Atoi(string(cellVal)) if tmp[index] == 1 { return false } tmp[index] = 1 } } } } } return true } // 解法二 添加缓存，时间复杂度 O(n^2) func isValidSudoku1(board [][]byte) bool { rowbuf, colbuf, boxbuf := make([][]bool, 9), make([][]bool, 9), make([][]bool, 9) for i := 0; i \u0026lt; 9; i++ { rowbuf[i] = make([]bool, 9) colbuf[i] = make([]bool, 9) boxbuf[i] = make([]bool, 9) } // 遍历一次，添加缓存 \tfor r := 0; r \u0026lt; 9; r++ { for c := 0; c \u0026lt; 9; c++ { if board[r][c] != \u0026#39;.\u0026#39; { num := board[r][c] - \u0026#39;0\u0026#39; - byte(1) if rowbuf[r][num] || colbuf[c][num] || boxbuf[r/3*3+c/3][num] { return false } rowbuf[r][num] = true colbuf[c][num] = true boxbuf[r/3*3+c/3][num] = true // r,c 转换到box方格中 \t} } } return true } "});index.add({'id':34,'href':'/leetcode-java/04_Leetcode/0037.Sudoku-Solver/','title':"0037. Sudoku Solver",'section':"第四章",'content':"37. Sudoku Solver #  题目 #  Write a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\n Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.  Empty cells are indicated by the character '.'.\n A sudoku puzzle\u0026hellip;\n \u0026hellip;and its solution numbers marked in red.\nNote:\n The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9.  题目大意 #  编写一个程序，通过已填充的空格来解决数独问题。一个数独的解法需遵循如下规则：\n 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  空白格用 \u0026lsquo;.\u0026rsquo; 表示。\n解题思路 #   给出一个数独谜题，要求解出这个数独 解题思路 DFS 暴力回溯枚举。数独要求每横行，每竖行，每九宫格内，1-9 的数字不能重复，每次放下一个数字的时候，在这 3 个地方都需要判断一次。 另外找到一组解以后就不需要再继续回溯了，直接返回即可。  代码 #  package leetcode type position struct { x int y int } func solveSudoku(board [][]byte) { pos, find := []position{}, false for i := 0; i \u0026lt; len(board); i++ { for j := 0; j \u0026lt; len(board[0]); j++ { if board[i][j] == \u0026#39;.\u0026#39; { pos = append(pos, position{x: i, y: j}) } } } putSudoku(\u0026amp;board, pos, 0, \u0026amp;find) } func putSudoku(board *[][]byte, pos []position, index int, succ *bool) { if *succ == true { return } if index == len(pos) { *succ = true return } for i := 1; i \u0026lt; 10; i++ { if checkSudoku(board, pos[index], i) \u0026amp;\u0026amp; !*succ { (*board)[pos[index].x][pos[index].y] = byte(i) + \u0026#39;0\u0026#39; putSudoku(board, pos, index+1, succ) if *succ == true { return } (*board)[pos[index].x][pos[index].y] = \u0026#39;.\u0026#39; } } } func checkSudoku(board *[][]byte, pos position, val int) bool { // 判断横行是否有重复数字 \tfor i := 0; i \u0026lt; len((*board)[0]); i++ { if (*board)[pos.x][i] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; int((*board)[pos.x][i]-\u0026#39;0\u0026#39;) == val { return false } } // 判断竖行是否有重复数字 \tfor i := 0; i \u0026lt; len((*board)); i++ { if (*board)[i][pos.y] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; int((*board)[i][pos.y]-\u0026#39;0\u0026#39;) == val { return false } } // 判断九宫格是否有重复数字 \tposx, posy := pos.x-pos.x%3, pos.y-pos.y%3 for i := posx; i \u0026lt; posx+3; i++ { for j := posy; j \u0026lt; posy+3; j++ { if (*board)[i][j] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; int((*board)[i][j]-\u0026#39;0\u0026#39;) == val { return false } } } return true } "});index.add({'id':35,'href':'/leetcode-java/04_Leetcode/0039.Combination-Sum/','title':"0039. Combination Sum",'section':"第四章",'content':"39. Combination Sum #  题目 #  Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nThe same repeated number may be chosen from candidates unlimited number of times.\nNote:\n All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1:\nInput: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:\nInput: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ]  题目大意 #  给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的数字可以无限制重复被选取。\n解题思路 #   题目要求出总和为 sum 的所有组合，组合需要去重。 这一题和第 47 题类似，只不过元素可以反复使用。  代码 #  package leetcode import \u0026#34;sort\u0026#34; func combinationSum(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } c, res := []int{}, [][]int{} sort.Ints(candidates) findcombinationSum(candidates, target, 0, c, \u0026amp;res) return res } func findcombinationSum(nums []int, target, index int, c []int, res *[][]int) { if target \u0026lt;= 0 { if target == 0 { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) } return } for i := index; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; target { // 这里可以剪枝优化 \tbreak } c = append(c, nums[i]) findcombinationSum(nums, target-nums[i], i, c, res) // 注意这里迭代的时候 index 依旧不变，因为一个元素可以取多次 \tc = c[:len(c)-1] } } "});index.add({'id':36,'href':'/leetcode-java/04_Leetcode/0040.Combination-Sum-II/','title':"0040. Combination Sum I I",'section':"第四章",'content':"40. Combination Sum II #  题目 #  Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nEach number in candidates may only be used once in the combination.\nNote:\n All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]  Example 2:\nInput: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ]  题目大意 #  给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用一次。\n解题思路 #   题目要求出总和为 sum 的所有组合，组合需要去重。这一题是第 39 题的加强版，第 39 题中元素可以重复利用(重复元素可无限次使用)，这一题中元素只能有限次数的利用，因为存在重复元素，并且每个元素只能用一次(重复元素只能使用有限次) 这一题和第 47 题类似，只不过元素可以反复使用。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func combinationSum2(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } c, res := []int{}, [][]int{} sort.Ints(candidates) // 这里是去重的关键逻辑 \tfindcombinationSum2(candidates, target, 0, c, \u0026amp;res) return res } func findcombinationSum2(nums []int, target, index int, c []int, res *[][]int) { if target == 0 { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } for i := index; i \u0026lt; len(nums); i++ { if i \u0026gt; index \u0026amp;\u0026amp; nums[i] == nums[i-1] { // 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字 \tcontinue } if target \u0026gt;= nums[i] { c = append(c, nums[i]) findcombinationSum2(nums, target-nums[i], i+1, c, res) c = c[:len(c)-1] } } } "});index.add({'id':37,'href':'/leetcode-java/04_Leetcode/0041.First-Missing-Positive/','title':"0041. First Missing Positive",'section':"第四章",'content':"41. First Missing Positive #  题目 #  Given an unsorted integer array, find the smallest missing positive integer.\nExample 1:\n Input: [1,2,0] Output: 3 Example 2:\n Input: [3,4,-1,1] Output: 2 Example 3:\n Input: [7,8,9,11,12] Output: 1 Note:\nYour algorithm should run in O(n) time and uses constant extra space.\n题目大意 #  找到缺失的第一个正整数。\n解题思路 #  为了减少时间复杂度，可以把 input 数组都装到 map 中，然后 i 循环从 1 开始，依次比对 map 中是否存在 i，只要不存在 i 就立即返回结果，即所求。\n代码 #  package leetcode func firstMissingPositive(nums []int) int { numMap := make(map[int]int, len(nums)) for _, v := range nums { numMap[v] = v } for index := 1; index \u0026lt; len(nums)+1; index++ { if _, ok := numMap[index]; !ok { return index } } return len(nums) + 1 } "});index.add({'id':38,'href':'/leetcode-java/04_Leetcode/0042.Trapping-Rain-Water/','title':"0042. Trapping Rain Water",'section':"第四章",'content':"42. Trapping Rain Water #  题目 #  Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\nExample:\n Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 题目大意 #  从 x 轴开始，给出一个数组，数组里面的数字代表从 (0,0) 点开始，宽度为 1 个单位，高度为数组元素的值。如果下雨了，问这样一个容器能装多少单位的水？\n解题思路 #   每个数组里面的元素值可以想象成一个左右都有壁的圆柱筒。例如上图中左边的第二个元素 1，当前左边最大的元素是 2 ，所以 2 高度的水会装到 1 的上面(因为想象成了左右都有筒壁)。这道题的思路就是左指针从 0 开始往右扫，右指针从最右边开始往左扫。额外还需要 2 个变量分别记住左边最大的高度和右边最大高度。遍历扫数组元素的过程中，如果左指针的高度比右指针的高度小，就不断的移动左指针，否则移动右指针。循环的终止条件就是左右指针碰上以后就结束。只要数组中元素的高度比保存的局部最大高度小，就累加 res 的值，否则更新局部最大高度。最终解就是 res 的值。\n代码 #  package leetcode func trap(height []int) int { res, left, right, maxLeft, maxRight := 0, 0, len(height)-1, 0, 0 for left \u0026lt;= right { if height[left] \u0026lt;= height[right] { if height[left] \u0026gt; maxLeft { maxLeft = height[left] } else { res += maxLeft - height[left] } left++ } else { if height[right] \u0026gt;= maxRight { maxRight = height[right] } else { res += maxRight - height[right] } right-- } } return res } "});index.add({'id':39,'href':'/leetcode-java/04_Leetcode/0046.Permutations/','title':"0046. Permutations",'section':"第四章",'content':"46. Permutations #  题目 #  Given a collection of distinct integers, return all possible permutations.\nExample:\nInput: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  题目大意 #  给定一个没有重复数字的序列，返回其所有可能的全排列。\n解题思路 #   求出一个数组的排列组合中的所有排列，用 DFS 深搜即可。  代码 #  package leetcode func permute(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} generatePermutation(nums, 0, p, \u0026amp;res, \u0026amp;used) return res } func generatePermutation(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) return } for i := 0; i \u0026lt; len(nums); i++ { if !(*used)[i] { (*used)[i] = true p = append(p, nums[i]) generatePermutation(nums, index+1, p, res, used) p = p[:len(p)-1] (*used)[i] = false } } return } "});index.add({'id':40,'href':'/leetcode-java/04_Leetcode/0047.Permutations-II/','title':"0047. Permutations I I",'section':"第四章",'content':"47. Permutations II #  题目 #  Given a collection of numbers that might contain duplicates, return all possible unique permutations.\nExample:\nInput: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ]  题目大意 #  给定一个可包含重复数字的序列，返回所有不重复的全排列。\n解题思路 #   这一题是第 46 题的加强版，第 46 题中求数组的排列，数组中元素不重复，但是这一题中，数组元素会重复，所以需要最终排列出来的结果需要去重。 去重的方法是经典逻辑，将数组排序以后，判断重复元素再做逻辑判断。 其他思路和第 46 题完全一致，DFS 深搜即可。  代码 #  package leetcode import \u0026#34;sort\u0026#34; func permuteUnique(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} sort.Ints(nums) // 这里是去重的关键逻辑 \tgeneratePermutation47(nums, 0, p, \u0026amp;res, \u0026amp;used) return res } func generatePermutation47(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) return } for i := 0; i \u0026lt; len(nums); i++ { if !(*used)[i] { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !(*used)[i-1] { // 这里是去重的关键逻辑 \tcontinue } (*used)[i] = true p = append(p, nums[i]) generatePermutation47(nums, index+1, p, res, used) p = p[:len(p)-1] (*used)[i] = false } } return } "});index.add({'id':41,'href':'/leetcode-java/04_Leetcode/0048.Rotate-Image/','title':"0048. Rotate Image",'section':"第四章",'content':"48. Rotate Image #  题目 #  You are given an n x n 2D matrix representing an image.\nRotate the image by 90 degrees (clockwise).\nNote:\nYou have to rotate the image  in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nGiven input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ]  Example 2:\nGiven input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]  题目大意 #  给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n解题思路 #   给出一个二维数组，要求顺时针旋转 90 度。 这一题比较简单，按照题意做就可以。这里给出 2 种旋转方法的实现，顺时针旋转和逆时针旋转。  /* * clockwise rotate 顺时针旋转 * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =\u0026gt; 4 5 6 =\u0026gt; 8 5 2 * 7 8 9 1 2 3 9 6 3 */ void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;matrix) { reverse(matrix.begin(), matrix.end()); for (int i = 0; i \u0026lt; matrix.size(); ++i) { for (int j = i + 1; j \u0026lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); } } /* * anticlockwise rotate 逆时针旋转 * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =\u0026gt; 6 5 4 =\u0026gt; 2 5 8 * 7 8 9 9 8 7 1 4 7 */ void anti_rotate(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;matrix) { for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i \u0026lt; matrix.size(); ++i) { for (int j = i + 1; j \u0026lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); } } 代码 #  package leetcode func rotate(matrix [][]int) { row := len(matrix) if row \u0026lt;= 0 { return } column := len(matrix[0]) // rotate by diagonal 对角线变换 \tfor i := 0; i \u0026lt; row; i++ { for j := i + 1; j \u0026lt; column; j++ { tmp := matrix[i][j] matrix[i][j] = matrix[j][i] matrix[j][i] = tmp } } // rotate by vertical centerline 竖直轴对称翻转 \thalfColumn := column / 2 for i := 0; i \u0026lt; row; i++ { for j := 0; j \u0026lt; halfColumn; j++ { tmp := matrix[i][j] matrix[i][j] = matrix[i][column-j-1] matrix[i][column-j-1] = tmp } } } "});index.add({'id':42,'href':'/leetcode-java/04_Leetcode/0049.Group-Anagrams/','title':"0049. Group Anagrams",'section':"第四章",'content':"49. Group Anagrams #  题目 #  Given an array of strings, group anagrams together.\nExample:\n Input: [\u0026quot;eat\u0026quot;, \u0026quot;tea\u0026quot;, \u0026quot;tan\u0026quot;, \u0026quot;ate\u0026quot;, \u0026quot;nat\u0026quot;, \u0026quot;bat\u0026quot;], Output: [ [\u0026quot;ate\u0026quot;,\u0026quot;eat\u0026quot;,\u0026quot;tea\u0026quot;], [\u0026quot;nat\u0026quot;,\u0026quot;tan\u0026quot;], [\u0026quot;bat\u0026quot;] ] Note:\n All inputs will be in lowercase. The order of your output does not matter.  题目大意 #  给出一个字符串数组，要求对字符串数组里面有 Anagrams 关系的字符串进行分组。Anagrams 关系是指两个字符串的字符完全相同，顺序不同，两者是由排列组合组成。\n解题思路 #  这道题可以将每个字符串都排序，排序完成以后，相同 Anagrams 的字符串必然排序结果一样。把排序以后的字符串当做 key 存入到 map 中。遍历数组以后，就能得到一个 map，key 是排序以后的字符串，value 对应的是这个排序字符串以后的 Anagrams 字符串集合。最后再将这些 value 对应的字符串数组输出即可。\n代码 #  package leetcode import \u0026#34;sort\u0026#34; type sortRunes []rune func (s sortRunes) Less(i, j int) bool { return s[i] \u0026lt; s[j] } func (s sortRunes) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s sortRunes) Len() int { return len(s) } func groupAnagrams(strs []string) [][]string { record, res := map[string][]string{}, [][]string{} for _, str := range strs { sByte := []rune(str) sort.Sort(sortRunes(sByte)) sstrs := record[string(sByte)] sstrs = append(sstrs, str) record[string(sByte)] = sstrs } for _, v := range record { res = append(res, v) } return res } "});index.add({'id':43,'href':'/leetcode-java/04_Leetcode/0050.Powx-n/','title':"0050. Powx N",'section':"第四章",'content':"50. Pow(x, n) #  题目 #  Implement pow(x, n), which calculates x raised to the power n (xn).\nExample 1:\nInput: 2.00000, 10 Output: 1024.00000  Example 2:\nInput: 2.10000, 3 Output: 9.26100  Example 3:\nInput: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:\n -100.0 \u0026lt; x \u0026lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31− 1]  题目大意 #  实现 pow(x, n) ，即计算 x 的 n 次幂函数。\n解题思路 #   要求计算 Pow(x, n) 这一题用递归的方式，不断的将 n 2 分下去。注意 n 的正负数，n 的奇偶性。  代码 #  package leetcode // 时间复杂度 O(log n),空间复杂度 O(1) func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } if n \u0026lt; 0 { n = -n x = 1 / x } tmp := myPow(x, n/2) if n%2 == 0 { return tmp * tmp } return tmp * tmp * x } "});index.add({'id':44,'href':'/leetcode-java/04_Leetcode/0051.N-Queens/','title':"0051. N Queens",'section':"第四章",'content':"51. N-Queens #  题目 #  The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n Given an integer n, return all distinct solutions to the n-queens puzzle.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\nExample:\nInput: 4 Output: [ [\u0026quot;.Q..\u0026quot;, // Solution 1 \u0026quot;...Q\u0026quot;, \u0026quot;Q...\u0026quot;, \u0026quot;..Q.\u0026quot;], [\u0026quot;..Q.\u0026quot;, // Solution 2 \u0026quot;Q...\u0026quot;, \u0026quot;...Q\u0026quot;, \u0026quot;.Q..\u0026quot;] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.  题目大意 #  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 \u0026lsquo;Q\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 分别代表了皇后和空位。\n解题思路 #   求解 n 皇后问题 利用 col 数组记录列信息，col 有 n 列。用 dia1，dia2 记录从左下到右上的对角线，从左上到右下的对角线的信息，dia1 和 dia2 分别都有 2*n-1 个。 dia1 对角线的规律是 i + j 是定值，例如[0,0]，为 0；[1,0]、[0,1] 为 1；[2,0]、[1,1]、[0,2] 为 2； dia2 对角线的规律是 i - j 是定值，例如[0,7]，为 -7；[0,6]、[1,7] 为 -6；[0,5]、[1,6]、[2,7] 为 -5；为了使他们从 0 开始，i - j + n - 1 偏移到 0 开始，所以 dia2 的规律是 i - j + n - 1 为定值。  代码 #  package leetcode // 解法一 DFS func solveNQueens(n int) [][]string { col, dia1, dia2, row, res := make([]bool, n), make([]bool, 2*n-1), make([]bool, 2*n-1), []int{}, [][]string{} putQueen(n, 0, \u0026amp;col, \u0026amp;dia1, \u0026amp;dia2, \u0026amp;row, \u0026amp;res) return res } // 尝试在一个n皇后问题中, 摆放第index行的皇后位置 func putQueen(n, index int, col, dia1, dia2 *[]bool, row *[]int, res *[][]string) { if index == n { *res = append(*res, generateBoard(n, row)) return } for i := 0; i \u0026lt; n; i++ { // 尝试将第index行的皇后摆放在第i列 \tif !(*col)[i] \u0026amp;\u0026amp; !(*dia1)[index+i] \u0026amp;\u0026amp; !(*dia2)[index-i+n-1] { *row = append(*row, i) (*col)[i] = true (*dia1)[index+i] = true (*dia2)[index-i+n-1] = true putQueen(n, index+1, col, dia1, dia2, row, res) (*col)[i] = false (*dia1)[index+i] = false (*dia2)[index-i+n-1] = false *row = (*row)[:len(*row)-1] } } return } func generateBoard(n int, row *[]int) []string { board := []string{} res := \u0026#34;\u0026#34; for i := 0; i \u0026lt; n; i++ { res += \u0026#34;.\u0026#34; } for i := 0; i \u0026lt; n; i++ { board = append(board, res) } for i := 0; i \u0026lt; n; i++ { tmp := []byte(board[i]) tmp[(*row)[i]] = \u0026#39;Q\u0026#39; board[i] = string(tmp) } return board } // 解法二 二进制操作法 // class Solution // { // int n; // string getNq(int p) // { // string s(n, \u0026#39;.\u0026#39;); // s[p] = \u0026#39;Q\u0026#39;; // return s; // } // void nQueens(int p, int l, int m, int r, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; \u0026amp;res) // { // static vector\u0026lt;string\u0026gt; ans; // if (p \u0026gt;= n) // { // res.push_back(ans); // return ; // } // int mask = l | m | r; // for (int i = 0, b = 1; i \u0026lt; n; ++ i, b \u0026lt;\u0026lt;= 1) // if (!(mask \u0026amp; b)) // { // ans.push_back(getNq(i)); // nQueens(p + 1, (l | b) \u0026gt;\u0026gt; 1, m | b, (r | b) \u0026lt;\u0026lt; 1, res); // ans.pop_back(); // } // } // public: // vector\u0026lt;vector\u0026lt;string\u0026gt; \u0026gt; solveNQueens(int n) // { // this-\u0026gt;n = n; // vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; // nQueens(0, 0, 0, 0, res); // return res; // } // };  "});index.add({'id':45,'href':'/leetcode-java/04_Leetcode/0052.N-Queens-II/','title':"0052. N Queens I I",'section':"第四章",'content':"52. N-Queens II #  题目 #  The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n Given an integer n, return the number of distinct solutions to the n-queens puzzle.\nExample:\nInput: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [ [\u0026quot;.Q..\u0026quot;, // Solution 1 \u0026quot;...Q\u0026quot;, \u0026quot;Q...\u0026quot;, \u0026quot;..Q.\u0026quot;], [\u0026quot;..Q.\u0026quot;, // Solution 2 \u0026quot;Q...\u0026quot;, \u0026quot;...Q\u0026quot;, \u0026quot;.Q..\u0026quot;] ]  题目大意 #  给定一个整数 n，返回 n 皇后不同的解决方案的数量。\n解题思路 #   这一题是第 51 题的加强版，在第 51 题的基础上累加记录解的个数即可。 这一题也可以暴力打表法，时间复杂度为 O(1)。  代码 #  package leetcode // 解法一，暴力打表法 func totalNQueens(n int) int { res := []int{0, 1, 0, 0, 2, 10, 4, 40, 92, 352, 724} return res[n] } // 解法二，DFS 回溯法 func totalNQueens1(n int) int { col, dia1, dia2, row, res := make([]bool, n), make([]bool, 2*n-1), make([]bool, 2*n-1), []int{}, 0 putQueen52(n, 0, \u0026amp;col, \u0026amp;dia1, \u0026amp;dia2, \u0026amp;row, \u0026amp;res) return res } // 尝试在一个n皇后问题中, 摆放第index行的皇后位置 func putQueen52(n, index int, col, dia1, dia2 *[]bool, row *[]int, res *int) { if index == n { *res++ return } for i := 0; i \u0026lt; n; i++ { // 尝试将第index行的皇后摆放在第i列 \tif !(*col)[i] \u0026amp;\u0026amp; !(*dia1)[index+i] \u0026amp;\u0026amp; !(*dia2)[index-i+n-1] { *row = append(*row, i) (*col)[i] = true (*dia1)[index+i] = true (*dia2)[index-i+n-1] = true putQueen52(n, index+1, col, dia1, dia2, row, res) (*col)[i] = false (*dia1)[index+i] = false (*dia2)[index-i+n-1] = false *row = (*row)[:len(*row)-1] } } return } // 解法三 二进制位操作法 // class Solution { // public: // int totalNQueens(int n) { // int ans=0; // int row=0,leftDiagonal=0,rightDiagonal=0; // int bit=(1\u0026lt;\u0026lt;n)-1;//to clear high bits of the 32-bit int // Queens(bit,row,leftDiagonal,rightDiagonal,ans); // return ans; // } // void Queens(int bit,int row,int leftDiagonal,int rightDiagonal,int \u0026amp;ans){ // int cur=(~(row|leftDiagonal|rightDiagonal))\u0026amp;bit;//possible place for this queen // if (!cur) return;//no pos for this queen // while(cur){ // int curPos=(cur\u0026amp;(~cur + 1))\u0026amp;bit;//choose possible place in the right // //update row,ld and rd // row+=curPos; // if (row==bit) ans++;//last row // else Queens(bit,row,((leftDiagonal|curPos)\u0026lt;\u0026lt;1)\u0026amp;bit,((rightDiagonal|curPos)\u0026gt;\u0026gt;1)\u0026amp;bit,ans); // cur-=curPos;//for next possible place // row-=curPos;//reset row // } // } // };  "});index.add({'id':46,'href':'/leetcode-java/04_Leetcode/0053.Maximum-Subarray/','title':"0053. Maximum Subarray",'section':"第四章",'content':"53. Maximum Subarray #  题目 #  Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\nInput: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n题目大意 #  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n解题思路 #   这一题可以用 DP 求解也可以不用 DP。 题目要求输出数组中某个区间内数字之和最大的那个值。dp[i] 表示 [0,i] 区间内各个子区间和的最大值，状态转移方程是 dp[i] = nums[i] + dp[i-1] (dp[i-1] \u0026gt; 0)，dp[i] = nums[i] (dp[i-1] ≤ 0)。  代码 #  package leetcode // 解法一 DP func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } dp, res := make([]int, len(nums)), nums[0] dp[0] = nums[0] for i := 1; i \u0026lt; len(nums); i++ { if dp[i-1] \u0026gt; 0 { dp[i] = nums[i] + dp[i-1] } else { dp[i] = nums[i] } res = max(res, dp[i]) } return res } // 解法二 模拟 func maxSubArray1(nums []int) int { if len(nums) == 1 { return nums[0] } maxSum, res, p := nums[0], 0, 0 for p \u0026lt; len(nums) { res += nums[p] if res \u0026gt; maxSum { maxSum = res } if res \u0026lt; 0 { res = 0 } p++ } return maxSum } "});index.add({'id':47,'href':'/leetcode-java/04_Leetcode/0054.Spiral-Matrix/','title':"0054. Spiral Matrix",'section':"第四章",'content':"54. Spiral Matrix #  题目 #  Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nExample 1:\nInput: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2:\nInput: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  题目大意 #  给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n解题思路 #   给出一个二维数组，按照螺旋的方式输出 解法一：需要注意的是特殊情况，比如二维数组退化成一维或者一列或者一个元素。注意了这些情况，基本就可以一次通过了。 解法二：提前算出一共多少个元素，一圈一圈地遍历矩阵，停止条件就是遍历了所有元素（count == sum）  代码 #  package leetcode // 解法 1 func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return []int{} } res := []int{} if len(matrix) == 1 { for i := 0; i \u0026lt; len(matrix[0]); i++ { res = append(res, matrix[0][i]) } return res } if len(matrix[0]) == 1 { for i := 0; i \u0026lt; len(matrix); i++ { res = append(res, matrix[i][0]) } return res } visit, m, n, round, x, y, spDir := make([][]int, len(matrix)), len(matrix), len(matrix[0]), 0, 0, 0, [][]int{ []int{0, 1}, // 朝右 \t[]int{1, 0}, // 朝下 \t[]int{0, -1}, // 朝左 \t[]int{-1, 0}, // 朝上 \t} for i := 0; i \u0026lt; m; i++ { visit[i] = make([]int, n) } visit[x][y] = 1 res = append(res, matrix[x][y]) for i := 0; i \u0026lt; m*n; i++ { x += spDir[round%4][0] y += spDir[round%4][1] if (x == 0 \u0026amp;\u0026amp; y == n-1) || (x == m-1 \u0026amp;\u0026amp; y == n-1) || (y == 0 \u0026amp;\u0026amp; x == m-1) { round++ } if x \u0026gt; m-1 || y \u0026gt; n-1 || x \u0026lt; 0 || y \u0026lt; 0 { return res } if visit[x][y] == 0 { visit[x][y] = 1 res = append(res, matrix[x][y]) } switch round % 4 { case 0: if y+1 \u0026lt;= n-1 \u0026amp;\u0026amp; visit[x][y+1] == 1 { round++ continue } case 1: if x+1 \u0026lt;= m-1 \u0026amp;\u0026amp; visit[x+1][y] == 1 { round++ continue } case 2: if y-1 \u0026gt;= 0 \u0026amp;\u0026amp; visit[x][y-1] == 1 { round++ continue } case 3: if x-1 \u0026gt;= 0 \u0026amp;\u0026amp; visit[x-1][y] == 1 { round++ continue } } } return res } // 解法 2 func spiralOrder2(matrix [][]int) []int { m := len(matrix) if m == 0 { return nil } n := len(matrix[0]) if n == 0 { return nil } // top、left、right、bottom 分别是剩余区域的上、左、右、下的下标 \ttop, left, bottom, right := 0, 0, m-1, n-1 count, sum := 0, m*n res := []int{} // 外层循环每次遍历一圈 \tfor count \u0026lt; sum { i, j := top, left for j \u0026lt;= right \u0026amp;\u0026amp; count \u0026lt; sum { res = append(res, matrix[i][j]) count++ j++ } i, j = top + 1, right for i \u0026lt;= bottom \u0026amp;\u0026amp; count \u0026lt; sum { res = append(res, matrix[i][j]) count++ i++ } i, j = bottom, right - 1 for j \u0026gt;= left \u0026amp;\u0026amp; count \u0026lt; sum { res = append(res, matrix[i][j]) count++ j-- } i, j = bottom - 1, left for i \u0026gt; top \u0026amp;\u0026amp; count \u0026lt; sum { res = append(res, matrix[i][j]) count++ i-- } // 进入到下一层 \ttop, left, bottom, right = top+1, left+1, bottom-1, right-1 } return res } "});index.add({'id':48,'href':'/leetcode-java/04_Leetcode/0055.Jump-Game/','title':"0055. Jump Game",'section':"第四章",'content':"55. Jump Game #  题目 #  Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 题目大意 #  给定一个非负整数数组，最初位于数组的第一个位置。数组中的每个元素代表在该位置可以跳跃的最大长度。判断是否能够到达最后一个位置。\n解题思路 #   给出一个非负数组，要求判断从数组 0 下标开始，能否到达数组最后一个位置。 这一题比较简单。如果某一个作为 起跳点 的格子可以跳跃的距离是 n，那么表示后面 n 个格子都可以作为 起跳点。可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离maxJump 不断更新。如果可以一直跳到最后，就成功了。如果中间有一个点比 maxJump 还要大，说明在这个点和 maxJump 中间连不上了，有些点不能到达最后一个位置。  代码 #  func canJump(nums []int) bool { n := len(nums) if n == 0 { return false } if n == 1 { return true } maxJump := 0 for i, v := range nums { if i \u0026gt; maxJump { return false } maxJump = max(maxJump, i+v) } return true } "});index.add({'id':49,'href':'/leetcode-java/04_Leetcode/0056.Merge-Intervals/','title':"0056. Merge Intervals",'section':"第四章",'content':"56. Merge Intervals #  题目 #  Given a collection of intervals, merge all overlapping intervals.\nExample 1:\n Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:\n Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. 题目大意 #  合并给的多个区间，区间有重叠的要进行区间合并。\n解题思路 #  先按照区间起点进行排序。然后从区间起点小的开始扫描，依次合并每个有重叠的区间。\n代码 #  package leetcode /** * Definition for an interval. * type Interval struct { *\tStart int *\tEnd int * } */ // Interval define type Interval struct { Start int End int } func merge56(intervals []Interval) []Interval { if len(intervals) == 0 { return intervals } quickSort(intervals, 0, len(intervals)-1) res := make([]Interval, 0) res = append(res, intervals[0]) curIndex := 0 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i].Start \u0026gt; res[curIndex].End { curIndex++ res = append(res, intervals[i]) } else { res[curIndex].End = max(intervals[i].End, res[curIndex].End) } } return res } func max(a int, b int) int { if a \u0026gt; b { return a } return b } func min(a int, b int) int { if a \u0026gt; b { return b } return a } func partitionSort(a []Interval, lo, hi int) int { pivot := a[hi] i := lo - 1 for j := lo; j \u0026lt; hi; j++ { if (a[j].Start \u0026lt; pivot.Start) || (a[j].Start == pivot.Start \u0026amp;\u0026amp; a[j].End \u0026lt; pivot.End) { i++ a[j], a[i] = a[i], a[j] } } a[i+1], a[hi] = a[hi], a[i+1] return i + 1 } func quickSort(a []Interval, lo, hi int) { if lo \u0026gt;= hi { return } p := partitionSort(a, lo, hi) quickSort(a, lo, p-1) quickSort(a, p+1, hi) } "});index.add({'id':50,'href':'/leetcode-java/04_Leetcode/0057.Insert-Interval/','title':"0057. Insert Interval",'section':"第四章",'content':"57. Insert Interval #  题目 #  Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\n Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:\n Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 题目大意 #  这一题是第 56 题的加强版。给出多个没有重叠的区间，然后再给一个区间，要求把如果有重叠的区间进行合并。\n解题思路 #  可以分 3 段处理，先添加原来的区间，即在给的 newInterval 之前的区间。然后添加 newInterval ，注意这里可能需要合并多个区间。最后把原来剩下的部分添加到最终结果中即可。\n代码 #  package leetcode /** * Definition for an interval. * type Interval struct { *\tStart int *\tEnd int * } */ func insert(intervals []Interval, newInterval Interval) []Interval { res := make([]Interval, 0) if len(intervals) == 0 { res = append(res, newInterval) return res } curIndex := 0 for curIndex \u0026lt; len(intervals) \u0026amp;\u0026amp; intervals[curIndex].End \u0026lt; newInterval.Start { res = append(res, intervals[curIndex]) curIndex++ } for curIndex \u0026lt; len(intervals) \u0026amp;\u0026amp; intervals[curIndex].Start \u0026lt;= newInterval.End { newInterval = Interval{Start: min(newInterval.Start, intervals[curIndex].Start), End: max(newInterval.End, intervals[curIndex].End)} curIndex++ } res = append(res, newInterval) for curIndex \u0026lt; len(intervals) { res = append(res, intervals[curIndex]) curIndex++ } return res } "});index.add({'id':51,'href':'/leetcode-java/04_Leetcode/0059.Spiral-Matrix-II/','title':"0059. Spiral Matrix I I",'section':"第四章",'content':"59. Spiral Matrix II #  题目 #  Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\nExample:\nInput: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]  题目大意 #  给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n解题思路 #   给出一个数组 n，要求输出一个 n * n 的二维数组，里面元素是 1 - n*n，且数组排列顺序是螺旋排列的 这一题是第 54 题的加强版，没有需要注意的特殊情况，直接模拟即可。  代码 #  package leetcode func generateMatrix(n int) [][]int { if n == 0 { return [][]int{} } if n == 1 { return [][]int{[]int{1}} } res, visit, round, x, y, spDir := make([][]int, n), make([][]int, n), 0, 0, 0, [][]int{ []int{0, 1}, // 朝右 \t[]int{1, 0}, // 朝下 \t[]int{0, -1}, // 朝左 \t[]int{-1, 0}, // 朝上 \t} for i := 0; i \u0026lt; n; i++ { visit[i] = make([]int, n) res[i] = make([]int, n) } visit[x][y] = 1 res[x][y] = 1 for i := 0; i \u0026lt; n*n; i++ { x += spDir[round%4][0] y += spDir[round%4][1] if (x == 0 \u0026amp;\u0026amp; y == n-1) || (x == n-1 \u0026amp;\u0026amp; y == n-1) || (y == 0 \u0026amp;\u0026amp; x == n-1) { round++ } if x \u0026gt; n-1 || y \u0026gt; n-1 || x \u0026lt; 0 || y \u0026lt; 0 { return res } if visit[x][y] == 0 { visit[x][y] = 1 res[x][y] = i + 2 } switch round % 4 { case 0: if y+1 \u0026lt;= n-1 \u0026amp;\u0026amp; visit[x][y+1] == 1 { round++ continue } case 1: if x+1 \u0026lt;= n-1 \u0026amp;\u0026amp; visit[x+1][y] == 1 { round++ continue } case 2: if y-1 \u0026gt;= 0 \u0026amp;\u0026amp; visit[x][y-1] == 1 { round++ continue } case 3: if x-1 \u0026gt;= 0 \u0026amp;\u0026amp; visit[x-1][y] == 1 { round++ continue } } } return res } "});index.add({'id':52,'href':'/leetcode-java/04_Leetcode/0060.Permutation-Sequence/','title':"0060. Permutation Sequence",'section':"第四章",'content':"60. Permutation Sequence #  题目 #  The set [1,2,3,...,*n*] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n \u0026quot;123\u0026quot; \u0026quot;132\u0026quot; \u0026quot;213\u0026quot; \u0026quot;231\u0026quot; \u0026quot;312\u0026quot; \u0026quot;321\u0026quot;  Given n and k, return the kth permutation sequence.\nNote:\n Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1:\n Input: n = 3, k = 3 Output: \u0026quot;213\u0026quot; Example 2:\n Input: n = 4, k = 9 Output: \u0026quot;2314\u0026quot; 题目大意 #  给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。\n按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：\u0026ldquo;123\u0026rdquo;，\u0026ldquo;132\u0026rdquo;，\u0026ldquo;213\u0026rdquo;，\u0026ldquo;231\u0026rdquo;，\u0026ldquo;312\u0026rdquo;，\u0026ldquo;321\u0026rdquo;，给定 n 和 k，返回第 k 个排列。\n解题思路 #   用 DFS 暴力枚举，这种做法时间复杂度特别高，想想更优的解法。  代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func getPermutation(n int, k int) string { if k == 0 { return \u0026#34;\u0026#34; } used, p, res := make([]bool, n), []int{}, \u0026#34;\u0026#34; findPermutation(n, 0, \u0026amp;k, p, \u0026amp;res, \u0026amp;used) return res } func findPermutation(n, index int, k *int, p []int, res *string, used *[]bool) { fmt.Printf(\u0026#34;n = %v index = %v k = %v p = %v res = %v user = %v\\n\u0026#34;, n, index, *k, p, *res, *used) if index == n { *k-- if *k == 0 { for _, v := range p { *res += strconv.Itoa(v + 1) } } return } for i := 0; i \u0026lt; n; i++ { if !(*used)[i] { (*used)[i] = true p = append(p, i) findPermutation(n, index+1, k, p, res, used) p = p[:len(p)-1] (*used)[i] = false } } return } "});index.add({'id':53,'href':'/leetcode-java/04_Leetcode/0061.Rotate-List/','title':"0061. Rotate List",'section':"第四章",'content':"61. 旋转链表 #  Difficulty: 中等\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\n示例 1:\n输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 输出: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL 解释: 向右旋转 1 步: 5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;NULL 向右旋转 2 步: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL 示例 2:\n输入: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL, k = 4 输出: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL 解释: 向右旋转 1 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL 向右旋转 2 步: 1-\u0026gt;2-\u0026gt;0-\u0026gt;NULL 向右旋转 3 步: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL 向右旋转 4 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL 题解 #  题解一： #  "});index.add({'id':54,'href':'/leetcode-java/04_Leetcode/0062.Unique-Paths/','title':"0062. Unique Paths",'section':"第四章",'content':"62. Unique Paths #  题目 #  A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nHow many possible unique paths are there?\n Above is a 7 x 3 grid. How many possible unique paths are there?\nNote: m and n will be at most 100.\nExample 1:\nInput: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -\u0026gt; Right -\u0026gt; Down 2. Right -\u0026gt; Down -\u0026gt; Right 3. Down -\u0026gt; Right -\u0026gt; Right  Example 2:\nInput: m = 7, n = 3 Output: 28  题目大意 #  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？\n解题思路 #   这是一道简单的 DP 题。输出地图上从左上角走到右下角的走法数。 由于机器人只能向右走和向下走，所以地图的第一行和第一列的走法数都是 1，地图中任意一点的走法数是 dp[i][j] = dp[i-1][j] + dp[i][j-1]  代码 #  package leetcode func uniquePaths(m int, n int) int { dp := make([][]int, n) for i := 0; i \u0026lt; n; i++ { dp[i] = make([]int, m) } for i := 0; i \u0026lt; m; i++ { dp[0][i] = 1 } for i := 0; i \u0026lt; n; i++ { dp[i][0] = 1 } for i := 1; i \u0026lt; n; i++ { for j := 1; j \u0026lt; m; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[n-1][m-1] } "});index.add({'id':55,'href':'/leetcode-java/04_Leetcode/0063.Unique-Paths-II/','title':"0063. Unique Paths I I",'section':"第四章",'content':"63. Unique Paths II #  题目 #  A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n An obstacle and empty space is marked as 1 and 0 respectively in the grid.\nNote: m and n will be at most 100.\nExample 1:\nInput: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -\u0026gt; Right -\u0026gt; Down -\u0026gt; Down 2. Down -\u0026gt; Down -\u0026gt; Right -\u0026gt; Right  题目大意 #  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n解题思路 #   这一题是第 62 题的加强版。也是一道考察 DP 的简单题。 这一题比第 62 题增加的条件是地图中会出现障碍物，障碍物的处理方法是 dp[i][j]=0。 需要注意的一种情况是，起点就是障碍物，那么这种情况直接输出 0 。  代码 #  package leetcode func uniquePathsWithObstacles(obstacleGrid [][]int) int { if len(obstacleGrid) == 0 || obstacleGrid[0][0] == 1 { return 0 } m, n := len(obstacleGrid), len(obstacleGrid[0]) dp := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]int, n) } dp[0][0] = 1 for i := 1; i \u0026lt; n; i++ { if dp[0][i-1] != 0 \u0026amp;\u0026amp; obstacleGrid[0][i] != 1 { dp[0][i] = 1 } } for i := 1; i \u0026lt; m; i++ { if dp[i-1][0] != 0 \u0026amp;\u0026amp; obstacleGrid[i][0] != 1 { dp[i][0] = 1 } } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if obstacleGrid[i][j] != 1 { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } } return dp[m-1][n-1] } "});index.add({'id':56,'href':'/leetcode-java/04_Leetcode/0064.Minimum-Path-Sum/','title':"0064. Minimum Path Sum",'section':"第四章",'content':"64. Minimum Path Sum #  题目 #  Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\nInput: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.  题目大意 #  给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。\n解题思路 #   在地图上求出从左上角到右下角的路径中，数字之和最小的一个，输出数字和。 这一题最简单的想法就是用一个二维数组来 DP，当然这是最原始的做法。由于只能往下和往右走，只需要维护 2 列信息就可以了，从左边推到最右边即可得到最小的解。更近一步，可以直接在原来的数组中做原地 DP，空间复杂度为 0 。  代码 #  package leetcode // 解法一 原地 DP，无辅助空间 func minPathSum(grid [][]int) int { m, n := len(grid), len(grid[0]) for i := 1; i \u0026lt; m; i++ { grid[i][0] += grid[i-1][0] } for j := 1; j \u0026lt; n; j++ { grid[0][j] += grid[0][j-1] } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { grid[i][j] += min(grid[i-1][j], grid[i][j-1]) } } return grid[m-1][n-1] } // 解法二 最原始的方法，辅助空间 O(n^2) func minPathSum1(grid [][]int) int { if len(grid) == 0 { return 0 } m, n := len(grid), len(grid[0]) if m == 0 || n == 0 { return 0 } dp := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]int, n) } // initFirstCol \tfor i := 0; i \u0026lt; len(dp); i++ { if i == 0 { dp[i][0] = grid[i][0] } else { dp[i][0] = grid[i][0] + dp[i-1][0] } } // initFirstRow \tfor i := 0; i \u0026lt; len(dp[0]); i++ { if i == 0 { dp[0][i] = grid[0][i] } else { dp[0][i] = grid[0][i] + dp[0][i-1] } } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] } } return dp[m-1][n-1] } "});index.add({'id':57,'href':'/leetcode-java/04_Leetcode/0066.Plus-One/','title':"0066. Plus One",'section':"第四章",'content':"66. Plus One #  题目 #  Given a non-empty array of digits representing a non-negative integer, plus one to the integer.\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2:\nInput: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.  题目大意 #  给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。\n解题思路 #   给出一个数组，代表一个十进制数，数组的 0 下标是十进制数的高位。要求计算这个十进制数加一以后的结果。 简单的模拟题。从数组尾部开始往前扫，逐位进位即可。最高位如果还有进位需要在数组里面第 0 位再插入一个 1 。  代码 #  package leetcode func plusOne(digits []int) []int { if len(digits) == 0 { return []int{} } carry := 1 for i := len(digits) - 1; i \u0026gt;= 0; i-- { if digits[i]+carry \u0026gt; 9 { digits[i] = 0 carry = 1 } else { digits[i] += carry carry = 0 } } if digits[0] == 0 \u0026amp;\u0026amp; carry == 1 { digits = append([]int{1}, digits...) } return digits } "});index.add({'id':58,'href':'/leetcode-java/04_Leetcode/0067.Add-Binary/','title':"0067. Add Binary",'section':"第四章",'content':"67. Add Binary #  题目 #  Given two binary strings, return their sum (also a binary string).\nThe input strings are both non-empty and contains only characters 1 or 0.\nExample 1:\nInput: a = \u0026quot;11\u0026quot;, b = \u0026quot;1\u0026quot; Output: \u0026quot;100\u0026quot; Example 2:\nInput: a = \u0026quot;1010\u0026quot;, b = \u0026quot;1011\u0026quot; Output: \u0026quot;10101\u0026quot; 题目大意 #  给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。\n解题思路 #   要求输出 2 个二进制数的和，结果也用二进制表示。 简单题。按照二进制的加法规则做加法即可。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) func addBinary(a string, b string) string { if len(b) \u0026gt; len(a) { a, b = b, a } res := make([]string, len(a)+1) i, j, k, c := len(a)-1, len(b)-1, len(a), 0 for i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0 { ai, _ := strconv.Atoi(string(a[i])) bj, _ := strconv.Atoi(string(b[j])) res[k] = strconv.Itoa((ai + bj + c) % 2) c = (ai + bj + c) / 2 i-- j-- k-- } for i \u0026gt;= 0 { ai, _ := strconv.Atoi(string(a[i])) res[k] = strconv.Itoa((ai + c) % 2) c = (ai + c) / 2 i-- k-- } if c \u0026gt; 0 { res[k] = strconv.Itoa(c) } return strings.Join(res, \u0026#34;\u0026#34;) } "});index.add({'id':59,'href':'/leetcode-java/04_Leetcode/0069.Sqrtx/','title':"0069. Sqrtx",'section':"第四章",'content':"69. Sqrt(x) #  题目 #  Implement int sqrt(int x).\nCompute and return the square root of x, where x is guaranteed to be a non-negative integer.\nSince the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\nExample 1:\nInput: 4 Output: 2  Example 2:\nInput: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.  题目大意 #  实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n解题思路 #    题目要求求出根号 x\n  根据题意，根号 x 的取值范围一定在 [0,x] 之间，这个区间内的值是递增有序的，有边界的，可以用下标访问的，满足这三点正好也就满足了二分搜索的 3 大条件。所以解题思路一，二分搜索。\n  解题思路二，牛顿迭代法。求根号 x，即求满足 x^2 - n = 0 方程的所有解。\n   代码 #  package leetcode // 解法一 二分 func mySqrt(x int) int { if x == 0 { return 0 } left, right, res := 1, x, 0 for left \u0026lt;= right { mid := left + ((right - left) \u0026gt;\u0026gt; 1) if mid \u0026lt; x/mid { left = mid + 1 res = mid } else if mid == x/mid { return mid } else { right = mid - 1 } } return res } // 解法二 牛顿迭代法 https://en.wikipedia.org/wiki/Integer_square_root func mySqrt1(x int) int { r := x for r*r \u0026gt; x { r = (r + x/r) / 2 } return r } // 解法三 Quake III 游戏引擎中有一种比 STL 的 sqrt 快 4 倍的实现 https://en.wikipedia.org/wiki/Fast_inverse_square_root // float Q_rsqrt( float number ) // { // long i; // float x2, y; // const float threehalfs = 1.5F;  // x2 = number * 0.5F; // y = number; // i = * ( long * ) \u0026amp;y; // evil floating point bit level hacking // i = 0x5f3759df - ( i \u0026gt;\u0026gt; 1 ); // what the fuck? // y = * ( float * ) \u0026amp;i; // y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration // //\ty = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed // return y; // }  "});index.add({'id':60,'href':'/leetcode-java/04_Leetcode/0070.Climbing-Stairs/','title':"0070. Climbing Stairs",'section':"第四章",'content':"70. Climbing Stairs #  题目 #  You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nNote: Given n will be a positive integer.\nExample 1:\nInput: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2:\nInput: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step  题目大意 #  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数\n解题思路 #   简单的 DP，经典的爬楼梯问题。一个楼梯可以由 n-1 和 n-2 的楼梯爬上来。 这一题求解的值就是斐波那契数列。  代码 #  package leetcode func climbStairs(n int) int { dp := make([]int, n+1) dp[0], dp[1] = 1, 1 for i := 2; i \u0026lt;= n; i++ { dp[i] = dp[i-1] + dp[i-2] } return dp[n] } "});index.add({'id':61,'href':'/leetcode-java/04_Leetcode/0071.Simplify-Path/','title':"0071. Simplify Path",'section':"第四章",'content':"71. Simplify Path #  题目 #  Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.\nIn a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix\nNote that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.\nExample 1:\n Input: \u0026quot;/home/\u0026quot; Output: \u0026quot;/home\u0026quot; Explanation: Note that there is no trailing slash after the last directory name. Example 2:\n Input: \u0026quot;/../\u0026quot; Output: \u0026quot;/\u0026quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3:\n Input: \u0026quot;/home//foo/\u0026quot; Output: \u0026quot;/home/foo\u0026quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4:\n Input: \u0026quot;/a/./b/../../c/\u0026quot; Output: \u0026quot;/c\u0026quot; Example 5:\n Input: \u0026quot;/a/../../b/../c//.//\u0026quot; Output: \u0026quot;/c\u0026quot; Example 6:\n Input: \u0026quot;/a//b////c/d//././/..\u0026quot; Output: \u0026quot;/a/b/c\u0026quot; 题目大意 #  给出一个 Unix 的文件路径，要求简化这个路径。这道题也是考察栈的题目。\n解题思路 #  这道题笔者提交了好多次才通过，并不是题目难，而是边界条件很多，没考虑全一种情况就会出错。有哪些边界情况就看笔者的 test 文件吧。\n代码 #  package leetcode import ( \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; ) // 解法一 func simplifyPath(path string) string { arr := strings.Split(path, \u0026#34;/\u0026#34;) stack := make([]string, 0) var res string for i := 0; i \u0026lt; len(arr); i++ { cur := arr[i] //cur := strings.TrimSpace(arr[i]) 更加严谨的做法应该还要去掉末尾的空格 \tif cur == \u0026#34;..\u0026#34; { if len(stack) \u0026gt; 0 { stack = stack[:len(stack)-1] } } else if cur != \u0026#34;.\u0026#34; \u0026amp;\u0026amp; len(cur) \u0026gt; 0 { stack = append(stack, arr[i]) } } if len(stack) == 0 { return \u0026#34;/\u0026#34; } res = strings.Join(stack, \u0026#34;/\u0026#34;) return \u0026#34;/\u0026#34; + res } // 解法二 golang 的官方库 API func simplifyPath1(path string) string { return filepath.Clean(path) } "});index.add({'id':62,'href':'/leetcode-java/04_Leetcode/0074.Search-a-2D-Matrix/','title':"0074. Search a 2 D Matrix",'section':"第四章",'content':"74. Search a 2D Matrix #  题目 #  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1:\nInput: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:\nInput: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false  题目大意 #  编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。  解题思路 #   给出一个二维矩阵，矩阵的特点是随着矩阵的下标增大而增大。要求设计一个算法能在这个矩阵中高效的找到一个数，如果找到就输出 true，找不到就输出 false。 虽然是一个二维矩阵，但是由于它特殊的有序性，所以完全可以按照下标把它看成一个一维矩阵，只不过需要行列坐标转换。最后利用二分搜索直接搜索即可。  代码 #  package leetcode func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } m, low, high := len(matrix[0]), 0, len(matrix[0])*len(matrix)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if matrix[mid/m][mid%m] == target { return true } else if matrix[mid/m][mid%m] \u0026gt; target { high = mid - 1 } else { low = mid + 1 } } return false } "});index.add({'id':63,'href':'/leetcode-java/04_Leetcode/0075.Sort-Colors/','title':"0075. Sort Colors",'section':"第四章",'content':"75. Sort Colors #  题目 #  Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote: You are not suppose to use the library\u0026rsquo;s sort function for this problem.\nExample 1:\n Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:\n A rather straight forward solution is a two-pass algorithm using counting sort.\nFirst, iterate the array counting number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s, then overwrite array with total number of 0\u0026rsquo;s, then 1\u0026rsquo;s and followed by 2\u0026rsquo;s. Could you come up with a one-pass algorithm using only constant space?  题目大意 #  抽象题意其实就是排序。这题可以用快排一次通过。\n解题思路 #  题目末尾的 Follow up 提出了一个更高的要求，能否用一次循环解决问题？这题由于数字只会出现 0，1，2 这三个数字，所以用游标移动来控制顺序也是可以的。具体做法：0 是排在最前面的，所以只要添加一个 0，就需要放置 1 和 2。1 排在 2 前面，所以添加 1 的时候也需要放置 2 。至于最后的 2，只用移动游标即可。\n这道题可以用计数排序，适合待排序数字很少的题目。用一个 3 个容量的数组分别计数，记录 0，1，2 出现的个数。然后再根据个数排列 0，1，2 即可。时间复杂度 O(n)，空间复杂度 O(K)。这一题 K = 3。\n这道题也可以用一次三路快排。数组分为 3 部分，第一个部分都是 0，中间部分都是 1，最后部分都是 2 。\n代码 #  package leetcode func sortColors(nums []int) { if len(nums) == 0 { return } r := 0 w := 0 b := 0 // label the end of different colors; \tfor _, num := range nums { if num == 0 { nums[b] = 2 b++ nums[w] = 1 w++ nums[r] = 0 r++ } else if num == 1 { nums[b] = 2 b++ nums[w] = 1 w++ } else if num == 2 { b++ } } } "});index.add({'id':64,'href':'/leetcode-java/04_Leetcode/0076.Minimum-Window-Substring/','title':"0076. Minimum Window Substring",'section':"第四章",'content':"76. Minimum Window Substring #  题目 #  Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nExample:\n Input: S = \u0026quot;ADOBECODEBANC\u0026quot;, T = \u0026quot;ABC\u0026quot; Output: \u0026quot;BANC\u0026quot; Note:\n If there is no such window in S that covers all characters in T, return the empty string \u0026ldquo;\u0026rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.  题目大意 #  给定一个源字符串 s，再给一个字符串 T，要求在源字符串中找到一个窗口，这个窗口包含由字符串各种排列组合组成的，窗口中可以包含 T 中没有的字符，如果存在多个，在结果中输出最小的窗口，如果找不到这样的窗口，输出空字符串。\n解题思路 #  这一题是滑动窗口的题目，在窗口滑动的过程中不断的包含字符串 T，直到完全包含字符串 T 的字符以后，记下左右窗口的位置和窗口大小。每次都不断更新这个符合条件的窗口和窗口大小的最小值。最后输出结果即可。\n代码 #  package leetcode func minWindow(s string, t string) string { if s == \u0026#34;\u0026#34; || t == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } var tFreq, sFreq [256]int result, left, right, finalLeft, finalRight, minW, count := \u0026#34;\u0026#34;, 0, -1, -1, -1, len(s)+1, 0 for i := 0; i \u0026lt; len(t); i++ { tFreq[t[i]-\u0026#39;a\u0026#39;]++ } for left \u0026lt; len(s) { if right+1 \u0026lt; len(s) \u0026amp;\u0026amp; count \u0026lt; len(t) { sFreq[s[right+1]-\u0026#39;a\u0026#39;]++ if sFreq[s[right+1]-\u0026#39;a\u0026#39;] \u0026lt;= tFreq[s[right+1]-\u0026#39;a\u0026#39;] { count++ } right++ } else { if right-left+1 \u0026lt; minW \u0026amp;\u0026amp; count == len(t) { minW = right - left + 1 finalLeft = left finalRight = right } if sFreq[s[left]-\u0026#39;a\u0026#39;] == tFreq[s[left]-\u0026#39;a\u0026#39;] { count-- } sFreq[s[left]-\u0026#39;a\u0026#39;]-- left++ } } if finalLeft != -1 { for i := finalLeft; i \u0026lt; finalRight+1; i++ { result += string(s[i]) } } return result } "});index.add({'id':65,'href':'/leetcode-java/04_Leetcode/0077.Combinations/','title':"0077. Combinations",'section':"第四章",'content':"77. Combinations #  题目 #  Given two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n.\nExample:\nInput: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]  题目大意 #  给定两个整数 n 和 k，返回 1 \u0026hellip; n 中所有可能的 k 个数的组合。\n解题思路 #   计算排列组合中的组合，用 DFS 深搜即可，注意剪枝  代码 #   package leetcode func combine(n int, k int) [][]int { if n \u0026lt;= 0 || k \u0026lt;= 0 || k \u0026gt; n { return [][]int{} } c, res := []int{}, [][]int{} generateCombinations(n, k, 1, c, \u0026amp;res) return res } func generateCombinations(n, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.size()) + 1 for i := start; i \u0026lt;= n-(k-len(c))+1; i++ { c = append(c, i) generateCombinations(n, k, i+1, c, res) c = c[:len(c)-1] } return } "});index.add({'id':66,'href':'/leetcode-java/04_Leetcode/0078.Subsets/','title':"0078. Subsets",'section':"第四章",'content':"78. Subsets #  题目 #  Given a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  题目大意 #  给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。\n解题思路 #   找出一个集合中的所有子集，空集也算是子集。且数组中的数字不会出现重复。用 DFS 暴力枚举即可。 这一题和第 90 题，第 491 题类似，可以一起解答和复习。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 func subsets(nums []int) [][]int { c, res := []int{}, [][]int{} for k := 0; k \u0026lt;= len(nums); k++ { generateSubsets(nums, k, 0, c, \u0026amp;res) } return res } func generateSubsets(nums []int, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.size()) + 1 \tfor i := start; i \u0026lt; len(nums)-(k-len(c))+1; i++ { c = append(c, nums[i]) generateSubsets(nums, k, i+1, c, res) c = c[:len(c)-1] } return } // 解法二 func subsets1(nums []int) [][]int { res := make([][]int, 1) sort.Ints(nums) for i := range nums { for _, org := range res { clone := make([]int, len(org), len(org)+1) copy(clone, org) clone = append(clone, nums[i]) res = append(res, clone) } } return res } // 解法三：位运算的方法 func subsets2(nums []int) [][]int { if len(nums) == 0 { return nil } res := [][]int{} sum := 1 \u0026lt;\u0026lt; uint(len(nums)) for i := 0; i \u0026lt; sum; i++ { stack := []int{} tmp := i // i 从 000...000 到 111...111 \tfor j := len(nums) - 1; j \u0026gt;= 0; j-- { // 遍历 i 的每一位 \tif tmp \u0026amp; 1 == 1 { stack = append([]int{nums[j]}, stack...) } tmp \u0026gt;\u0026gt;= 1 } res = append(res, stack) } return res } "});index.add({'id':67,'href':'/leetcode-java/04_Leetcode/0079.Word-Search/','title':"0079. Word Search",'section':"第四章",'content':"79. Word Search #  题目 #  Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.  题目大意 #  给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n解题思路 #   在地图上的任意一个起点开始，向 4 个方向分别 DFS 搜索，直到所有的单词字母都找到了就输出 true，否则输出 false。  代码 #  package leetcode var dir = [][]int{ []int{-1, 0}, []int{0, 1}, []int{1, 0}, []int{0, -1}, } func exist(board [][]byte, word string) bool { visited := make([][]bool, len(board)) for i := 0; i \u0026lt; len(visited); i++ { visited[i] = make([]bool, len(board[0])) } for i, v := range board { for j := range v { if searchWord(board, visited, word, 0, i, j) { return true } } } return false } func isInBoard(board [][]byte, x, y int) bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(board) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(board[0]) } func searchWord(board [][]byte, visited [][]bool, word string, index, x, y int) bool { if index == len(word)-1 { return board[x][y] == word[index] } if board[x][y] == word[index] { visited[x][y] = true for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isInBoard(board, nx, ny) \u0026amp;\u0026amp; !visited[nx][ny] \u0026amp;\u0026amp; searchWord(board, visited, word, index+1, nx, ny) { return true } } visited[x][y] = false } return false } "});index.add({'id':68,'href':'/leetcode-java/04_Leetcode/0080.Remove-Duplicates-from-Sorted-Array-II/','title':"0080. Remove Duplicates From Sorted Array I I",'section':"第四章",'content':"80. Remove Duplicates from Sorted Array II #  题目 #  Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn't matter what you leave beyond the returned length. Example 2:\n Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length. Clarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 题目大意 #  给定一个有序数组 nums，对数组中的元素进行去重，使得原数组中的每个元素最多暴露 2 个。最后返回去重以后数组的长度值。\n解题思路 #  这道题和第 26 题很像。是第 26 题的加强版。这道题和第 283 题，第 27 题基本一致，283 题是删除 0，27 题是删除指定元素，这一题是删除重复元素，实质是一样的。\n这里数组的删除并不是真的删除，只是将删除的元素移动到数组后面的空间内，然后返回数组实际剩余的元素个数，OJ 最终判断题目的时候会读取数组剩余个数的元素进行输出。\n代码 #  package leetcode func removeDuplicates80(nums []int) int { if len(nums) == 0 { return 0 } last, finder := 0, 0 for last \u0026lt; len(nums)-1 { startFinder := -1 for nums[finder] == nums[last] { if startFinder == -1 || startFinder \u0026gt; finder { startFinder = finder } if finder == len(nums)-1 { break } finder++ } if finder-startFinder \u0026gt;= 2 \u0026amp;\u0026amp; nums[finder-1] == nums[last] \u0026amp;\u0026amp; nums[finder] != nums[last] { nums[last+1] = nums[finder-1] nums[last+2] = nums[finder] last += 2 } else { nums[last+1] = nums[finder] last++ } if finder == len(nums)-1 { if nums[finder] != nums[last-1] { nums[last] = nums[finder] } return last + 1 } } return last + 1 } "});index.add({'id':69,'href':'/leetcode-java/04_Leetcode/0081.Search-in-Rotated-Sorted-Array-II/','title':"0081. Search in Rotated Sorted Array I I",'section':"第四章",'content':"81. Search in Rotated Sorted Array II #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\nYou are given a target value to search. If found in the array return true, otherwise return false.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up:\n This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?  题目大意 #  假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。\n编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。\n进阶:\n 这是搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？  解题思路 #   给出一个数组，数组中本来是从小到大排列的，并且数组中有重复数字。但是现在把后面随机一段有序的放到数组前面，这样形成了前后两端有序的子序列。在这样的一个数组里面查找一个数，设计一个 O(log n) 的算法。如果找到就输出 true，如果没有找到，就输出 false 。 这一题是第 33 题的加强版，实现代码完全一样，只不过输出变了。这一题输出 true 和 false 了。具体思路见第 33 题。  代码 #  package leetcode func search(nums []int, target int) bool { if len(nums) == 0 { return false } low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] == target { return true } else if nums[mid] \u0026gt; nums[low] { // 在数值大的一部分区间里 \tif nums[low] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { high = mid - 1 } else { low = mid + 1 } } else if nums[mid] \u0026lt; nums[high] { // 在数值小的一部分区间里 \tif nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[high] { low = mid + 1 } else { high = mid - 1 } } else { if nums[low] == nums[mid] { low++ } if nums[high] == nums[mid] { high-- } } } return false } "});index.add({'id':70,'href':'/leetcode-java/04_Leetcode/0082.Remove-Duplicates-from-Sorted-List-II/','title':"0082. Remove Duplicates From Sorted List I I",'section':"第四章",'content':"82. Remove Duplicates from Sorted List II #  题目 #  Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\nExample 1:\n Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 Output: 1-\u0026gt;2-\u0026gt;5 Example 2:\n Input: 1-\u0026gt;1-\u0026gt;1-\u0026gt;2-\u0026gt;3 Output: 2-\u0026gt;3 题目大意 #  删除链表中重复的结点，只要是有重复过的结点，全部删除。\n解题思路 #  按照题意做即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 func deleteDuplicates1(head *ListNode) *ListNode { if head == nil { return nil } if head.Next == nil { return head } newHead := \u0026amp;ListNode{Next: head, Val: -999999} cur := newHead last := newHead front := head for front.Next != nil { if front.Val == cur.Val { // fmt.Printf(\u0026#34;相同节点front = %v | cur = %v | last = %v\\n\u0026#34;, front.Val, cur.Val, last.Val) \tfront = front.Next continue } else { if cur.Next != front { // fmt.Printf(\u0026#34;删除重复节点front = %v | cur = %v | last = %v\\n\u0026#34;, front.Val, cur.Val, last.Val) \tlast.Next = front if front.Next != nil \u0026amp;\u0026amp; front.Next.Val != front.Val { last = front } cur = front front = front.Next } else { // fmt.Printf(\u0026#34;常规循环前front = %v | cur = %v | last = %v\\n\u0026#34;, front.Val, cur.Val, last.Val) \tlast = cur cur = cur.Next front = front.Next // fmt.Printf(\u0026#34;常规循环后front = %v | cur = %v | last = %v\\n\u0026#34;, front.Val, cur.Val, last.Val)  } } } if front.Val == cur.Val { // fmt.Printf(\u0026#34;相同节点front = %v | cur = %v | last = %v\\n\u0026#34;, front.Val, cur.Val, last.Val) \tlast.Next = nil } else { if cur.Next != front { last.Next = front } } return newHead.Next } // 解法二 func deleteDuplicates2(head *ListNode) *ListNode { if head == nil { return nil } if head.Next != nil \u0026amp;\u0026amp; head.Val == head.Next.Val { for head.Next != nil \u0026amp;\u0026amp; head.Val == head.Next.Val { head = head.Next } return deleteDuplicates(head.Next) } head.Next = deleteDuplicates(head.Next) return head } func deleteDuplicates(head *ListNode) *ListNode { cur := head if head == nil { return nil } if head.Next == nil { return head } for cur.Next != nil { if cur.Next.Val == cur.Val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return head } // 解法三 双循环简单解法 O(n*m) func deleteDuplicates3(head *ListNode) *ListNode { if head == nil { return head } nilNode := \u0026amp;ListNode{Val: 0, Next: head} head = nilNode lastVal := 0 for head.Next != nil \u0026amp;\u0026amp; head.Next.Next != nil { if head.Next.Val == head.Next.Next.Val { lastVal = head.Next.Val for head.Next != nil \u0026amp;\u0026amp; lastVal == head.Next.Val { head.Next = head.Next.Next } } else { head = head.Next } } return nilNode.Next } // 解法四 双指针+删除标志位，单循环解法 O(n) func deleteDuplicates4(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nilNode := \u0026amp;ListNode{Val: 0, Next: head} // 上次遍历有删除操作的标志位 \tlastIsDel := false // 虚拟空结点 \thead = nilNode // 前后指针用于判断 \tpre, back := head.Next, head.Next.Next // 每次只删除前面的一个重复的元素，留一个用于下次遍历判重 \t// pre, back 指针的更新位置和值比较重要和巧妙 \tfor head.Next != nil \u0026amp;\u0026amp; head.Next.Next != nil { if pre.Val != back.Val \u0026amp;\u0026amp; lastIsDel { head.Next = head.Next.Next pre, back = head.Next, head.Next.Next lastIsDel = false continue } if pre.Val == back.Val { head.Next = head.Next.Next pre, back = head.Next, head.Next.Next lastIsDel = true } else { head = head.Next pre, back = head.Next, head.Next.Next lastIsDel = false } } // 处理 [1,1] 这种删除还剩一个的情况 \tif lastIsDel \u0026amp;\u0026amp; head.Next != nil { head.Next = nil } return nilNode.Next } "});index.add({'id':71,'href':'/leetcode-java/04_Leetcode/0083.Remove-Duplicates-from-Sorted-List/','title':"0083. Remove Duplicates From Sorted List",'section':"第四章",'content':"83. Remove Duplicates from Sorted List #  题目 #  Given a sorted linked list, delete all duplicates such that each element appear only once.\nExample 1:\n Input: 1-\u0026gt;1-\u0026gt;2 Output: 1-\u0026gt;2 Example 2:\n Input: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3 题目大意 #  删除链表中重复的结点，以保障每个结点只出现一次。\n解题思路 #  按照题意做即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { cur := head if head == nil { return nil } if head.Next == nil { return head } for cur.Next != nil { if cur.Next.Val == cur.Val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return head } "});index.add({'id':72,'href':'/leetcode-java/04_Leetcode/0084.Largest-Rectangle-in-Histogram/','title':"0084. Largest Rectangle in Histogram",'section':"第四章",'content':"84. Largest Rectangle in Histogram #  题目 #  Given n non-negative integers representing the histogram\u0026rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n The largest rectangle is shown in the shaded area, which has area = 10 unit.\nExample:\n Input: [2,1,5,6,2,3] Output: 10 题目大意 #  给出每个直方图的高度，要求在这些直方图之中找到面积最大的矩形，输出矩形的面积。\n解题思路 #  用单调栈依次保存直方图的高度下标，一旦出现高度比栈顶元素小的情况就取出栈顶元素，单独计算一下这个栈顶元素的矩形的高度。然后停在这里(外层循环中的 i\u0026ndash;，再 ++，就相当于停在这里了)，继续取出当前最大栈顶的前一个元素，即连续弹出 2 个最大的，以稍小的一个作为矩形的边，宽就是 2 计算面积…………如果停在这里的下标代表的高度一直比栈里面的元素小，就一直弹出，取出最后一个比当前下标大的高度作为矩形的边。宽就是最后一个比当前下标大的高度和当前下标 i 的差值。计算出面积以后不断的更新 maxArea 即可。\n代码 #  package leetcode import \u0026#34;fmt\u0026#34; func largestRectangleArea(heights []int) int { maxArea, stack, height := 0, []int{}, 0 for i := 0; i \u0026lt;= len(heights); i++ { if i == len(heights) { height = 0 } else { height = heights[i] } if len(stack) == 0 || height \u0026gt;= heights[stack[len(stack)-1]] { stack = append(stack, i) } else { tmp := stack[len(stack)-1] fmt.Printf(\u0026#34;1. tmp = %v stack = %v\\n\u0026#34;, tmp, stack) stack = stack[:len(stack)-1] length := 0 if len(stack) == 0 { length = i } else { length = i - 1 - stack[len(stack)-1] fmt.Printf(\u0026#34;2. length = %v stack = %v i = %v\\n\u0026#34;, length, stack, i) } maxArea = max(maxArea, heights[tmp]*length) fmt.Printf(\u0026#34;3. maxArea = %v heights[tmp]*length = %v\\n\u0026#34;, maxArea, heights[tmp]*length) i-- } } return maxArea } "});index.add({'id':73,'href':'/leetcode-java/04_Leetcode/0086.Partition-List/','title':"0086. Partition List",'section':"第四章",'content':"86. Partition List #  题目 #  Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample:\n Input: head = 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;2, x = 3 Output: 1-\u0026gt;2-\u0026gt;2-\u0026gt;4-\u0026gt;3-\u0026gt;5 题目大意 #  给定一个数 x，比 x 大或等于的数字都要排列在比 x 小的数字后面，并且相对位置不能发生变化。由于相对位置不能发生变化，所以不能用类似冒泡排序的思想。\n解题思路 #  这道题最简单的做法是构造双向链表，不过时间复杂度是 O(n^2)。\n(以下描述定义，大于等于 x 的都属于比 x 大)\n更优的方法是新构造 2 个链表，一个链表专门存储比 x 小的结点，另一个专门存储比 x 大的结点。在原链表头部开始扫描一边，依次把这两类点归类到 2 个新建链表中，有点入栈的意思。由于是从头开始扫描的原链表，所以原链表中的原有顺序会依旧被保存下来。最后 2 个新链表里面会存储好各自的结果，把这两个链表，比 x 小的链表拼接到 比 x 大的链表的前面，就能得到最后的答案了。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 单链表 func partition(head *ListNode, x int) *ListNode { beforeHead := \u0026amp;ListNode{Val: 0, Next: nil} before := beforeHead afterHead := \u0026amp;ListNode{Val: 0, Next: nil} after := afterHead for head != nil { if head.Val \u0026lt; x { before.Next = head before = before.Next } else { after.Next = head after = after.Next } head = head.Next } after.Next = nil before.Next = afterHead.Next return beforeHead.Next } // DoublyListNode define type DoublyListNode struct { Val int Prev *DoublyListNode Next *DoublyListNode } // 解法二 双链表 func partition1(head *ListNode, x int) *ListNode { if head == nil || head.Next == nil { return head } DLNHead := genDoublyListNode(head) cur := DLNHead for cur != nil { if cur.Val \u0026lt; x { tmp := \u0026amp;DoublyListNode{Val: cur.Val, Prev: nil, Next: nil} compareNode := cur for compareNode.Prev != nil { if compareNode.Val \u0026gt;= x \u0026amp;\u0026amp; compareNode.Prev.Val \u0026lt; x { break } compareNode = compareNode.Prev } if compareNode == DLNHead { if compareNode.Val \u0026lt; x { cur = cur.Next continue } else { tmp.Next = DLNHead DLNHead.Prev = tmp DLNHead = tmp } } else { tmp.Next = compareNode tmp.Prev = compareNode.Prev compareNode.Prev.Next = tmp compareNode.Prev = tmp } deleteNode := cur if cur.Prev != nil { deleteNode.Prev.Next = deleteNode.Next } if cur.Next != nil { deleteNode.Next.Prev = deleteNode.Prev } } cur = cur.Next } return genListNode(DLNHead) } func genDoublyListNode(head *ListNode) *DoublyListNode { cur := head.Next DLNHead := \u0026amp;DoublyListNode{Val: head.Val, Prev: nil, Next: nil} curDLN := DLNHead for cur != nil { tmp := \u0026amp;DoublyListNode{Val: cur.Val, Prev: curDLN, Next: nil} curDLN.Next = tmp curDLN = tmp cur = cur.Next } return DLNHead } func genListNode(head *DoublyListNode) *ListNode { cur := head.Next LNHead := \u0026amp;ListNode{Val: head.Val, Next: nil} curLN := LNHead for cur != nil { tmp := \u0026amp;ListNode{Val: cur.Val, Next: nil} curLN.Next = tmp curLN = tmp cur = cur.Next } return LNHead } "});index.add({'id':74,'href':'/leetcode-java/04_Leetcode/0088.Merge-Sorted-Array/','title':"0088. Merge Sorted Array",'section':"第四章",'content':"88. Merge Sorted Array #  题目 #  Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote:\n The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.  Example:\nInput: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  Constraints:\n -10^9 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^9 nums1.length == m + n nums2.length == n  题目大意 #  合并两个已经有序的数组，结果放在第一个数组中，第一个数组假设空间足够大。要求算法时间复杂度足够低。\n解题思路 #  为了不大量移动元素，就要从2个数组长度之和的最后一个位置开始，依次选取两个数组中大的数，从第一个数组的尾巴开始往头放，只要循环一次以后，就生成了合并以后的数组了。\n代码 #  package leetcode func merge(nums1 []int, m int, nums2 []int, n int) { if m == 0 { copy(nums1, nums2) return } // 这里不需要，因为测试数据考虑到了第一个数组的空间问题 \t// for index := 0; index \u0026lt; n; index++ { \t// nums1 = append(nums1, nums2[index]) \t// } \ti := m - 1 j := n - 1 k := m + n - 1 // 从后面往前放，只需要循环一次即可 \tfor ; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; k-- { if nums1[i] \u0026gt; nums2[j] { nums1[k] = nums1[i] i-- } else { nums1[k] = nums2[j] j-- } } for ; j \u0026gt;= 0; k-- { nums1[k] = nums2[j] j-- } } "});index.add({'id':75,'href':'/leetcode-java/04_Leetcode/0089.Gray-Code/','title':"0089. Gray Code",'section':"第四章",'content':"89. Gray Code #  题目 #  The gray code is a binary numeral system where two successive values differ in only one bit.\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\nExample 1:\nInput: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence. 00 - 0 10 - 2 11 - 3 01 - 1  Example 2:\nInput: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore, for n = 0 the gray code sequence is [0].  题目大意 #  格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。\n解题思路 #   输出 n 位格雷码 格雷码生成规则：以二进制为0值的格雷码为第零项，第一次改变最右边的位元，第二次改变右起第一个为1的位元的左边位元，第三、四次方法同第一、二次，如此反复，即可排列出 n 个位元的格雷码。 可以直接模拟，也可以用递归求解。  代码 #  package leetcode // 解法一 递归方法，时间复杂度和空间复杂度都较优 func grayCode(n int) []int { if n == 0 { return []int{0} } res := []int{} num := make([]int, n) generateGrayCode(int(1\u0026lt;\u0026lt;uint(n)), 0, \u0026amp;num, \u0026amp;res) return res } func generateGrayCode(n, step int, num *[]int, res *[]int) { if n == 0 { return } *res = append(*res, convertBinary(*num)) if step%2 == 0 { (*num)[len(*num)-1] = flipGrayCode((*num)[len(*num)-1]) } else { index := len(*num) - 1 for ; index \u0026gt;= 0; index-- { if (*num)[index] == 1 { break } } if index == 0 { (*num)[len(*num)-1] = flipGrayCode((*num)[len(*num)-1]) } else { (*num)[index-1] = flipGrayCode((*num)[index-1]) } } generateGrayCode(n-1, step+1, num, res) return } func convertBinary(num []int) int { res, rad := 0, 1 for i := len(num) - 1; i \u0026gt;= 0; i-- { res += num[i] * rad rad *= 2 } return res } func flipGrayCode(num int) int { if num == 0 { return 1 } return 0 } // 解法二 直译 func grayCode1(n int) []int { var l uint = 1 \u0026lt;\u0026lt; uint(n) out := make([]int, l) for i := uint(0); i \u0026lt; l; i++ { out[i] = int((i \u0026gt;\u0026gt; 1) ^ i) } return out } "});index.add({'id':76,'href':'/leetcode-java/04_Leetcode/0090.Subsets-II/','title':"0090. Subsets I I",'section':"第四章",'content':"90. Subsets II #  题目 #  Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]  题目大意 #  给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。\n解题思路 #   这一题是第 78 题的加强版，比第 78 题多了一个条件，数组中的数字会出现重复。 解题方法依旧是 DFS，需要在回溯的过程中加上一些判断。 这一题和第 78 题，第 491 题类似，可以一起解答和复习。  代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func subsetsWithDup(nums []int) [][]int { c, res := []int{}, [][]int{} sort.Ints(nums) // 这里是去重的关键逻辑 \tfor k := 0; k \u0026lt;= len(nums); k++ { generateSubsetsWithDup(nums, k, 0, c, \u0026amp;res) } return res } func generateSubsetsWithDup(nums []int, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.size()) + 1 \tfor i := start; i \u0026lt; len(nums)-(k-len(c))+1; i++ { fmt.Printf(\u0026#34;i = %v start = %v c = %v\\n\u0026#34;, i, start, c) if i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i-1] { // 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字 \tcontinue } c = append(c, nums[i]) generateSubsetsWithDup(nums, k, i+1, c, res) c = c[:len(c)-1] } return } "});index.add({'id':77,'href':'/leetcode-java/04_Leetcode/0091.Decode-Ways/','title':"0091. Decode Ways",'section':"第四章",'content':"91. Decode Ways #  题目 #  A message containing letters from A-Z is being encoded to numbers using the following mapping:\n'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26  Given a non-empty string containing only digits, determine the total number of ways to decode it.\nExample 1:\nInput: \u0026quot;12\u0026quot; Output: 2 Explanation: It could be decoded as \u0026quot;AB\u0026quot; (1 2) or \u0026quot;L\u0026quot; (12).  Example 2:\nInput: \u0026quot;226\u0026quot; Output: 3 Explanation: It could be decoded as \u0026quot;BZ\u0026quot; (2 26), \u0026quot;VF\u0026quot; (22 6), or \u0026quot;BBF\u0026quot; (2 2 6).  题目大意 #  一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\u0026#39;A\u0026#39; -\u0026gt; 1 \u0026#39;B\u0026#39; -\u0026gt; 2 ... \u0026#39;Z\u0026#39; -\u0026gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。\n解题思路 #   给出一个数字字符串，题目要求把数字映射成 26 个字母，映射以后问有多少种可能的翻译方法。 这题思路也是 DP。dp[n] 代表翻译长度为 n 个字符的字符串的方法总数。由于题目中的数字可能出现 0，0 不能翻译成任何字母，所以出现 0 要跳过。dp[0] 代表空字符串，只有一种翻译方法，dp[0] = 1。dp[1] 需要考虑原字符串是否是 0 开头的，如果是 0 开头的，dp[1] = 0，如果不是 0 开头的，dp[1] = 1。状态转移方程是 dp[i] += dp[i-1] (当 1 ≤ s[i-1 : i] ≤ 9)；dp[i] += dp[i-2] (当 10 ≤ s[i-2 : i] ≤ 26)。最终结果是 dp[n]。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) func numDecodings(s string) int { if len(s) == 0 { return 0 } dp := make([]int, len(s)+1) dp[0] = 1 if s[:1] == \u0026#34;0\u0026#34; { dp[1] = 0 } else { dp[1] = 1 } for i := 2; i \u0026lt;= len(s); i++ { lastNum, _ := strconv.Atoi(s[i-1 : i]) if lastNum \u0026gt;= 1 \u0026amp;\u0026amp; lastNum \u0026lt;= 9 { dp[i] += dp[i-1] } lastNum, _ = strconv.Atoi(s[i-2 : i]) if lastNum \u0026gt;= 10 \u0026amp;\u0026amp; lastNum \u0026lt;= 26 { dp[i] += dp[i-2] } } return dp[len(s)] } "});index.add({'id':78,'href':'/leetcode-java/04_Leetcode/0092.Reverse-Linked-List-II/','title':"0092. Reverse Linked List I I",'section':"第四章",'content':"92. Reverse Linked List II #  题目 #  Reverse a linked list from position m to n. Do it in one-pass.\nNote: 1 ≤ m ≤ n ≤ length of list.\nExample:\n Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL 题目大意 #  给定 2 个链表中结点的位置 m, n，反转这个两个位置区间内的所有结点。\n解题思路 #  由于有可能整个链表都被反转，所以构造一个新的头结点指向当前的头。之后的处理方法是：找到第一个需要反转的结点的前一个结点 p，从这个结点开始，依次把后面的结点用“头插”法，插入到 p 结点的后面。循环次数用 n-m 来控制。\n这一题结点可以原地变化，更改各个结点的 next 指针就可以。不需要游标 p 指针。因为每次逆序以后，原有结点的相对位置就发生了变化，相当于游标指针已经移动了，所以不需要再有游标 p = p.Next 的操作了。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseBetween(head *ListNode, m int, n int) *ListNode { if head == nil || m \u0026gt;= n { return head } newHead := \u0026amp;ListNode{Val: 0, Next: head} pre := newHead for count := 0; pre.Next != nil \u0026amp;\u0026amp; count \u0026lt; m-1; count++ { pre = pre.Next } if pre.Next == nil { return head } cur := pre.Next for i := 0; i \u0026lt; n-m; i++ { tmp := pre.Next pre.Next = cur.Next cur.Next = cur.Next.Next pre.Next.Next = tmp } return newHead.Next } "});index.add({'id':79,'href':'/leetcode-java/04_Leetcode/0093.Restore-IP-Addresses/','title':"0093. Restore I P Addresses",'section':"第四章",'content':"93. Restore IP Addresses #  题目 #  Given a string containing only digits, restore it by returning all possible valid IP address combinations.\nExample:\nInput: \u0026quot;25525511135\u0026quot; Output: [\u0026quot;255.255.11.135\u0026quot;, \u0026quot;255.255.111.35\u0026quot;]  题目大意 #  给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n解题思路 #   DFS 深搜 需要注意的点是 IP 的规则，以 0 开头的数字和超过 255 的数字都为非法的。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) func restoreIPAddresses(s string) []string { if s == \u0026#34;\u0026#34; { return []string{} } res, ip := []string{}, []int{} dfs(s, 0, ip, \u0026amp;res) return res } func dfs(s string, index int, ip []int, res *[]string) { if index == len(s) { if len(ip) == 4 { *res = append(*res, getString(ip)) } return } if index == 0 { num, _ := strconv.Atoi(string(s[0])) ip = append(ip, num) dfs(s, index+1, ip, res) } else { num, _ := strconv.Atoi(string(s[index])) next := ip[len(ip)-1]*10 + num if next \u0026lt;= 255 \u0026amp;\u0026amp; ip[len(ip)-1] != 0 { ip[len(ip)-1] = next dfs(s, index+1, ip, res) ip[len(ip)-1] /= 10 } if len(ip) \u0026lt; 4 { ip = append(ip, num) dfs(s, index+1, ip, res) ip = ip[:len(ip)-1] } } } func getString(ip []int) string { res := strconv.Itoa(ip[0]) for i := 1; i \u0026lt; len(ip); i++ { res += \u0026#34;.\u0026#34; + strconv.Itoa(ip[i]) } return res } "});index.add({'id':80,'href':'/leetcode-java/04_Leetcode/0094.Binary-Tree-Inorder-Traversal/','title':"0094. Binary Tree Inorder Traversal",'section':"第四章",'content':"94. 二叉树的中序遍历 #  Difficulty: 中等\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n示例 1：\n 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n输入：root = [] 输出：[] 示例 3：\n输入：root = [1] 输出：[1] 示例 4：\n 输入：root = [1,2] 输出：[2,1] 示例 5：\n 输入：root = [1,null,2] 输出：[1,2] 提示：\n 树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100  进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n题解 #  解法一：递归中序遍历 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;Integer\u0026gt;(); helper(root, result); return result; } private void helper(TreeNode node, List\u0026lt;Integer\u0026gt; result) { if (node == null) { return; } helper(node.left, result); result.add(node.val); helper(node.right, result); } } 解法二：Stack 数据结构 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;Integer\u0026gt;(); TreeNode cur = root; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;TreeNode\u0026gt;(); while (cur != null || !stack.isEmpty()) { while (cur != null) { stack.add(cur); cur = cur.left; } cur = stack.pop(); result.add(cur.val); cur = cur.right; } return result; } } "});index.add({'id':81,'href':'/leetcode-java/04_Leetcode/0095.Unique-Binary-Search-Trees-II/','title':"0095. Unique Binary Search Trees I I",'section':"第四章",'content':"95. Unique Binary Search Trees II #  题目 #  Given an integer n, generate all structurally unique BST\u0026rsquo;s (binary search trees) that store values 1 \u0026hellip; n.\nExample:\nInput: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3  题目大意 #  给定一个整数 n，生成所有由 1 \u0026hellip; n 为节点所组成的二叉搜索树。\n解题思路 #   输出 1~n 元素组成的 BST 所有解。这一题递归求解即可。外层循环遍历 1~n 所有结点，作为根结点，内层双层递归分别求出左子树和右子树。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func generateTrees(n int) []*TreeNode { if n == 0 { return []*TreeNode{} } return generateBSTree(1, n) } func generateBSTree(start, end int) []*TreeNode { tree := []*TreeNode{} if start \u0026gt; end { tree = append(tree, nil) return tree } for i := start; i \u0026lt;= end; i++ { left := generateBSTree(start, i-1) right := generateBSTree(i+1, end) for _, l := range left { for _, r := range right { root := \u0026amp;TreeNode{Val: i, Left: l, Right: r} tree = append(tree, root) } } } return tree } "});index.add({'id':82,'href':'/leetcode-java/04_Leetcode/0096.Unique-Binary-Search-Trees/','title':"0096. Unique Binary Search Trees",'section':"第四章",'content':"96. 不同的二叉搜索树 #  Difficulty: 中等\n给定一个整数 n，求以 1 \u0026hellip; n 为节点组成的二叉搜索树有多少种？\n示例:\n输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\  / / / \\  \\  3 2 1 1 3 2 / / \\  \\  2 1 2 3 题解 #  题解一：DP（动态规划） #  class Solution { public int numTrees(int n) { int[] result = new int[n + 1]; result[0] = 1; result[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { result[i] += result[j - 1] * result[i - j]; } } return result[n]; } } 复杂度分析\n  时间复杂度：O(n2)。\n  空间复杂度：O(n)。\n  "});index.add({'id':83,'href':'/leetcode-java/04_Leetcode/0098.Validate-Binary-Search-Tree/','title':"0098. Validate Binary Search Tree",'section':"第四章",'content':"98. Validate Binary Search Tree #  题目 #  Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  xample 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  题目大意 #  给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：\n 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。  解题思路 #   判断一个树是否是 BST，按照定义递归判断即可  代码 #  package leetcode import \u0026#34;math\u0026#34; /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一，直接按照定义比较大小，比 root 节点小的都在左边，比 root 节点大的都在右边 func isValidBST(root *TreeNode) bool { return isValidbst(root, math.Inf(-1), math.Inf(1)) } func isValidbst(root *TreeNode, min, max float64) bool { if root == nil { return true } v := float64(root.Val) return v \u0026lt; max \u0026amp;\u0026amp; v \u0026gt; min \u0026amp;\u0026amp; isValidbst(root.Left, min, v) \u0026amp;\u0026amp; isValidbst(root.Right, v, max) } // 解法二，把 BST 按照左中右的顺序输出到数组中，如果是 BST，则数组中的数字是从小到大有序的，如果出现逆序就不是 BST func isValidBST1(root *TreeNode) bool { arr := []int{} inOrder(root, \u0026amp;arr) for i := 1; i \u0026lt; len(arr); i++ { if arr[i-1] \u0026gt;= arr[i] { return false } } return true } func inOrder(root *TreeNode, arr *[]int) { if root == nil { return } inOrder(root.Left, arr) *arr = append(*arr, root.Val) inOrder(root.Right, arr) } "});index.add({'id':84,'href':'/leetcode-java/04_Leetcode/0099.Recover-Binary-Search-Tree/','title':"0099. Recover Binary Search Tree",'section':"第四章",'content':"99. Recover Binary Search Tree #  题目 #  Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nExample 1:\nInput: [1,3,null,null,2] 1 / 3 \\ 2 Output: [3,1,null,null,2] 3 / 1 \\ 2  Example 2:\nInput: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3  Follow up:\n A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?  题目大意 #  二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\n解题思路 #   在二叉搜索树中，有 2 个结点的值出错了，要求修复这两个结点。 这一题按照先根遍历 1 次就可以找到这两个出问题的结点，因为先访问根节点，然后左孩子，右孩子。用先根遍历二叉搜索树的时候，根结点比左子树都要大，根结点比右子树都要小。所以左子树比根结点大的话，就是出现了乱序；根节点比右子树大的话，就是出现了乱序。遍历过程中在左子树中如果出现了前一次遍历的结点的值大于此次根节点的值，这就出现了出错结点了，记录下来。继续遍历直到找到第二个这样的结点。最后交换这两个结点的时候，只是交换他们的值就可以了，而不是交换这两个结点相应的指针指向。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func recoverTree(root *TreeNode) { var prev, target1, target2 *TreeNode _, target1, target2 = inOrderTraverse(root, prev, target1, target2) if target1 != nil \u0026amp;\u0026amp; target2 != nil { target1.Val, target2.Val = target2.Val, target1.Val } } func inOrderTraverse(root, prev, target1, target2 *TreeNode) (*TreeNode, *TreeNode, *TreeNode) { if root == nil { return prev, target1, target2 } prev, target1, target2 = inOrderTraverse(root.Left, prev, target1, target2) if prev != nil \u0026amp;\u0026amp; prev.Val \u0026gt; root.Val { if target1 == nil { target1 = prev } target2 = root } prev = root prev, target1, target2 = inOrderTraverse(root.Right, prev, target1, target2) return prev, target1, target2 } "});index.add({'id':85,'href':'/leetcode-java/04_Leetcode/0100.Same-Tree/','title':"0100. Same Tree",'section':"第四章",'content':"100. Same Tree #  题目 #  Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nExample 1:\n Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2:\n Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3:\n Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false 题目大意 #  这一题要求判断 2 颗树是否是完全相等的。\n解题思路 #  递归判断即可。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } else if p != nil \u0026amp;\u0026amp; q != nil { if p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } else { return false } } "});index.add({'id':86,'href':'/leetcode-java/04_Leetcode/0101.Symmetric-Tree/','title':"0101. Symmetric Tree",'section':"第四章",'content':"101. Symmetric Tree #  题目 #  Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3 Note:\nBonus points if you could solve it both recursively and iteratively.\n题目大意 #  这一题要求判断 2 颗树是否是左右对称的。\n解题思路 #   这道题是几道题的综合题。将根节点的左字数反转二叉树，然后再和根节点的右节点进行比较，是否完全相等。 反转二叉树是第 226 题。判断 2 颗树是否完全相等是第 100 题。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSameTree(invertTree(root.Left), root.Right) } "});index.add({'id':87,'href':'/leetcode-java/04_Leetcode/0102.Binary-Tree-Level-Order-Traversal/','title':"0102. Binary Tree Level Order Traversal",'section':"第四章",'content':"102. Binary Tree Level Order Traversal #  题目 #  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\nFor Example:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its level order traversal as:\n [ [3], [9,20], [15,7] ] 题目大意 #  按层序从上到下遍历一颗树。\n解题思路 #  用一个队列即可实现。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 BFS func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } queue := []*TreeNode{} queue = append(queue, root) curNum, nextLevelNum, res, tmp := 1, 0, [][]int{}, []int{} for len(queue) != 0 { if curNum \u0026gt; 0 { node := queue[0] if node.Left != nil { queue = append(queue, node.Left) nextLevelNum++ } if node.Right != nil { queue = append(queue, node.Right) nextLevelNum++ } curNum-- tmp = append(tmp, node.Val) queue = queue[1:] } if curNum == 0 { res = append(res, tmp) curNum = nextLevelNum nextLevelNum = 0 tmp = []int{} } } return res } // 解法二 DFS func levelOrder1(root *TreeNode) [][]int { levels := [][]int{} dfsLevel(root, -1, \u0026amp;levels) return levels } func dfsLevel(node *TreeNode, level int, res *[][]int) { if node == nil { return } currLevel := level + 1 for len(*res) \u0026lt;= currLevel { *res = append(*res, []int{}) } (*res)[currLevel] = append((*res)[currLevel], node.Val) dfsLevel(node.Left, currLevel, res) dfsLevel(node.Right, currLevel, res) } "});index.add({'id':88,'href':'/leetcode-java/04_Leetcode/0103.Binary-Tree-Zigzag-Level-Order-Traversal/','title':"0103. Binary Tree Zigzag Level Order Traversal",'section':"第四章",'content':"103. 二叉树的锯齿形层次遍历 #  Difficulty: 中等\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下：\n[ [3], [20,9], [15,7] ] 题解 #  题解一：BFS（广度优先遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Deque\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.addLast(root); queue.addLast(null); LinkedList\u0026lt;Integer\u0026gt; levelList = new LinkedList\u0026lt;\u0026gt;(); boolean isOrderLeft = true; while (queue.size() \u0026gt; 0) { TreeNode currentNode = queue.pollFirst(); if (currentNode != null) { if (isOrderLeft) { levelList.addLast(currentNode.val); } else { levelList.addFirst(currentNode.val); } if (currentNode.left != null) { queue.addLast(currentNode.left); } if (currentNode.right != null) { queue.addLast(currentNode.right); } } else { result.add(levelList); levelList = new LinkedList\u0026lt;\u0026gt;(); if (queue.size() \u0026gt; 0) { queue.addLast(null); } isOrderLeft = !isOrderLeft; } } return result; } } 复杂度分析 #    时间复杂度：O(N)，其中 N 是树中节点的数量。\n  空间复杂度：O(N)，其中 N 是树中节点的数量。\n  解法二：DFS （深度优先遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { protected void DFS(TreeNode node, int level, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; results) { if (level \u0026gt;= results.size()) { LinkedList\u0026lt;Integer\u0026gt; newLevel = new LinkedList\u0026lt;Integer\u0026gt;(); newLevel.add(node.val); results.add(newLevel); } else { if (level % 2 == 0) results.get(level).add(node.val); else results.get(level).add(0, node.val); } if (node.left != null) DFS(node.left, level + 1, results); if (node.right != null) DFS(node.right, level + 1, results); } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { if (root == null) { return new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); } List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; results = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); DFS(root, 0, results); return results; } } 复杂度分析 #    时间复杂度：O(N)，其中 N 是树中节点的数量。\n  空间复杂度：O(H)，其中 H 是树的高度。\n  "});index.add({'id':89,'href':'/leetcode-java/04_Leetcode/0104.Maximum-Depth-of-Binary-Tree/','title':"0104. Maximum Depth of Binary Tree",'section':"第四章",'content':"104. Maximum Depth of Binary Tree #  题目 #  Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its depth = 3.\n题目大意 #  要求输出一棵树的最大高度。\n解题思路 #  这一题递归遍历就可，遍历根节点的左孩子的高度和根节点右孩子的高度，取出两者的最大值再加一即为总高度。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } "});index.add({'id':90,'href':'/leetcode-java/04_Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/','title':"0105. Construct Binary Tree From Preorder and Inorder Traversal",'section':"第四章",'content':"105. Construct Binary Tree from Preorder and Inorder Traversal #  题目 #  Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:You may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7] inorder = [9,3,15,20,7]  Return the following binary tree:\n 3 / \\ 9 20 / \\ 15 7  题目大意 #  根据一棵树的前序遍历与中序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n解题思路 #   给出 2 个数组，根据 preorder 和 inorder 数组构造一颗树。 利用递归思想，从 preorder 可以得到根节点，从 inorder 中得到左子树和右子树。只剩一个节点的时候即为根节点。不断的递归直到所有的树都生成完成。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { inPos := make(map[int]int) for i := 0; i \u0026lt; len(inorder); i++ { inPos[inorder[i]] = i } return buildPreIn2TreeDFS(preorder, 0, len(preorder)-1, 0, inPos) } func buildPreIn2TreeDFS(pre []int, preStart int, preEnd int, inStart int, inPos map[int]int) *TreeNode { if preStart \u0026gt; preEnd { return nil } root := \u0026amp;TreeNode{Val: pre[preStart]} rootIdx := inPos[pre[preStart]] leftLen := rootIdx - inStart root.Left = buildPreIn2TreeDFS(pre, preStart+1, preStart+leftLen, inStart, inPos) root.Right = buildPreIn2TreeDFS(pre, preStart+leftLen+1, preEnd, rootIdx+1, inPos) return root } "});index.add({'id':91,'href':'/leetcode-java/04_Leetcode/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/','title':"0106. Construct Binary Tree From Inorder and Postorder Traversal",'section':"第四章",'content':"106. Construct Binary Tree from Inorder and Postorder Traversal #  题目 #  Given inorder and postorder traversal of a tree, construct the binary tree.\nNote: You may assume that duplicates do not exist in the tree.\nFor example, given\ninorder = [9,3,15,20,7] postorder = [9,15,7,20,3]  Return the following binary tree:\n 3 / \\ 9 20 / \\ 15 7  题目大意 #  根据一棵树的中序遍历与后序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n解题思路 #   给出 2 个数组，根据 inorder 和 postorder 数组构造一颗树。 利用递归思想，从 postorder 可以得到根节点，从 inorder 中得到左子树和右子树。只剩一个节点的时候即为根节点。不断的递归直到所有的树都生成完成。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree106(inorder []int, postorder []int) *TreeNode { inPos := make(map[int]int) for i := 0; i \u0026lt; len(inorder); i++ { inPos[inorder[i]] = i } return buildInPos2TreeDFS(postorder, 0, len(postorder)-1, 0, inPos) } func buildInPos2TreeDFS(post []int, postStart int, postEnd int, inStart int, inPos map[int]int) *TreeNode { if postStart \u0026gt; postEnd { return nil } root := \u0026amp;TreeNode{Val: post[postEnd]} rootIdx := inPos[post[postEnd]] leftLen := rootIdx - inStart root.Left = buildInPos2TreeDFS(post, postStart, postStart+leftLen-1, inStart, inPos) root.Right = buildInPos2TreeDFS(post, postStart+leftLen, postEnd-1, rootIdx+1, inPos) return root } "});index.add({'id':92,'href':'/leetcode-java/04_Leetcode/0107.Binary-Tree-Level-Order-Traversal-II/','title':"0107. Binary Tree Level Order Traversal I I",'section':"第四章",'content':"107. Binary Tree Level Order Traversal II #  题目 #  Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\nFor Example:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as:\n [ [15,7], [9,20], [3] ] 题目大意 #  按层序从下到上遍历一颗树。\n解题思路 #  用一个队列即可实现。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrderBottom(root *TreeNode) [][]int { tmp := levelOrder(root) res := [][]int{} for i := len(tmp) - 1; i \u0026gt;= 0; i-- { res = append(res, tmp[i]) } return res } "});index.add({'id':93,'href':'/leetcode-java/04_Leetcode/0108.Convert-Sorted-Array-to-Binary-Search-Tree/','title':"0108. Convert Sorted Array to Binary Search Tree",'section':"第四章",'content':"108. Convert Sorted Array to Binary Search Tree #  题目 #  Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\nGiven the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5  题目大意 #  将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n解题思路 #   把一个有序数组转换成高度平衡的二叉搜索数，按照定义即可  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } return \u0026amp;TreeNode{Val: nums[len(nums)/2], Left: sortedArrayToBST(nums[:len(nums)/2]), Right: sortedArrayToBST(nums[len(nums)/2+1:])} } "});index.add({'id':94,'href':'/leetcode-java/04_Leetcode/0109.Convert-Sorted-List-to-Binary-Search-Tree/','title':"0109. Convert Sorted List to Binary Search Tree",'section':"第四章",'content':"109. Convert Sorted List to Binary Search Tree #  题目 #  Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\n Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 题目大意 #  将链表转化为高度平衡的二叉搜索树。高度平衡的定义：每个结点的 2 个子结点的深度不能相差超过 1 。\n解题思路 #  思路比较简单，依次把链表的中间点作为根结点，类似二分的思想，递归排列所有结点即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // TreeNode define type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } if head != nil \u0026amp;\u0026amp; head.Next == nil { return \u0026amp;TreeNode{Val: head.Val, Left: nil, Right: nil} } middleNode, preNode := middleNodeAndPreNode(head) if middleNode == nil { return nil } if preNode != nil { preNode.Next = nil } if middleNode == head { head = nil } return \u0026amp;TreeNode{Val: middleNode.Val, Left: sortedListToBST(head), Right: sortedListToBST(middleNode.Next)} } func middleNodeAndPreNode(head *ListNode) (middle *ListNode, pre *ListNode) { if head == nil || head.Next == nil { return nil, head } p1 := head p2 := head for p2.Next != nil \u0026amp;\u0026amp; p2.Next.Next != nil { pre = p1 p1 = p1.Next p2 = p2.Next.Next } return p1, pre } "});index.add({'id':95,'href':'/leetcode-java/04_Leetcode/0110.Balanced-Binary-Tree/','title':"0110. Balanced Binary Tree",'section':"第四章",'content':"110. 平衡二叉树 #  Difficulty: 简单\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n 一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过 1 。\n 示例 1：\n 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：\n 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：\n输入：root = [] 输出：true 提示：\n 树中的节点数在范围 [0, 5000] 内 -10\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt; \u0026lt;= Node.val \u0026lt;= 10\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt;  题解 #  解法一：递归求解（自顶向下） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } return Math.abs(height(root.left) - height(root.right)) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } private int height(TreeNode node) { if (node == null) { return 0; } return Math.max(height(node.left), height(node.right)) + 1; } }  时间复杂度：O(n2) 空间复杂度：O(n)  解法二：递归求解（自底向上） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isBalanced(TreeNode root) { return height(root) \u0026gt;= 0; } public int height(TreeNode root) { if (root == null) { return 0; } int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) \u0026gt; 1) { return -1; } else { return Math.max(leftHeight, rightHeight) + 1; } } }  时间复杂度：O(n) 空间复杂度：O(n)  "});index.add({'id':96,'href':'/leetcode-java/04_Leetcode/0111.Minimum-Depth-of-Binary-Tree/','title':"0111. Minimum Depth of Binary Tree",'section':"第四章",'content':"111. Minimum Depth of Binary Tree #  题目 #  Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return its minimum depth = 2.\n题目大意 #  给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。\n解题思路 #   递归求出根节点到叶子节点的深度，输出最小值即可  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil { return minDepth(root.Right) + 1 } if root.Right == nil { return minDepth(root.Left) + 1 } return min(minDepth(root.Left), minDepth(root.Right)) + 1 } "});index.add({'id':97,'href':'/leetcode-java/04_Leetcode/0112.Path-Sum/','title':"0112. Path Sum",'section':"第四章",'content':"112. 路径总和 #  Difficulty: 简单\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n说明: 叶子节点是指没有子节点的节点。\n示例: 给定如下二叉树，以及目标和 sum = 22，\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-\u0026gt;4-\u0026gt;11-\u0026gt;2。\n题解 #  题解一：递归求解 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return root.val == sum; } return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } } "});index.add({'id':98,'href':'/leetcode-java/04_Leetcode/0113.Path-Sum-II/','title':"0113. Path Sum I I",'section':"第四章",'content':"113. Path Sum II #  题目 #  Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum.\nNote: A leaf is a node with no children.\nExample:\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1  Return:\n[ [5,4,11,2], [5,8,4,5] ]  题目大意 #  给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。\n解题思路 #   这一题是第 257 题和第 112 题的组合增强版  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 func pathSum(root *TreeNode, sum int) [][]int { var slice [][]int slice = findPath(root, sum, slice, []int(nil)) return slice } func findPath(n *TreeNode, sum int, slice [][]int, stack []int) [][]int { if n == nil { return slice } sum -= n.Val stack = append(stack, n.Val) if sum == 0 \u0026amp;\u0026amp; n.Left == nil \u0026amp;\u0026amp; n.Right == nil { slice = append(slice, append([]int{}, stack...)) stack = stack[:len(stack)-1] } slice = findPath(n.Left, sum, slice, stack) slice = findPath(n.Right, sum, slice, stack) return slice } // 解法二 func pathSum1(root *TreeNode, sum int) [][]int { if root == nil { return [][]int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if sum == root.Val { return [][]int{[]int{root.Val}} } } path, res := []int{}, [][]int{} tmpLeft := pathSum(root.Left, sum-root.Val) path = append(path, root.Val) if len(tmpLeft) \u0026gt; 0 { for i := 0; i \u0026lt; len(tmpLeft); i++ { tmpLeft[i] = append(path, tmpLeft[i]...) } res = append(res, tmpLeft...) } path = []int{} tmpRight := pathSum(root.Right, sum-root.Val) path = append(path, root.Val) if len(tmpRight) \u0026gt; 0 { for i := 0; i \u0026lt; len(tmpRight); i++ { tmpRight[i] = append(path, tmpRight[i]...) } res = append(res, tmpRight...) } return res } "});index.add({'id':99,'href':'/leetcode-java/04_Leetcode/0114.Flatten-Binary-Tree-to-Linked-List/','title':"0114. Flatten Binary Tree to Linked List",'section':"第四章",'content':"114. Flatten Binary Tree to Linked List #  题目 #  Given a binary tree, flatten it to a linked list in-place.\nFor example, given the following tree:\n 1 / \\ 2 5 / \\ \\ 3 4 6  The flattened tree should look like:\n1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6  题目大意 #  给定一个二叉树，原地将它展开为链表。\n解题思路 #    要求把二叉树“打平”，按照先根遍历的顺序，把树的结点都放在右结点中。\n  按照递归和非递归思路实现即可。\n  递归的思路可以这么想：倒序遍历一颗树，即是先遍历右孩子，然后遍历左孩子，最后再遍历根节点。\n 1 / \\ 2 5 / \\ \\ 3 4 6 ----------- pre = 5 cur = 4 1 / 2 / \\ 3 4 \\ 5 \\ 6 ----------- pre = 4 cur = 3 1 / 2 / 3 \\ 4 \\ 5 \\ 6 ----------- cur = 2 pre = 3 1 / 2 \\ 3 \\ 4 \\ 5 \\ 6 ----------- cur = 1 pre = 2 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6    可以先仿造先根遍历的代码，写出这个倒序遍历的逻辑：\n public void flatten(TreeNode root) { if (root == null) return; flatten(root.right); flatten(root.left); }    实现了倒序遍历的逻辑以后，再进行结点之间的拼接：\n private TreeNode prev = null; public void flatten(TreeNode root) { if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; }    代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 非递归 func flatten(root *TreeNode) { list, cur := []int{}, \u0026amp;TreeNode{} preorder(root, \u0026amp;list) cur = root for i := 1; i \u0026lt; len(list); i++ { cur.Left = nil cur.Right = \u0026amp;TreeNode{Val: list[i], Left: nil, Right: nil} cur = cur.Right } return } // 解法二 递归 func flatten1(root *TreeNode) { if root == nil || (root.Left == nil \u0026amp;\u0026amp; root.Right == nil) { return } flatten(root.Left) flatten(root.Right) currRight := root.Right root.Right = root.Left root.Left = nil for root.Right != nil { root = root.Right } root.Right = currRight } // 解法三 递归 func flatten2(root *TreeNode) { if root == nil { return } flatten(root.Right) if root.Left == nil { return } flatten(root.Left) p := root.Left for p.Right != nil { p = p.Right } p.Right = root.Right root.Right = root.Left root.Left = nil } "});index.add({'id':100,'href':'/leetcode-java/04_Leetcode/0118.Pascals-Triangle/','title':"0118. Pascals Triangle",'section':"第四章",'content':"118. Pascal\u0026rsquo;s Triangle #  题目 #  Given a non-negative integer numRows, generate the first numRows of Pascal\u0026rsquo;s triangle.\n Note: In Pascal\u0026rsquo;s triangle, each number is the sum of the two numbers directly above it.\nExample:\nInput: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 题目大意 #  给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。\n解题思路 #   给定一个 n，要求打印杨辉三角的前 n 行。 简单题。按照杨辉三角的生成规则循环打印即可。  代码 #  package leetcode func generate(numRows int) [][]int { result := [][]int{} for i := 0; i \u0026lt; numRows; i++ { row := []int{} for j := 0; j \u0026lt; i+1; j++ { if j == 0 || j == i { row = append(row, 1) } else if i \u0026gt; 1 { row = append(row, result[i-1][j-1]+result[i-1][j]) } } result = append(result, row) } return result } "});index.add({'id':101,'href':'/leetcode-java/04_Leetcode/0120.Triangle/','title':"0120. Triangle",'section':"第四章",'content':"120. 三角形最小路径和 #  Difficulty: 中等\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。\n例如，给定三角形：\n[ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n说明：\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n题解 #  题解一 #  class Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[] dp = new int[n + 1]; for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j); } } return dp[0]; } } 复杂度分析 #    时间复杂度：O(n2)。\n  空间复杂度：O(n)。\n  "});index.add({'id':102,'href':'/leetcode-java/04_Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/','title':"0121. Best Time to Buy and Sell Stock",'section':"第四章",'content':"121. Best Time to Buy and Sell Stock #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nNote that you cannot sell a stock before you buy one.\nExample 1:\nInput: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2:\nInput: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  题目大意 #  给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。\n解题思路 #   题目要求找出股票中能赚的钱最多的差价 这一题也有多个解法，可以用 DP，也可以用单调栈  代码 #  package leetcode // 解法一 模拟 DP func maxProfit(prices []int) int { if len(prices) \u0026lt; 1 { return 0 } min, maxProfit := prices[0], 0 for i := 1; i \u0026lt; len(prices); i++ { if prices[i]-min \u0026gt; maxProfit { maxProfit = prices[i] - min } if prices[i] \u0026lt; min { min = prices[i] } } return maxProfit } // 解法二 单调栈 func maxProfit1(prices []int) int { if len(prices) == 0 { return 0 } stack, res := []int{prices[0]}, 0 for i := 1; i \u0026lt; len(prices); i++ { if prices[i] \u0026gt; stack[len(stack)-1] { stack = append(stack, prices[i]) } else { index := len(stack) - 1 for ; index \u0026gt;= 0; index-- { if stack[index] \u0026lt; prices[i] { break } } stack = stack[:index+1] stack = append(stack, prices[i]) } res = max(res, stack[len(stack)-1]-stack[0]) } return res } "});index.add({'id':103,'href':'/leetcode-java/04_Leetcode/0122.Best-Time-to-Buy-and-Sell-Stock-II/','title':"0122. Best Time to Buy and Sell Stock I I",'section':"第四章",'content':"122. Best Time to Buy and Sell Stock II #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2:\nInput: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.  Example 3:\nInput: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  题目大意 #  给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n解题思路 #   这一题是第 121 题的加强版。要求输出最大收益，这一题不止买卖一次，可以买卖多次，买卖不能在同一天内操作。 最大收益来源，必然是每次跌了就买入，涨到顶峰的时候就抛出。只要有涨峰就开始计算赚的钱，连续涨可以用两两相减累加来计算，两两相减累加，相当于涨到波峰的最大值减去谷底的值。这一点看通以后，题目非常简单。  代码 #  package leetcode func maxProfit122(prices []int) int { profit := 0 for i := 0; i \u0026lt; len(prices)-1; i++ { if prices[i+1] \u0026gt; prices[i] { profit += prices[i+1] - prices[i] } } return profit } "});index.add({'id':104,'href':'/leetcode-java/04_Leetcode/0124.Binary-Tree-Maximum-Path-Sum/','title':"0124. Binary Tree Maximum Path Sum",'section':"第四章",'content':"124. Binary Tree Maximum Path Sum #  题目 #  Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nExample 1:\nInput: [1,2,3] 1 / \\ 2 3 Output: 6  Example 2:\nInput: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42  题目大意 #  给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。\n解题思路 #   给出一个二叉树，要求找一条路径使得路径的和是最大的。 这一题思路比较简单，递归维护最大值即可。不过需要比较的对象比较多。maxPathSum(root) = max(maxPathSum(root.Left), maxPathSum(root.Right), maxPathSumFrom(root.Left) (if\u0026gt;0) + maxPathSumFrom(root.Right) (if\u0026gt;0) + root.Val) ，其中，maxPathSumFrom(root) = max(maxPathSumFrom(root.Left), maxPathSumFrom(root.Right)) + root.Val  代码 #  package leetcode import \u0026#34;math\u0026#34; /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxPathSum(root *TreeNode) int { if root == nil { return 0 } max := math.MinInt32 getPathSum(root, \u0026amp;max) return max } func getPathSum(root *TreeNode, maxSum *int) int { if root == nil { return math.MinInt32 } left := getPathSum(root.Left, maxSum) right := getPathSum(root.Right, maxSum) currMax := max(max(left+root.Val, right+root.Val), root.Val) *maxSum = max(*maxSum, max(currMax, left+right+root.Val)) return currMax } "});index.add({'id':105,'href':'/leetcode-java/04_Leetcode/0125.Valid-Palindrome/','title':"0125. Valid Palindrome",'section':"第四章",'content':"125. Valid Palindrome #  题目 #  Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nFor example,\n \u0026quot;A man, a plan, a canal: Panama\u0026quot; is a palindrome. \u0026quot;race a car\u0026quot; is not a palindrome. Note:\nHave you consider that the string might be empty? This is a good question to ask during an interview.\nFor the purpose of this problem, we define empty string as valid palindrome.\n题目大意 #  判断所给的字符串是否是有效的回文串。\n解题思路 #  简单题，按照题意做即可。\n代码 #  package leetcode import ( \u0026#34;strings\u0026#34; ) func isPalindrome(s string) bool { s = strings.ToLower(s) i, j := 0, len(s)-1 for i \u0026lt; j { for i \u0026lt; j \u0026amp;\u0026amp; !isChar(s[i]) { i++ } for i \u0026lt; j \u0026amp;\u0026amp; !isChar(s[j]) { j-- } if s[i] != s[j] { return false } i++ j-- } return true } // 判断 c 是否是字符或者数字 func isChar(c byte) bool { if (\u0026#39;a\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (\u0026#39;0\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return true } return false } "});index.add({'id':106,'href':'/leetcode-java/04_Leetcode/0126.Word-Ladder-II/','title':"0126. Word Ladder I I",'section':"第四章",'content':"126. Word Ladder II #  题目 #  Given two words (beginWord and endWord), and a dictionary\u0026rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\n Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:\n Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1:\nInput: beginWord = \u0026quot;hit\u0026quot;, endWord = \u0026quot;cog\u0026quot;, wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;] Output: [ [\u0026quot;hit\u0026quot;,\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;cog\u0026quot;], [\u0026quot;hit\u0026quot;,\u0026quot;hot\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;] ]  Example 2:\nInput: beginWord = \u0026quot;hit\u0026quot; endWord = \u0026quot;cog\u0026quot; wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;] Output: [] Explanation: The endWord \u0026quot;cog\u0026quot; is not in wordList, therefore no possible transformation.  题目大意 #  给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：\n 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。  说明:\n 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。  解题思路 #   这一题是第 127 题的加强版，除了找到路径的长度，还进一步要求输出所有路径。解题思路同第 127 题一样，也是用 BFS 遍历。 当前做法不是最优解，是否可以考虑双端 BFS 优化，或者迪杰斯塔拉算法？  代码 #  package leetcode func findLadders(beginWord string, endWord string, wordList []string) [][]string { result, wordMap := make([][]string, 0), make(map[string]bool) for _, w := range wordList { wordMap[w] = true } if !wordMap[endWord] { return result } // create a queue, track the path \tqueue := make([][]string, 0) queue = append(queue, []string{beginWord}) // queueLen is used to track how many slices in queue are in the same level \t// if found a result, I still need to finish checking current level cause I need to return all possible paths \tqueueLen := 1 // use to track strings that this level has visited \t// when queueLen == 0, remove levelMap keys in wordMap \tlevelMap := make(map[string]bool) for len(queue) \u0026gt; 0 { path := queue[0] queue = queue[1:] lastWord := path[len(path)-1] for i := 0; i \u0026lt; len(lastWord); i++ { for c := \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++ { nextWord := lastWord[:i] + string(c) + lastWord[i+1:] if nextWord == endWord { path = append(path, endWord) result = append(result, path) continue } if wordMap[nextWord] { // different from word ladder, don\u0026#39;t remove the word from wordMap immediately \t// same level could reuse the key. \t// delete from wordMap only when currently level is done. \tlevelMap[nextWord] = true newPath := make([]string, len(path)) copy(newPath, path) newPath = append(newPath, nextWord) queue = append(queue, newPath) } } } queueLen-- // if queueLen is 0, means finish traversing current level. if result is not empty, return result \tif queueLen == 0 { if len(result) \u0026gt; 0 { return result } for k := range levelMap { delete(wordMap, k) } // clear levelMap \tlevelMap = make(map[string]bool) queueLen = len(queue) } } return result } "});index.add({'id':107,'href':'/leetcode-java/04_Leetcode/0127.Word-Ladder/','title':"0127. Word Ladder",'section':"第四章",'content':"127. Word Ladder #  题目 #  Given two words (beginWord and endWord), and a dictionary\u0026rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:\n Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1:\nInput: beginWord = \u0026quot;hit\u0026quot;, endWord = \u0026quot;cog\u0026quot;, wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;] Output: 5 Explanation: As one shortest transformation is \u0026quot;hit\u0026quot; -\u0026gt; \u0026quot;hot\u0026quot; -\u0026gt; \u0026quot;dot\u0026quot; -\u0026gt; \u0026quot;dog\u0026quot; -\u0026gt; \u0026quot;cog\u0026quot;, return its length 5.  Example 2:\nInput: beginWord = \u0026quot;hit\u0026quot; endWord = \u0026quot;cog\u0026quot; wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;] Output: 0 Explanation: The endWord \u0026quot;cog\u0026quot; is not in wordList, therefore no possible transformation.  题目大意 #  给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：\n 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。  说明:\n 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。  解题思路 #   这一题要求输出从 beginWord 变换到 endWord 最短变换次数。可以用 BFS，从 beginWord 开始变换，把该单词的每个字母都用 'a'~'z' 变换一次，生成的数组到 wordList 中查找，这里用 Map 来记录查找。找得到就入队列，找不到就输出 0 。入队以后按照 BFS 的算法依次遍历完，当所有单词都 len(queue)\u0026lt;=0 出队以后，整个程序结束。 这一题题目中虽然说了要求找到一条最短的路径，但是实际上最短的路径的寻找方法已经告诉你了：  每次只变换一个字母 每次变换都必须在 wordList 中\n所以不需要单独考虑何种方式是最短的。    代码 #  package leetcode func ladderLength(beginWord string, endWord string, wordList []string) int { wordMap, que, depth := getWordMap(wordList, beginWord), []string{beginWord}, 0 for len(que) \u0026gt; 0 { depth++ qlen := len(que) for i := 0; i \u0026lt; qlen; i++ { word := que[0] que = que[1:] candidates := getCandidates(word) for _, candidate := range candidates { if _, ok := wordMap[candidate]; ok { if candidate == endWord { return depth + 1 } delete(wordMap, candidate) que = append(que, candidate) } } } } return 0 } func getWordMap(wordList []string, beginWord string) map[string]int { wordMap := make(map[string]int) for i, word := range wordList { if _, ok := wordMap[word]; !ok { if word != beginWord { wordMap[word] = i } } } return wordMap } func getCandidates(word string) []string { var res []string for i := 0; i \u0026lt; 26; i++ { for j := 0; j \u0026lt; len(word); j++ { if word[j] != byte(int(\u0026#39;a\u0026#39;)+i) { res = append(res, word[:j]+string(int(\u0026#39;a\u0026#39;)+i)+word[j+1:]) } } } return res } "});index.add({'id':108,'href':'/leetcode-java/04_Leetcode/0128.Longest-Consecutive-Sequence/','title':"0128. Longest Consecutive Sequence",'section':"第四章",'content':"128. Longest Consecutive Sequence #  题目 #  Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  题目大意 #  给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。\n解题思路 #   给出一个数组，要求找出最长连续序列，输出这个最长的长度。要求时间复杂度为 O(n)。 这一题可以先用暴力解决解决，代码见解法三。思路是把每个数都存在 map 中，先删去 map 中没有前一个数 nums[i]-1 也没有后一个数 nums[i]+1 的数 nums[i]，这种数前后都不连续。然后在 map 中找到前一个数 nums[i]-1 不存在，但是后一个数 nums[i]+1 存在的数，这种数是连续序列的起点，那么不断的往后搜，直到序列“断”了。最后输出最长序列的长度。 这一题最优的解法是解法一，针对每一个 map 中不存在的数 n，插入进去都做 2 件事情。第一件事，先查看 n - 1 和 n + 1 是否都存在于 map 中，如果都存在，代表存在连续的序列，那么就更新 left，right 边界。那么 n 对应的这个小的子连续序列长度为 sum = left + right + 1。第二件事就是更新 left 和 right 左右边界对应的 length = sum。 这一题还可以用并查集解决，见解法二。利用每个数在 nums 中的下标，把下标和下标进行 union()，具体做法是看前一个数 nums[i]-1 和后一个数 nums[i]+1 在 map 中是否存在，如果存在就 union()，最终输出整个并查集中包含最多元素的那个集合的元素总数。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 map，时间复杂度 O(n) func longestConsecutive(nums []int) int { res, numMap := 0, map[int]int{} for _, num := range nums { if numMap[num] == 0 { left, right, sum := 0, 0, 0 if numMap[num-1] \u0026gt; 0 { left = numMap[num-1] } else { left = 0 } if numMap[num+1] \u0026gt; 0 { right = numMap[num+1] } else { right = 0 } // sum: length of the sequence n is in \tsum = left + right + 1 numMap[num] = sum // keep track of the max length \tres = max(res, sum) // extend the length to the boundary(s) of the sequence \t// will do nothing if n has no neighbors \tnumMap[num-left] = sum numMap[num+right] = sum } else { continue } } return res } // 解法二 并查集 func longestConsecutive1(nums []int) int { if len(nums) == 0 { return 0 } numMap, countMap, lcs, uf := map[int]int{}, map[int]int{}, 0, template.UnionFind{} uf.Init(len(nums)) for i := 0; i \u0026lt; len(nums); i++ { countMap[i] = 1 } for i := 0; i \u0026lt; len(nums); i++ { if _, ok := numMap[nums[i]]; ok { continue } numMap[nums[i]] = i if _, ok := numMap[nums[i]+1]; ok { uf.Union(i, numMap[nums[i]+1]) } if _, ok := numMap[nums[i]-1]; ok { uf.Union(i, numMap[nums[i]-1]) } } for key := range countMap { parent := uf.Find(key) if parent != key { countMap[parent]++ } if countMap[parent] \u0026gt; lcs { lcs = countMap[parent] } } return lcs } // 解法三 暴力解法，时间复杂度 O(n^2) func longestConsecutive2(nums []int) int { if len(nums) == 0 { return 0 } numMap, length, tmp, lcs := map[int]bool{}, 0, 0, 0 for i := 0; i \u0026lt; len(nums); i++ { numMap[nums[i]] = true } for key := range numMap { if !numMap[key-1] \u0026amp;\u0026amp; !numMap[key+1] { delete(numMap, key) } } if len(numMap) == 0 { return 1 } for key := range numMap { if !numMap[key-1] \u0026amp;\u0026amp; numMap[key+1] { length, tmp = 1, key+1 for numMap[tmp] { length++ tmp++ } lcs = max(lcs, length) } } return max(lcs, length) } "});index.add({'id':109,'href':'/leetcode-java/04_Leetcode/0129.Sum-Root-to-Leaf-Numbers/','title':"0129. Sum Root to Leaf Numbers",'section':"第四章",'content':"129. 求根到叶子节点数字之和 #  Difficulty: 中等\n给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。\n例如，从根到叶子节点路径 1-\u0026gt;2-\u0026gt;3 代表数字 123。\n计算从根到叶子节点生成的所有数字之和。\n说明: 叶子节点是指没有子节点的节点。\n示例 1:\n输入: [1,2,3] 1 / \\  2 3 输出: 25 解释: 从根到叶子节点路径 1-\u0026gt;2 代表数字 12. 从根到叶子节点路径 1-\u0026gt;3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2:\n输入: [4,9,0,5,1] 4 / \\  9 0 / \\ 5 1 输出: 1026 解释: 从根到叶子节点路径 4-\u0026gt;9-\u0026gt;5 代表数字 495. 从根到叶子节点路径 4-\u0026gt;9-\u0026gt;1 代表数字 491. 从根到叶子节点路径 4-\u0026gt;0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. 题解 #  题解一：DFS（深度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int sumNumbers(TreeNode root) { return helper(root, 0); } private int helper(TreeNode node, int prevSum) { if (node == null) { return 0; } int sum = prevSum * 10 + node.val; if (node.left == null \u0026amp;\u0026amp; node.right == null) { return sum; } else { return helper(node.left, sum) + helper(node.right, sum); } } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(n)。\n  "});index.add({'id':110,'href':'/leetcode-java/04_Leetcode/0130.Surrounded-Regions/','title':"0130. Surrounded Regions",'section':"第四章",'content':"130. Surrounded Regions #  题目 #  Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\nExample:\nX X X X X O O X X X O X X O X X  After running your function, the board should be:\nX X X X X X X X X X X X X O X X  Explanation:\nSurrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n题目大意 #  给定一个二维的矩阵，包含 \u0026lsquo;X\u0026rsquo; 和 \u0026lsquo;O\u0026rsquo;（字母 O）。找到所有被 \u0026lsquo;X\u0026rsquo; 围绕的区域，并将这些区域里所有的 \u0026lsquo;O\u0026rsquo; 用 \u0026lsquo;X\u0026rsquo; 填充。被围绕的区间不会存在于边界上，换句话说，任何边界上的 \u0026lsquo;O\u0026rsquo; 都不会被填充为 \u0026lsquo;X\u0026rsquo;。 任何不在边界上，或不与边界上的 \u0026lsquo;O\u0026rsquo; 相连的 \u0026lsquo;O\u0026rsquo; 最终都会被填充为 \u0026lsquo;X\u0026rsquo;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n解题思路 #   给出一张二维地图，要求把地图上非边缘上的 \u0026lsquo;O\u0026rsquo; 都用 \u0026lsquo;X\u0026rsquo; 覆盖掉。 这一题有多种解法。第一种解法是并查集。先将边缘上的 \u0026lsquo;O\u0026rsquo; 全部都和一个特殊的点进行 union() 。然后再把地图中间的 \u0026lsquo;O\u0026rsquo; 都进行 union()，最后把和特殊点不是同一个集合的点都标记成 \u0026lsquo;X\u0026rsquo;。第二种解法是 DFS 或者 BFS，可以先将边缘上的 \u0026lsquo;O\u0026rsquo; 先标记成另外一个字符，然后在递归遍历过程中，把剩下的 \u0026lsquo;O\u0026rsquo; 都标记成 \u0026lsquo;X\u0026rsquo;。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 并查集 func solve(board [][]byte) { if len(board) == 0 { return } m, n := len(board[0]), len(board) uf := template.UnionFind{} uf.Init(n*m + 1) // 特意多一个特殊点用来标记  for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; m; j++ { if (i == 0 || i == n-1 || j == 0 || j == m-1) \u0026amp;\u0026amp; board[i][j] == \u0026#39;O\u0026#39; { //棋盘边缘上的 \u0026#39;O\u0026#39; 点 \tuf.Union(i*m+j, n*m) } else if board[i][j] == \u0026#39;O\u0026#39; { //棋盘非边缘上的内部的 \u0026#39;O\u0026#39; 点 \tif board[i-1][j] == \u0026#39;O\u0026#39; { uf.Union(i*m+j, (i-1)*m+j) } if board[i+1][j] == \u0026#39;O\u0026#39; { uf.Union(i*m+j, (i+1)*m+j) } if board[i][j-1] == \u0026#39;O\u0026#39; { uf.Union(i*m+j, i*m+j-1) } if board[i][j+1] == \u0026#39;O\u0026#39; { uf.Union(i*m+j, i*m+j+1) } } } } for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; m; j++ { if uf.Find(i*m+j) != uf.Find(n*m) { board[i][j] = \u0026#39;X\u0026#39; } } } } // 解法二 DFS func solve1(board [][]byte) { for i := range board { for j := range board[i] { if i == 0 || i == len(board)-1 || j == 0 || j == len(board[i])-1 { if board[i][j] == \u0026#39;O\u0026#39; { dfs130(i, j, board) } } } } for i := range board { for j := range board[i] { if board[i][j] == \u0026#39;*\u0026#39; { board[i][j] = \u0026#39;O\u0026#39; } else if board[i][j] == \u0026#39;O\u0026#39; { board[i][j] = \u0026#39;X\u0026#39; } } } } func dfs130(i, j int, board [][]byte) { if i \u0026lt; 0 || i \u0026gt; len(board)-1 || j \u0026lt; 0 || j \u0026gt; len(board[i])-1 { return } if board[i][j] == \u0026#39;O\u0026#39; { board[i][j] = \u0026#39;*\u0026#39; for k := 0; k \u0026lt; 4; k++ { dfs130(i+dir[k][0], j+dir[k][1], board) } } } "});index.add({'id':111,'href':'/leetcode-java/04_Leetcode/0131.Palindrome-Partitioning/','title':"0131. Palindrome Partitioning",'section':"第四章",'content':"131. Palindrome Partitioning #  题目 #  Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn all possible palindrome partitioning of s.\nExample:\nInput: \u0026quot;aab\u0026quot; Output: [ [\u0026quot;aa\u0026quot;,\u0026quot;b\u0026quot;], [\u0026quot;a\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;] ]  题目大意 #  给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。\n解题思路 #   要求输出一个字符串可以被拆成回文串的所有解，DFS 递归求解即可。  代码 #  package leetcode // 解法一 func partition131(s string) [][]string { if s == \u0026#34;\u0026#34; { return [][]string{} } res, pal := [][]string{}, []string{} findPalindrome(s, 0, \u0026#34;\u0026#34;, true, pal, \u0026amp;res) return res } func findPalindrome(str string, index int, s string, isPal bool, pal []string, res *[][]string) { if index == len(str) { if isPal { tmp := make([]string, len(pal)) copy(tmp, pal) *res = append(*res, tmp) } return } if index == 0 { s = string(str[index]) pal = append(pal, s) findPalindrome(str, index+1, s, isPal \u0026amp;\u0026amp; isPalindrome131(s), pal, res) } else { temp := pal[len(pal)-1] s = pal[len(pal)-1] + string(str[index]) pal[len(pal)-1] = s findPalindrome(str, index+1, s, isPalindrome131(s), pal, res) pal[len(pal)-1] = temp if isPalindrome131(temp) { pal = append(pal, string(str[index])) findPalindrome(str, index+1, temp, isPal \u0026amp;\u0026amp; isPalindrome131(temp), pal, res) pal = pal[:len(pal)-1] } } return } func isPalindrome131(s string) bool { slen := len(s) for i, j := 0, slen-1; i \u0026lt; j; i, j = i+1, j-1 { if s[i] != s[j] { return false } } return true } // 解法二 func partition131_1(s string) [][]string { result := [][]string{} size := len(s) if size == 0 { return result } current := make([]string, 0, size) dfs131(s, 0, current, \u0026amp;result) return result } func dfs131(s string, idx int, cur []string, result *[][]string) { start, end := idx, len(s) if start == end { temp := make([]string, len(cur)) copy(temp, cur) *result = append(*result, temp) return } for i := start; i \u0026lt; end; i++ { if isPal(s, start, i) { dfs131(s, i+1, append(cur, s[start:i+1]), result) } } } func isPal(str string, s, e int) bool { for s \u0026lt; e { if str[s] != str[e] { return false } s++ e-- } return true } "});index.add({'id':112,'href':'/leetcode-java/04_Leetcode/0136.Single-Number/','title':"0136. Single Number",'section':"第四章",'content':"136. Single Number #  题目 #  Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1] Output: 1  Example 2:\nInput: [4,1,2,1,2] Output: 4  题目大意 #  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。\n解题思路 #   题目要求不能使用辅助空间，并且时间复杂度只能是线性的。 题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现依次的数字，因为那些出现两次的数字全部在异或中抵消掉了。于是最终做法是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。利用的性质是 x^x = 0。  代码 #  package leetcode func singleNumber(nums []int) int { result := 0 for i := 0; i \u0026lt; len(nums); i++ { result ^= nums[i] } return result } "});index.add({'id':113,'href':'/leetcode-java/04_Leetcode/0137.Single-Number-II/','title':"0137. Single Number I I",'section':"第四章",'content':"137. Single Number II #  题目 #  Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,3,2] Output: 3  Example 2:\nInput: [0,1,0,1,0,1,99] Output: 99  题目大意 #  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。\n解题思路 #   这一题是第 136 题的加强版。这类题也可以扩展，在数组中每个元素都出现 5 次，找出只出现 1 次的数。 本题中要求找出只出现 1 次的数，出现 3 次的数都要被消除。第 136 题是消除出现 2 次的数。这一题也会相当相同的解法，出现 3 次的数也要被消除。定义状态，00、10、01，这 3 个状态。当一个数出现 3 次，那么它每个位置上的 1 出现的次数肯定是 3 的倍数，所以当 1 出现 3 次以后，就归零清除。如何能做到这点呢？仿造三进制(00，10，01) 就可以做到。 变量 ones 中记录遍历中每个位上出现 1 的个数。将它与 A[i] 进行异或，目的是：  每位上两者都是 1 的，表示历史统计结果 ones 出现1次、A[i]中又出现1次，则是出现 2 次，需要进位到 twos 变量中。 每位上两者分别为 0、1 的，加入到 ones 统计结果中。 最后还要 \u0026amp; ^twos ，是为了能做到三进制，出现 3 次就清零。例如 ones = x，那么 twos = 0，当 twos = x，那么 ones = 0；   变量 twos 中记录遍历中每个位上出现 1 ，2次 的个数。与 A[i] 进行异或的目的和上述描述相同，不再赘述。   在 golang 中，\u0026amp;^ 表示 AND NOT 的意思。这里的 ^ 作为一元操作符，表示按位取反 (^0001 0100 = 1110 1011)，X \u0026amp;^ Y 的意思是将 X 中与 Y 相异的位保留，相同的位清零。\n  在 golang 中没有 Java 中的 ~ 位操作运算符，Java 中的 ~ 运算符代表按位取反。这个操作就想当于 golang 中的 ^ 运算符当做一元运算符使用的效果。\n 这一题还可以继续扩展，在数组中每个元素都出现 5 次，找出只出现 1 次的数。那该怎么做呢？思路还是一样的，模拟一个五进制，5 次就会消除。代码如下：\n// 解法一 func singleNumberIII(nums []int) int { na, nb, nc := 0, 0, 0 for i := 0; i \u0026lt; len(nums); i++ { nb = nb ^ (nums[i] \u0026amp; na) na = (na ^ nums[i]) \u0026amp; ^nc nc = nc ^ (nums[i] \u0026amp; ^na \u0026amp; ^nb) } return na \u0026amp; ^nb \u0026amp; ^nc } // 解法二 func singleNumberIIII(nums []int) int { twos, threes, ones := 0xffffffff, 0xffffffff, 0 for i := 0; i \u0026lt; len(nums); i++ { threes = threes ^ (nums[i] \u0026amp; twos) twos = (twos ^ nums[i]) \u0026amp; ^ones ones = ones ^ (nums[i] \u0026amp; ^twos \u0026amp; ^threes) } return ones }  代码 #  package leetcode func singleNumberII(nums []int) int { ones, twos := 0, 0 for i := 0; i \u0026lt; len(nums); i++ { ones = (ones ^ nums[i]) \u0026amp; ^twos twos = (twos ^ nums[i]) \u0026amp; ^ones } return ones } // 以下是拓展题 // 在数组中每个元素都出现 5 次，找出只出现 1 次的数。  // 解法一 func singleNumberIIIII(nums []int) int { na, nb, nc := 0, 0, 0 for i := 0; i \u0026lt; len(nums); i++ { nb = nb ^ (nums[i] \u0026amp; na) na = (na ^ nums[i]) \u0026amp; ^nc nc = nc ^ (nums[i] \u0026amp; ^na \u0026amp; ^nb) } return na \u0026amp; ^nb \u0026amp; ^nc } // 解法二 func singleNumberIIIII1(nums []int) int { twos, threes, ones := 0xffffffff, 0xffffffff, 0 for i := 0; i \u0026lt; len(nums); i++ { threes = threes ^ (nums[i] \u0026amp; twos) twos = (twos ^ nums[i]) \u0026amp; ^ones ones = ones ^ (nums[i] \u0026amp; ^twos \u0026amp; ^threes) } return ones } "});index.add({'id':114,'href':'/leetcode-java/04_Leetcode/0141.Linked-List-Cycle/','title':"0141. Linked List Cycle",'section':"第四章",'content':"141. Linked List Cycle #  题目 #  Given a linked list, determine if it has a cycle in it.\nFollow up:\nCan you solve it without using extra space?\n题目大意 #  判断链表是否有环，不能使用额外的空间。\n解题思路 #  给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。\n代码 #  package leetcode /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ func hasCycle(head *ListNode) bool { fast := head slow := head for slow != nil \u0026amp;\u0026amp; fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { return true } } return false } ```w "});index.add({'id':115,'href':'/leetcode-java/04_Leetcode/0142.Linked-List-Cycle-II/','title':"0142. Linked List Cycle I I",'section':"第四章",'content':"142. Linked List Cycle II #  题目 #  Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nNote: Do not modify the linked list.\nExample 1:\n Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2:\n Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3:\n Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. 题目大意 #  判断链表是否有环，不能使用额外的空间。如果有环，输出环的起点指针，如果没有环，则输出空。\n解题思路 #  这道题是第 141 题的加强版。在判断是否有环的基础上，还需要输出环的第一个点。\n分析一下判断环的原理。fast 指针一次都 2 步，slow 指针一次走 1 步。令链表 head 到环的一个点需要 x1 步，从环的第一个点到相遇点需要 x2 步，从环中相遇点回到环的第一个点需要 x3 步。那么环的总长度是 x2 + x3 步。\nfast 和 slow 会相遇，说明他们走的时间是相同的，可以知道他们走的路程有以下的关系：\nfast 的 t = (x1 + x2 + x3 + x2) / 2 slow 的 t = (x1 + x2) / 1 x1 + x2 + x3 + x2 = 2 * (x1 + x2) 所以 x1 = x3 所以 2 个指针相遇以后，如果 slow 继续往前走，fast 指针回到起点 head，两者都每次走一步，那么必定会在环的起点相遇，相遇以后输出这个点即是结果。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { if head == nil || head.Next == nil { return nil } isCycle, slow := hasCycle142(head) if !isCycle { return nil } fast := head for fast != slow { fast = fast.Next slow = slow.Next } return fast } func hasCycle142(head *ListNode) (bool, *ListNode) { fast := head slow := head for slow != nil \u0026amp;\u0026amp; fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { return true, slow } } return false, nil } "});index.add({'id':116,'href':'/leetcode-java/04_Leetcode/0143.Reorder-List/','title':"0143. Reorder List",'section':"第四章",'content':"143. Reorder List #  题目 #  Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…\nYou may not modify the values in the list\u0026rsquo;s nodes, only nodes itself may be changed.\nExample 1:\n Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, reorder it to 1-\u0026gt;4-\u0026gt;2-\u0026gt;3. Example 2:\n Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, reorder it to 1-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;3. 题目大意 #  按照指定规则重新排序链表：第一个元素和最后一个元素排列在一起，接着第二个元素和倒数第二个元素排在一起，接着第三个元素和倒数第三个元素排在一起。\n解题思路 #  最近简单的方法是先把链表存储到数组里，然后找到链表中间的结点，按照规则拼接即可。这样时间复杂度是 O(n)，空间复杂度是 O(n)。\n更好的做法是结合之前几道题的操作：链表逆序，找中间结点。\n先找到链表的中间结点，然后利用逆序区间的操作，如 第 92 题 里的 reverseBetween() 操作，只不过这里的反转区间是从中点一直到末尾。最后利用 2 个指针，一个指向头结点，一个指向中间结点，开始拼接最终的结果。这种做法的时间复杂度是 O(n)，空间复杂度是 O(1)。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 单链表 func reorderList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } // 寻找中间结点 \tp1 := head p2 := head for p2.Next != nil \u0026amp;\u0026amp; p2.Next.Next != nil { p1 = p1.Next p2 = p2.Next.Next } // 反转链表后半部分 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 to 1-\u0026gt;2-\u0026gt;3-\u0026gt;6-\u0026gt;5-\u0026gt;4 \tpreMiddle := p1 preCurrent := p1.Next for preCurrent.Next != nil { current := preCurrent.Next preCurrent.Next = current.Next current.Next = preMiddle.Next preMiddle.Next = current } // 重新拼接链表 1-\u0026gt;2-\u0026gt;3-\u0026gt;6-\u0026gt;5-\u0026gt;4 to 1-\u0026gt;6-\u0026gt;2-\u0026gt;5-\u0026gt;3-\u0026gt;4 \tp1 = head p2 = preMiddle.Next for p1 != preMiddle { preMiddle.Next = p2.Next p2.Next = p1.Next p1.Next = p2 p1 = p2.Next p2 = preMiddle.Next } return head } // 解法二 数组 func reorderList1(head *ListNode) *ListNode { array := listToArray(head) length := len(array) if length == 0 { return head } cur := head last := head for i := 0; i \u0026lt; len(array)/2; i++ { tmp := \u0026amp;ListNode{Val: array[length-1-i], Next: cur.Next} cur.Next = tmp cur = tmp.Next last = tmp } if length%2 == 0 { last.Next = nil } else { cur.Next = nil } return head } func listToArray(head *ListNode) []int { array := []int{} if head == nil { return array } cur := head for cur != nil { array = append(array, cur.Val) cur = cur.Next } return array } "});index.add({'id':117,'href':'/leetcode-java/04_Leetcode/0144.Binary-Tree-Preorder-Traversal/','title':"0144. Binary Tree Preorder Traversal",'section':"第四章",'content':"144. Binary Tree Preorder Traversal #  题目 #  Given a binary tree, return the preorder traversal of its nodes' values.\nExample:\n Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively?\n题目大意 #  先根遍历一颗树。\n解题思路 #  两种递归的实现方法，见代码。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 递归 func preorderTraversal(root *TreeNode) []int { res := []int{} if root != nil { res = append(res, root.Val) tmp := preorderTraversal(root.Left) for _, t := range tmp { res = append(res, t) } tmp = preorderTraversal(root.Right) for _, t := range tmp { res = append(res, t) } } return res } // 解法二 递归 func preorderTraversal1(root *TreeNode) []int { var result []int preorder(root, \u0026amp;result) return result } func preorder(root *TreeNode, output *[]int) { if root != nil { *output = append(*output, root.Val) preorder(root.Left, output) preorder(root.Right, output) } } // 解法三 非递归，用栈模拟递归过程 func preorderTraversal2(root *TreeNode) []int { if root == nil { return []int{} } stack, res := []*TreeNode{}, []int{} stack = append(stack, root) for len(stack) != 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node != nil { res = append(res, node.Val) } if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } "});index.add({'id':118,'href':'/leetcode-java/04_Leetcode/0145.Binary-Tree-Postorder-Traversal/','title':"0145. Binary Tree Postorder Traversal",'section':"第四章",'content':"145. Binary Tree Postorder Traversal #  题目 #  Given a binary tree, return the postorder traversal of its nodes' values.\nExample:\n Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively?\n题目大意 #  后根遍历一颗树。\n解题思路 #  递归的实现方法，见代码。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func postorderTraversal(root *TreeNode) []int { var result []int postorder(root, \u0026amp;result) return result } func postorder(root *TreeNode, output *[]int) { if root != nil { postorder(root.Left, output) postorder(root.Right, output) *output = append(*output, root.Val) } } "});index.add({'id':119,'href':'/leetcode-java/04_Leetcode/0147.Insertion-Sort-List/','title':"0147. Insertion Sort List",'section':"第四章",'content':"147. Insertion Sort List #  题目 #  Sort a linked list using insertion sort.\n A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list\nAlgorithm of Insertion Sort:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nExample 1:\n Input: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 Example 2:\n Input: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5 题目大意 #  链表的插入排序\n解题思路 #  按照题意做即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func insertionSortList(head *ListNode) *ListNode { if head == nil { return head } newHead := \u0026amp;ListNode{Val: 0, Next: nil} // 这里初始化不要直接指向 head，为了下面循环可以统一处理 \tcur, pre := head, newHead for cur != nil { next := cur.Next for pre.Next != nil \u0026amp;\u0026amp; pre.Next.Val \u0026lt; cur.Val { pre = pre.Next } cur.Next = pre.Next pre.Next = cur pre = newHead // 归位，重头开始 \tcur = next } return newHead.Next } "});index.add({'id':120,'href':'/leetcode-java/04_Leetcode/0148.Sort-List/','title':"0148. Sort List",'section':"第四章",'content':"148. Sort List #  题目 #  Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\n Input: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 Example 2:\n Input: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5 题目大意 #  链表的排序，要求时间复杂度必须是 O(n log n)，空间复杂度是 O(1)\n解题思路 #  这道题只能用归并排序才能符合要求。归并排序需要的 2 个操作在其他题目已经出现过了，取中间点是第 876 题，合并 2 个有序链表是第 21 题。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { length := 0 cur := head for cur != nil { length++ cur = cur.Next } if length \u0026lt;= 1 { return head } middleNode := middleNode1(head) cur = middleNode.Next middleNode.Next = nil middleNode = cur left := sortList(head) right := sortList(middleNode) return mergeTwoLists148(left, right) } func middleNode1(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } p1 := head p2 := head for p2.Next != nil \u0026amp;\u0026amp; p2.Next.Next != nil { p1 = p1.Next p2 = p2.Next.Next } return p1 } func mergeTwoLists148(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } l2.Next = mergeTwoLists(l1, l2.Next) return l2 } "});index.add({'id':121,'href':'/leetcode-java/04_Leetcode/0150.Evaluate-Reverse-Polish-Notation/','title':"0150. Evaluate Reverse Polish Notation",'section':"第四章",'content':"150. Evaluate Reverse Polish Notation #  题目 #  Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\nNote:\n Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won\u0026rsquo;t be any divide by zero operation.  Example 1:\n Input: [\u0026quot;2\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;*\u0026quot;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2:\n Input: [\u0026quot;4\u0026quot;, \u0026quot;13\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot;+\u0026quot;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3:\n Input: [\u0026quot;10\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;9\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;-11\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;17\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;+\u0026quot;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 题目大意 #  计算逆波兰表达式。\n解题思路 #  这道题就是经典的考察栈的知识的题目。\n代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) func evalRPN(tokens []string) int { if len(tokens) == 1 { i, _ := strconv.Atoi(tokens[0]) return i } stack, top := []int{}, 0 for _, v := range tokens { switch v { case \u0026#34;+\u0026#34;: { sum := stack[top-2] + stack[top-1] stack = stack[:top-2] stack = append(stack, sum) top-- } case \u0026#34;-\u0026#34;: { sub := stack[top-2] - stack[top-1] stack = stack[:top-2] stack = append(stack, sub) top-- } case \u0026#34;*\u0026#34;: { mul := stack[top-2] * stack[top-1] stack = stack[:top-2] stack = append(stack, mul) top-- } case \u0026#34;/\u0026#34;: { div := stack[top-2] / stack[top-1] stack = stack[:top-2] stack = append(stack, div) top-- } default: { i, _ := strconv.Atoi(v) stack = append(stack, i) top++ } } } return stack[0] } "});index.add({'id':122,'href':'/leetcode-java/04_Leetcode/0151.Reverse-Words-in-a-String/','title':"0151. Reverse Words in a String",'section':"第四章",'content':"151. Reverse Words in a String #  题目 #  Given an input string, reverse the string word by word.\nExample 1:\nInput: \u0026quot;the sky is blue\u0026quot; Output: \u0026quot;blue is sky the\u0026quot;  Example 2:\nInput: \u0026quot; hello world! \u0026quot; Output: \u0026quot;world! hello\u0026quot; Explanation: Your reversed string should not contain leading or trailing spaces.  Example 3:\nInput: \u0026quot;a good example\u0026quot; Output: \u0026quot;example good a\u0026quot; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.  Note:\n A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.  Follow up:\nFor C programmers, try to solve it in-place in O(1) extra space.\n题目大意 #  给定一个字符串，逐个翻转字符串中的每个单词。\n说明：\n 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。   进阶：\n 请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。  解题思路 #   给出一个中间有空格分隔的字符串，要求把这个字符串按照单词的维度前后翻转。 依照题意，先把字符串按照空格分隔成每个小单词，然后把单词前后翻转，最后再把每个单词中间添加空格。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func reverseWords151(s string) string { ss := strings.Fields(s) reverse151(\u0026amp;ss, 0, len(ss)-1) return strings.Join(ss, \u0026#34; \u0026#34;) } func reverse151(m *[]string, i int, j int) { for i \u0026lt;= j { (*m)[i], (*m)[j] = (*m)[j], (*m)[i] i++ j-- } } "});index.add({'id':123,'href':'/leetcode-java/04_Leetcode/0152.Maximum-Product-Subarray/','title':"0152. Maximum Product Subarray",'section':"第四章",'content':"152. Maximum Product Subarray #  题目 #  Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\nExample 1:\nInput: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2:\nInput: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  题目大意 #  给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n解题思路 #   给出一个数组，要求找出这个数组中连续元素乘积最大的值。 这一题是 DP 的题，状态转移方程是：最大值是 Max(f(n)) = Max( Max(f(n-1)) * n, Min(f(n-1)) * n)；最小值是 Min(f(n)) = Min( Max(f(n-1)) * n, Min(f(n-1)) * n)。只要动态维护这两个值，如果最后一个数是负数，最大值就在负数 * 最小值中产生，如果最后一个数是正数，最大值就在正数 * 最大值中产生。  代码 #  package leetcode func maxProduct(nums []int) int { minimum, maximum, res := nums[0], nums[0], nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026lt; 0 { maximum, minimum = minimum, maximum } maximum = max(nums[i], maximum*nums[i]) minimum = min(nums[i], minimum*nums[i]) res = max(res, maximum) } return res } "});index.add({'id':124,'href':'/leetcode-java/04_Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/','title':"0153. Find Minimum in Rotated Sorted Array",'section':"第四章",'content':"153. Find Minimum in Rotated Sorted Array #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nFind the minimum element.\nYou may assume no duplicate exists in the array.\nExample 1:\nInput: [3,4,5,1,2] Output: 1  Example 2:\nInput: [4,5,6,7,0,1,2] Output: 0  题目大意 #  假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。\n你可以假设数组中不存在重复元素。\n解题思路 #   给出一个原本从小到大排序过的数组，但是在某一个分割点上，把数组切分后的两部分对调位置，数值偏大的放到了数组的前部。求这个数组中最小的元素。 求数组最小的元素其实就是找分割点，前一个数比当前数大，后一个数比当前数也要大。可以用二分搜索查找，需要查找的两个有序区间。时间复杂度 O(log n)。这一题也可以用暴力解法，从头开始遍历，动态维护一个最小值即可，时间复杂度 O(n)。  代码 #  package leetcode // 解法一 二分 func findMin(nums []int) int { low, high := 0, len(nums)-1 for low \u0026lt; high { if nums[low] \u0026lt; nums[high] { return nums[low] } mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] \u0026gt;= nums[low] { low = mid + 1 } else { high = mid } } return nums[low] } // 解法二 二分 func findMin1(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } if nums[len(nums)-1] \u0026gt; nums[0] { return nums[0] } low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[low] \u0026lt; nums[high] { return nums[low] } if (mid == len(nums)-1 \u0026amp;\u0026amp; nums[mid-1] \u0026gt; nums[mid]) || (mid \u0026lt; len(nums)-1 \u0026amp;\u0026amp; mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid-1] \u0026gt; nums[mid] \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid+1]) { return nums[mid] } if nums[mid] \u0026gt; nums[low] \u0026amp;\u0026amp; nums[low] \u0026gt; nums[high] { // mid 在数值大的一部分区间里 \tlow = mid + 1 } else if nums[mid] \u0026lt; nums[low] \u0026amp;\u0026amp; nums[low] \u0026gt; nums[high] { // mid 在数值小的一部分区间里 \thigh = mid - 1 } else { if nums[low] == nums[mid] { low++ } if nums[high] == nums[mid] { high-- } } } return -1 } // 解法三 暴力 func findMin2(nums []int) int { min := nums[0] for _, num := range nums[1:] { if min \u0026gt; num { min = num } } return min } "});index.add({'id':125,'href':'/leetcode-java/04_Leetcode/0154.Find-Minimum-in-Rotated-Sorted-Array-II/','title':"0154. Find Minimum in Rotated Sorted Array I I",'section':"第四章",'content':"154. Find Minimum in Rotated Sorted Array II #  题目 #  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nFind the minimum element.\nThe array may contain duplicates.\nExample 1:\nInput: [1,3,5] Output: 1  Example 2:\nInput: [2,2,2,0,1] Output: 0  Note:\n This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?  题目大意 #  假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。\n注意数组中可能存在重复的元素。\n解题思路 #   给出一个原本从小到大排序过的数组，注意数组中有重复的元素。但是在某一个分割点上，把数组切分后的两部分对调位置，数值偏大的放到了数组的前部。求这个数组中最小的元素。 这一题是第 153 题的加强版，增加了重复元素的条件。但是实际做法还是没有变，还是用二分搜索，只不过在相等元素上多增加一个判断即可。时间复杂度 O(log n)。  代码 #  package leetcode func findMin154(nums []int) int { low, high := 0, len(nums)-1 for low \u0026lt; high { if nums[low] \u0026lt; nums[high] { return nums[low] } mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] \u0026gt; nums[low] { low = mid + 1 } else if nums[mid] == nums[low] { low++ } else { high = mid } } return nums[low] } "});index.add({'id':126,'href':'/leetcode-java/04_Leetcode/0155.Min-Stack/','title':"0155. Min Stack",'section':"第四章",'content':"155. Min Stack #  题目 #  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\npush(x) \u0026ndash; Push element x onto stack. pop() \u0026ndash; Removes the element on top of the stack. top() \u0026ndash; Get the top element. getMin() \u0026ndash; Retrieve the minimum element in the stack.\nExample:\n MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u0026gt; Returns -3. minStack.pop(); minStack.top(); --\u0026gt; Returns 0. minStack.getMin(); --\u0026gt; Returns -2. 题目大意 #  这道题是一个数据结构实现题。要求实现一个栈的类，实现 push()、pop()、top()、getMin()。\n解题思路 #  按照题目要求实现即可。\n代码 #  package leetcode // MinStack define type MinStack struct { elements, min []int l int } /** initialize your data structure here. */ // Constructor155 define func Constructor155() MinStack { return MinStack{make([]int, 0), make([]int, 0), 0} } // Push define func (this *MinStack) Push(x int) { this.elements = append(this.elements, x) if this.l == 0 { this.min = append(this.min, x) } else { min := this.GetMin() if x \u0026lt; min { this.min = append(this.min, x) } else { this.min = append(this.min, min) } } this.l++ } func (this *MinStack) Pop() { this.l-- this.min = this.min[:this.l] this.elements = this.elements[:this.l] } func (this *MinStack) Top() int { return this.elements[this.l-1] } func (this *MinStack) GetMin() int { return this.min[this.l-1] } "});index.add({'id':127,'href':'/leetcode-java/04_Leetcode/0160.Intersection-of-Two-Linked-Lists/','title':"0160. Intersection of Two Linked Lists",'section':"第四章",'content':"160. Intersection of Two Linked Lists #  题目 #  Write a program to find the node at which the intersection of two singly linked lists begins.\nFor example, the following two linked lists:\n begin to intersect at node c1.\nExample 1:\n  Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2:\n  Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3:\n  Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Notes:\n If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.  题目大意 #  找到 2 个链表的交叉点。\n解题思路 #  这道题的思路其实类似链表找环。\n给定的 2 个链表的长度如果一样长，都从头往后扫即可。如果不一样长，需要先“拼成”一样长。把 B 拼接到 A 后面，把 A 拼接到 B 后面。这样 2 个链表的长度都是 A + B。再依次扫描比较 2 个链表的结点是否相同。\n代码 #  package leetcode import \u0026#34;fmt\u0026#34; /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { //boundary check \tif headA == nil || headB == nil { return nil } a := headA b := headB //if a \u0026amp; b have different len, then we will stop the loop after second iteration \tfor a != b { //for the end of first iteration, we just reset the pointer to the head of another linkedlist \tif a == nil { a = headB } else { a = a.Next } if b == nil { b = headA } else { b = b.Next } fmt.Printf(\u0026#34;a = %v b = %v\\n\u0026#34;, a, b) } return a } "});index.add({'id':128,'href':'/leetcode-java/04_Leetcode/0162.Find-Peak-Element/','title':"0162. Find Peak Element",'section':"第四章",'content':"162. Find Peak Element #  题目 #  A peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may imagine that nums[-1] = nums[n] = -∞.\nExample 1:\nInput: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.  Example 2:\nInput: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.  Note:\nYour solution should be in logarithmic complexity.\n题目大意 #  峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。你可以假设 nums[-1] = nums[n] = -∞。\n说明:\n 你的解法应该是 O(logN) 时间复杂度的。  解题思路 #   给出一个数组，数组里面存在多个“山峰”，(山峰的定义是，下标 i 比 i-1、i+1 位置上的元素都要大)，找到这个“山峰”，并输出其中一个山峰的下标。 这一题是第 852 题的伪加强版，第 852 题中只存在一个山峰，这一题存在多个山峰。但是实际上搜索的代码是一样的，因为此题只要求随便输出一个山峰的下标即可。思路同第 852 题。  代码 #  package leetcode // 解法一 二分 func findPeakElement(nums []int) int { if len(nums) == 0 || len(nums) == 1 { return 0 } low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if (mid == len(nums)-1 \u0026amp;\u0026amp; nums[mid-1] \u0026lt; nums[mid]) || (mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid-1] \u0026lt; nums[mid] \u0026amp;\u0026amp; (mid \u0026lt;= len(nums)-2 \u0026amp;\u0026amp; nums[mid+1] \u0026lt; nums[mid])) || (mid == 0 \u0026amp;\u0026amp; nums[1] \u0026lt; nums[0]) { return mid } if mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid-1] \u0026lt; nums[mid] { low = mid + 1 } if mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid-1] \u0026gt; nums[mid] { high = mid - 1 } if mid == low { low++ } if mid == high { high-- } } return -1 } // 解法二 二分 func findPeakElement1(nums []int) int { low, high := 0, len(nums)-1 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 // 如果 mid 较大，则左侧存在峰值，high = m，如果 mid + 1 较大，则右侧存在峰值，low = mid + 1 \tif nums[mid] \u0026gt; nums[mid+1] { high = mid } else { low = mid + 1 } } return low } "});index.add({'id':129,'href':'/leetcode-java/04_Leetcode/0164.Maximum-Gap/','title':"0164. Maximum Gap",'section':"第四章",'content':"164. Maximum Gap #  题目 #  Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\nReturn 0 if the array contains less than 2 elements.\nExample 1:\n Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2:\n Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note:\n You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.  题目大意 #  在数组中找到 2 个数字之间最大的间隔。要求尽量用 O(1) 的时间复杂度和空间复杂度。\n解题思路 #  虽然使用排序算法可以 AC 这道题。先排序，然后依次计算数组中两两数字之间的间隔，找到最大的一个间隔输出即可。\n这道题满足要求的做法是基数排序。\n代码 #  package leetcode // 解法一 func maximumGap(nums []int) int { if len(nums) \u0026lt; 2 { return 0 } quickSort164(nums, 0, len(nums)-1) res := 0 for i := 0; i \u0026lt; len(nums)-1; i++ { if (nums[i+1] - nums[i]) \u0026gt; res { res = nums[i+1] - nums[i] } } return res } func partition164(a []int, lo, hi int) int { pivot := a[hi] i := lo - 1 for j := lo; j \u0026lt; hi; j++ { if a[j] \u0026lt; pivot { i++ a[j], a[i] = a[i], a[j] } } a[i+1], a[hi] = a[hi], a[i+1] return i + 1 } func quickSort164(a []int, lo, hi int) { if lo \u0026gt;= hi { return } p := partition164(a, lo, hi) quickSort164(a, lo, p-1) quickSort164(a, p+1, hi) } // 解法二 func maximumGap1(nums []int) int { if nums == nil || len(nums) \u0026lt; 2 { return 0 } // m is the maximal number in nums \tm := nums[0] for i := 1; i \u0026lt; len(nums); i++ { m = max(m, nums[i]) } exp := 1 // 1, 10, 100, 1000 ... \tR := 10 // 10 digits  aux := make([]int, len(nums)) for (m / exp) \u0026gt; 0 { // Go through all digits from LSB to MSB \tcount := make([]int, R) for i := 0; i \u0026lt; len(nums); i++ { count[(nums[i]/exp)%10]++ } for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] } for i := len(nums) - 1; i \u0026gt;= 0; i-- { tmp := count[(nums[i]/exp)%10] tmp-- aux[tmp] = nums[i] } for i := 0; i \u0026lt; len(nums); i++ { nums[i] = aux[i] } exp *= 10 } maxValue := 0 for i := 1; i \u0026lt; len(aux); i++ { maxValue = max(maxValue, aux[i]-aux[i-1]) } return maxValue } "});index.add({'id':130,'href':'/leetcode-java/04_Leetcode/0167.Two-Sum-II-Input-array-is-sorted/','title':"0167. Two Sum I I Input Array Is Sorted",'section':"第四章",'content':"167. Two Sum II - Input array is sorted #  题目 #  Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\nNote:\n Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.  Example:\n Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 题目大意 #  找出两个数之和等于 target 的两个数字，要求输出它们的下标。注意一个数字不能使用 2 次。下标从小到大输出。假定题目一定有一个解。\n解题思路 #  这一题比第 1 题 Two Sum 的问题还要简单，因为这里数组是有序的。可以直接用第一题的解法解决这道题。\n代码 #  package leetcode // 解法一 这一题可以利用数组有序的特性 func twoSum167(numbers []int, target int) []int { i, j := 0, len(numbers)-1 for i \u0026lt; j { if numbers[i]+numbers[j] == target { return []int{i + 1, j + 1} } else if numbers[i]+numbers[j] \u0026lt; target { i++ } else { j-- } } return []int{-1, -1} } // 解法二 不管数组是否有序，空间复杂度比上一种解法要多 O(n) func twoSum167_1(numbers []int, target int) []int { m := make(map[int]int) for i := 0; i \u0026lt; len(numbers); i++ { another := target - numbers[i] if _, ok := m[another]; ok { return []int{m[another] + 1, i + 1} } m[numbers[i]] = i } return nil } "});index.add({'id':131,'href':'/leetcode-java/04_Leetcode/0168.Excel-Sheet-Column-Title/','title':"0168. Excel Sheet Column Title",'section':"第四章",'content':"168. Excel Sheet Column Title #  题目 #  Given a positive integer, return its corresponding column title as appear in an Excel sheet.\nFor example:\n\t1 -\u0026gt; A 2 -\u0026gt; B 3 -\u0026gt; C ... 26 -\u0026gt; Z 27 -\u0026gt; AA 28 -\u0026gt; AB ... Example 1:\nInput: 1 Output: \u0026quot;A\u0026quot; Example 2:\nInput: 28 Output: \u0026quot;AB\u0026quot; Example 3:\nInput: 701 Output: \u0026quot;ZY\u0026quot; 题目大意 #  给定一个正整数，返回它在 Excel 表中相对应的列名称。\n例如，\n1 -\u0026gt; A 2 -\u0026gt; B 3 -\u0026gt; C ... 26 -\u0026gt; Z 27 -\u0026gt; AA 28 -\u0026gt; AB ...  解题思路 #   给定一个正整数，返回它在 Excel 表中的对应的列名称 简单题。这一题就类似短除法的计算过程。以 26 进制的字母编码。按照短除法先除，然后余数逆序输出即可。  代码 #  package leetcode func convertToTitle(n int) string { result := []byte{} for n \u0026gt; 0 { result = append(result, \u0026#39;A\u0026#39;+byte((n-1)%26)) n = (n - 1) / 26 } for i, j := 0, len(result)-1; i \u0026lt; j; i, j = i+1, j-1 { result[i], result[j] = result[j], result[i] } return string(result) } "});index.add({'id':132,'href':'/leetcode-java/04_Leetcode/0169.Majority-Element/','title':"0169. Majority Element",'section':"第四章",'content':"169. Majority Element #  题目 #  Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\nExample 1:\nInput: [3,2,3] Output: 3  Example 2:\nInput: [2,2,1,1,1,2,2] Output: 2  题目大意 #  给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。\n解题思路 #   题目要求找出数组中出现次数大于 ⌊ n/2 ⌋ 次的数。要求空间复杂度为 O(1)。简单题。 这一题利用的算法是 Boyer-Moore Majority Vote Algorithm。 https://www.zhihu.com/question/49973163/answer/235921864  代码 #  package leetcode // 解法一 时间复杂度 O(n) 空间复杂度 O(1) func majorityElement(nums []int) int { res, count := nums[0], 0 for i := 0; i \u0026lt; len(nums); i++ { if count == 0 { res, count = nums[i], 1 } else { if nums[i] == res { count++ } else { count-- } } } return res } // 解法二 时间复杂度 O(n) 空间复杂度 O(n) func majorityElement1(nums []int) int { m := make(map[int]int) for _, v := range nums { m[v]++ if m[v] \u0026gt; len(nums)/2 { return v } } return 0 } "});index.add({'id':133,'href':'/leetcode-java/04_Leetcode/0171.Excel-Sheet-Column-Number/','title':"0171. Excel Sheet Column Number",'section':"第四章",'content':"171. Excel Sheet Column Number #  题目 #  Given a column title as appear in an Excel sheet, return its corresponding column number.\nFor example:\n A -\u0026gt; 1 B -\u0026gt; 2 C -\u0026gt; 3 ... Z -\u0026gt; 26 AA -\u0026gt; 27 AB -\u0026gt; 28 ... Example 1:\nInput: \u0026quot;A\u0026quot; Output: 1 Example 2:\nInput: \u0026quot;AB\u0026quot; Output: 28 Example 3:\nInput: \u0026quot;ZY\u0026quot; Output: 701 题目大意 #  给定一个 Excel 表格中的列名称，返回其相应的列序号。\n解题思路 #   给出 Excel 中列的名称，输出其对应的列序号。 简单题。这一题是第 168 题的逆序题。按照 26 进制还原成十进制即可。  代码 #  package leetcode func titleToNumber(s string) int { val, res := 0, 0 for i := 0; i \u0026lt; len(s); i++ { val = int(s[i] - \u0026#39;A\u0026#39; + 1) res = res*26 + val } return res } "});index.add({'id':134,'href':'/leetcode-java/04_Leetcode/0172.Factorial-Trailing-Zeroes/','title':"0172. Factorial Trailing Zeroes",'section':"第四章",'content':"172. Factorial Trailing Zeroes #  题目 #  Given an integer n, return the number of trailing zeroes in n!.\nExample 1:\nInput: 3 Output: 0 Explanation: 3! = 6, no trailing zero.  Example 2:\nInput: 5 Output: 1 Explanation: 5! = 120, one trailing zero.  Note: Your solution should be in logarithmic time complexity.\n题目大意 #  给定一个整数 n，返回 n! 结果尾数中零的数量。说明: 你算法的时间复杂度应为 O(log n) 。\n解题思路 #   给出一个数 n，要求 n！末尾 0 的个数。 这是一道数学题。计算 N 的阶乘有多少个后缀 0，即计算 N! 里有多少个 10，也是计算 N! 里有多少个 2 和 5（分解质因数），最后结果即 2 的个数和 5 的个数取较小值。每两个数字就会多一个质因数 2，而每五个数字才多一个质因数 5。每 5 个数字就会多一个质因数 5。0~4 的阶乘里没有质因数 5，5~9 的阶乘里有 1 个质因数 5，10~14 的阶乘里有 2 个质因数 5，依此类推。所以 0 的个数即为 min(阶乘中 5 的个数和 2 的个数)。 N! 有多少个后缀 0，即 N! 有多少个质因数 5。N! 有多少个质因数 5，即 N 可以划分成多少组 5个数字一组，加上划分成多少组 25 个数字一组，加上划分多少组成 125 个数字一组，等等。即 res = N/5 + N/(5^2) + N/(5^3) + ... = ((N / 5) / 5) / 5 /... 。最终算法复杂度为 O(logN)。  代码 #  package leetcode func trailingZeroes(n int) int { if n/5 == 0 { return 0 } return n/5 + trailingZeroes(n/5) } "});index.add({'id':135,'href':'/leetcode-java/04_Leetcode/0173.Binary-Search-Tree-Iterator/','title':"0173. Binary Search Tree Iterator",'section':"第四章",'content':"173. Binary Search Tree Iterator #  题目 #  Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\nCalling next() will return the next smallest number in the BST.\nExample:\n BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.hasNext(); // return true iterator.next(); // return 20 iterator.hasNext(); // return false  Note:\n next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.  题目大意 #  实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。调用 next() 将返回二叉搜索树中的下一个最小的数。\n解题思路 #   用优先队列解决即可  代码 #  package leetcode import \u0026#34;container/heap\u0026#34; /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // BSTIterator define type BSTIterator struct { pq PriorityQueueOfInt count int } // Constructor173 define func Constructor173(root *TreeNode) BSTIterator { result, pq := []int{}, PriorityQueueOfInt{} postorder(root, \u0026amp;result) for _, v := range result { heap.Push(\u0026amp;pq, v) } bs := BSTIterator{pq: pq, count: len(result)} return bs } /** @return the next smallest number */ func (this *BSTIterator) Next() int { this.count-- return heap.Pop(\u0026amp;this.pq).(int) } /** @return whether we have a next smallest number */ func (this *BSTIterator) HasNext() bool { return this.count != 0 } /** * Your BSTIterator object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.Next(); * param_2 := obj.HasNext(); */ type PriorityQueueOfInt []int func (pq PriorityQueueOfInt) Len() int { return len(pq) } func (pq PriorityQueueOfInt) Less(i, j int) bool { return pq[i] \u0026lt; pq[j] } func (pq PriorityQueueOfInt) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueueOfInt) Push(x interface{}) { item := x.(int) *pq = append(*pq, item) } func (pq *PriorityQueueOfInt) Pop() interface{} { n := len(*pq) item := (*pq)[n-1] *pq = (*pq)[:n-1] return item } "});index.add({'id':136,'href':'/leetcode-java/04_Leetcode/0174.Dungeon-Game/','title':"0174. Dungeon Game",'section':"第四章",'content':"174. Dungeon Game #  题目 #  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0\u0026rsquo;s) or contain magic orbs that increase the knight\u0026rsquo;s health (positive integers).\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nWrite a function to determine the knight\u0026rsquo;s minimum initial health so that he is able to rescue the princess.\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-\u0026gt; RIGHT -\u0026gt; DOWN -\u0026gt; DOWN.\n Note:\n The knight\u0026rsquo;s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  题目大意 #  一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。\n说明:\n 骑士的健康点数没有上限。 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。  解题思路 #    在二维地图上给出每个格子扣血数，负数代表扣血，正数代表补血。左上角第一个格子是起点，右下角最后一个格子是终点。问骑士初始最少多少血才能走完迷宫，顺利营救位于终点的公主。需要注意的是，起点和终点都会对血量进行影响。每到一个格子，骑士的血都不能少于 1，一旦少于 1 点血，骑士就会死去。\n  这一题首先想到的解题思路是动态规划。从终点逆推回起点。dp[i][j] 代表骑士进入坐标为 (i,j) 的格子之前最少的血量值。 那么 dp[m-1][n-1] 应该同时满足两个条件，dp[m-1][n-1] + dungeon[m-1][n-1] ≥ 1 并且 dp[m-1][n-1] ≥ 1，由于这两个不等式的方向是相同的，取交集以后，起决定作用的是数轴最右边的数，即 max(1-dungeon[m-1][n-1] , 1)。算出 dp[m-1][n-1] 以后，接着可以推出 dp[m-1][i] 这一行和 dp[i][n-1] 这一列的值。因为骑士只能往右走和往下走。往回推，即只能往上走和往左走。到这里，DP 的初始条件都准备好了。那么状态转移方程是什么呢？分析一般的情况，dp[i][j] 这个值应该是和 dp[i+1][j] 和 dp[i][j+1] 这两者有关系。即 dp[i][j] 经过自己本格子的扣血以后，要能至少满足下一行和右一列格子血量的最少要求。并且自己的血量也应该 ≥1。即需要满足下面这两组不等式。\n上面不等式中第一组不等式是满足下一行格子的最低血量要求，第二组不等式是满足右一列格子的最低血量要求。第一个式子化简即 dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])，第二个式子化简即 dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])。求得了这两种走法的最低血量值，从这两个值里面取最小，即是当前格子所需的最低血量，所以状态转移方程为 dp[i][j] = min(max(1, dp[i][j+1]-dungeon[i][j]), max(1, dp[i+1][j]-dungeon[i][j]))。DP 完成以后，dp[0][0] 中记录的就是骑士初始最低血量值。时间复杂度 O(m*n)，空间复杂度 O(m*n)。\n  这一题还可以用二分搜索来求解。骑士的血量取值范围一定是在 [1，+∞) 这个区间内。那么二分这个区间，每次二分的中间值，再用 dp 在地图中去判断是否能到达终点，如果能，就缩小搜索空间至 [1，mid]，否则搜索空间为 [mid + 1，+∞) 。时间复杂度 O(m*n* log math.MaxInt64)，空间复杂度 O(m*n)。\n  代码 #  package leetcode import \u0026#34;math\u0026#34; // 解法一 动态规划 func calculateMinimumHP(dungeon [][]int) int { if len(dungeon) == 0 { return 0 } m, n := len(dungeon), len(dungeon[0]) dp := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]int, n) } dp[m-1][n-1] = max(1-dungeon[m-1][n-1], 1) for i := n - 2; i \u0026gt;= 0; i-- { dp[m-1][i] = max(1, dp[m-1][i+1]-dungeon[m-1][i]) } for i := m - 2; i \u0026gt;= 0; i-- { dp[i][n-1] = max(1, dp[i+1][n-1]-dungeon[i][n-1]) } for i := m - 2; i \u0026gt;= 0; i-- { for j := n - 2; j \u0026gt;= 0; j-- { dp[i][j] = min(max(1, dp[i][j+1]-dungeon[i][j]), max(1, dp[i+1][j]-dungeon[i][j])) } } return dp[0][0] } // 解法二 二分搜索 func calculateMinimumHP1(dungeon [][]int) int { low, high := 1, math.MaxInt64 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if canCross(dungeon, mid) { high = mid } else { low = mid + 1 } } return low } func canCross(dungeon [][]int, start int) bool { m, n := len(dungeon), len(dungeon[0]) dp := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]int, n) } for i := 0; i \u0026lt; len(dp); i++ { for j := 0; j \u0026lt; len(dp[i]); j++ { if i == 0 \u0026amp;\u0026amp; j == 0 { dp[i][j] = start + dungeon[0][0] } else { a, b := math.MinInt64, math.MinInt64 if i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j] \u0026gt; 0 { a = dp[i-1][j] + dungeon[i][j] } if j \u0026gt; 0 \u0026amp;\u0026amp; dp[i][j-1] \u0026gt; 0 { b = dp[i][j-1] + dungeon[i][j] } dp[i][j] = max(a, b) } } } return dp[m-1][n-1] \u0026gt; 0 } "});index.add({'id':137,'href':'/leetcode-java/04_Leetcode/0179.Largest-Number/','title':"0179. Largest Number",'section':"第四章",'content':"179. Largest Number #  题目 #  Given a list of non negative integers, arrange them such that they form the largest number.\nExample 1:\n Input: [10,2] Output: \u0026quot;210\u0026quot; Example 2:\n Input: [3,30,34,5,9] Output: \u0026quot;9534330\u0026quot; Note:\nThe result may be very large, so you need to return a string instead of an integer.\n题目大意 #  给出一个数组，要求排列这些数组里的元素，使得最终排列出来的数字是最大的。\n解题思路 #  这一题很容易想到把数字都转化为字符串，利用字符串比较，来排序，这样 9 开头的一定排在最前面。不过这样做有一个地方是错误的，比如：\u0026ldquo;3\u0026rdquo; 和 \u0026ldquo;30\u0026rdquo; 比较，\u0026ldquo;30\u0026rdquo; 比 \u0026ldquo;3\u0026rdquo; 的字符序要大，这样排序以后就出错了。实际上就这道题而言， \u0026ldquo;3\u0026rdquo; 应该排在 \u0026ldquo;30\u0026rdquo; 前面。\n在比较 2 个字符串大小的时候，不单纯的只用字符串顺序进行比较，还加入一个顺序。\naStr := a + b bStr := b + a 通过比较 aStr 和 bStr 的大小来得出是 a 大还是 b 大。\n举个例子，还是 \u0026ldquo;3\u0026rdquo; 和 \u0026ldquo;30\u0026rdquo; 的例子，比较这 2 个字符串的大小。\naStr := \u0026#34;3\u0026#34; + \u0026#34;30\u0026#34; = \u0026#34;330\u0026#34; bStr := \u0026#34;30\u0026#34; + \u0026#34;3\u0026#34; = \u0026#34;303\u0026#34; 通过互相补齐位数之后再进行比较，就没有问题了。很显然这里 \u0026ldquo;3\u0026rdquo; 比 \u0026ldquo;30\u0026rdquo; 要大。\n代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) func largestNumber(nums []int) string { if len(nums) == 0 { return \u0026#34;\u0026#34; } numStrs := toStringArray(nums) quickSortString(numStrs, 0, len(numStrs)-1) res := \u0026#34;\u0026#34; for _, str := range numStrs { if res == \u0026#34;0\u0026#34; \u0026amp;\u0026amp; str == \u0026#34;0\u0026#34; { continue } res = res + str } return res } func toStringArray(nums []int) []string { strs := make([]string, 0) for _, num := range nums { strs = append(strs, strconv.Itoa(num)) } return strs } func partitionString(a []string, lo, hi int) int { pivot := a[hi] i := lo - 1 for j := lo; j \u0026lt; hi; j++ { ajStr := a[j] + pivot pivotStr := pivot + a[j] if ajStr \u0026gt; pivotStr { // 这里的判断条件是关键 \ti++ a[j], a[i] = a[i], a[j] } } a[i+1], a[hi] = a[hi], a[i+1] return i + 1 } func quickSortString(a []string, lo, hi int) { if lo \u0026gt;= hi { return } p := partitionString(a, lo, hi) quickSortString(a, lo, p-1) quickSortString(a, p+1, hi) } "});index.add({'id':138,'href':'/leetcode-java/04_Leetcode/0187.Repeated-DNA-Sequences/','title':"0187. Repeated D N a Sequences",'section':"第四章",'content':"187. Repeated DNA Sequences #  题目 #  All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for Example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\nExample:\nInput: s = \u0026quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\u0026quot; Output: [\u0026quot;AAAAACCCCC\u0026quot;, \u0026quot;CCCCCAAAAA\u0026quot;]  题目大意 #  所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。\n解题思路 #   这一题不用位运算比较好做，维护一个长度为 10 的字符串，在 map 中出现次数 \u0026gt; 1 就输出。 用位运算想做这一题，需要动态的维护长度为 10 的 hashkey，先计算开头长度为 9 的 hash，在往后面扫描的过程中，如果长度超过了 10 ，就移除 hash 开头的一个字符，加入后面一个字符。具体做法是先将 ATCG 变成 00，01，10，11 的编码，那么长度为 10 ，hashkey 就需要维护在 20 位。mask = 0xFFFFF 就是 20 位的。维护了 hashkey 以后，根据这个 hashkey 进行去重和统计频次。  代码 #  package leetcode // 解法一 func findRepeatedDnaSequences(s string) []string { if len(s) \u0026lt; 10 { return nil } charMap, mp, result := map[uint8]uint32{\u0026#39;A\u0026#39;: 0, \u0026#39;C\u0026#39;: 1, \u0026#39;G\u0026#39;: 2, \u0026#39;T\u0026#39;: 3}, make(map[uint32]int, 0), []string{} var cur uint32 for i := 0; i \u0026lt; 9; i++ { // 前9位，忽略 \tcur = cur\u0026lt;\u0026lt;2 | charMap[s[i]] } for i := 9; i \u0026lt; len(s); i++ { cur = ((cur \u0026lt;\u0026lt; 2) \u0026amp; 0xFFFFF) | charMap[s[i]] if mp[cur] == 0 { mp[cur] = 1 } else if mp[cur] == 1 { // \u0026gt;2，重复 \tmp[cur] = 2 result = append(result, s[i-9:i+1]) } } return result } // 解法二 func findRepeatedDnaSequences1(s string) []string { if len(s) \u0026lt; 10 { return []string{} } ans, cache := make([]string, 0), make(map[string]int) for i := 0; i \u0026lt;= len(s)-10; i++ { curr := string(s[i : i+10]) if cache[curr] == 1 { ans = append(ans, curr) } cache[curr]++ } return ans } "});index.add({'id':139,'href':'/leetcode-java/04_Leetcode/0190.Reverse-Bits/','title':"0190. Reverse Bits",'section':"第四章",'content':"190. Reverse Bits #  题目 #  Reverse bits of a given 32 bits unsigned integer.\nExample 1:\nInput: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.  Example 2:\nInput: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.  Note:\n Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.  题目大意 #  颠倒给定的 32 位无符号整数的二进制位。提示：\n 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。  解题思路 #   简单题，要求反转 32 位的二进制位。 把 num 往右移动，不断的消灭右边最低位的 1，将这个 1 给 res，res 不断的左移即可实现反转二进制位的目的。  代码 #  package leetcode func reverseBits(num uint32) uint32 { var res uint32 for i := 0; i \u0026lt; 32; i++ { res = res\u0026lt;\u0026lt;1 | num\u0026amp;1 num \u0026gt;\u0026gt;= 1 } return res } "});index.add({'id':140,'href':'/leetcode-java/04_Leetcode/0191.Number-of-1-Bits/','title':"0191. Number of 1 Bits",'section':"第四章",'content':"191. Number of 1 Bits #  题目 #  Write a function that takes an unsigned integer and return the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight).\nExample 1:\nInput: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.  Example 2:\nInput: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.  Example 3:\nInput: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.  Note:\n Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 3 above the input represents the signed integer -3.  题目大意 #  编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n解题思路 #   求 uint32 数的二进制位中 1 的个数。 这一题的解题思路就是利用二进制位操作。X = X \u0026amp; ( X -1 ) 这个操作可以清除最低位的二进制位 1，利用这个操作，直至把数清零。操作了几次即为有几个二进制位 1 。 最简单的方法即是直接调用库函数 bits.OnesCount(uint(num)) 。  代码 #  package leetcode import \u0026#34;math/bits\u0026#34; // 解法一 func hammingWeight(num uint32) int { return bits.OnesCount(uint(num)) } // 解法二 func hammingWeight1(num uint32) int { count := 0 for num != 0 { num = num \u0026amp; (num - 1) count++ } return count } "});index.add({'id':141,'href':'/leetcode-java/04_Leetcode/0198.House-Robber/','title':"0198. House Robber",'section':"第四章",'content':"198. House Robber #  题目 #  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.  Example 2:\nInput: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.  题目大意 #  你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n解题思路 #   你是一个专业的小偷，打算洗劫一条街的所有房子。每个房子里面有不同价值的宝物，但是如果你选择偷窃连续的 2 栋房子，就会触发警报系统，编程求出你最多可以偷窃价值多少的宝物？ 这一题可以用 DP 来解答，也可以用找规律的方法来解答。 DP 的状态定义是：dp[i] 代表抢 nums[0,i] 这个区间内房子的最大值，状态转移方程是 dp[i] = max(dp[i-1], nums[i]+dp[i-2]) 。可以优化迭代的过程，用两个临时变量来存储中间结果，以节约辅助空间。  代码 #  package leetcode // 解法一 DP func rob198(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } // dp[i] 代表抢 nums[0...i] 房子的最大价值 \tdp := make([]int, n) dp[0], dp[1] = nums[0], max(nums[1], nums[0]) for i := 2; i \u0026lt; n; i++ { dp[i] = max(dp[i-1], nums[i]+dp[i-2]) } return dp[n-1] } // 解法二 DP 优化辅助空间，把迭代的值保存在 2 个变量中 func rob198_1(nums []int) int { n := len(nums) if n == 0 { return 0 } curMax, preMax := 0, 0 for i := 0; i \u0026lt; n; i++ { tmp := curMax curMax = max(curMax, nums[i]+preMax) preMax = tmp } return curMax } // 解法三 模拟 func rob(nums []int) int { // a 对于偶数位上的最大值的记录 \t// b 对于奇数位上的最大值的记录 \ta, b := 0, 0 for i := 0; i \u0026lt; len(nums); i++ { if i%2 == 0 { a = max(a+nums[i], b) } else { b = max(a, b+nums[i]) } } return max(a, b) } "});index.add({'id':142,'href':'/leetcode-java/04_Leetcode/0199.Binary-Tree-Right-Side-View/','title':"0199. Binary Tree Right Side View",'section':"第四章",'content':"199. Binary Tree Right Side View #  题目 #  Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample:\n Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 \u0026lt;--- / \\ 2 3 \u0026lt;--- \\ \\ 5 4 \u0026lt;--- 题目大意 #  从右边看一个树，输出看到的数字。注意有遮挡。\n解题思路 #   这一题是按层序遍历的变种题。按照层序把每层的元素都遍历出来，然后依次取每一层的最右边的元素即可。用一个队列即可实现。 第 102 题和第 107 题都是按层序遍历的。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root == nil { return []int{} } queue := []*TreeNode{} queue = append(queue, root) curNum, nextLevelNum, res, tmp := 1, 0, []int{}, []int{} for len(queue) != 0 { if curNum \u0026gt; 0 { node := queue[0] if node.Left != nil { queue = append(queue, node.Left) nextLevelNum++ } if node.Right != nil { queue = append(queue, node.Right) nextLevelNum++ } curNum-- tmp = append(tmp, node.Val) queue = queue[1:] } if curNum == 0 { res = append(res, tmp[len(tmp)-1]) curNum = nextLevelNum nextLevelNum = 0 tmp = []int{} } } return res } "});index.add({'id':143,'href':'/leetcode-java/04_Leetcode/0200.Number-of-Islands/','title':"0200. Number of Islands",'section':"第四章",'content':"200. Number of Islands #  题目 #  Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: 11110 11010 11000 00000 Output: 1  Example 2:\nInput: 11000 11000 00100 00011 Output: 3  题目大意 #  给定一个由 \u0026lsquo;1\u0026rsquo;（陆地）和 \u0026lsquo;0\u0026rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。\n解题思路 #   要求找出地图中的孤岛。孤岛的含义是四周被海水包围的岛。 这一题可以按照第 79 题的思路进行搜索，只要找到为 \u0026ldquo;1\u0026rdquo; 的岛以后，从这里开始搜索这周连通的陆地，也都标识上访问过。每次遇到新的 \u0026ldquo;1\u0026rdquo; 且没有访问过，就相当于遇到了新的岛屿了。  代码 #  package leetcode func numIslands(grid [][]byte) int { m := len(grid) if m == 0 { return 0 } n := len(grid[0]) if n == 0 { return 0 } res, visited := 0, make([][]bool, m) for i := 0; i \u0026lt; m; i++ { visited[i] = make([]bool, n) } for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; !visited[i][j] { searchIslands(grid, \u0026amp;visited, i, j) res++ } } } return res } func searchIslands(grid [][]byte, visited *[][]bool, x, y int) { (*visited)[x][y] = true for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isInBoard(grid, nx, ny) \u0026amp;\u0026amp; !(*visited)[nx][ny] \u0026amp;\u0026amp; grid[nx][ny] == \u0026#39;1\u0026#39; { searchIslands(grid, visited, nx, ny) } } } "});index.add({'id':144,'href':'/leetcode-java/04_Leetcode/0201.Bitwise-AND-of-Numbers-Range/','title':"0201. Bitwise a N D of Numbers Range",'section':"第四章",'content':"201. Bitwise AND of Numbers Range #  题目 #  Given a range [m, n] where 0 \u0026lt;= m \u0026lt;= n \u0026lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: [5,7] Output: 4  Example 2:\nInput: [0,1] Output: 0  题目大意 #  给定范围 [m, n]，其中 0 \u0026lt;= m \u0026lt;= n \u0026lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。\n解题思路 #    这一题要求输出 [m,n] 区间内所有数的 AND 与操作之后的结果。\n  举个例子，假设区间是 [26,30]，那么这个区间内的数用二进制表示出来为：\n11010\n11011\n11100\n11101\n11110\n  可以观察到，把这些数都 AND 起来，只要有 0 的位，最终结果都是 0，所以需要从右往前找到某一位上不为 0 的。不断的右移左边界和右边界，把右边的 0 都移走，直到它们俩相等，就找到了某一位上开始都不为 0 的了。在右移的过程中记录下右移了多少位，最后把 m 或者 n 的右边添上 0 即可。按照上面这个例子来看，11000 是最终的结果。\n  这一题还有解法二，还是以 [26,30] 这个区间为例。这个区间内的数末尾 3 位不断的 0，1 变化着。那么如果把末尾的 1 都打掉，就是最终要求的结果了。当 n == m 或者 n \u0026lt; m 的时候就退出循环，说明后面不同的位数已经都被抹平了，1 都被打掉为 0 了。所以关键的操作为 n \u0026amp;= (n - 1) ，清除最低位的 1 。这个算法名叫 Brian Kernighan 算法。\n  代码 #  package leetcode // 解法一 func rangeBitwiseAnd1(m int, n int) int { if m == 0 { return 0 } moved := 0 for m != n { m \u0026gt;\u0026gt;= 1 n \u0026gt;\u0026gt;= 1 moved++ } return m \u0026lt;\u0026lt; uint32(moved) } // 解法二 Brian Kernighan\u0026#39;s algorithm func rangeBitwiseAnd(m int, n int) int { for n \u0026gt; m { n \u0026amp;= (n - 1) // 清除最低位的 1 \t} return n } "});index.add({'id':145,'href':'/leetcode-java/04_Leetcode/0202.Happy-Number/','title':"0202. Happy Number",'section':"第四章",'content':"202. Happy Number #  题目 #  Write an algorithm to determine if a number is \u0026ldquo;happy\u0026rdquo;.\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\nExample 1:\n Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 题目大意 #  判断一个数字是否是“快乐数字”，“快乐数字”的定义是，不断的把这个数字的每个数字的平方和加起来，反复的加，最终如果能有结果是 1，则是“快乐数字”，如果不能得到一，出现了循环，则输出 false。\n解题思路 #  按照题意要求做即可。\n代码 #  package leetcode func isHappy(n int) bool { if n == 0 { return false } res := 0 num := n record := map[int]int{} for { for num != 0 { res += (num % 10) * (num % 10) num = num / 10 } if _, ok := record[res]; !ok { if res == 1 { return true } record[res] = res num = res res = 0 continue } else { return false } } } "});index.add({'id':146,'href':'/leetcode-java/04_Leetcode/0203.Remove-Linked-List-Elements/','title':"0203. Remove Linked List Elements",'section':"第四章",'content':"203. 移除链表元素 #  Difficulty: 简单\n删除链表中等于给定值 **_val _**的所有节点。\n示例:\n输入: 1-\u0026gt;2-\u0026gt;6-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6, val = 6 输出: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 题解 #  题解一：哨兵节点 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode sential = new ListNode(0); sential.next = head; ListNode prev = sential, curr = head; while (curr != null) { if (curr.val == val) { prev.next = curr.next; } else { prev = curr; } curr = curr.next; } return sential.next; } } 复杂度分析 #    时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  "});index.add({'id':147,'href':'/leetcode-java/04_Leetcode/0204.Count-Primes/','title':"0204. Count Primes",'section':"第四章",'content':"204. Count Primes #  题目 #  Count the number of prime numbers less than a non-negative number, n.\nExample:\nInput: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  题目大意 #  统计所有小于非负整数 n 的质数的数量。\n解题思路 #   给出一个数字 n，要求输出小于 n 的所有素数的个数总和。简单题。  代码 #  package leetcode func countPrimes(n int) int { isNotPrime := make([]bool, n) for i := 2; i*i \u0026lt; n; i++ { if isNotPrime[i] { continue } for j := i * i; j \u0026lt; n; j = j + i { isNotPrime[j] = true } } count := 0 for i := 2; i \u0026lt; n; i++ { if !isNotPrime[i] { count++ } } return count } "});index.add({'id':148,'href':'/leetcode-java/04_Leetcode/0205.Isomorphic-Strings/','title':"0205. Isomorphic Strings",'section':"第四章",'content':"205. Isomorphic Strings #  题目 #  Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\nExample 1:\n Input: s = \u0026quot;egg\u0026quot;, t = \u0026quot;add\u0026quot; Output: true Example 2:\n Input: s = \u0026quot;foo\u0026quot;, t = \u0026quot;bar\u0026quot; Output: false Example 3:\n Input: s = \u0026quot;paper\u0026quot;, t = \u0026quot;title\u0026quot; Output: true Note:\nYou may assume both s and t have the same length.\n题目大意 #  这道题和第 290 题基本是一样的。第 290 题是模式匹配，这道题的题意是字符串映射，实质是一样的。\n给定一个初始字符串串，判断初始字符串是否可以通过字符映射的方式，映射到目标字符串，如果可以映射，则输出 true，反之输出 false。\n解题思路 #  这道题做法和第 290 题基本一致。\n代码 #  package leetcode func isIsomorphic(s string, t string) bool { strList := []byte(t) patternByte := []byte(s) if (s == \u0026#34;\u0026#34; \u0026amp;\u0026amp; t != \u0026#34;\u0026#34;) || (len(patternByte) != len(strList)) { return false } pMap := map[byte]byte{} sMap := map[byte]byte{} for index, b := range patternByte { if _, ok := pMap[b]; !ok { if _, ok = sMap[strList[index]]; !ok { pMap[b] = strList[index] sMap[strList[index]] = b } else { if sMap[strList[index]] != b { return false } } } else { if pMap[b] != strList[index] { return false } } } return true } "});index.add({'id':149,'href':'/leetcode-java/04_Leetcode/0206.Reverse-Linked-List/','title':"0206. Reverse Linked List",'section':"第四章",'content':"206. Reverse Linked List #  题目 #  Reverse a singly linked list.\n题目大意 #  翻转单链表\n解题思路 #  按照题意做即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // ListNode define type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { var behind *ListNode for head != nil { next := head.Next head.Next = behind behind = head head = next } return behind } "});index.add({'id':150,'href':'/leetcode-java/04_Leetcode/0207.Course-Schedule/','title':"0207. Course Schedule",'section':"第四章",'content':"207. Course Schedule #  题目 #  There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nExample 1:\nInput: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.  Example 2:\nInput: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.  Note:\n The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.  题目大意 #  现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？\n解题思路 #    给出 n 个任务，每两个任务之间有相互依赖关系，比如 A 任务一定要在 B 任务之前完成才行。问是否可以完成所有任务。\n  这一题就是标准的 AOV 网的拓扑排序问题。拓扑排序问题的解决办法是主要是循环执行以下两步，直到不存在入度为0的顶点为止。\n   选择一个入度为0的顶点并输出之；    从网中删除此顶点及所有出边。    循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，即无法完成所有任务；否则输出的顶点序列就是一种拓扑序列，即可以完成所有任务。\n  代码 #  package leetcode // AOV 网的拓扑排序 func canFinish(n int, pre [][]int) bool { in := make([]int, n) frees := make([][]int, n) next := make([]int, 0, n) for _, v := range pre { in[v[0]]++ frees[v[1]] = append(frees[v[1]], v[0]) } for i := 0; i \u0026lt; n; i++ { if in[i] == 0 { next = append(next, i) } } for i := 0; i != len(next); i++ { c := next[i] v := frees[c] for _, vv := range v { in[vv]-- if in[vv] == 0 { next = append(next, vv) } } } return len(next) == n } "});index.add({'id':151,'href':'/leetcode-java/04_Leetcode/0208.Implement-Trie-Prefix-Tree/','title':"0208. Implement Trie Prefix Tree",'section':"第四章",'content':"208. Implement Trie (Prefix Tree) #  题目 #  Implement a trie with insert, search, and startsWith methods.\nExample:\nTrie trie = new Trie(); trie.insert(\u0026quot;apple\u0026quot;); trie.search(\u0026quot;apple\u0026quot;); // returns true trie.search(\u0026quot;app\u0026quot;); // returns false trie.startsWith(\u0026quot;app\u0026quot;); // returns true trie.insert(\u0026quot;app\u0026quot;); trie.search(\u0026quot;app\u0026quot;); // returns true  Note:\n You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings.  题目大意 #  实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n解题思路 #   要求实现一个 Trie 的数据结构，具有 insert, search, startsWith 三种操作 这一题就是经典的 Trie 实现。本题的实现可以作为 Trie 的模板。  代码 #  package leetcode type Trie struct { isWord bool children map[rune]*Trie } /** Initialize your data structure here. */ func Constructor208() Trie { return Trie{isWord: false, children: make(map[rune]*Trie)} } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { parent := this for _, ch := range word { if child, ok := parent.children[ch]; ok { parent = child } else { newChild := \u0026amp;Trie{children: make(map[rune]*Trie)} parent.children[ch] = newChild parent = newChild } } parent.isWord = true } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { parent := this for _, ch := range word { if child, ok := parent.children[ch]; ok { parent = child continue } return false } return parent.isWord } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { parent := this for _, ch := range prefix { if child, ok := parent.children[ch]; ok { parent = child continue } return false } return true } /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ "});index.add({'id':152,'href':'/leetcode-java/04_Leetcode/0209.Minimum-Size-Subarray-Sum/','title':"0209. Minimum Size Subarray Sum",'section':"第四章",'content':"209. Minimum Size Subarray Sum #  题目 #  Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn\u0026rsquo;t one, return 0 instead.\nExample 1:\n Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).\n题目大意 #  给定一个整型数组和一个数字 s，找到数组中最短的一个连续子数组，使得连续子数组的数字之和 sum\u0026gt;=s，返回最短的连续子数组的返回值。\n解题思路 #  这一题的解题思路是用滑动窗口。在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum \u0026gt; s，之和再缩小 i 的左边界，不断缩小直到 sum \u0026lt; s，这时候右边界又可以往右移动。以此类推。\n代码 #  package leetcode func minSubArrayLen(s int, nums []int) int { n := len(nums) if n == 0 { return 0 } left, right, res, sum := 0, -1, n+1, 0 for left \u0026lt; n { if (right+1) \u0026lt; n \u0026amp;\u0026amp; sum \u0026lt; s { right++ sum += nums[right] } else { sum -= nums[left] left++ } if sum \u0026gt;= s { res = min(res, right-left+1) } } if res == n+1 { return 0 } return res } "});index.add({'id':153,'href':'/leetcode-java/04_Leetcode/0210.Course-Schedule-II/','title':"0210. Course Schedule I I",'section':"第四章",'content':"210. Course Schedule II #  题目 #  There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .  Example 2:\nInput: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .  Note:\n The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.  题目大意 #  现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n解题思路 #   给出 n 个任务，每两个任务之间有相互依赖关系，比如 A 任务一定要在 B 任务之前完成才行。问是否可以完成所有任务，如果可以完成任务，就输出完成任务的顺序，如果不能完成，输出空数组。 这一题是第 207 题的加强版。解题思路是 AOV 网的拓扑排序。最后输出数组即可。代码和第 207 题基本不变。具体解题思路见第 207 题。  代码 #  package leetcode func findOrder(numCourses int, prerequisites [][]int) []int { in := make([]int, numCourses) frees := make([][]int, numCourses) next := make([]int, 0, numCourses) for _, v := range prerequisites { in[v[0]]++ frees[v[1]] = append(frees[v[1]], v[0]) } for i := 0; i \u0026lt; numCourses; i++ { if in[i] == 0 { next = append(next, i) } } for i := 0; i != len(next); i++ { c := next[i] v := frees[c] for _, vv := range v { in[vv]-- if in[vv] == 0 { next = append(next, vv) } } } if len(next) == numCourses { return next } return []int{} } "});index.add({'id':154,'href':'/leetcode-java/04_Leetcode/0211.Add-and-Search-Word-Data-structure-design/','title':"0211. Add and Search Word Data Structure Design",'section':"第四章",'content':"211. Add and Search Word - Data structure design #  题目 #  Design a data structure that supports the following two operations:\nvoid addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\nExample:\naddWord(\u0026quot;bad\u0026quot;) addWord(\u0026quot;dad\u0026quot;) addWord(\u0026quot;mad\u0026quot;) search(\u0026quot;pad\u0026quot;) -\u0026gt; false search(\u0026quot;bad\u0026quot;) -\u0026gt; true search(\u0026quot;.ad\u0026quot;) -\u0026gt; true search(\u0026quot;b..\u0026quot;) -\u0026gt; true  Note: You may assume that all words are consist of lowercase letters a-z.\n题目大意 #  设计一个支持以下两种操作的数据结构：void addWord(word)、bool search(word)。search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 \u0026ldquo;.\u0026rdquo; 可以表示任何一个字母。\n解题思路 #   设计一个 WordDictionary 的数据结构，要求具有 addWord(word) 和 search(word) 的操作，并且具有模糊查找的功能。 这一题是第 208 题的加强版，在第 208 题经典的 Trie 上加上了模糊查找的功能。其他实现一模一样。  代码 #  package leetcode type WordDictionary struct { children map[rune]*WordDictionary isWord bool } /** Initialize your data structure here. */ func Constructor211() WordDictionary { return WordDictionary{children: make(map[rune]*WordDictionary)} } /** Adds a word into the data structure. */ func (this *WordDictionary) AddWord(word string) { parent := this for _, ch := range word { if child, ok := parent.children[ch]; ok { parent = child } else { newChild := \u0026amp;WordDictionary{children: make(map[rune]*WordDictionary)} parent.children[ch] = newChild parent = newChild } } parent.isWord = true } /** Returns if the word is in the data structure. A word could contain the dot character \u0026#39;.\u0026#39; to represent any one letter. */ func (this *WordDictionary) Search(word string) bool { parent := this for i, ch := range word { if rune(ch) == \u0026#39;.\u0026#39; { isMatched := false for _, v := range parent.children { if v.Search(word[i+1:]) { isMatched = true } } return isMatched } else if _, ok := parent.children[rune(ch)]; !ok { return false } parent = parent.children[rune(ch)] } return len(parent.children) == 0 || parent.isWord } /** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */ "});index.add({'id':155,'href':'/leetcode-java/04_Leetcode/0212.Word-Search-II/','title':"0212. Word Search I I",'section':"第四章",'content':"212. Word Search II #  题目 #  Given a 2D board and a list of words from the dictionary, find all words in the board.\nEach word must be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample:\nInput: board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\u0026quot;oath\u0026quot;,\u0026quot;pea\u0026quot;,\u0026quot;eat\u0026quot;,\u0026quot;rain\u0026quot;] Output: [\u0026quot;eat\u0026quot;,\u0026quot;oath\u0026quot;]  Note:\n All inputs are consist of lowercase letters a-z. The values of words are distinct.  题目大意 #  给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n解题思路 #   这一题是第 79 题的加强版，在第 79 题的基础上增加了一个 word 数组，要求找出所有出现在地图中的单词。思路还是可以按照第 79 题 DFS 搜索，不过时间复杂度特别高！ 想想更优的解法。  代码 #  package leetcode func findWords(board [][]byte, words []string) []string { res := []string{} for _, v := range words { if exist(board, v) { res = append(res, v) } } return res } "});index.add({'id':156,'href':'/leetcode-java/04_Leetcode/0213.House-Robber-II/','title':"0213. House Robber I I",'section':"第四章",'content':"213. House Robber II #  题目 #  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.  Example 2:\nInput: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.  题目大意 #  你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n解题思路 #   这一题是第 198 题的加强版。不过这次是在一个环形的街道中，即最后一个元素和第一个元素是邻居，在不触碰警报的情况下，问能够窃取的财产的最大值是多少？ 解题思路和第 198 完全一致，只需要增加额外的一个转换。由于首尾是相邻的，所以在取了第一个房子以后就不能取第 n 个房子，那么就在 [0,n - 1] 的区间内找出总价值最多的解，然后再 [1,n] 的区间内找出总价值最多的解，两者取最大值即可。  代码 #  package leetcode func rob213(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } if n == 2 { return max(nums[0], nums[1]) } // 由于首尾是相邻的，所以需要对比 [0，n-1]、[1，n] 这两个区间的最大值 \treturn max(rob213_1(nums, 0, n-2), rob213_1(nums, 1, n-1)) } func rob213_1(nums []int, start, end int) int { preMax := nums[start] curMax := max(preMax, nums[start+1]) for i := start + 2; i \u0026lt;= end; i++ { tmp := curMax curMax = max(curMax, nums[i]+preMax) preMax = tmp } return curMax } "});index.add({'id':157,'href':'/leetcode-java/04_Leetcode/0215.Kth-Largest-Element-in-an-Array/','title':"0215. Kth Largest Element in an Array",'section':"第四章",'content':"215. Kth Largest Element in an Array #  题目 #  Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nExample 1:\n Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2:\n Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:\nYou may assume k is always valid, 1 ≤ k ≤ array\u0026rsquo;s length.\n题目大意 #  找出数组中第 K 大的元素。这一题非常经典。可以用 O(n) 的时间复杂度实现。\n解题思路 #  在快排的 partition 操作中，每次 partition 操作结束都会返回一个点，这个标定点的下标和最终排序之后有序数组中这个元素所在的下标是一致的。利用这个特性，我们可以不断的划分数组区间，最终找到第 K 大的元素。执行一次 partition 操作以后，如果这个元素的下标比 K 小，那么接着就在后边的区间继续执行 partition 操作；如果这个元素的下标比 K 大，那么就在左边的区间继续执行 partition 操作；如果相等就直接输出这个下标对应的数组元素即可。\n代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 排序，排序的方法反而速度是最快的 func findKthLargest1(nums []int, k int) int { sort.Ints(nums) return nums[len(nums)-k] } // 解法二 这个方法的理论依据是 partition 得到的点的下标就是最终排序之后的下标，根据这个下标，我们可以判断第 K 大的数在哪里 func findKthLargest(nums []int, k int) int { if len(nums) == 0 { return 0 } return selection(nums, 0, len(nums)-1, len(nums)-k) } func selection(arr []int, l, r, k int) int { if l == r { return arr[l] } p := partition164(arr, l, r) if k == p { return arr[p] } else if k \u0026lt; p { return selection(arr, l, p-1, k) } else { return selection(arr, p+1, r, k) } } "});index.add({'id':158,'href':'/leetcode-java/04_Leetcode/0216.Combination-Sum-III/','title':"0216. Combination Sum I I I",'section':"第四章",'content':"216. Combination Sum III #  题目 #  Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\nNote:\n All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1:\nInput: k = 3, n = 7 Output: [[1,2,4]]  Example 2:\nInput: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]  题目大意 #  找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n说明：\n 所有数字都是正整数。 解集不能包含重复的组合。  解题思路 #   这一题比第 39 题还要简单一些，在第 39 题上稍加改动就可以解出这一道题。 第 39 题是给出数组，这一道题数组是固定死的 [1,2,3,4,5,6,7,8,9]，并且数字不能重复使用。  代码 #  package leetcode func combinationSum3(k int, n int) [][]int { if k == 0 { return [][]int{} } c, res := []int{}, [][]int{} findcombinationSum3(k, n, 1, c, \u0026amp;res) return res } func findcombinationSum3(k, target, index int, c []int, res *[][]int) { if target == 0 { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) } return } for i := index; i \u0026lt; 10; i++ { if target \u0026gt;= i { c = append(c, i) findcombinationSum3(k, target-i, i+1, c, res) c = c[:len(c)-1] } } } "});index.add({'id':159,'href':'/leetcode-java/04_Leetcode/0217.Contains-Duplicate/','title':"0217. Contains Duplicate",'section':"第四章",'content':"217. Contains Duplicate #  题目 #  Given an array of integers, find if the array contains any duplicates.\nYour function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\nExample 1:\n Input: [1,2,3,1] Output: true Example 2:\n Input: [1,2,3,4] Output: false Example 3:\n Input: [1,1,1,3,3,4,3,2,4,2] Output: true 题目大意 #  这是一道简单题，如果数组里面有重复数字就输出 true，否则输出 flase。\n解题思路 #  用 map 判断即可。\n代码 #  package leetcode func containsDuplicate(nums []int) bool { record := make(map[int]bool, len(nums)) for _, n := range nums { if _, found := record[n]; found { return true } record[n] = true } return false } "});index.add({'id':160,'href':'/leetcode-java/04_Leetcode/0218.The-Skyline-Problem/','title':"0218. the Skyline Problem",'section':"第四章",'content':"218. The Skyline Problem #  题目 #  A city\u0026rsquo;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\n  The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 \u0026lt; Hi ≤ INT_MAX, and Ri - Li \u0026gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\nThe output is a list of \u0026ldquo;key points\u0026rdquo; (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\nNotes:\n The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]  题目大意 #  城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。\n每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 \u0026lt; Hi ≤ INT_MAX 和 Ri - Li \u0026gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。\n例如，图 A 中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。\n输出是以 [ [x1,y1], [x2, y2], [x3, y3], \u0026hellip; ] 格式的“关键点”（图 B 中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。\n例如，图 B 中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。\n说明:\n 任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。 输入列表已经按左 x 坐标 Li 进行升序排列。 输出列表必须按 x 位排序。 输出天际线中不得有连续的相同高度的水平线。例如 [\u0026hellip;[2 3], [4 5], [7 5], [11 5], [12 7]\u0026hellip;] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[\u0026hellip;[2 3], [4 5], [12 7], \u0026hellip;]  解题思路 #    给出一个二维数组，每个子数组里面代表一个高楼的信息，一个高楼的信息包含 3 个信息，高楼起始坐标，高楼终止坐标，高楼高度。要求找到这些高楼的边际点，并输出这些边际点的高度信息。\n  这一题可以用线段树来解。用线段树来解答，可以不用关心“楼挡住楼”的情况。由于楼的坐标是离散的，所以先把楼在 X 轴上两个坐标离散化。同第 699 题一样，楼的宽度是一个区间，但是离散的过程中，楼的宽度右边界需要减一，不然查询一个区间会包含两个点，导致错误的结果，例如，第一个楼是 [1,3)，楼高 10，第二个楼是 [3,6)，楼高 20 。第一个楼如果算上右边界 3，查询 [1,3] 的结果是 20，因为 [3,3] 这个点会查询到第二个楼上面去。所以每个楼的右边界应该减一。但是每个楼的右边界也要加入到 query 中，因为最终 query 的结果需要包含这些边界。将离散的数据排序以后，按照楼的信息，每个区间依次 update。最后统计的时候依次统计每个区间，如果当前区间的高度和前一个区间的高度一样，就算是等高的楼。当高度与前一个高度不相同的时候就算是天际线的边缘，就要添加到最后输出数组中。\n  类似的线段树的题目有：第 715 题，第 732 题，第 699 题。第 715 题是区间更新定值(不是增减)，第 218 题可以用扫描线，第 732 题和第 699 题类似，也是俄罗斯方块的题目，但是第 732 题的俄罗斯方块的方块会“断裂”。\n  这一题用线段树做时间复杂度有点高，可以用扫描线解题。扫描线的思路很简单，用一根根垂直于 X 轴的竖线，从最左边依次扫到最右边，扫描每一条大楼的边界，当进入大楼的左边界的时候，如果没有比这个左边界最高点更高的点，就记录下这个最高点 keyPoint，状态是进入状态。如果扫到一个大楼的左边界，有比它更高的高度，就不记录，因为它不是天际线，它被楼挡楼，挡在其他楼后面了。当扫到一个大楼的右边界的时候，如果是最高点，那么记录下它的状态是离开状态，此时还需要记录下第二高的点。在扫描线扫描的过程中，动态的维护大楼的高度，同时维护最高的高度和第二高的高度。其实只需要维护最高的高度这一个高度，因为当离开状态到来的时候，移除掉当前最高的，剩下的高度里面最高的就是第二高的高度。描述的伪代码如下：\n // 扫描线伪代码 events = {{x: L , height: H , type: entering}, {x: R , height: H , type: leaving}} event.SortByX() ds = new DS() for e in events: if entering(e): if e.height \u0026gt; ds.max(): ans += [e.height] ds.add(e.height) if leaving(e): ds.remove(e.height) if e.height \u0026gt; ds.max(): ans += [ds.max()]    动态插入，查找最大值可以选用的数据结构有，最大堆和二叉搜索树。最大堆找最大值 O(1)，插入 O(log n)，但是 remove_by_key 需要 O(n) 的时间复杂度，并且需要自己实现。二叉搜索树，查找 max，添加和删除元素都是 O(log n) 的时间复杂度。\n  排序的时候也需要注意几个问题：如果大楼的边界相等，并且是进入状态，那么再按照高度从大到小进行排序；如果大楼的边界相等，并且是离开状态，那么高度按照从小到大进行排序。\n  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 线段树 Segment Tree，时间复杂度 O(n log n) func getSkyline(buildings [][]int) [][]int { st, ans, lastHeight, check := template.SegmentTree{}, [][]int{}, 0, false posMap, pos := discretization218(buildings) tmp := make([]int, len(posMap)) st.Init(tmp, func(i, j int) int { return max(i, j) }) for _, b := range buildings { st.UpdateLazy(posMap[b[0]], posMap[b[1]-1], b[2]) } for i := 0; i \u0026lt; len(pos); i++ { h := st.QueryLazy(posMap[pos[i]], posMap[pos[i]]) if check == false \u0026amp;\u0026amp; h != 0 { ans = append(ans, []int{pos[i], h}) check = true } else if i \u0026gt; 0 \u0026amp;\u0026amp; h != lastHeight { ans = append(ans, []int{pos[i], h}) } lastHeight = h } return ans } func discretization218(positions [][]int) (map[int]int, []int) { tmpMap, posArray, posMap := map[int]int{}, []int{}, map[int]int{} for _, pos := range positions { tmpMap[pos[0]]++ tmpMap[pos[1]-1]++ tmpMap[pos[1]]++ } for k := range tmpMap { posArray = append(posArray, k) } sort.Ints(posArray) for i, pos := range posArray { posMap[pos] = i } return posMap, posArray } // 解法二 扫描线 Sweep Line，时间复杂度 O(n log n) func getSkyline1(buildings [][]int) [][]int { size := len(buildings) es := make([]E, 0) for i, b := range buildings { l := b[0] r := b[1] h := b[2] // 1-- enter \tel := NewE(i, l, h, 0) es = append(es, el) // 0 -- leave \ter := NewE(i, r, h, 1) es = append(es, er) } skyline := make([][]int, 0) sort.Slice(es, func(i, j int) bool { if es[i].X == es[j].X { if es[i].T == es[j].T { if es[i].T == 0 { return es[i].H \u0026gt; es[j].H } return es[i].H \u0026lt; es[j].H } return es[i].T \u0026lt; es[j].T } return es[i].X \u0026lt; es[j].X }) pq := NewIndexMaxPQ(size) for _, e := range es { curH := pq.Front() if e.T == 0 { if e.H \u0026gt; curH { skyline = append(skyline, []int{e.X, e.H}) } pq.Enque(e.N, e.H) } else { pq.Remove(e.N) h := pq.Front() if curH \u0026gt; h { skyline = append(skyline, []int{e.X, h}) } } } return skyline } // 扫面线伪代码 // events = {{x: L , height: H , type: entering}, // {x: R , height: H , type: leaving}} // event.SortByX() // ds = new DS()  // for e in events: // if entering(e): // if e.height \u0026gt; ds.max(): ans += [e.height] // ds.add(e.height) // if leaving(e): // ds.remove(e.height) // if e.height \u0026gt; ds.max(): ans += [ds.max()]  // E define type E struct { // 定义一个 event 事件 \tN int // number 编号 \tX int // x 坐标 \tH int // height 高度 \tT int // type 0-进入 1-离开 } // NewE define func NewE(n, x, h, t int) E { return E{ N: n, X: x, H: h, T: t, } } // IndexMaxPQ define type IndexMaxPQ struct { items []int pq []int qp []int total int } // NewIndexMaxPQ define func NewIndexMaxPQ(n int) IndexMaxPQ { qp := make([]int, n) for i := 0; i \u0026lt; n; i++ { qp[i] = -1 } return IndexMaxPQ{ items: make([]int, n), pq: make([]int, n+1), qp: qp, } } // Enque define func (q *IndexMaxPQ) Enque(key, val int) { q.total++ q.items[key] = val q.pq[q.total] = key q.qp[key] = q.total q.swim(q.total) } // Front define func (q *IndexMaxPQ) Front() int { if q.total \u0026lt; 1 { return 0 } return q.items[q.pq[1]] } // Remove define func (q *IndexMaxPQ) Remove(key int) { rank := q.qp[key] q.exch(rank, q.total) q.total-- q.qp[key] = -1 q.sink(rank) } func (q *IndexMaxPQ) sink(n int) { for 2*n \u0026lt;= q.total { k := 2 * n if k \u0026lt; q.total \u0026amp;\u0026amp; q.less(k, k+1) { k++ } if q.less(k, n) { break } q.exch(k, n) n = k } } func (q *IndexMaxPQ) swim(n int) { for n \u0026gt; 1 { k := n / 2 if q.less(n, k) { break } q.exch(n, k) n = k } } func (q *IndexMaxPQ) exch(i, j int) { q.pq[i], q.pq[j] = q.pq[j], q.pq[i] q.qp[q.pq[i]] = i q.qp[q.pq[j]] = j } func (q *IndexMaxPQ) less(i, j int) bool { return q.items[q.pq[i]] \u0026lt; q.items[q.pq[j]] } "});index.add({'id':161,'href':'/leetcode-java/04_Leetcode/0219.Contains-Duplicate-II/','title':"0219. Contains Duplicate I I",'section':"第四章",'content':"219. 存在重复元素 II #  Difficulty: 简单\n给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] ，并且 i 和 j 的差的 绝对值 至多为 k。\n示例 1:\n输入: nums = [1,2,3,1], k = 3 输出: true 示例 2:\n输入: nums = [1,0,1,1], k = 1 输出: true 示例 3:\n输入: nums = [1,2,3,1,2,3], k = 2 输出: false 题解 #  题解一：哈希表结构 #  class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (map.containsKey(nums[i])) { if (i - map.get(nums[i]) \u0026lt;= k) { return true; } } map.put(nums[i], i); } return false; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(n)。\n  题解二：哈希表结构 #  class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; ++i) { if (set.contains(nums[i])) { return true; } set.add(nums[i]); if (set.size() \u0026gt; k) { set.remove(nums[i - k]); } } return false; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(min(n, k))。\n  "});index.add({'id':162,'href':'/leetcode-java/04_Leetcode/0220.Contains-Duplicate-III/','title':"0220. Contains Duplicate I I I",'section':"第四章",'content':"220. Contains Duplicate III #  题目 #  Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3, t = 0 Output: true  Example 2:\nInput: nums = [1,0,1,1], k = 1, t = 2 Output: true  Example 3:\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false  题目大意 #  给出一个数组 num，再给 K 和 t。问在 num 中能否找到一组 i 和 j，使得 num[i] 和 num[j] 的绝对差值最大为 t，并且 i 和 j 之前的绝对差值最大为 k。\n解题思路 #   给出一个数组，要求在数组里面找到 2 个索引，i 和 j，使得 | nums[i] - nums[j] | ≤ t ，并且 | i - j | ≤ k 。 这是一道滑动窗口的题目。第一想法就是用 i 和 j 两个指针，针对每个 i ，都从 i + 1 往后扫完整个数组，判断每个 i 和 j ，判断是否满足题意。j 在循环的过程中注意判断剪枝条件 | i - j | ≤ k。这个做法的时间复杂度是 O(n^2)。这个做法慢的原因在于滑动窗口的左边界和右边界在滑动过程中不是联动滑动的。 于是考虑，如果数组是有序的呢？把数组按照元素值从小到大进行排序，如果元素值相等，就按照 index 从小到大进行排序。在这样有序的数组中找满足题意的 i 和 j，滑动窗口左边界和右边界就是联动的了。窗口的右边界滑到与左边界元素值的差值 ≤ t 的地方，满足了这个条件再判断 | i - j | ≤ k，如果右边界与左边界元素值的差值 \u0026gt; t 了，说明该把左边界往右移动了(能这样移动的原因就是因为我们将数组元素大小排序了，右移是增大元素的方向)。移动左边界的时候需要注意左边界不能超过右边界。这样滑动窗口一次滑过整个排序后的数组，就可以判断是否存在满足题意的 i 和 j 。这个做法的时间主要花在排序上了，时间复杂度是 O(n log n)。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 排序 + 滑动窗口 func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool { if len(nums) \u0026lt; 2 { return false } elemList := make([]*elem, len(nums)) for i, num := range nums { elemList[i] = \u0026amp;elem{num, i} } sort.SliceStable(elemList, func(i, j int) bool { if elemList[i].val != elemList[j].val { return elemList[i].val \u0026lt; elemList[j].val } return elemList[i].idx \u0026lt; elemList[j].idx }) i, j := 0, 1 for j \u0026lt; len(elemList) { if elemList[j].val-elemList[i].val \u0026lt;= t { if abs(elemList[j].idx-elemList[i].idx) \u0026lt;= k { return true } j++ } else { i++ if j \u0026lt;= i { j++ } } } return false } type elem struct { val int idx int } // 解法二 滑动窗口 + 剪枝 func containsNearbyAlmostDuplicate1(nums []int, k int, t int) bool { if len(nums) \u0026lt;= 1 { return false } if k \u0026lt;= 0 { return false } n := len(nums) for i := 0; i \u0026lt; n; i++ { count := 0 for j := i + 1; j \u0026lt; n \u0026amp;\u0026amp; count \u0026lt; k; j++ { if abs(nums[i]-nums[j]) \u0026lt;= t { return true } count++ } } return false } "});index.add({'id':163,'href':'/leetcode-java/04_Leetcode/0222.Count-Complete-Tree-Nodes/','title':"0222. Count Complete Tree Nodes",'section':"第四章",'content':"222. 完全二叉树的节点个数 #  Difficulty: 中等\n给出一个完全二叉树，求出该树的节点个数。\n说明：\n的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n示例：\n输入: 1 / \\ 2 3 / \\ / 4 5 6 输出: 6 题解 #  解法一：递归遍历（前、中、后序遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int countNodes(TreeNode root) { List\u0026lt;TreeNode\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); helper(root, list); return list.size(); } private void helper(TreeNode node, List\u0026lt;TreeNode\u0026gt; list) { if (node == null) { return; } list.add(node); helper(node.left, list); helper(node.right, list); } } 解法二：递归遍历（一行递归） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; } } 解法三：二分查找 + 位运算（官方） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } int level = 0; TreeNode node = root; while (node.left != null) { level++; node = node.left; } int low = 1 \u0026lt;\u0026lt; level, high = (1 \u0026lt;\u0026lt; (level + 1)) - 1; while (low \u0026lt; high) { int mid = (high - low + 1) / 2 + low; if (exists(root, level, mid)) { low = mid; } else { high = mid - 1; } } return low; } private boolean exists(TreeNode root, int level, int k) { int bits = 1 \u0026lt;\u0026lt; (level - 1); TreeNode node = root; while (node != null \u0026amp;\u0026amp; bits \u0026gt; 0) { if ((bits \u0026amp; k) == 0) { node = node.left; } else { node = node.right; } bits \u0026gt;\u0026gt;= 1; } return node != null; } } "});index.add({'id':164,'href':'/leetcode-java/04_Leetcode/0223.Rectangle-Area/','title':"0223. Rectangle Area",'section':"第四章",'content':"223. Rectangle Area #  题目 #  Find the total area covered by two rectilinear rectangles in a 2D plane.\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n Example:\nInput: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45  Note:\nAssume that the total area is never beyond the maximum possible value of int.\n题目大意 #  在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。每个矩形由其左下顶点和右上顶点坐标表示，如图所示。说明: 假设矩形面积不会超出 int 的范围。\n解题思路 #   给出两个矩形的坐标，求这两个矩形在坐标轴上覆盖的总面积。 几何题，由于只有 2 个矩形，所以按照题意做即可。先分别求两个矩形的面积，加起来再减去两个矩形重叠的面积。  代码 #  package leetcode func computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int { X0, Y0, X1, Y1 := max(A, E), max(B, F), min(C, G), min(D, H) return area(A, B, C, D) + area(E, F, G, H) - area(X0, Y0, X1, Y1) } func area(x0, y0, x1, y1 int) int { l, h := x1-x0, y1-y0 if l \u0026lt;= 0 || h \u0026lt;= 0 { return 0 } return l * h } "});index.add({'id':165,'href':'/leetcode-java/04_Leetcode/0224.Basic-Calculator/','title':"0224. Basic Calculator",'section':"第四章",'content':"224. Basic Calculator #  题目 #  Implement a basic calculator to evaluate a simple expression string.\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .\nExample 1:\nInput: \u0026quot;1 + 1\u0026quot; Output: 2  Example 2:\nInput: \u0026quot; 2-1 + 2 \u0026quot; Output: 3  Example 3:\nInput: \u0026quot;(1+(4+5+2)-3)+(6+8)\u0026quot; Output: 23  Note:\n You may assume that the given expression is always valid. Do not use the eval built-in library function.  题目大意 #  实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。\n解题思路 #   注意点一：算式中有空格，需要跳过 注意点二：算式中会出现负数，负负得正的情况需要特殊处理，所以需要记录每次计算出来的符号  代码 #  package leetcode import ( \u0026#34;container/list\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) // 解法一 func calculate(s string) int { i, stack, result, sign := 0, list.New(), 0, 1 // 记录加减状态 \tfor i \u0026lt; len(s) { if s[i] == \u0026#39; \u0026#39; { i++ } else if s[i] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; s[i] \u0026gt;= \u0026#39;0\u0026#39; { // 获取一段数字 \tbase, v := 10, int(s[i]-\u0026#39;0\u0026#39;) for i+1 \u0026lt; len(s) \u0026amp;\u0026amp; s[i+1] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; s[i+1] \u0026gt;= \u0026#39;0\u0026#39; { v = v*base + int(s[i+1]-\u0026#39;0\u0026#39;) i++ } result += v * sign i++ } else if s[i] == \u0026#39;+\u0026#39; { sign = 1 i++ } else if s[i] == \u0026#39;-\u0026#39; { sign = -1 i++ } else if s[i] == \u0026#39;(\u0026#39; { // 把之前计算结果及加减状态压栈，开始新的计算 \tstack.PushBack(result) stack.PushBack(sign) result = 0 sign = 1 i++ } else if s[i] == \u0026#39;)\u0026#39; { // 新的计算结果 * 前一个加减状态 + 之前计算结果 \tresult = result*stack.Remove(stack.Back()).(int) + stack.Remove(stack.Back()).(int) i++ } } return result } // 解法二 func calculate1(s string) int { stack := []byte{} for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { continue } else if s[i] == \u0026#39;)\u0026#39; { tmp, index := \u0026#34;\u0026#34;, len(stack)-1 for ; index \u0026gt;= 0; index-- { if stack[index] == \u0026#39;(\u0026#39; { break } } tmp = string(stack[index+1:]) stack = stack[:index] res := strconv.Itoa(calculateStr(tmp)) for j := 0; j \u0026lt; len(res); j++ { stack = append(stack, res[j]) } } else { stack = append(stack, s[i]) } } fmt.Printf(\u0026#34;stack = %v\\n\u0026#34;, string(stack)) return calculateStr(string(stack)) } func calculateStr(str string) int { s, nums, tmpStr, res := []byte{}, []int{}, \u0026#34;\u0026#34;, 0 // 处理符号的问题，++得+，--得+，+-、-+得- \tfor i := 0; i \u0026lt; len(str); i++ { if len(s) \u0026gt; 0 \u0026amp;\u0026amp; s[len(s)-1] == \u0026#39;+\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;+\u0026#39; { continue } else if len(s) \u0026gt; 0 \u0026amp;\u0026amp; s[len(s)-1] == \u0026#39;+\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;-\u0026#39; { s[len(s)-1] = \u0026#39;-\u0026#39; } else if len(s) \u0026gt; 0 \u0026amp;\u0026amp; s[len(s)-1] == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;+\u0026#39; { continue } else if len(s) \u0026gt; 0 \u0026amp;\u0026amp; s[len(s)-1] == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;-\u0026#39; { s[len(s)-1] = \u0026#39;+\u0026#39; } else { s = append(s, str[i]) } } str = string(s) s = []byte{} for i := 0; i \u0026lt; len(str); i++ { if isDigital(str[i]) { tmpStr += string(str[i]) } else { num, _ := strconv.Atoi(tmpStr) nums = append(nums, num) tmpStr = \u0026#34;\u0026#34; s = append(s, str[i]) } } if tmpStr != \u0026#34;\u0026#34; { num, _ := strconv.Atoi(tmpStr) nums = append(nums, num) } res = nums[0] for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39;+\u0026#39; { res += nums[i+1] } else { res -= nums[i+1] } } fmt.Printf(\u0026#34;s = %v nums = %v res = %v\\n\u0026#34;, string(s), nums, res) return res } func isDigital(v byte) bool { if v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39; { return true } return false } "});index.add({'id':166,'href':'/leetcode-java/04_Leetcode/0225.Implement-Stack-using-Queues/','title':"0225. Implement Stack Using Queues",'section':"第四章",'content':"225. Implement Stack using Queues #  题目 #  Implement the following operations of a stack using queues.\n push(x) \u0026ndash; Push element x onto stack. pop() \u0026ndash; Removes the element on top of the stack. top() \u0026ndash; Get the top element. empty() \u0026ndash; Return whether the stack is empty.  Example:\n MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Note:\n You must use only standard operations of a queue \u0026ndash; which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).  题目大意 #  题目要求用队列实现一个栈的基本操作：push(x)、pop()、top()、empty()。\n解题思路 #  按照题目要求实现即可。\n代码 #  package leetcode type MyStack struct { enque []int deque []int } /** Initialize your data structure here. */ func Constructor225() MyStack { return MyStack{[]int{}, []int{}} } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.enque = append(this.enque, x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { length := len(this.enque) for i := 0; i \u0026lt; length-1; i++ { this.deque = append(this.deque, this.enque[0]) this.enque = this.enque[1:] } topEle := this.enque[0] this.enque = this.deque this.deque = nil return topEle } /** Get the top element. */ func (this *MyStack) Top() int { topEle := this.Pop() this.enque = append(this.enque, topEle) return topEle } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { if len(this.enque) == 0 { return true } return false } "});index.add({'id':167,'href':'/leetcode-java/04_Leetcode/0226.Invert-Binary-Tree/','title':"0226. Invert Binary Tree",'section':"第四章",'content':"226. Invert Binary Tree #  题目 #  Invert a binary tree.\nExample:\nInput:\n 4 / \\ 2 7 / \\ / \\ 1 3 6 9 Output:\n 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia:\nThis problem was inspired by this original tweet by Max Howell:\n Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.\n 题目大意 #  \u0026ldquo;经典\u0026quot;的反转二叉树的问题。\n解题思路 #  还是用递归来解决，先递归调用反转根节点的左孩子，然后递归调用反转根节点的右孩子，然后左右交换根节点的左孩子和右孩子。\n代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } invertTree(root.Left) invertTree(root.Right) root.Left, root.Right = root.Right, root.Left return root } "});index.add({'id':168,'href':'/leetcode-java/04_Leetcode/0228.Summary-Ranges/','title':"0228. Summary Ranges",'section':"第四章",'content':"228. 汇总区间 #  Difficulty: 简单\n给定一个无重复元素的有序整数数组 nums 。\n返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。\n列表中的每个区间范围 [a,b] 应该按如下格式输出：\n \u0026quot;a-\u0026gt;b\u0026quot; ，如果 a != b \u0026quot;a\u0026quot; ，如果 a == b  示例 1：\n输入：nums = [0,1,2,4,5,7] 输出：[\u0026quot;0-\u0026gt;2\u0026quot;,\u0026quot;4-\u0026gt;5\u0026quot;,\u0026quot;7\u0026quot;] 解释：区间范围是： [0,2] --\u0026gt; \u0026quot;0-\u0026gt;2\u0026quot; [4,5] --\u0026gt; \u0026quot;4-\u0026gt;5\u0026quot; [7,7] --\u0026gt; \u0026quot;7\u0026quot; 示例 2：\n输入：nums = [0,2,3,4,6,8,9] 输出：[\u0026quot;0\u0026quot;,\u0026quot;2-\u0026gt;4\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;8-\u0026gt;9\u0026quot;] 解释：区间范围是： [0,0] --\u0026gt; \u0026quot;0\u0026quot; [2,4] --\u0026gt; \u0026quot;2-\u0026gt;4\u0026quot; [6,6] --\u0026gt; \u0026quot;6\u0026quot; [8,9] --\u0026gt; \u0026quot;8-\u0026gt;9\u0026quot; 示例 3：\n输入：nums = [] 输出：[] 示例 4：\n输入：nums = [-1] 输出：[\u0026quot;-1\u0026quot;] 示例 5：\n输入：nums = [0] 输出：[\u0026quot;0\u0026quot;] 提示：\n 0 \u0026lt;= nums.length \u0026lt;= 20 -2\u0026lt;sup\u0026gt;31\u0026lt;/sup\u0026gt; \u0026lt;= nums[i] \u0026lt;= 2\u0026lt;sup\u0026gt;31\u0026lt;/sup\u0026gt; - 1 nums 中的所有值都 互不相同  题解 #  题解一：双指针 #  class Solution { public List\u0026lt;String\u0026gt; summaryRanges(int[] nums) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int i =0, j = 0; j \u0026lt; nums.length; j++) { if (j + 1 \u0026lt; nums.length \u0026amp;\u0026amp; nums[j + 1] == nums[j] + 1) { continue; } if (i == j) { result.add(nums[i] + \u0026#34;\u0026#34;); } else { result.add(nums[i] + \u0026#34;-\u0026gt;\u0026#34; + nums[j]); } i = j + 1; } return result; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  解法二：双指针，代码优化 #  class Solution { public List\u0026lt;String\u0026gt; summaryRanges(int[] nums) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0, j = 0; j \u0026lt; nums.length; j++) { if (j + 1 == nums.length || nums[j] + 1 != nums[j + 1]) { result.add(String.valueOf(nums[i]) + (i == j ? \u0026#34;\u0026#34; : \u0026#34;-\u0026gt;\u0026#34; + String.valueOf(nums[j]))); i = j + 1; } } return result; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  "});index.add({'id':169,'href':'/leetcode-java/04_Leetcode/0229.Majority-Element-II/','title':"0229. Majority Element I I",'section':"第四章",'content':"229. Majority Element II #  题目 #  Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\nNote: The algorithm should run in linear time and in O(1) space.\nExample 1:\nInput: [3,2,3] Output: [3]  Example 2:\nInput: [1,1,1,3,3,2,2,2] Output: [1,2]  题目大意 #  给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。\n解题思路 #   这一题是第 169 题的加强版。Boyer-Moore Majority Vote algorithm 算法的扩展版。 题目要求找出数组中出现次数大于 ⌊ n/3 ⌋ 次的数。要求空间复杂度为 O(1)。简单题。 这篇文章写的不错，可参考： https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html  代码 #  package leetcode // 解法一 时间复杂度 O(n) 空间复杂度 O(1) func majorityElement229(nums []int) []int { // since we are checking if a num appears more than 1/3 of the time \t// it is only possible to have at most 2 nums (\u0026gt;1/3 + \u0026gt;1/3 = \u0026gt;2/3) \tcount1, count2, candidate1, candidate2 := 0, 0, 0, 1 // Select Candidates \tfor _, num := range nums { if num == candidate1 { count1++ } else if num == candidate2 { count2++ } else if count1 \u0026lt;= 0 { // We have a bad first candidate, replace! \tcandidate1, count1 = num, 1 } else if count2 \u0026lt;= 0 { // We have a bad second candidate, replace! \tcandidate2, count2 = num, 1 } else { // Both candidates suck, boo! \tcount1-- count2-- } } // Recount! \tcount1, count2 = 0, 0 for _, num := range nums { if num == candidate1 { count1++ } else if num == candidate2 { count2++ } } length := len(nums) if count1 \u0026gt; length/3 \u0026amp;\u0026amp; count2 \u0026gt; length/3 { return []int{candidate1, candidate2} } if count1 \u0026gt; length/3 { return []int{candidate1} } if count2 \u0026gt; length/3 { return []int{candidate2} } return []int{} } // 解法二 时间复杂度 O(n) 空间复杂度 O(n) func majorityElement229_1(nums []int) []int { result, m := make([]int, 0), make(map[int]int) for _, val := range nums { if v, ok := m[val]; ok { m[val] = v + 1 } else { m[val] = 1 } } for k, v := range m { if v \u0026gt; len(nums)/3 { result = append(result, k) } } return result } "});index.add({'id':170,'href':'/leetcode-java/04_Leetcode/0230.Kth-Smallest-Element-in-a-BST/','title':"0230. Kth Smallest Element in a B S T",'section':"第四章",'content':"230. Kth Smallest Element in a BST #  题目 #  Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\nNote: You may assume k is always valid, 1 ≤ k ≤ BST\u0026rsquo;s total elements.\nExample 1:\nInput: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1  Example 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3  Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n题目大意 #  给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n解题思路 #   由于二叉搜索树有序的特性，所以中根遍历它，遍历到第 K 个数的时候就是结果  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthSmallest(root *TreeNode, k int) int { res, count := 0, 0 inorder230(root, k, \u0026amp;count, \u0026amp;res) return res } func inorder230(node *TreeNode, k int, count *int, ans *int) { if node != nil { inorder230(node.Left, k, count, ans) *count++ if *count == k { *ans = node.Val return } inorder230(node.Right, k, count, ans) } } "});index.add({'id':171,'href':'/leetcode-java/04_Leetcode/0231.Power-of-Two/','title':"0231. Power of Two",'section':"第四章",'content':"231. Power of Two #  题目 #  Given an integer, write a function to determine if it is a power of two.\nExample 1:\nInput: 1 Output: true Explanation: 2^0 = 1  Example 2:\nInput: 16 Output: true Explanation: 2^4 = 16  Example 3:\nInput: 218 Output: false  题目大意 #  给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n解题思路 #   判断一个数是不是 2 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。这一题和第 326 题是一样的思路。  代码 #  package leetcode // 解法一 二进制位操作法 func isPowerOfTwo(num int) bool { return (num \u0026gt; 0 \u0026amp;\u0026amp; ((num \u0026amp; (num - 1)) == 0)) } // 解法二 数论 func isPowerOfTwo1(num int) bool { return num \u0026gt; 0 \u0026amp;\u0026amp; (1073741824%num == 0) } // 解法三 打表法 func isPowerOfTwo2(num int) bool { allPowerOfTwoMap := map[int]int{1: 1, 2: 2, 4: 4, 8: 8, 16: 16, 32: 32, 64: 64, 128: 128, 256: 256, 512: 512, 1024: 1024, 2048: 2048, 4096: 4096, 8192: 8192, 16384: 16384, 32768: 32768, 65536: 65536, 131072: 131072, 262144: 262144, 524288: 524288, 1048576: 1048576, 2097152: 2097152, 4194304: 4194304, 8388608: 8388608, 16777216: 16777216, 33554432: 33554432, 67108864: 67108864, 134217728: 134217728, 268435456: 268435456, 536870912: 536870912, 1073741824: 1073741824} _, ok := allPowerOfTwoMap[num] return ok } // 解法四 循环 func isPowerOfTwo3(num int) bool { for num \u0026gt;= 2 { if num%2 == 0 { num = num / 2 } else { return false } } return num == 1 } "});index.add({'id':172,'href':'/leetcode-java/04_Leetcode/0232.Implement-Queue-using-Stacks/','title':"0232. Implement Queue Using Stacks",'section':"第四章",'content':"232. Implement Queue using Stacks #  题目 #  Implement the following operations of a queue using stacks.\n push(x) \u0026ndash; Push element x to the back of queue. pop() \u0026ndash; Removes the element from in front of queue. peek() \u0026ndash; Get the front element. empty() \u0026ndash; Return whether the queue is empty.  Example:\n MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false Note:\n You must use only standard operations of a stack \u0026ndash; which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).  题目大意 #  题目要求用栈实现一个队列的基本操作：push(x)、pop()、peek()、empty()。\n解题思路 #  按照题目要求实现即可。\n代码 #  package leetcode type MyQueue struct { Stack *[]int Queue *[]int } /** Initialize your data structure here. */ func Constructor232() MyQueue { tmp1, tmp2 := []int{}, []int{} return MyQueue{Stack: \u0026amp;tmp1, Queue: \u0026amp;tmp2} } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { *this.Stack = append(*this.Stack, x) } /** Removes the element from in front of queue and returns that element. */ func (this *MyQueue) Pop() int { if len(*this.Queue) == 0 { this.fromStackToQueue(this.Stack, this.Queue) } popped := (*this.Queue)[len(*this.Queue)-1] *this.Queue = (*this.Queue)[:len(*this.Queue)-1] return popped } /** Get the front element. */ func (this *MyQueue) Peek() int { if len(*this.Queue) == 0 { this.fromStackToQueue(this.Stack, this.Queue) } return (*this.Queue)[len(*this.Queue)-1] } /** Returns whether the queue is empty. */ func (this *MyQueue) Empty() bool { return len(*this.Stack)+len(*this.Queue) == 0 } func (this *MyQueue) fromStackToQueue(s, q *[]int) { for len(*s) \u0026gt; 0 { popped := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] *q = append(*q, popped) } } "});index.add({'id':173,'href':'/leetcode-java/04_Leetcode/0234.Palindrome-Linked-List/','title':"0234. Palindrome Linked List",'section':"第四章",'content':"234. Palindrome Linked List #  题目 #  Given a singly linked list, determine if it is a palindrome.\nExample 1:\n Input: 1-\u0026gt;2 Output: false Example 2:\n Input: 1-\u0026gt;2-\u0026gt;2-\u0026gt;1 Output: true Follow up:\nCould you do it in O(n) time and O(1) space?\n题目大意 #  判断一个链表是否是回文链表。要求时间复杂度 O(n)，空间复杂度 O(1)。\n解题思路 #  这道题只需要在第 143 题上面改改就可以了。思路是完全一致的。先找到中间结点，然后反转中间结点后面到结尾的所有结点。最后一一判断头结点开始的结点和中间结点往后开始的结点是否相等。如果一直相等，就是回文链表，如果有不相等的，直接返回不是回文链表。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 此题和 143 题 Reorder List 思路基本一致 func isPalindrome234(head *ListNode) bool { if head == nil || head.Next == nil { return true } res := true // 寻找中间结点 \tp1 := head p2 := head for p2.Next != nil \u0026amp;\u0026amp; p2.Next.Next != nil { p1 = p1.Next p2 = p2.Next.Next } // 反转链表后半部分 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 to 1-\u0026gt;2-\u0026gt;3-\u0026gt;6-\u0026gt;5-\u0026gt;4 \tpreMiddle := p1 preCurrent := p1.Next for preCurrent.Next != nil { current := preCurrent.Next preCurrent.Next = current.Next current.Next = preMiddle.Next preMiddle.Next = current } // 扫描表，判断是否是回文 \tp1 = head p2 = preMiddle.Next // fmt.Printf(\u0026#34;p1 = %v p2 = %v preMiddle = %v head = %v\\n\u0026#34;, p1.Val, p2.Val, preMiddle.Val, L2ss(head)) \tfor p1 != preMiddle { // fmt.Printf(\u0026#34;*****p1 = %v p2 = %v preMiddle = %v head = %v\\n\u0026#34;, p1, p2, preMiddle, L2ss(head)) \tif p1.Val == p2.Val { p1 = p1.Next p2 = p2.Next // fmt.Printf(\u0026#34;-------p1 = %v p2 = %v preMiddle = %v head = %v\\n\u0026#34;, p1, p2, preMiddle, L2ss(head)) \t} else { res = false break } } if p1 == preMiddle { if p2 != nil \u0026amp;\u0026amp; p1.Val != p2.Val { return false } } return res } // L2ss define func L2ss(head *ListNode) []int { res := []int{} for head != nil { res = append(res, head.Val) head = head.Next } return res } "});index.add({'id':174,'href':'/leetcode-java/04_Leetcode/0235.Lowest-Common-Ancestor-of-a-Binary-Search-Tree/','title':"0235. Lowest Common Ancestor of a Binary Search Tree",'section':"第四章",'content':"235. Lowest Common Ancestor of a Binary Search Tree #  题目 #  Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nGiven binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]\n Example 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.  Note:\n All of the nodes' values will be unique. p and q are different and both values will exist in the BST.  题目大意 #  给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n解题思路 #   在二叉搜索树中求两个节点的最近公共祖先，由于二叉搜索树的特殊性质，所以找任意两个节点的最近公共祖先非常简单。  代码 #  package leetcode /** * Definition for TreeNode. * type TreeNode struct { * Val int * Left *ListNode * Right *ListNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p == nil || q == nil || root == nil { return nil } if p.Val \u0026lt; root.Val \u0026amp;\u0026amp; q.Val \u0026lt; root.Val { return lowestCommonAncestor(root.Left, p, q) } if p.Val \u0026gt; root.Val \u0026amp;\u0026amp; q.Val \u0026gt; root.Val { return lowestCommonAncestor(root.Right, p, q) } return root } "});index.add({'id':175,'href':'/leetcode-java/04_Leetcode/0236.Lowest-Common-Ancestor-of-a-Binary-Tree/','title':"0236. Lowest Common Ancestor of a Binary Tree",'section':"第四章",'content':"236. Lowest Common Ancestor of a Binary Tree #  题目 #  Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nGiven the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]\n Example 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.  Example 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.  Note:\n All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree.  题目大意 #  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n解题思路 #   这是一套经典的题目，寻找任意一个二叉树中两个结点的 LCA 最近公共祖先，考察递归  代码 #  package leetcode /** * Definition for TreeNode. * type TreeNode struct { * Val int * Left *ListNode * Right *ListNode * } */ func lowestCommonAncestor236(root, p, q *TreeNode) *TreeNode { if root == nil || root == q || root == p { return root } left := lowestCommonAncestor236(root.Left, p, q) right := lowestCommonAncestor236(root.Right, p, q) if left != nil { if right != nil { return root } return left } return right } "});index.add({'id':176,'href':'/leetcode-java/04_Leetcode/0237.Delete-Node-in-a-Linked-List/','title':"0237. Delete Node in a Linked List",'section':"第四章",'content':"237. Delete Node in a Linked List #  题目 #  Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\nGiven linked list \u0026ndash; head = [4,5,1,9], which looks like following:\n Example 1:\n Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function. Example 2:\n Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function. Note:\n The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function.  题目大意 #  删除给点结点。没有给链表的头结点。\n解题思路 #  其实就是把后面的结点都覆盖上来即可。或者直接当前结点的值等于下一个结点，Next 指针指向下下个结点，这样做也可以，只不过中间有一个结点不被释放，内存消耗多一些。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { if node == nil { return } cur := node for cur.Next.Next != nil { cur.Val = cur.Next.Val cur = cur.Next } cur.Val = cur.Next.Val cur.Next = nil } "});index.add({'id':177,'href':'/leetcode-java/04_Leetcode/0239.Sliding-Window-Maximum/','title':"0239. Sliding Window Maximum",'section':"第四章",'content':"239. Sliding Window Maximum #  题目 #  Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\nExample:\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7  Note:\nYou may assume k is always valid, 1 ≤ k ≤ input array\u0026rsquo;s size for non-empty array.\nFollow up:\nCould you solve it in linear time?\n题目大意 #  给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。返回滑动窗口最大值。\n解题思路 #   给定一个数组和一个窗口为 K 的窗口，当窗口从数组的左边滑动到数组右边的时候，输出每次移动窗口以后，在窗口内的最大值。 这道题最暴力的方法就是 2 层循环，时间复杂度 O(n * K)。 另一种思路是用优先队列，每次窗口以后的时候都向优先队列里面新增一个节点，并删除一个节点。时间复杂度是 O(n * log n) 最优的解法是用双端队列，队列的一边永远都存的是窗口的最大值，队列的另外一个边存的是比最大值小的值。队列中最大值左边的所有值都出队。在保证了双端队列的一边即是最大值以后，时间复杂度是 O(n)，空间复杂度是 O(K)  代码 #  package leetcode // 解法一 暴力解法 O(nk) func maxSlidingWindow1(a []int, k int) []int { res := make([]int, 0, k) n := len(a) if n == 0 { return []int{} } for i := 0; i \u0026lt;= n-k; i++ { max := a[i] for j := 1; j \u0026lt; k; j++ { if max \u0026lt; a[i+j] { max = a[i+j] } } res = append(res, max) } return res } // 解法二 双端队列 Deque func maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 || len(nums) \u0026lt; k { return make([]int, 0) } window := make([]int, 0, k) // store the index of nums \tresult := make([]int, 0, len(nums)-k+1) for i, v := range nums { // if the left-most index is out of window, remove it \tif i \u0026gt;= k \u0026amp;\u0026amp; window[0] \u0026lt;= i-k { window = window[1:len(window)] } for len(window) \u0026gt; 0 \u0026amp;\u0026amp; nums[window[len(window)-1]] \u0026lt; v { // maintain window \twindow = window[0 : len(window)-1] } window = append(window, i) // store the index of nums \tif i \u0026gt;= k-1 { result = append(result, nums[window[0]]) // the left-most is the index of max value in nums \t} } return result } "});index.add({'id':178,'href':'/leetcode-java/04_Leetcode/0240.Search-a-2D-Matrix-II/','title':"0240. Search a 2 D Matrix I I",'section':"第四章",'content':"240. Search a 2D Matrix II #  题目 #  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example:\nConsider the following matrix:\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]  Given target = 5, return true.\nGiven target = 20, return false.\n题目大意 #  编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：\n 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。  解题思路 #   给出一个二维矩阵，矩阵的特点是每一个行内，元素随着下标增大而增大，每一列内，元素也是随着下标增大而增大。但是相邻两行的元素并没有大小关系。例如第一行最后一个元素就比第二行第一个元素要大。要求设计一个算法能在这个矩阵中高效的找到一个数，如果找到就输出 true，找不到就输出 false。 这一题是第 74 题的加强版。第 74 题中的二维矩阵完全是一个有序的一维矩阵，但是这一题如果把它拍扁成一维，并不是有序的。首先每一个行或者每一列是有序的 ，那么我们可以依次在每一行或者每一列中利用二分去搜索。这样做时间复杂度为 O(n log n)。 还有一个模拟的解法。通过观察，我们发现了这个矩阵的一个特点，最右边一列的元素是本行中最大的元素，所以我们可以先从最右边一列开始找到第一个比 target 元素大的元素，这个元素所在的行，是我们接着要搜索的。在行中搜索是从最右边开始往左边搜索，时间复杂度是 O(n)，算上一开始在最右边一列中查找的时间复杂度是 O(m)，所以最终的时间复杂度为 O(m+n)。  代码 #  package leetcode // 解法一 模拟，时间复杂度 O(m+n) func searchMatrix240(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } row, col := 0, len(matrix[0])-1 for col \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt;= len(matrix)-1 { if target == matrix[row][col] { return true } else if target \u0026gt; matrix[row][col] { row++ } else { col-- } } return false } // 解法二 二分搜索，时间复杂度 O(n log n) func searchMatrix2401(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } for _, row := range matrix { low, high := 0, len(matrix[0])-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if row[mid] \u0026gt; target { high = mid - 1 } else if row[mid] \u0026lt; target { low = mid + 1 } else { return true } } } return false } "});index.add({'id':179,'href':'/leetcode-java/04_Leetcode/0242.Valid-Anagram/','title':"0242. Valid Anagram",'section':"第四章",'content':"242. Valid Anagram #  题目 #  Given two strings s and t , write a function to determine if t is an anagram of s.\nExample 1:\n Input: s = \u0026quot;anagram\u0026quot;, t = \u0026quot;nagaram\u0026quot; Output: true Example 2:\n Input: s = \u0026quot;rat\u0026quot;, t = \u0026quot;car\u0026quot; Output: false Note:\nYou may assume the string contains only lowercase alphabets.\nFollow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?\n题目大意 #  给出 2 个字符串 s 和 t，如果 t 中的字母在 s 中都存在，输出 true，否则输出 false。\n解题思路 #  这道题可以用打表的方式做。先把 s 中的每个字母都存在一个 26 个容量的数组里面，每个下标依次对应 26 个字母。s 中每个字母都对应表中一个字母，每出现一次就加 1。然后再扫字符串 t，每出现一个字母就在表里面减一。如果都出现了，最终表里面的值肯定都是 0 。最终判断表里面的值是否都是 0 即可，有非 0 的数都输出 false 。\n代码 #  package leetcode // 解法一 func isAnagram(s string, t string) bool { alphabet := make([]int, 26) sBytes := []byte(s) tBytes := []byte(t) if len(sBytes) != len(tBytes) { return false } for i := 0; i \u0026lt; len(sBytes); i++ { alphabet[sBytes[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; len(tBytes); i++ { alphabet[tBytes[i]-\u0026#39;a\u0026#39;]-- } for i := 0; i \u0026lt; 26; i++ { if alphabet[i] != 0 { return false } } return true } // 解法二 func isAnagram1(s string, t string) bool { if s == \u0026#34;\u0026#34; \u0026amp;\u0026amp; t == \u0026#34;\u0026#34; { return true } if s == \u0026#34;\u0026#34; || t == \u0026#34;\u0026#34; { return false } sBytes := []byte(s) tBytes := []byte(t) if len(sBytes) != len(tBytes) { return false } quickSortByte(sBytes, 0, len(sBytes)-1) quickSortByte(tBytes, 0, len(tBytes)-1) for i := 0; i \u0026lt; len(sBytes); i++ { if sBytes[i] != tBytes[i] { return false } } return true } func partitionByte(a []byte, lo, hi int) int { pivot := a[hi] i := lo - 1 for j := lo; j \u0026lt; hi; j++ { if a[j] \u0026gt; pivot { i++ a[j], a[i] = a[i], a[j] } } a[i+1], a[hi] = a[hi], a[i+1] return i + 1 } func quickSortByte(a []byte, lo, hi int) { if lo \u0026gt;= hi { return } p := partitionByte(a, lo, hi) quickSortByte(a, lo, p-1) quickSortByte(a, p+1, hi) } "});index.add({'id':180,'href':'/leetcode-java/04_Leetcode/0257.Binary-Tree-Paths/','title':"0257. Binary Tree Paths",'section':"第四章",'content':"257. Binary Tree Paths #  题目 #  Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExample:\nInput: 1 / \\ 2 3 \\ 5 Output: [\u0026quot;1-\u0026gt;2-\u0026gt;5\u0026quot;, \u0026quot;1-\u0026gt;3\u0026quot;] Explanation: All root-to-leaf paths are: 1-\u0026gt;2-\u0026gt;5, 1-\u0026gt;3  题目大意 #  给定一个二叉树，返回所有从根节点到叶子节点的路径。说明: 叶子节点是指没有子节点的节点。\n解题思路 #   Google 的面试题，考察递归  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func binaryTreePaths(root *TreeNode) []string { if root == nil { return []string{} } res := []string{} if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []string{strconv.Itoa(root.Val)} } tmpLeft := binaryTreePaths(root.Left) for i := 0; i \u0026lt; len(tmpLeft); i++ { res = append(res, strconv.Itoa(root.Val)+\u0026#34;-\u0026gt;\u0026#34;+tmpLeft[i]) } tmpRight := binaryTreePaths(root.Right) for i := 0; i \u0026lt; len(tmpRight); i++ { res = append(res, strconv.Itoa(root.Val)+\u0026#34;-\u0026gt;\u0026#34;+tmpRight[i]) } return res } "});index.add({'id':181,'href':'/leetcode-java/04_Leetcode/0258.Add-Digits/','title':"0258. Add Digits",'section':"第四章",'content':"258. Add Digits #  题目 #  Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nExample:\nInput: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime?\n题目大意 #  给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。\n解题思路 #   给定一个非负整数，反复加各个位上的数，直到结果为一位数为止，最后输出这一位数。 简单题。按照题意循环累加即可。  代码 #  package leetcode func addDigits(num int) int { for num \u0026gt; 9 { cur := 0 for num != 0 { cur += num % 10 num /= 10 } num = cur } return num } "});index.add({'id':182,'href':'/leetcode-java/04_Leetcode/0260.Single-Number-III/','title':"0260. Single Number I I I",'section':"第四章",'content':"260. Single Number III #  题目 #  Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\nExample:\nInput: [1,2,1,3,2,5] Output: [3,5]  Note:\n The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?  题目大意 #  给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n注意：\n 结果输出的顺序并不重要，对于上面的例子，[5, 3] 也是正确答案。 要求算法时间复杂度是线性的，并且不使用额外的辅助空间。  解题思路 #   这一题是第 136 题的加强版。第 136 题里面只有一个数出现一次，其他数都出现 2 次。而这一次有 2 个数字出现一次，其他数出现 2 次。 解题思路还是利用异或，把出现 2 次的数先消除。最后我们要找的 2 个数肯定也是不同的，所以最后 2 个数对一个数进行异或，答案肯定是不同的。那么我们找哪个数为参照物呢？可以随便取，不如就取 lsb 最低位为 1 的数吧 于是整个数组会被分为 2 部分，异或 lsb 为 0 的和异或 lsb 为 1 的，在这 2 部分中，用异或操作把出现 2 次的数都消除，那么剩下的 2 个数分别就在这 2 部分中。  代码 #  package leetcode func singleNumberIII(nums []int) []int { diff := 0 for _, num := range nums { diff ^= num } // Get its last set bit (lsb) \tdiff \u0026amp;= -diff res := []int{0, 0} // this array stores the two numbers we will return \tfor _, num := range nums { if (num \u0026amp; diff) == 0 { // the bit is not set \tres[0] ^= num } else { // the bit is set \tres[1] ^= num } } return res } "});index.add({'id':183,'href':'/leetcode-java/04_Leetcode/0263.Ugly-Number/','title':"0263. Ugly Number",'section':"第四章",'content':"263. Ugly Number #  题目 #  Write a program to check whether a given number is an ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5.\nExample 1:\n Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2:\nInput: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3:\n Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Note:\n 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−2^31, 2^31 − 1].  题目大意 #  判断一个数字是否是“丑陋数字”，“丑陋数字”的定义是一个正数，并且因子只包含 2，3，5 。\n解题思路 #  依照题意要求做即可。\n代码 #  package leetcode func isUgly(num int) bool { for i := 2; i \u0026lt; 6 \u0026amp;\u0026amp; num \u0026gt; 0; i++ { for num%i == 0 { num /= i } } return num == 1 } "});index.add({'id':184,'href':'/leetcode-java/04_Leetcode/0268.Missing-Number/','title':"0268. Missing Number",'section':"第四章",'content':"268. 丢失的数字 #  Difficulty: 简单\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n进阶：\n 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?  示例 1：\n输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2：\n输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3：\n输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4：\n输入：nums = [0] 输出：1 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示：\n n == nums.length 1 \u0026lt;= n \u0026lt;= 10\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt; 0 \u0026lt;= nums[i] \u0026lt;= n nums 中的所有数字都 独一无二  题解 #  题解一：暴力求解 #  class Solution { public int missingNumber(int[] nums) { Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (i != nums[i]) { return i; } } return nums.length; } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  题解二：位运算 #  class Solution { public int missingNumber(int[] nums) { int missing = nums.length; for (int i = 0; i \u0026lt; nums.length; i++) { missing ^= i ^ nums[i]; } return missing; } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  "});index.add({'id':185,'href':'/leetcode-java/04_Leetcode/0274.H-Index/','title':"0274. H Index",'section':"第四章",'content':"274. H-Index #  题目 #  Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher\u0026rsquo;s h-index.\nAccording to the definition of h-index on Wikipedia: \u0026ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\u0026rdquo;\nExample 1:\n Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. Note:\nIf there are several possible values for h, the maximum one is taken as the h-index.\n题目大意 #  求 h-index。h-index 值的定义：如果他/她的 N 篇论文中至少有 h 引用，而其他 N-h 论文的引用数不超过 h 引用数。\n解题思路 #  可以先将数组里面的数从小到大排序。因为要找最大的 h-index，所以从数组末尾开始往前找，找到第一个数组的值，小于，总长度减去下标的值，这个值就是 h-index。\n代码 #  package leetcode // 解法一 func hIndex(citations []int) int { n := len(citations) buckets := make([]int, n+1) for _, c := range citations { if c \u0026gt;= n { buckets[n]++ } else { buckets[c]++ } } count := 0 for i := n; i \u0026gt;= 0; i-- { count += buckets[i] if count \u0026gt;= i { return i } } return 0 } // 解法二 func hIndex1(citations []int) int { quickSort164(citations, 0, len(citations)-1) hIndex := 0 for i := len(citations) - 1; i \u0026gt;= 0; i-- { if citations[i] \u0026gt;= len(citations)-i { hIndex++ } else { break } } return hIndex } "});index.add({'id':186,'href':'/leetcode-java/04_Leetcode/0275.H-Index-II/','title':"0275. H Index I I",'section':"第四章",'content':"275. H-Index II #  题目 #  Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher\u0026rsquo;s h-index.\nAccording to the definition of h-index on Wikipedia: \u0026ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\u0026rdquo;\nExample:\nInput: citations = [0,1,3,5,6] Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3.  Note:\nIf there are several possible values for h, the maximum one is taken as the h-index.\nFollow up:\n This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?  题目大意 #  给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。\nh 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）\u0026quot;\n说明:\n 如果 h 有多有种可能的值 ，h 指数是其中最大的那个。  进阶：\n 这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？  解题思路 #   给出一个数组，代表该作者论文被引用次数，要求这个作者的 h 指数。h 指数定义：\u0026ldquo;高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。） 这一题要找出 h 指数，即要找到一个边界，在这个边界上为最多的 h 指数。可以用二分搜索来解决这道题。当 len(citations)-mid \u0026gt; citations[mid] 时，说明 h 指数的边界一定在右边，因为最多 len(citations)-mid 篇数比引用数 citations[mid] 还要大。否则 h 指数的边界在左边界，缩小边界以后继续二分。找到边界以后，最终求的是 h 指数，用 len(citations) - low 即是结果。  代码 #  package leetcode func hIndex275(citations []int) int { low, high := 0, len(citations)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if len(citations)-mid \u0026gt; citations[mid] { low = mid + 1 } else { high = mid - 1 } } return len(citations) - low } "});index.add({'id':187,'href':'/leetcode-java/04_Leetcode/0283.Move-Zeroes/','title':"0283. Move Zeroes",'section':"第四章",'content':"283. Move Zeroes #  题目 #  Given an array nums, write a function to move all 0\u0026rsquo;s to the end of it while maintaining the relative order of the non-zero elements.\nExample 1:\n Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:\n You must do this in-place without making a copy of the array. Minimize the total number of operations.  题目大意 #  题目要求不能采用额外的辅助空间，将数组中 0 元素都移动到数组的末尾，并且维持所有非 0 元素的相对位置。\n解题思路 #  这一题可以只扫描数组一遍，不断的用 i，j 标记 0 和非 0 的元素，然后相互交换，最终到达题目的目的。与这一题相近的题目有第 26 题，第 27 题，第 80 题。\n代码 #  package leetcode func moveZeroes(nums []int) { if len(nums) == 0 { return } j := 0 for i := 0; i \u0026lt; len(nums); i++ { if nums[i] != 0 { if i != j { nums[i], nums[j] = nums[j], nums[i] j++ } else { j++ } } } } "});index.add({'id':188,'href':'/leetcode-java/04_Leetcode/0287.Find-the-Duplicate-Number/','title':"0287. Find the Duplicate Number",'section':"第四章",'content':"287. Find the Duplicate Number #  题目 #  Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\nExample 1:\n Input: [1,3,4,2,2] Output: 2 Example 2:\n Input: [3,1,3,4,2] Output: 3 Note:\n You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n^2). There is only one duplicate number in the array, but it could be repeated more than once.  题目大意 #  给出 n + 1 个数，这些数是在 1-n 中取值的，同一个数字可以出现多次。要求找出这些数中重复的数字。时间复杂度最好低于 O(n^2)，空间复杂度为 O(1)。\n解题思路 #   这道题比较巧的思路是，将这些数字想象成链表中的结点，数组中数字代表下一个结点的数组下标。找重复的数字就是找链表中成环的那个点。由于题目保证了一定会有重复的数字，所以一定会成环。所以用快慢指针的方法，快指针一次走 2 步，慢指针一次走 1 步，相交以后，快指针从头开始，每次走一步，再次遇见的时候就是成环的交点处，也即是重复数字所在的地方。 这一题有多种做法。可以用快慢指针求解。还可以用二分搜索：(这里的题解感谢 @imageslr 指出错误）：  假设有 n+1 个数，则可能重复的数位于区间 [1, n] 中。记该区间最小值、最大值和中间值为 low、high、mid 遍历整个数组，统计小于等于 mid 的整数的个数，至多为 mid 个 如果超过 mid 个就说明重复的数存在于区间 [low,mid] （闭区间）中；否则，重复的数存在于区间 (mid, high] （左开右闭）中 缩小区间，继续重复步骤 2、3，直到区间变成 1 个整数，即 low == high 整数 low 就是要找的重复的数   另外一个做法是，先将数组排序，依照下标是从 0 开始递增的特性，那么数组里面的数字与下标的差值应该是越来越大。如果出现了相同的数字，下标变大，差值应该比前一个数字小，出现了这个情况就说明找到了相同数字了。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 快慢指针 func findDuplicate(nums []int) int { slow := nums[0] fast := nums[nums[0]] for fast != slow { slow = nums[slow] fast = nums[nums[fast]] } walker := 0 for walker != slow { walker = nums[walker] slow = nums[slow] } return walker } // 解法二 二分搜索 func findDuplicate1(nums []int) int { low, high := 0, len(nums)-1 for low \u0026lt; high { mid, count := low+(high-low)\u0026gt;\u0026gt;1, 0 for _, num := range nums { if num \u0026lt;= mid { count++ } } if count \u0026gt; mid { high = mid } else { low = mid + 1 } } return low } // 解法三 func findDuplicate2(nums []int) int { if len(nums) == 0 { return 0 } sort.Ints(nums) diff := -1 for i := 0; i \u0026lt; len(nums); i++ { if nums[i]-i-1 \u0026gt;= diff { diff = nums[i] - i - 1 } else { return nums[i] } } return 0 } "});index.add({'id':189,'href':'/leetcode-java/04_Leetcode/0290.Word-Pattern/','title':"0290. Word Pattern",'section':"第四章",'content':"290. Word Pattern #  题目 #  Given a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\nExample 1:\n Input: pattern = \u0026quot;abba\u0026quot;, str = \u0026quot;dog cat cat dog\u0026quot; Output: true Example 2:\n Input:pattern = \u0026quot;abba\u0026quot;, str = \u0026quot;dog cat cat fish\u0026quot; Output: false Example 3:\n Input: pattern = \u0026quot;aaaa\u0026quot;, str = \u0026quot;dog cat cat dog\u0026quot; Output: false Example 4:\n Input: pattern = \u0026quot;abba\u0026quot;, str = \u0026quot;dog dog dog dog\u0026quot; Output: false Note:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\n题目大意 #  给定一个模式串，判断字符串是否和给定的模式串，是一样的模式。\n解题思路 #  这道题用 2 个 map 即可。1 个 map 记录模式与字符串的匹配关系，另外一个 map 记录字符串和模式的匹配关系。为什么需要记录双向的关系呢？因为 Example 4 中，a 对应了 dog，这个时候 b 如果再对应 dog 是错误的，所以这里需要从 dog 查询它是否已经和某个模式匹配过了。所以需要双向的关系。\n代码 #  package leetcode import \u0026#34;strings\u0026#34; func wordPattern(pattern string, str string) bool { strList := strings.Split(str, \u0026#34; \u0026#34;) patternByte := []byte(pattern) if pattern == \u0026#34;\u0026#34; || len(patternByte) != len(strList) { return false } pMap := map[byte]string{} sMap := map[string]byte{} for index, b := range patternByte { if _, ok := pMap[b]; !ok { if _, ok = sMap[strList[index]]; !ok { pMap[b] = strList[index] sMap[strList[index]] = b } else { if sMap[strList[index]] != b { return false } } } else { if pMap[b] != strList[index] { return false } } } return true } "});index.add({'id':190,'href':'/leetcode-java/04_Leetcode/0300.Longest-Increasing-Subsequence/','title':"0300. Longest Increasing Subsequence",'section':"第四章",'content':"300. Longest Increasing Subsequence #  题目 #  Given an unsorted array of integers, find the length of longest increasing subsequence.\nExample:\nInput: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:\n There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n^2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?\n题目大意 #  给定一个无序的整数数组，找到其中最长上升子序列的长度。\n解题思路 #   给定一个整数序列，求其中的最长上升子序列的长度。这一题就是经典的最长上升子序列的问题。 dp[i] 代表为第 i 个数字为结尾的最长上升子序列的长度。换种表述，dp[i] 代表 [0,i] 范围内，选择数字 nums[i] 可以获得的最长上升子序列的长度。状态转移方程为 dp[i] = max( 1 + dp[j]) ，其中 j \u0026lt; i \u0026amp;\u0026amp; nums[j] \u0026gt; nums[i]，取所有满足条件的最大值。时间复杂度 O(n^2) 这道题还有一种更快的解法。考虑这样一个问题，我们是否能用一个数组，记录上升子序列的最末尾的一个数字呢？如果这个数字越小，那么这个子序列往后面添加数字的几率就越大，那么就越可能成为最长的上升子序列。举个例子：nums = [4,5,6,3]，它的所有的上升子序列为   len = 1 : [4], [5], [6], [3] =\u0026gt; tails[0] = 3 len = 2 : [4, 5], [5, 6] =\u0026gt; tails[1] = 5 len = 3 : [4, 5, 6] =\u0026gt; tails[2] = 6  其中 tails[i] 中存储的是所有长度为 i + 1 的上升子序列中末尾最小的值。也很容易证明 tails 数组里面的值一定是递增的(因为我们用末尾的数字描述最长递增子序列)。既然 tails 是有序的，我们就可以用二分查找的方法去更新这个 tail 数组里面的值。更新策略如下：(1). 如果 x 比所有的 tails 元素都要大，那么就直接放在末尾，并且 tails 数组长度加一；(2). 如果 tails[i-1] \u0026lt; x \u0026lt;= tails[i]，则更新 tails[i]，因为 x 更小，更能获得最长上升子序列。最终 tails 数组的长度即为最长的上升子序列。这种做法的时间复杂度 O(n log n)。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 O(n^2) DP func lengthOfLIS(nums []int) int { dp, res := make([]int, len(nums)+1), 0 dp[0] = 0 for i := 1; i \u0026lt;= len(nums); i++ { for j := 1; j \u0026lt; i; j++ { if nums[j-1] \u0026lt; nums[i-1] { dp[i] = max(dp[i], dp[j]) } } dp[i] = dp[i] + 1 res = max(res, dp[i]) } return res } // 解法二 O(n log n) DP func lengthOfLIS1(nums []int) int { dp := []int{} for _, num := range nums { i := sort.SearchInts(dp, num) if i == len(dp) { dp = append(dp, num) } else { dp[i] = num } } return len(dp) } "});index.add({'id':191,'href':'/leetcode-java/04_Leetcode/0303.Range-Sum-Query-Immutable/','title':"0303. Range Sum Query Immutable",'section':"第四章",'content':"303. Range Sum Query - Immutable #  题目 #  Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nExample:\nGiven nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3  Note:\n You may assume that the array does not change. There are many calls to sumRange function.  题目大意 #  给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。\n示例：\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3 说明:\n 你可以假设数组不可变。 会多次调用 sumRange 方法。  解题思路 #   给出一个数组，数组里面的数都是**不可变**的，设计一个数据结构能够满足查询数组任意区间内元素的和。 这一题由于数组里面的元素都是**不可变**的，所以可以用 2 种方式来解答，第一种解法是用 prefixSum，通过累计和相减的办法来计算区间内的元素和，初始化的时间复杂度是 O(n)，但是查询区间元素和的时间复杂度是 O(1)。第二种解法是利用线段树，构建一颗线段树，父结点内存的是两个子结点的和，初始化建树的时间复杂度是 O(log n)，查询区间元素和的时间复杂度是 O(log n)。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) //解法一 线段树，sumRange 时间复杂度 O(1)  // NumArray define type NumArray struct { st *template.SegmentTree } // Constructor303 define func Constructor303(nums []int) NumArray { st := template.SegmentTree{} st.Init(nums, func(i, j int) int { return i + j }) return NumArray{st: \u0026amp;st} } // SumRange define func (ma *NumArray) SumRange(i int, j int) int { return ma.st.Query(i, j) } //解法二 prefixSum，sumRange 时间复杂度 O(1)  // // NumArray define // type NumArray struct { // prefixSum []int // }  // // Constructor303 define // func Constructor303(nums []int) NumArray { // for i := 1; i \u0026lt; len(nums); i++ { // nums[i] += nums[i-1] // } // return NumArray{prefixSum: nums} // }  // // SumRange define // func (this *NumArray) SumRange(i int, j int) int { // if i \u0026gt; 0 { // return this.prefixSum[j] - this.prefixSum[i-1] // } // return this.prefixSum[j] // }  /** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(i,j); */ "});index.add({'id':192,'href':'/leetcode-java/04_Leetcode/0306.Additive-Number/','title':"0306. Additive Number",'section':"第四章",'content':"306. Additive Number #  题目 #  Additive number is a string whose digits can form additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits '0'-'9', write a function to determine if it\u0026rsquo;s an additive number.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\nExample 1:\nInput: \u0026quot;112358\u0026quot; Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8  Example 2:\nInput: \u0026quot;199100199\u0026quot; Output: true Explanation: The additive sequence is: 1, 99, 100, 199. 1 + 99 = 100, 99 + 100 = 199  Follow up:How would you handle overflow for very large input integers?\n题目大意 #  累加数是一个字符串，组成它的数字可以形成累加序列。一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。给定一个只包含数字 \u0026lsquo;0\u0026rsquo;-\u0026lsquo;9\u0026rsquo; 的字符串，编写一个算法来判断给定输入是否是累加数。说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。\n解题思路 #   在给出的字符串中判断该字符串是否为斐波那契数列形式的字符串。 由于每次判断需要累加 2 个数字，所以在 DFS 遍历的过程中需要维护 2 个数的边界，firstEnd 和 secondEnd，两个数加起来的和数的起始位置是 secondEnd + 1。每次在移动 firstEnd 和 secondEnd 的时候，需要判断 strings.HasPrefix(num[secondEnd + 1:], strconv.Itoa(x1 + x2))，即后面的字符串中是否以和为开头。 如果第一个数字起始数字出现了 0 ，或者第二个数字起始数字出现了 0，都算非法异常情况，都应该直接返回 false。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) // This function controls various combinations as starting points func isAdditiveNumber(num string) bool { if len(num) \u0026lt; 3 { return false } for firstEnd := 0; firstEnd \u0026lt; len(num)/2; firstEnd++ { if num[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; firstEnd \u0026gt; 0 { break } first, _ := strconv.Atoi(num[:firstEnd+1]) for secondEnd := firstEnd + 1; max(firstEnd, secondEnd-firstEnd) \u0026lt;= len(num)-secondEnd; secondEnd++ { if num[firstEnd+1] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; secondEnd-firstEnd \u0026gt; 1 { break } second, _ := strconv.Atoi(num[firstEnd+1 : secondEnd+1]) if recursiveCheck(num, first, second, secondEnd+1) { return true } } } return false } //Propagate for rest of the string func recursiveCheck(num string, x1 int, x2 int, left int) bool { if left == len(num) { return true } if strings.HasPrefix(num[left:], strconv.Itoa(x1+x2)) { return recursiveCheck(num, x2, x1+x2, left+len(strconv.Itoa(x1+x2))) } return false } "});index.add({'id':193,'href':'/leetcode-java/04_Leetcode/0307.Range-Sum-Query-Mutable/','title':"0307. Range Sum Query Mutable",'section':"第四章",'content':"307. Range Sum Query - Mutable #  题目 #  Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val.\nExample:\nGiven nums = [1, 3, 5] sumRange(0, 2) -\u0026gt; 9 update(1, 2) sumRange(0, 2) -\u0026gt; 8  Note:\n The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.  题目大意 #  给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。\nupdate(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。\n示例:\nGiven nums = [1, 3, 5] sumRange(0, 2) -\u0026gt; 9 update(1, 2) sumRange(0, 2) -\u0026gt; 8 说明:\n 数组仅可以在 update 函数下进行修改。 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。  解题思路 #   给出一个数组，数组里面的数都是**可变**的，设计一个数据结构能够满足查询数组任意区间内元素的和。 对比第 303 题，这一题由于数组里面的元素都是**可变**的，所以第一个想到的解法就是线段树，构建一颗线段树，父结点内存的是两个子结点的和，初始化建树的时间复杂度是 O(log n)，查询区间元素和的时间复杂度是 O(log n)，更新元素值的时间复杂度是 O(log n)。 如果此题还用 prefixSum 的思路解答呢？那每次 update 操作的时间复杂度都是 O(n)，因为每次更改一个值，最坏情况就是所有的 prefixSum 都要更新一次。prefixSum 的方法在这道题上面也可以 AC，只不过时间排名在 5%，非常差。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // Constructor307 define func Constructor307(nums []int) NumArray { st := template.SegmentTree{} st.Init(nums, func(i, j int) int { return i + j }) return NumArray{st: \u0026amp;st} } // Update define func (this *NumArray) Update(i int, val int) { this.st.Update(i, val) } //解法二 prefixSum，sumRange 时间复杂度 O(1)  // // NumArray define // type NumArray307 struct { // prefixSum []int // data []int // }  // // Constructor307 define // func Constructor307(nums []int) NumArray307 { // data := make([]int, len(nums)) // for i := 0; i \u0026lt; len(nums); i++ { // data[i] = nums[i] // } // for i := 1; i \u0026lt; len(nums); i++ { // nums[i] += nums[i-1] // } // return NumArray307{prefixSum: nums, data: data} // }  // // Update define // func (this *NumArray307) Update(i int, val int) { // this.data[i] = val // this.prefixSum[0] = this.data[0] // for i := 1; i \u0026lt; len(this.data); i++ { // this.prefixSum[i] = this.prefixSum[i-1] + this.data[i] // } // }  // // SumRange define // func (this *NumArray307) SumRange(i int, j int) int { // if i \u0026gt; 0 { // return this.prefixSum[j] - this.prefixSum[i-1] // } // return this.prefixSum[j] // }  /** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * obj.Update(i,val); * param_2 := obj.SumRange(i,j); */ "});index.add({'id':194,'href':'/leetcode-java/04_Leetcode/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/','title':"0309. Best Time to Buy and Sell Stock With Cooldown",'section':"第四章",'content':"309. Best Time to Buy and Sell Stock with Cooldown #  题目 #  Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example:\nInput: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell]  题目大意 #  给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。  解题思路 #   给定一个数组，表示一支股票在每一天的价格。设计一个交易算法，在这些天进行自动交易，要求：每一天只能进行一次操作；在买完股票后，必须卖了股票，才能再次买入；每次卖了股票以后，在下一天是不能购买的。问如何交易，能让利润最大？ 这一题是第 121 题和第 122 题的变种题。 每天都有 3 种操作，buy，sell，cooldown。sell 之后的一天一定是 cooldown，但是 cooldown 可以出现在任意一天。例如：buy，cooldown，cooldown，sell，cooldown，cooldown。buy[i] 代表第 i 天通过 buy 或者 cooldown 结束此天能获得的最大收益。例如：buy, sell, buy 或者 buy, cooldown, cooldown。sell[i] 代表第 i 天通过 sell 或者 cooldown 结束此天能获得的最大收益。例如：buy, sell, buy, sell 或者 buy, sell, cooldown, cooldown。price[i-1] 代表第 i 天的股票价格(由于 price 是从 0 开始的)。 第 i 天如果是 sell，那么这天能获得的最大收益是 buy[i - 1] + price[i - 1]，因为只有 buy 了才能 sell。如果这一天是 cooldown，那么这天能获得的最大收益还是 sell[i - 1]。所以 sell[i] 的状态转移方程 sell[i] = max(buy[i - 1] + price[i - 1], sell[i - 1])。sell[0] = 0 代表第一天就卖了，由于第一天不持有股票，所以 sell[0] = 0。sell[1] = max(sell[0], buy[0]+prices[1]) 代表第一天卖了，和第一天不卖，第二天卖做对比，钱多的保存至 sell[1]。 第 i 天如果是 buy，那么这天能获得的最大收益是 sell[i - 2] - price[i - 1]，因为 i - 1 天是 cooldown。如果这一天是 cooldown，那么这天能获得的最大收益还是 buy[i - 1]。所以 buy[i] 的状态转移方程 buy[i] = max(sell[i - 2] - price[i - 1], buy[i - 1])。buy[0] = -prices[0] 代表第一天就买入，所以金钱变成了负的。buy[1] = max(buy[0], -prices[1]) 代表第一天不买入，第二天再买入。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) // 解法一 DP func maxProfit309(prices []int) int { if len(prices) \u0026lt;= 1 { return 0 } buy, sell := make([]int, len(prices)), make([]int, len(prices)) for i := range buy { buy[i] = math.MinInt64 } buy[0] = -prices[0] buy[1] = max(buy[0], -prices[1]) sell[1] = max(sell[0], buy[0]+prices[1]) for i := 2; i \u0026lt; len(prices); i++ { sell[i] = max(sell[i-1], buy[i-1]+prices[i]) buy[i] = max(buy[i-1], sell[i-2]-prices[i]) } return sell[len(sell)-1] } // 解法二 优化辅助空间的 DP func maxProfit309_1(prices []int) int { if len(prices) \u0026lt;= 1 { return 0 } buy := []int{-prices[0], max(-prices[0], -prices[1]), math.MinInt64} sell := []int{0, max(0, -prices[0]+prices[1]), 0} for i := 2; i \u0026lt; len(prices); i++ { sell[i%3] = max(sell[(i-1)%3], buy[(i-1)%3]+prices[i]) buy[i%3] = max(buy[(i-1)%3], sell[(i-2)%3]-prices[i]) } return sell[(len(prices)-1)%3] } "});index.add({'id':195,'href':'/leetcode-java/04_Leetcode/0315.Count-of-Smaller-Numbers-After-Self/','title':"0315. Count of Smaller Numbers After Self",'section':"第四章",'content':"315. Count of Smaller Numbers After Self #  题目 #  You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\nExample:\nInput: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.  题目大意 #  给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。\n示例:\n 输入: [5,2,6,1] 输出: [2,1,1,0] 解释: 5 的右侧有 2 个更小的元素 (2 和 1). 2 的右侧仅有 1 个更小的元素 (1). 6 的右侧有 1 个更小的元素 (1). 1 的右侧有 0 个更小的元素. 解题思路 #   给出一个数组，要求输出数组中每个元素相对于数组中的位置右边比它小的元素。 这一题是第 327 题的缩水版。由于需要找数组位置右边比当前位置元素小的元素，所以从数组右边开始往左边扫。构造一颗线段树，线段树里面父节点存的是子节点出现的次数和。有可能给的数据会很大，所以构造线段树的时候先离散化。还需要注意的是数组里面可能有重复元素，所以构造线段树要先去重并排序。从右往左扫的过程中，依次添加数组中的元素，添加了一次就立即 query 一次。query 的区间是 [minNum, nums[i]-1]。如果是 minNum 则输出 0，并且也要记得插入这个最小值。这一题的思路和第 327 题大体类似，详解可见第 327 题。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func countSmaller(nums []int) []int { if len(nums) == 0 { return []int{} } st, minNum, numsMap, numsArray, res := template.SegmentCountTree{}, 0, make(map[int]int, 0), []int{}, make([]int, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { numsMap[nums[i]] = nums[i] } for _, v := range numsMap { numsArray = append(numsArray, v) } // 排序是为了使得线段树中的区间 left \u0026lt;= right，如果此处不排序，线段树中的区间有很多不合法。 \tsort.Ints(numsArray) minNum = numsArray[0] // 初始化线段树，节点内的值都赋值为 0，即计数为 0 \tst.Init(numsArray, func(i, j int) int { return 0 }) for i := len(nums) - 1; i \u0026gt;= 0; i-- { if nums[i] == minNum { res[i] = 0 st.UpdateCount(nums[i]) continue } st.UpdateCount(nums[i]) res[i] = st.Query(minNum, nums[i]-1) } return res } "});index.add({'id':196,'href':'/leetcode-java/04_Leetcode/0318.Maximum-Product-of-Word-Lengths/','title':"0318. Maximum Product of Word Lengths",'section':"第四章",'content':"318. Maximum Product of Word Lengths #  题目 #  Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\nExample 1:\nInput: [\u0026quot;abcw\u0026quot;,\u0026quot;baz\u0026quot;,\u0026quot;foo\u0026quot;,\u0026quot;bar\u0026quot;,\u0026quot;xtfn\u0026quot;,\u0026quot;abcdef\u0026quot;] Output: 16 Explanation: The two words can be \u0026quot;abcw\u0026quot;, \u0026quot;xtfn\u0026quot;.  Example 2:\nInput: [\u0026quot;a\u0026quot;,\u0026quot;ab\u0026quot;,\u0026quot;abc\u0026quot;,\u0026quot;d\u0026quot;,\u0026quot;cd\u0026quot;,\u0026quot;bcd\u0026quot;,\u0026quot;abcd\u0026quot;] Output: 4 Explanation: The two words can be \u0026quot;ab\u0026quot;, \u0026quot;cd\u0026quot;.  Example 3:\nInput: [\u0026quot;a\u0026quot;,\u0026quot;aa\u0026quot;,\u0026quot;aaa\u0026quot;,\u0026quot;aaaa\u0026quot;] Output: 0 Explanation: No such pair of words.  题目大意 #  给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。\n解题思路 #   在字符串数组中找到 2 个没有公共字符的字符串，并且这两个字符串的长度乘积要是最大的，求这个最大的乘积。 这里需要利用位运算 \u0026amp; 运算的性质，如果 X \u0026amp; Y = 0，说明 X 和 Y 完全不相同。那么我们将字符串都编码成二进制数，进行 \u0026amp; 运算即可分出没有公共字符的字符串，最后动态维护长度乘积最大值即可。将字符串编码成二进制数的规则比较简单，每个字符相对于 \u0026lsquo;a\u0026rsquo; 的距离，根据这个距离将 1 左移多少位。  a 1-\u0026gt;1 b 2-\u0026gt;10 c 4-\u0026gt;100 ab 3-\u0026gt;11 ac 5-\u0026gt;101 abc 7-\u0026gt;111 az 33554433-\u0026gt;10000000000000000000000001 代码 #  package leetcode func maxProduct318(words []string) int { if words == nil || len(words) == 0 { return 0 } length, value, maxProduct := len(words), make([]int, len(words)), 0 for i := 0; i \u0026lt; length; i++ { tmp := words[i] value[i] = 0 for j := 0; j \u0026lt; len(tmp); j++ { value[i] |= 1 \u0026lt;\u0026lt; (tmp[j] - \u0026#39;a\u0026#39;) } } for i := 0; i \u0026lt; length; i++ { for j := i + 1; j \u0026lt; length; j++ { if (value[i]\u0026amp;value[j]) == 0 \u0026amp;\u0026amp; (len(words[i])*len(words[j]) \u0026gt; maxProduct) { maxProduct = len(words[i]) * len(words[j]) } } } return maxProduct } "});index.add({'id':197,'href':'/leetcode-java/04_Leetcode/0322.Coin-Change/','title':"0322. Coin Change",'section':"第四章",'content':"322. Coin Change #  题目 #  You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nExample 1:\nInput: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1  Example 2:\nInput: coins = [2], amount = 3 Output: -1  Note:\nYou may assume that you have an infinite number of each kind of coin.\n题目大意 #  给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n解题思路 #   给出一些硬币和一个总数，问组成这个总数的硬币数最少是多少个？ 这一题是经典的硬币问题，利用 DP 求解。不过这一题的测试用例有一个很大的值，这样开 DP 数组会比较浪费空间。例如 [1,1000000000,500000] 有这样的硬币种类，要求组成 2389412493027523 这样的总数。那么按照下面的解题方法，数组会开的很大，非常浪费空间。这个时候用 DFS 解题会节约一点空间。  代码 #  package leetcode func coinChange(coins []int, amount int) int { dp := make([]int, amount+1) dp[0] = 0 for i := 1; i \u0026lt; len(dp); i++ { dp[i] = amount + 1 } for i := 1; i \u0026lt;= amount; i++ { for j := 0; j \u0026lt; len(coins); j++ { if coins[j] \u0026lt;= i { dp[i] = min(dp[i], dp[i-coins[j]]+1) } } } if dp[amount] \u0026gt; amount { return -1 } return dp[amount] } "});index.add({'id':198,'href':'/leetcode-java/04_Leetcode/0324.Wiggle-Sort-II/','title':"0324. Wiggle Sort I I",'section':"第四章",'content':"324. Wiggle Sort II #  题目 #  Given an unsorted array nums, reorder it such that nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]\u0026hellip;.\nExample 1:\n Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2:\n Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note:\nYou may assume all input has valid answer.\nFollow up:\nCan you do it in O(n) time and/or in-place with O(1) extra space?\n题目大意 #  给定一个数组，要求给它进行“摆动排序”，“摆动排序”即：nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]\u0026hellip;\n解题思路 #  这一题最直接的方法是先排序，然后用 2 个指针，一个指向下标为 0 的位置，另一个指向下标为 n/2 的位置。最终的数组的奇数位从下标为 0 开始往后取，偶数位从下标为 n/2 中间位置开始往后取。这种方法时间复杂度为 O(n log n)。\n题目要求用时间复杂度 O(n) 和 空间复杂度 O(1) 的方法解决。思路如下，先找到数组中间大小的数字，然后把数组分为 2 部分：\nIndex : 0 1 2 3 4 5 Small half: M S S Large half: L L L(M) 奇数位排中间数和小于中间数的数字，偶数位排大于中间数的数字和中间数。如果中间数字有多个，那么偶数位最后几位也是中间数，奇数位开头的前几位也是中间数。\n举例，给定一个数组如下，中间数是 5 。有 2 个 5 。\n13 6 5 5 4 2 M Step 1: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[Mapped_idx[i]] = nums[1] = 6 \u0026gt; 5, 所以可以把 6 放在第 1 个奇数位的位置。left 和 i 同时右移。\nStep 2: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[3] = 5 = 5, 5 可以放在下标为 3 的位置，由于 5 已经和中间数相等了，所以只后移 i 。\nStep 3: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[5] = 2 \u0026lt; 5, 因为比中位数小，所以应该放在偶数位的最后 1 位。这里的例子而言，应该放在下标为 4 的位置上。交换 nums[Mapped_idx[i]] 和 nums[Mapped_idx[Right]]，交换完成以后 right 向左移。\nStep 4: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 2 4 Left i Right nums[5] = 4 \u0026lt; 5, 因为比中位数小，所以应该放在偶数位的当前倒数第一位。这里的例子而言，应该放在下标为 2 的位置上。交换 nums[Mapped_idx[i]] 和 nums[Mapped_idx[Right]]，交换完成以后 right 向左移。\nStep 5: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 4 5 2 5 Left i Right nums[5] = 5 = 5, 由于 5 已经和中间数相等了，所以只后移 i 。\nStep 6: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 4 5 2 5 Left i Right nums[0] = 13 \u0026gt; 5, 由于 13 比中位数大，所以可以把 13 放在第 2 个奇数位的位置，并移动 left 和 i 。\nStep Final: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 5 6 4 13 2 5 Left i Right i \u0026gt; Right, 退出循环，最终摆动排序的结果是 5 6 4 13 2 5 。\n具体时间见代码，时间复杂度 O(n) 和 空间复杂度 O(1)。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) // 解法一 func wiggleSort(nums []int) { if len(nums) \u0026lt; 2 { return } median := findKthLargest324(nums, (len(nums)+1)/2) n, i, left, right := len(nums), 0, 0, len(nums)-1 for i \u0026lt;= right { if nums[indexMap(i, n)] \u0026gt; median { nums[indexMap(left, n)], nums[indexMap(i, n)] = nums[indexMap(i, n)], nums[indexMap(left, n)] left++ i++ } else if nums[indexMap(i, n)] \u0026lt; median { nums[indexMap(right, n)], nums[indexMap(i, n)] = nums[indexMap(i, n)], nums[indexMap(right, n)] right-- } else { i++ } } } func indexMap(index, n int) int { return (1 + 2*index) % (n | 1) } func findKthLargest324(nums []int, k int) int { if len(nums) == 0 { return 0 } return selection324(nums, 0, len(nums)-1, len(nums)-k) } func selection324(arr []int, l, r, k int) int { if l == r { return arr[l] } p := partition324(arr, l, r) if k == p { return arr[p] } else if k \u0026lt; p { return selection324(arr, l, p-1, k) } else { return selection324(arr, p+1, r, k) } } func partition324(a []int, lo, hi int) int { pivot := a[hi] i := lo - 1 for j := lo; j \u0026lt; hi; j++ { if a[j] \u0026lt; pivot { i++ a[j], a[i] = a[i], a[j] } } a[i+1], a[hi] = a[hi], a[i+1] return i + 1 } // 解法二 func wiggleSort1(nums []int) { if len(nums) \u0026lt; 2 { return } array := make([]int, len(nums)) copy(array, nums) sort.Ints(array) n := len(nums) left := (n+1)/2 - 1 // median index \tright := n - 1 // largest value index \tfor i := 0; i \u0026lt; len(nums); i++ { // copy large values on odd indexes \tif i%2 == 1 { nums[i] = array[right] right-- } else { // copy values decremeting from median on even indexes \tnums[i] = array[left] left-- } } } "});index.add({'id':199,'href':'/leetcode-java/04_Leetcode/0326.Power-of-Three/','title':"0326. Power of Three",'section':"第四章",'content':"326. Power of Three #  题目 #  Given an integer, write a function to determine if it is a power of three.\nExample 1:\nInput: 27 Output: true  Example 2:\nInput: 0 Output: false  Example 3:\nInput: 9 Output: true  Example 4:\nInput: 45 Output: false  Follow up:\nCould you do it without using any loop / recursion?\n题目大意 #  给定一个整数，写一个函数来判断它是否是 3 的幂次方。\n解题思路 #   判断一个数是不是 3 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。由于 3^20 超过了 int 的范围了，所以 3^19 次方就是 int 类型中最大的值。这一题和第 231 题是一样的思路。  代码 #  package leetcode // 解法一 数论 func isPowerOfThree(n int) bool { // 1162261467 is 3^19, 3^20 is bigger than int \treturn n \u0026gt; 0 \u0026amp;\u0026amp; (1162261467%n == 0) } // 解法二 打表法 func isPowerOfThree1(n int) bool { // 1162261467 is 3^19, 3^20 is bigger than int \tallPowerOfThreeMap := map[int]int{1: 1, 3: 3, 9: 9, 27: 27, 81: 81, 243: 243, 729: 729, 2187: 2187, 6561: 6561, 19683: 19683, 59049: 59049, 177147: 177147, 531441: 531441, 1594323: 1594323, 4782969: 4782969, 14348907: 14348907, 43046721: 43046721, 129140163: 129140163, 387420489: 387420489, 1162261467: 1162261467} _, ok := allPowerOfThreeMap[n] return ok } // 解法三 循环 func isPowerOfThree2(num int) bool { for num \u0026gt;= 3 { if num%3 == 0 { num = num / 3 } else { return false } } return num == 1 } "});index.add({'id':200,'href':'/leetcode-java/04_Leetcode/0327.Count-of-Range-Sum/','title':"0327. Count of Range Sum",'section':"第四章",'content':"327. Count of Range Sum #  题目 #  Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.\nNote:A naive algorithm of O(n2) is trivial. You MUST do better than that.\nExample:\nInput: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3 Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.  题目大意 #  给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。\n说明:\n最直观的算法复杂度是 O(n^2) ，请在此基础上优化你的算法。\n解题思路 #    给出一个数组，要求在这个数组中找出任意一段子区间的和，位于 [lower,upper] 之间。\n  这一题可以用暴力解法，2 层循环，遍历所有子区间，求和并判断是否位于 [lower,upper] 之间，时间复杂度 O(n^2)。\n  这一题当然还有更优的解法，用线段树或者树状数组，将时间复杂度降为 O(n log n)。题目中要求 lower ≤ sum(i,j) ≤ upper，sum(i,j) = prefixSum(j) - prefixSum(i-1)，那么 lower + prefixSum(i-1) ≤ prefixSum(j) ≤ upper + prefixSum(i-1)。所以利用前缀和将区间和转换成了前缀和在线段树中 query 的问题，只不过线段树中父节点中存的不是子节点的和，而应该是子节点出现的次数。第二个转换，由于前缀和会很大，所以需要离散化。例如 prefixSum = [-3,-2,-1,0]，用前缀和下标进行离散化，所以线段树中左右区间变成了 0-3 。\n 利用 prefixSum 下标离散化：\n   还需要注意一些小细节，prefixSum 计算完以后需要去重，去重以后并排序，方便构造线段树的有效区间。如果不去重，线段树中可能出现非法区间(left \u0026gt; right)或者重叠区间。最后一步往线段树中倒序插入 prefixSum 的时候，用的是非去重的，插入 prefixSum[j] 代表 sum(i,j) 中的 j，例如往线段树中插入 prefixSum[5]，代表当前树中加入了 j = 5 的情况。query 操作实质是在做区间匹配，例如当前 i 循环到 i = 3，累计往线段树中插入了 prefixSum[5]，prefixSum[4]，prefixSum[3]，那么 query 操作实质是在判断：lower ≤ sum(i=3,j=3) ≤ upper，lower ≤ sum(i=3,j=4) ≤ upper，lower ≤ sum(i=3,j=5) ≤ upper，这 3 个等式是否成立，有几个成立就返回几个，即是最终要求得的结果的一部分。\n  举个例子，nums = [-3,1,2,-2,2,-1]，prefixSum = [-3,-2,0,-2,0,-1]，去重以后并排序得到 sum = [-3,-2,-1,0]。离散化构造线段树，这里出于演示的方便，下图中就不画出离散后的线段树了，用非离散的线段树展示：\n 倒序插入 len(prefixSum)-1 = prefixSum[5] = -1：\n 这时候查找区间变为了 [-3 + prefixSum[5-1], -1 + prefixSum[5-1]] = [-3,-1]，即判断 -3 ≤ sum(5,5) ≤ -1，满足等式的有几种情况，这里明显只有一种情况，即 j = 5，也满足等式，所以这一步 res = 1。\n  倒序插入 len(prefixSum)-2 = prefixSum[4] = 0：\n 这时候查找区间变为了 [-3 + prefixSum[4-1], -1 + prefixSum[4-1]] = [-5,-3]，即判断 -5 ≤ sum(4, 4,5) ≤ -3，满足等式的有几种情况，这里有两种情况，即 j = 4 或者 j = 5，都不满足等式，所以这一步 res = 0。\n  倒序插入 len(prefixSum)-3 = prefixSum[3] = -2：\n 这时候查找区间变为了 [-3 + prefixSum[3-1], -1 + prefixSum[3-1]] = [-3,-1]，即判断 -3 ≤ sum(3, 3,4,5) ≤ -1，满足等式的有几种情况，这里有三种情况，即 j = 3 、j = 4 或者 j = 5，满足等式的有 j = 3 和 j = 5，即 -3 ≤ sum(3, 3) ≤ -1 和 -3 ≤ sum(3, 5) ≤ -1。所以这一步 res = 2。\n  倒序插入 len(prefixSum)-4 = prefixSum[2] = 0：\n 这时候查找区间变为了 [-3 + prefixSum[2-1], -1 + prefixSum[2-1]] = [-5,-3]，即判断 -5 ≤ sum(2, 2,3,4,5) ≤ -3，满足等式的有几种情况，这里有四种情况，即 j = 2、 j = 3 、j = 4 或者 j = 5，都不满足等式。所以这一步 res = 0。\n  倒序插入 len(prefixSum)-5 = prefixSum[1] = -2：\n 这时候查找区间变为了 [-3 + prefixSum[1-1], -1 + prefixSum[1-1]] = [-6,-4]，即判断 -6 ≤ sum(1, 1,2,3,4,5) ≤ -4，满足等式的有几种情况，这里有五种情况，即 j = 1、 j = 2、 j = 3 、j = 4 或者 j = 5，都不满足等式。所以这一步 res = 0。\n  倒序插入 len(prefixSum)-6 = prefixSum[0] = -3：\n 这时候查找区间变为了 [-3 + prefixSum[0-1], -1 + prefixSum[0-1]] = [-3,-1]，注意 prefixSum[-1] = 0，即判断 -3 ≤ sum(0, 0,1,2,3,4,5) ≤ -1，满足等式的有几种情况，这里有六种情况，即 j = 0、j = 1、j = 2、 j = 3 、j = 4 或者 j = 5，满足等式的有 j = 0、j = 1、 j = 3 和 j = 5，即 -3 ≤ sum(0, 0) ≤ -1 、 -3 ≤ sum(0, 1) ≤ -1、-3 ≤ sum(0, 3) ≤ -1 和 -3 ≤ sum(0, 5) ≤ -1。所以这一步 res = 4。最后的答案就是把每一步的结果都累加，res = 1 + 0 + 2 + 0 + 0 + 4 = 7。\n  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 线段树，时间复杂度 O(n log n) func countRangeSum(nums []int, lower int, upper int) int { if len(nums) == 0 { return 0 } st, prefixSum, sumMap, sumArray, res := template.SegmentCountTree{}, make([]int, len(nums)), make(map[int]int, 0), []int{}, 0 prefixSum[0], sumMap[nums[0]] = nums[0], nums[0] for i := 1; i \u0026lt; len(nums); i++ { prefixSum[i] = prefixSum[i-1] + nums[i] sumMap[prefixSum[i]] = prefixSum[i] } // sumArray 是 prefixSum 去重之后的版本，利用 sumMap 去重 \tfor _, v := range sumMap { sumArray = append(sumArray, v) } // 排序是为了使得线段树中的区间 left \u0026lt;= right，如果此处不排序，线段树中的区间有很多不合法。 \tsort.Ints(sumArray) // 初始化线段树，节点内的值都赋值为 0，即计数为 0 \tst.Init(sumArray, func(i, j int) int { return 0 }) // 倒序是为了方便寻找 j，sum(i，j) 规定了 j \u0026gt;= i，所以倒序遍历，i 从大到小 \tfor i := len(nums) - 1; i \u0026gt;= 0; i-- { // 插入的 prefixSum[i] 即是 j \tst.UpdateCount(prefixSum[i]) if i \u0026gt; 0 { res += st.Query(lower+prefixSum[i-1], upper+prefixSum[i-1]) } else { res += st.Query(lower, upper) } } return res } // 解法二 暴力，时间复杂度 O(n^2) func countRangeSum1(nums []int, lower int, upper int) int { res, n := 0, len(nums) for i := 0; i \u0026lt; n; i++ { tmp := 0 for j := i; j \u0026lt; n; j++ { if i == j { tmp = nums[i] } else { tmp += nums[j] } if tmp \u0026lt;= upper \u0026amp;\u0026amp; tmp \u0026gt;= lower { res++ } } } return res } "});index.add({'id':201,'href':'/leetcode-java/04_Leetcode/0328.Odd-Even-Linked-List/','title':"0328. Odd Even Linked List",'section':"第四章",'content':"328. Odd Even Linked List #  题目 #  Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\n Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL Example 2:\n Input: 2-\u0026gt;1-\u0026gt;3-\u0026gt;5-\u0026gt;6-\u0026gt;4-\u0026gt;7-\u0026gt;NULL Output: 2-\u0026gt;3-\u0026gt;6-\u0026gt;7-\u0026gt;1-\u0026gt;5-\u0026gt;4-\u0026gt;NULL Note:\n The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on \u0026hellip;  题目大意 #  这道题和第 86 题非常类型。第 86 题是把排在某个点前面的小值放在一个链表中，排在某个点后端的大值放在另外一个链表中，最后 2 个链表首尾拼接一下就是答案。\n解题思路 #  这道题思路也是一样的，分别把奇数和偶数都放在 2 个链表中，最后首尾拼接就是答案。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func oddEvenList(head *ListNode) *ListNode { oddHead := \u0026amp;ListNode{Val: 0, Next: nil} odd := oddHead evenHead := \u0026amp;ListNode{Val: 0, Next: nil} even := evenHead count := 1 for head != nil { if count%2 == 1 { odd.Next = head odd = odd.Next } else { even.Next = head even = even.Next } head = head.Next count++ } even.Next = nil odd.Next = evenHead.Next return oddHead.Next } "});index.add({'id':202,'href':'/leetcode-java/04_Leetcode/0329.Longest-Increasing-Path-in-a-Matrix/','title':"0329. Longest Increasing Path in a Matrix",'section':"第四章",'content':"329. Longest Increasing Path in a Matrix #  题目 #  Given an integer matrix, find the length of the longest increasing path.\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\nExample 1:\nInput: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2:\nInput: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.  题目大意 #  给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。\n解题思路 #   给出一个矩阵，要求在这个矩阵中找到一个最长递增的路径。路径有上下左右 4 个方向。 这一题解题思路很明显，用 DFS 即可。在提交完第一版以后会发现 TLE，因为题目给出了一个非常大的矩阵，搜索次数太多。所以需要用到记忆化，把曾经搜索过的最大长度缓存起来，增加了记忆化以后再次提交 AC。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) func longestIncreasingPath(matrix [][]int) int { cache, res := make([][]int, len(matrix)), 0 for i := 0; i \u0026lt; len(cache); i++ { cache[i] = make([]int, len(matrix[0])) } for i, v := range matrix { for j := range v { searchPath(matrix, cache, math.MinInt64, i, j) res = max(res, cache[i][j]) } } return res } func isInIntBoard(board [][]int, x, y int) bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(board) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(board[0]) } func searchPath(board, cache [][]int, lastNum, x, y int) int { if board[x][y] \u0026lt;= lastNum { return 0 } if cache[x][y] \u0026gt; 0 { return cache[x][y] } count := 1 for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isInIntBoard(board, nx, ny) { count = max(count, searchPath(board, cache, board[x][y], nx, ny)+1) } } cache[x][y] = count return count } "});index.add({'id':203,'href':'/leetcode-java/04_Leetcode/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/','title':"0331. Verify Preorder Serialization of a Binary Tree",'section':"第四章",'content':"331. Verify Preorder Serialization of a Binary Tree #  题目 #  One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node\u0026rsquo;s value. If it is a null node, we record using a sentinel value such as #.\n _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # For example, the above binary tree can be serialized to the string \u0026ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#\u0026rdquo;, where # represents a null node.\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\nEach comma separated value in the string must be either an integer or a character \u0026lsquo;#\u0026rsquo; representing null pointer.\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \u0026ldquo;1,,3\u0026rdquo;.\nExample 1:\n Input: \u0026quot;9,3,4,#,#,1,#,#,2,#,6,#,#\u0026quot; Output: true Example 2:\n Input: \u0026quot;1,#\u0026quot; Output: false Example 3:\n Input: \u0026quot;9,#,#,1\u0026quot; Output: false 题目大意 #  给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。\n解题思路 #  这道题有些人用栈，有些用栈的深度求解。换个视角。如果叶子结点是 null，那么所有非 null 的结点(除了 root 结点)必然有 2 个出度，1 个入度(2 个孩子和 1 个父亲，孩子可能为空，但是这一题用 \u0026ldquo;#\u0026rdquo; 代替了，所以肯定有 2 个孩子)；所有的 null 结点只有 0 个出度，1 个入度(0 个孩子和 1 个父亲)。\n我们开始构建这颗树，在构建过程中，我们记录出度和度之间的差异 diff = outdegree - indegree。当下一个节点到来时，我们将 diff 减 1，因为这个节点提供了一个度。如果这个节点不为 null，我们将 diff 增加 2，因为它提供两个出度。如果序列化是正确的，则 diff 应该永远不会为负，并且 diff 在完成时将为零。最后判断一下 diff 是不是为 0 即可判断它是否是正确的二叉树的前序序列化。\n代码 #  package leetcode import \u0026#34;strings\u0026#34; func isValidSerialization(preorder string) bool { nodes, diff := strings.Split(preorder, \u0026#34;,\u0026#34;), 1 for _, node := range nodes { diff-- if diff \u0026lt; 0 { return false } if node != \u0026#34;#\u0026#34; { diff += 2 } } return diff == 0 } "});index.add({'id':204,'href':'/leetcode-java/04_Leetcode/0337.House-Robber-III/','title':"0337. House Robber I I I",'section':"第四章",'content':"337. House Robber III #  题目 #  The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \u0026ldquo;root.\u0026rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \u0026ldquo;all houses in this place forms a binary tree\u0026rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\nExample 1:\nInput: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2:\nInput: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. 题目大意 #  一个新的可行窃的地区只有一个入口，称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n解题思路 #   这一题是打家劫舍的第 3 题。这一题需要偷的房子是树状的。报警的条件还是相邻的房子如果都被偷了，就会触发报警。只不过这里相邻的房子是树上的。问小偷在不触发报警的条件下最终能偷的最高金额。 解题思路是 DFS。当前节点是否被打劫，会产生 2 种结果。如果当前节点被打劫，那么它的孩子节点可以被打劫；如果当前节点没有被打劫，那么它的孩子节点不能被打劫。按照这个逻辑递归，最终递归到根节点，取最大值输出即可。  代码 #  func rob337(root *TreeNode) int { a, b := dfsTreeRob(root) return max(a, b) } func dfsTreeRob(root *TreeNode) (a, b int) { if root == nil { return 0, 0 } l0, l1 := dfsTreeRob(root.Left) r0, r1 := dfsTreeRob(root.Right) // 当前节点没有被打劫 \ttmp0 := max(l0, l1) + max(r0, r1) // 当前节点被打劫 \ttmp1 := root.Val + l0 + r0 return tmp0, tmp1 } "});index.add({'id':205,'href':'/leetcode-java/04_Leetcode/0338.Counting-Bits/','title':"0338. Counting Bits",'section':"第四章",'content':"338. Counting Bits #  题目 #  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1\u0026rsquo;s in their binary representation and return them as an array.\nExample 1:\nInput: 2 Output: [0,1,1]  Example 2:\nInput: 5 Output: [0,1,1,2,1,2]  Follow up:\n It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.  题目大意 #  给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n解题思路 #    给出一个数，要求计算出 0 ≤ i ≤ num 中每个数的二进制位 1 的个数。\n  这一题就是利用二进制位运算的经典题。\n X\u0026amp;1==1or==0，可以用 X\u0026amp;1 判断奇偶性，X\u0026amp;1\u0026gt;0 即奇数。 X = X \u0026amp; (X-1) 清零最低位的1 X \u0026amp; -X =\u0026gt; 得到最低位的1 X\u0026amp;~X=\u0026gt;0    代码 #  package leetcode func countBits(num int) []int { bits := make([]int, num+1) for i := 1; i \u0026lt;= num; i++ { bits[i] += bits[i\u0026amp;(i-1)] + 1 } return bits } "});index.add({'id':206,'href':'/leetcode-java/04_Leetcode/0342.Power-of-Four/','title':"0342. Power of Four",'section':"第四章",'content':"342. Power of Four #  题目 #  Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\nExample 1:\nInput: 16 Output: true  Example 2:\nInput: 5 Output: false  Follow up: Could you solve it without loops/recursion?\n题目大意 #  给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。\n解题思路 #   判断一个数是不是 4 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。 证明 (4^n - 1) % 3 == 0，(1) 4^n - 1 = (2^n + 1) * (2^n - 1)(2) 在任何连续的 3 个数中 (2^n-1)，(2^n)，(2^n+1)，一定有一个数是 3 的倍数。(2^n) 肯定不是 3 的倍数，那么 (2^n-1) 或者 (2^n+1) 中一定有一个是 3 的倍数。所以 4^n-1 一定是 3 的倍数。  代码 #  package leetcode // 解法一 数论 func isPowerOfFour(num int) bool { return num \u0026gt; 0 \u0026amp;\u0026amp; (num\u0026amp;(num-1)) == 0 \u0026amp;\u0026amp; (num-1)%3 == 0 } // 解法二 循环 func isPowerOfFour1(num int) bool { for num \u0026gt;= 4 { if num%4 == 0 { num = num / 4 } else { return false } } return num == 1 } "});index.add({'id':207,'href':'/leetcode-java/04_Leetcode/0343.Integer-Break/','title':"0343. Integer Break",'section':"第四章",'content':"343. Integer Break #  题目 #  Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\nExample 1:\nInput: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2:\nInput: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.  Note: You may assume that n is not less than 2 and not larger than 58.\n题目大意 #  给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n解题思路 #   这一题是 DP 的题目，将一个数字分成多个数字之和，至少分为 2 个数字之和，求解分解出来的数字乘积最大是多少。 这一题的动态转移方程是 dp[i] = max(dp[i], j * (i - j), j * dp[i-j]) ，一个数分解成 j 和 i - j 两个数字，或者分解成 j 和 更多的分解数，更多的分解数即是 dp[i-j]，由于 dp[i-j] 下标小于 i ，所以 dp[i-j] 在计算 dp[i] 的时候一定计算出来了。  代码 #  package leetcode func integerBreak(n int) int { dp := make([]int, n+1) dp[0], dp[1] = 1, 1 for i := 1; i \u0026lt;= n; i++ { for j := 1; j \u0026lt; i; j++ { // dp[i] = max(dp[i], j * (i - j), j*dp[i-j]) \tdp[i] = max(dp[i], j*max(dp[i-j], i-j)) } } return dp[n] } "});index.add({'id':208,'href':'/leetcode-java/04_Leetcode/0344.Reverse-String/','title':"0344. Reverse String",'section':"第四章",'content':"344. Reverse String #  题目 #  Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\n Input: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\n Input: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 题目大意 #  题目要求我们反转一个字符串。\n解题思路 #  这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。\n代码 #  package leetcode func reverseString(s []byte) { for i, j := 0, len(s)-1; i \u0026lt; j; { s[i], s[j] = s[j], s[i] i++ j-- } } "});index.add({'id':209,'href':'/leetcode-java/04_Leetcode/0345.Reverse-Vowels-of-a-String/','title':"0345. Reverse Vowels of a String",'section':"第四章",'content':"345. Reverse Vowels of a String #  题目 #  Write a function that takes a string as input and reverse only the vowels of a string.\nExample 1:\n Input: \u0026quot;hello\u0026quot; Output: \u0026quot;holle\u0026quot; Example 2:\n Input: \u0026quot;leetcode\u0026quot; Output: \u0026quot;leotcede\u0026quot; 题目大意 #  题目要求我们反转字符串中的元音字母。需要注意字母大小写。\n解题思路 #  这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。这一题和第 344 题思路一样。\n代码 #  package leetcode func reverseVowels(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i \u0026lt; j; { if isVowels(b[i]) \u0026amp;\u0026amp; isVowels(b[j]) { b[i], b[j] = b[j], b[i] i++ j-- } else if isVowels(b[i]) \u0026amp;\u0026amp; !isVowels(b[j]) { j-- } else if !isVowels(b[i]) \u0026amp;\u0026amp; isVowels(b[j]) { i++ } else { i++ j-- } } return string(b) } func isVowels(s byte) bool { if s == \u0026#39;a\u0026#39; || s == \u0026#39;e\u0026#39; || s == \u0026#39;i\u0026#39; || s == \u0026#39;o\u0026#39; || s == \u0026#39;u\u0026#39; || s == \u0026#39;A\u0026#39; || s == \u0026#39;E\u0026#39; || s == \u0026#39;I\u0026#39; || s == \u0026#39;O\u0026#39; || s == \u0026#39;U\u0026#39; { return true } return false } "});index.add({'id':210,'href':'/leetcode-java/04_Leetcode/0347.Top-K-Frequent-Elements/','title':"0347. Top K Frequent Elements",'section':"第四章",'content':"347. Top K Frequent Elements #  题目 #  Given a non-empty array of integers, return the k most frequent elements.\nExample 1:\n Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:\n Input: nums = [1], k = 1 Output: [1] Note:\n You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm\u0026rsquo;s time complexity must be better than O(n log n), where n is the array\u0026rsquo;s size.  题目大意 #  给一个非空的数组，输出前 K 个频率最高的元素。\n解题思路 #  这一题是考察优先队列的题目。把数组构造成一个优先队列，输出前 K 个即可。\n代码 #  package leetcode import \u0026#34;container/heap\u0026#34; func topKFrequent(nums []int, k int) []int { m := make(map[int]int) for _, n := range nums { m[n]++ } q := PriorityQueue{} for key, count := range m { heap.Push(\u0026amp;q, \u0026amp;Item{key: key, count: count}) } var result []int for len(result) \u0026lt; k { item := heap.Pop(\u0026amp;q).(*Item) result = append(result, item.key) } return result } // Item define type Item struct { key int count int } // A PriorityQueue implements heap.Interface and holds Items. type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { // 注意：因为golang中的heap是按最小堆组织的，所以count越大，Less()越小，越靠近堆顶. \treturn pq[i].count \u0026gt; pq[j].count } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } // Push define func (pq *PriorityQueue) Push(x interface{}) { item := x.(*Item) *pq = append(*pq, item) } // Pop define func (pq *PriorityQueue) Pop() interface{} { n := len(*pq) item := (*pq)[n-1] *pq = (*pq)[:n-1] return item } "});index.add({'id':211,'href':'/leetcode-java/04_Leetcode/0349.Intersection-of-Two-Arrays/','title':"0349. Intersection of Two Arrays",'section':"第四章",'content':"349. Intersection of Two Arrays #  题目 #  Given two arrays, write a function to compute their intersection.\nExample 1:\n Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2:\n Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note:\n Each element in the result must be unique. The result can be in any order.  题目大意 #  找到两个数组的交集元素，如果交集元素同一个数字出现了多次，只输出一次。\n解题思路 #  把数组一的每个数字都存进字典中，然后在数组二中依次判断字典中是否存在，如果存在，在字典中删除它(因为输出要求只输出一次)。\n代码 #  package leetcode func intersection(nums1 []int, nums2 []int) []int { m := map[int]bool{} var res []int for _, n := range nums1 { m[n] = true } for _, n := range nums2 { if m[n] { delete(m, n) res = append(res, n) } } return res } "});index.add({'id':212,'href':'/leetcode-java/04_Leetcode/0350.Intersection-of-Two-Arrays-II/','title':"0350. Intersection of Two Arrays I I",'section':"第四章",'content':"350. Intersection of Two Arrays II #  题目 #  Given two arrays, write a function to compute their intersection.\nExample 1:\n Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:\n Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note:\n Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:\n What if the given array is already sorted? How would you optimize your algorithm? What if nums1\u0026rsquo;s size is small compared to nums2\u0026rsquo;s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?  题目大意 #  这题是第 349 题的加强版。要求输出 2 个数组的交集元素，如果元素出现多次，要输出多次。\n解题思路 #  这一题还是延续第 349 题的思路。把数组一中的数字都放进字典中，另外字典的 key 是数组中的数字，value 是这个数字出现的次数。在扫描数组二的时候，每取出一个存在的数组，把字典中的 value 减一。如果 value 是 0 代表不存在这个数字。\n代码 #  package leetcode func intersect(nums1 []int, nums2 []int) []int { m := map[int]int{} var res []int for _, n := range nums1 { m[n]++ } for _, n := range nums2 { if m[n] \u0026gt; 0 { res = append(res, n) m[n]-- } } return res } "});index.add({'id':213,'href':'/leetcode-java/04_Leetcode/0354.Russian-Doll-Envelopes/','title':"0354. Russian Doll Envelopes",'section':"第四章",'content':"354. Russian Doll Envelopes #  题目 #  You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\nNote: Rotation is not allowed.\nExample:\nInput: [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =\u0026gt; [5,4] =\u0026gt; [6,7]).  题目大意 #  给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。\n请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。\n说明:\n 不允许旋转信封。  解题思路 #   给出一组信封的宽度和高度，如果组成俄罗斯套娃，问最多能套几层。只有当一个信封的宽度和高度都比另外一个信封大的时候，才能套在小信封上面。 这一题的实质是第 300 题 Longest Increasing Subsequence 的加强版。能组成俄罗斯套娃的条件就是能找到一个最长上升子序列。但是这题的条件是二维的，要求能找到在二维上都能满足条件的最长上升子序列。先降维，把宽度排序。然后在高度上寻找最长上升子序列。这里用到的方法和第 300 题的方法一致。解题思路详解见第 300 题。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) type sortEnvelopes [][]int func (s sortEnvelopes) Len() int { return len(s) } func (s sortEnvelopes) Less(i, j int) bool { if s[i][0] == s[j][0] { return s[i][1] \u0026gt; s[j][1] } return s[i][0] \u0026lt; s[j][0] } func (s sortEnvelopes) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func maxEnvelopes(envelopes [][]int) int { sort.Sort(sortEnvelopes(envelopes)) dp := []int{} for _, e := range envelopes { low, high := 0, len(dp) for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if dp[mid] \u0026gt;= e[1] { high = mid } else { low = mid + 1 } } if low == len(dp) { dp = append(dp, e[1]) } else { dp[low] = e[1] } } return len(dp) } "});index.add({'id':214,'href':'/leetcode-java/04_Leetcode/0357.Count-Numbers-with-Unique-Digits/','title':"0357. Count Numbers With Unique Digits",'section':"第四章",'content':"357. Count Numbers with Unique Digits #  题目 #  Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x \u0026lt; 10n.\nExample:\nInput: 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x \u0026lt; 100, excluding 11,22,33,44,55,66,77,88,99  题目大意 #  给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x \u0026lt; 10^n 。\n解题思路 #   输出 n 位数中不出现重复数字的数字的个数 这道题摸清楚规律以后，可以直接写出最终所有答案，答案只有 11 个。 考虑不重复数字是如生成的。如果只是一位数，不存在重复的数字，结果是 10 。如果是二位数，第一位一定不能取 0，那么第一位有 1-9，9种取法，第二位为了和第一位不重复，只能有 0-9，10种取法中减去第一位取的数字，那么也是 9 种取法。以此类推，如果是三位数，第三位是 8 种取法；四位数，第四位是 7 种取法；五位数，第五位是 6 种取法；六位数，第六位是 5 种取法；七位数，第七位是 4 种取法；八位数，第八位是 3 种取法；九位数，第九位是 2 种取法；十位数，第十位是 1 种取法；十一位数，第十一位是 0 种取法；十二位数，第十二位是 0 种取法；那么第 11 位数以后，每个数都是重复数字的数字。知道这个规律以后，可以累积上面的结果，把结果直接存在数组里面，暴力打表即可。O(1) 的时间复杂度。  代码 #  package leetcode // 暴力打表法 func countNumbersWithUniqueDigits1(n int) int { res := []int{1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691} if n \u0026gt;= 10 { return res[10] } return res[n] } // 打表方法 func countNumbersWithUniqueDigits(n int) int { if n == 0 { return 1 } res, uniqueDigits, availableNumber := 10, 9, 9 for n \u0026gt; 1 \u0026amp;\u0026amp; availableNumber \u0026gt; 0 { uniqueDigits = uniqueDigits * availableNumber res += uniqueDigits availableNumber-- n-- } return res } "});index.add({'id':215,'href':'/leetcode-java/04_Leetcode/0367.Valid-Perfect-Square/','title':"0367. Valid Perfect Square",'section':"第四章",'content':"367. Valid Perfect Square #  题目 #  Given a positive integer num, write a function which returns True if num is a perfect square else False.\nNote: Do not use any built-in library function such as sqrt.\nExample 1:\nInput: 16 Output: true  Example 2:\nInput: 14 Output: false  题目大意 #  给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。\n说明：不要使用任何内置的库函数，如 sqrt。\n解题思路 #   给出一个数，要求判断这个数是不是完全平方数。 可以用二分搜索来解答这道题。判断完全平方数，根据它的定义来，是否能被开根号，即找到一个数的平方是否可以等于待判断的数字。从 [1, n] 区间内进行二分，若能找到则返回 true，找不到就返回 false 。  代码 #  package leetcode func isPerfectSquare(num int) bool { low, high := 1, num for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if mid*mid == num { return true } else if mid*mid \u0026lt; num { low = mid + 1 } else { high = mid - 1 } } return false } "});index.add({'id':216,'href':'/leetcode-java/04_Leetcode/0371.Sum-of-Two-Integers/','title':"0371. Sum of Two Integers",'section':"第四章",'content':"371. Sum of Two Integers #  题目 #  Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\nExample 1:\nInput: a = 1, b = 2 Output: 3  Example 2:\nInput: a = -2, b = 3 Output: 1  题目大意 #  不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。\n解题思路 #   要求不用加法和减法运算符计算 a+b。这一题需要用到 ^ 和 \u0026amp; 运算符的性质，两个数 ^ 可以实现两个数不带进位的二进制加法。这里需要实现加法，肯定需要进位。所以如何找到进位是本题的关键。 在二进制中，只有 1 和 1 加在一起才会进位，0 和 0，0 和 1，1 和 0，这三种情况都不会进位，规律就是 a \u0026amp; b 为 0 的时候就不用进位，为 1 的时候代表需要进位。进位是往前进一位，所以还需要左移操作，所以加上的进位为 (a\u0026amp;b)\u0026lt;\u0026lt;1。  代码 #  package leetcode func getSum(a int, b int) int { if a == 0 { return b } if b == 0 { return a } // (a \u0026amp; b)\u0026lt;\u0026lt;1 计算的是进位 \t// a ^ b 计算的是不带进位的加法 \treturn getSum((a\u0026amp;b)\u0026lt;\u0026lt;1, a^b) } "});index.add({'id':217,'href':'/leetcode-java/04_Leetcode/0372.Super-Pow/','title':"0372. Super Pow",'section':"第四章",'content':"372. Super Pow #  题目 #  Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\nExample 1:\nInput: a = 2, b = [3] Output: 8  Example 2:\nInput: a = 2, b = [1,0] Output: 1024  题目大意 #  你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。\n解题思路 #    求 a^b mod p 的结果，b 是大数。\n  这一题可以用暴力解法尝试。需要用到 mod 计算的几个运算性质：\n 模运算性质一：(a + b) % p = (a % p + b % p) % p 模运算性质二：(a - b) % p = (a % p - b % p + p) % p 模运算性质三：(a * b) % p = (a % p * b % p) % p 模运算性质四：a ^ b % p = ((a % p)^b) % p 模运算性质五：ab % p = ((a % p) * ( b % p)) % p, 其中 ab 是一个数字，如:2874，98374 等等  这一题需要用到性质三、四、五。举个例子：\n 12345^678 % 1337 = (12345^670 * 12345^8) % 1337 = ((12345^670 % 1337) * (12345^8 % 1337)) % 1337 ---\u0026gt; 利用性质 三 = (((12345^67)^10 % 1337) * (12345^8 % 1337)) % 1337 ---\u0026gt; 乘方性质 = ((12345^67 % 1337)^10) % 1337 * (12345^8 % 1337)) % 1337 ---\u0026gt; 利用性质 四 = (((12345^67 % 1337)^10) * (12345^8 % 1337)) % 1337 ---\u0026gt; 反向利用性质 三  经过上面这样的变换，把指数 678 的个位分离出来了，可以单独求解。继续经过上面的变换，可以把指数的 6 和 7 也分离出来。最终可以把大数 b 一位一位的分离出来。至于计算 a^b 就结果快速幂求解。\n  代码 #  package leetcode // 解法一 快速幂 res = res^10 * qpow(a, b[i]) // 模运算性质一：(a + b) % p = (a % p + b % p) % p // 模运算性质二：(a - b) % p = (a % p - b % p + p) % p // 模运算性质三：(a * b) % p = (a % p * b % p) % p // 模运算性质四：a ^ b % p = ((a % p)^b) % p // 模运算性质五：ab % p = ((a % p) * ( b % p)) % p, 其中 ab 是一个数字，如:2874，98374 等等 // 举个例子 // 12345^678 % 1337 = (12345^670 * 12345^8) % 1337 //\t= ((12345^670 % 1337) * (12345^8 % 1337)) % 1337 ---\u0026gt; 利用性质 三 //\t= (((12345^67)^10 % 1337) * (12345^8 % 1337)) % 1337 ---\u0026gt; 乘方性质 // = ((12345^67 % 1337)^10) % 1337 * (12345^8 % 1337)) % 1337 ---\u0026gt; 利用性质 四 //\t= (((12345^67 % 1337)^10) * (12345^8 % 1337)) % 1337 ---\u0026gt; 反向利用性质 三 func superPow(a int, b []int) int { res := 1 for i := 0; i \u0026lt; len(b); i++ { res = (qpow(res, 10) * qpow(a, b[i])) % 1337 } return res } // 快速幂计算 x^n func qpow(x, n int) int { res := 1 x %= 1337 for n \u0026gt; 0 { if (n \u0026amp; 1) == 1 { res = (res * x) % 1337 } x = (x * x) % 1337 n \u0026gt;\u0026gt;= 1 } return res } // 解法二 暴力解法 // 利用上面的性质，可以得到：a^1234567 % 1337 = (a^1234560 % 1337) * (a^7 % 1337) % k = ((((a^123456) % 1337)^10)% 1337 * (a^7 % 1337))% 1337; func superPow1(a int, b []int) int { if len(b) == 0 { return 1 } last := b[len(b)-1] l := 1 // 先计算个位的 a^x 结果，对应上面例子中的 (a^7 % 1337)% 1337 \tfor i := 1; i \u0026lt;= last; i++ { l = l * a % 1337 } // 再计算除去个位以外的 a^y 的结果，对应上面例子中的 (a^123456) % 1337) \ttemp := superPow1(a, b[:len(b)-1]) f := 1 // 对应上面例子中的 (((a^123456) % 1337)^10)% 1337 \tfor i := 1; i \u0026lt;= 10; i++ { f = f * temp % 1337 } return f * l % 1337 } "});index.add({'id':218,'href':'/leetcode-java/04_Leetcode/0373.Find-K-Pairs-with-Smallest-Sums/','title':"0373. Find K Pairs With Smallest Sums",'section':"第四章",'content':"373. Find K Pairs with Smallest Sums #  题目 #  You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\nFind the k pairs (u1,v1),(u2,v2) \u0026hellip;(uk,vk) with the smallest sums.\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]  Example 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]  Example 3:\nInput: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]  题目大意 #  给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。\n定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。\n找到和最小的 k 对数字 (u1,v1), (u2,v2) \u0026hellip; (uk,vk)。\n解题思路 #   给出 2 个数组，和数字 k，要求找到 k 个数值对，数值对两个数的和最小。 这一题咋一看可以用二分搜索，两个数组两个组合有 m * n 个数值对。然后找到最小的和，最大的和，在这个范围内进行二分搜索，每分出一个 mid，再去找比 mid 小的数值对有多少个，如果个数小于 k 个，那么在右区间上继续二分，如果个数大于 k 个，那么在左区间上继续二分。到目前为止，这个思路看似可行。但是每次搜索的数值对是无序的。这会导致最终出现错误的结果。例如 mid = 10 的时候，小于 10 的和有 22 个，而 k = 25 。这说明 mid 偏小，mid 增大，mid = 11 的时候，小于 11 的和有 30 个，而 k = 25 。这时候应该从这 30 个和中取前 25 个。但是我们遍历数值对的时候，和并不是从小到大排序的。这时候还需要额外对这 30 个候选值进行排序。这样时间复杂度又增大了。 可以先用暴力解法解答。将所有的和都遍历出来，排序以后，取前 k 个。这个暴力方法可以 AC。 本题最优解应该是优先队列。维护一个最小堆。把数值对的和放在这个最小堆中，不断的 pop 出 k 个最小值到数组中，即为答案。 在已排序的矩阵中寻找最 K 小的元素这一系列的题目有：第 373 题，第 378 题，第 668 题，第 719 题，第 786 题。  代码 #  package leetcode import ( \u0026#34;container/heap\u0026#34; \u0026#34;sort\u0026#34; ) // 解法一 优先队列 func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int { result, h := [][]int{}, \u0026amp;minHeap{} if len(nums1) == 0 || len(nums2) == 0 || k == 0 { return result } if len(nums1)*len(nums2) \u0026lt; k { k = len(nums1) * len(nums2) } heap.Init(h) for _, num := range nums1 { heap.Push(h, []int{num, nums2[0], 0}) } for len(result) \u0026lt; k { min := heap.Pop(h).([]int) result = append(result, min[:2]) if min[2] \u0026lt; len(nums2)-1 { heap.Push(h, []int{min[0], nums2[min[2]+1], min[2] + 1}) } } return result } type minHeap [][]int func (h minHeap) Len() int { return len(h) } func (h minHeap) Less(i, j int) bool { return h[i][0]+h[i][1] \u0026lt; h[j][0]+h[j][1] } func (h minHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *minHeap) Push(x interface{}) { *h = append(*h, x.([]int)) } func (h *minHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } // 解法二 暴力解法 func kSmallestPairs1(nums1 []int, nums2 []int, k int) [][]int { size1, size2, res := len(nums1), len(nums2), [][]int{} if size1 == 0 || size2 == 0 || k \u0026lt; 0 { return nil } for i := 0; i \u0026lt; size1; i++ { for j := 0; j \u0026lt; size2; j++ { res = append(res, []int{nums1[i], nums2[j]}) } } sort.Slice(res, func(i, j int) bool { return res[i][0]+res[i][1] \u0026lt; res[j][0]+res[j][1] }) if len(res) \u0026gt;= k { return res[:k] } return res } "});index.add({'id':219,'href':'/leetcode-java/04_Leetcode/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/','title':"0378. Kth Smallest Element in a Sorted Matrix",'section':"第四章",'content':"378. Kth Smallest Element in a Sorted Matrix #  题目 #  Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\nExample:\nmatrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13.  Note: You may assume k is always valid, 1 ≤ k ≤ n2.\n题目大意 #  给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是排序后的第 k 小元素，而不是第 k 个元素。\n说明: 你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。\n解题思路 #   给出一个行有序，列有序的矩阵(并非是按照下标有序的)，要求找出这个矩阵中第 K 小的元素。注意找的第 K 小元素指的不是 k 个不同的元素，可能存在相同的元素。 最容易想到的就解法是优先队列。依次把矩阵中的元素推入到优先队列中。维护一个最小堆，一旦优先队列里面的元素有 k 个了，就算找到结果了。 这一题最优解法是二分搜索。那搜索的空间是什么呢？根据题意，可以知道，矩阵左上角的那个元素是最小的，右下角的元素是最大的。即矩阵第一个元素确定了下界，矩阵的最后一个元素确定了上界。在这个解空间里面二分搜索所有值，找到第 K 小的元素。判断是否找到的条件是，在矩阵中比 mid 小的元素个数等于 K。不断的逼近 low，使得 low == high 的时候，就是找到了第 K 小的元素了。(因为题目中说了，一定会存在第 K 小元素，所以二分搜索到一个元素的时候，一定会得出结果)。   代码 #  package leetcode import ( \u0026#34;container/heap\u0026#34; ) // 解法一 二分搜索 func kthSmallest378(matrix [][]int, k int) int { m, n, low := len(matrix), len(matrix[0]), matrix[0][0] high := matrix[m-1][n-1] + 1 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 // 如果 count 比 k 小，在大值的那一半继续二分搜索 \tif counterKthSmall(m, n, mid, matrix) \u0026gt;= k { high = mid } else { low = mid + 1 } } return low } func counterKthSmall(m, n, mid int, matrix [][]int) int { count, j := 0, n-1 // 每次循环统计比 mid 值小的元素个数 \tfor i := 0; i \u0026lt; m; i++ { // 遍历每行中比 mid 小的元素的个数 \tfor j \u0026gt;= 0 \u0026amp;\u0026amp; mid \u0026lt; matrix[i][j] { j-- } count += j + 1 } return count } // 解法二 优先队列 func kthSmallest3781(matrix [][]int, k int) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } pq := \u0026amp;pq{data: make([]interface{}, k)} heap.Init(pq) for i := 0; i \u0026lt; len(matrix); i++ { for j := 0; j \u0026lt; len(matrix[0]); j++ { if pq.Len() \u0026lt; k { heap.Push(pq, matrix[i][j]) } else if matrix[i][j] \u0026lt; pq.Head().(int) { heap.Pop(pq) heap.Push(pq, matrix[i][j]) } else { break } } } return heap.Pop(pq).(int) } type pq struct { data []interface{} len int } func (p *pq) Len() int { return p.len } func (p *pq) Less(a, b int) bool { return p.data[a].(int) \u0026gt; p.data[b].(int) } func (p *pq) Swap(a, b int) { p.data[a], p.data[b] = p.data[b], p.data[a] } func (p *pq) Push(o interface{}) { p.data[p.len] = o p.len++ } func (p *pq) Head() interface{} { return p.data[0] } func (p *pq) Pop() interface{} { p.len-- return p.data[p.len] } "});index.add({'id':220,'href':'/leetcode-java/04_Leetcode/0385.Mini-Parser/','title':"0385. Mini Parser",'section':"第四章",'content':"385. Mini Parser #  题目 #  Given a nested list of integers represented as a string, implement a parser to deserialize it.\nEach element is either an integer, or a list \u0026ndash; whose elements may also be integers or other lists.\nNote: You may assume that the string is well-formed:\n String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].  Example 1:\nGiven s = \u0026quot;324\u0026quot;, You should return a NestedInteger object which contains a single integer 324.  Example 2:\nGiven s = \u0026quot;[123,[456,[789]]]\u0026quot;, Return a NestedInteger object containing a nested list with 2 elements: 1. An integer containing value 123. 2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789.  题目大意 #  给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。列表中的每个元素只可能是整数或整数嵌套列表\n提示：你可以假定这些字符串都是格式良好的：\n 字符串非空 字符串不包含空格 字符串只包含数字0-9, [, - ,, ]  解题思路 #   将一个嵌套的数据结构中的数字转换成 NestedInteger 数据结构。 这一题用栈一层一层的处理就行。有一些比较坑的特殊的边界数据见测试文件。这一题正确率比很多 Hard 题还要低的原因应该是没有理解好题目和边界测试数据没有考虑到。NestedInteger 这个数据结构笔者实现了一遍，见代码。  代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * type NestedInteger struct { * } * * // Return true if this NestedInteger holds a single integer, rather than a nested list. * func (n NestedInteger) IsInteger() bool {} * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * // So before calling this method, you should have a check * func (n NestedInteger) GetInteger() int {} * * // Set this NestedInteger to hold a single integer. * func (n *NestedInteger) SetInteger(value int) {} * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * func (n *NestedInteger) Add(elem NestedInteger) {} * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The list length is zero if this NestedInteger holds a single integer * // You can access NestedInteger\u0026#39;s List element directly if you want to modify it * func (n NestedInteger) GetList() []*NestedInteger {} */ // NestedInteger define type NestedInteger struct { Num int List []*NestedInteger } // IsInteger define func (n NestedInteger) IsInteger() bool { if n.List == nil { return true } return false } // GetInteger define func (n NestedInteger) GetInteger() int { return n.Num } // SetInteger define func (n *NestedInteger) SetInteger(value int) { n.Num = value } // Add define func (n *NestedInteger) Add(elem NestedInteger) { n.List = append(n.List, \u0026amp;elem) } // GetList define func (n NestedInteger) GetList() []*NestedInteger { return n.List } // Print define func (n NestedInteger) Print() { if len(n.List) != 0 { for _, v := range n.List { if len(v.List) != 0 { v.Print() return } fmt.Printf(\u0026#34;%v \u0026#34;, v.Num) } } else { fmt.Printf(\u0026#34;%v \u0026#34;, n.Num) } fmt.Printf(\u0026#34;\\n\u0026#34;) } func deserialize(s string) *NestedInteger { stack, cur := []*NestedInteger{}, \u0026amp;NestedInteger{} for i := 0; i \u0026lt; len(s); { switch { case isDigital(s[i]) || s[i] == \u0026#39;-\u0026#39;: j := 0 for j = i + 1; j \u0026lt; len(s) \u0026amp;\u0026amp; isDigital(s[j]); j++ { } num, _ := strconv.Atoi(s[i:j]) next := \u0026amp;NestedInteger{} next.SetInteger(num) if len(stack) \u0026gt; 0 { stack[len(stack)-1].List = append(stack[len(stack)-1].GetList(), next) } else { cur = next } i = j case s[i] == \u0026#39;[\u0026#39;: next := \u0026amp;NestedInteger{} if len(stack) \u0026gt; 0 { stack[len(stack)-1].List = append(stack[len(stack)-1].GetList(), next) } stack = append(stack, next) i++ case s[i] == \u0026#39;]\u0026#39;: cur = stack[len(stack)-1] stack = stack[:len(stack)-1] i++ case s[i] == \u0026#39;,\u0026#39;: i++ } } return cur } "});index.add({'id':221,'href':'/leetcode-java/04_Leetcode/0386.Lexicographical-Numbers/','title':"0386. Lexicographical Numbers",'section':"第四章",'content':"386. Lexicographical Numbers #  题目 #  Given an integer n, return 1 - n in lexicographical order.\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\n题目大意 #  给定一个整数 n, 返回从 1 到 n 的字典顺序。例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。\n请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。\n解题思路 #   给出一个数字 n ，要求按照字典序对 1-n 这 n 个数排序。 DFS 暴力求解即可。  代码 #  package leetcode func lexicalOrder(n int) []int { res := make([]int, 0, n) dfs386(1, n, \u0026amp;res) return res } func dfs386(x, n int, res *[]int) { limit := (x + 10) / 10 * 10 for x \u0026lt;= n \u0026amp;\u0026amp; x \u0026lt; limit { *res = append(*res, x) if x*10 \u0026lt;= n { dfs386(x*10, n, res) } x++ } } "});index.add({'id':222,'href':'/leetcode-java/04_Leetcode/0387.First-Unique-Character-in-a-String/','title':"0387. First Unique Character in a String",'section':"第四章",'content':"387. First Unique Character in a String #  题目 #  Given a string, find the first non-repeating character in it and return it\u0026rsquo;s index. If it doesn\u0026rsquo;t exist, return -1.\nExamples:\ns = \u0026quot;leetcode\u0026quot; return 0. s = \u0026quot;loveleetcode\u0026quot;, return 2.  Note: You may assume the string contain only lowercase letters.\n题目大意 #  给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n解题思路 #   简单题，要求输出第一个没有重复的字符。  代码 #  package leetcode func firstUniqChar(s string) int { result := make([]int, 26) for i := 0; i \u0026lt; len(s); i++ { result[s[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; len(s); i++ { if result[s[i]-\u0026#39;a\u0026#39;] == 1 { return i } } return -1 } "});index.add({'id':223,'href':'/leetcode-java/04_Leetcode/0389.Find-the-Difference/','title':"0389. Find the Difference",'section':"第四章",'content':"389. Find the Difference #  题目 #  Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nFind the letter that was added in t.\nExample:\nInput: s = \u0026quot;abcd\u0026quot; t = \u0026quot;abcde\u0026quot; Output: e Explanation: 'e' is the letter that was added.  题目大意 #  给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。\n解题思路 #   题目要求找出 t 字符串中比 s 字符串多出的一个字符。思路还是利用异或的性质，X^X = 0，将 s 和 t 依次异或，最终多出来的字符就是最后异或的结果。  代码 #  package leetcode func findTheDifference(s string, t string) byte { n, ch := len(t), t[len(t)-1] for i := 0; i \u0026lt; n-1; i++ { ch ^= s[i] ch ^= t[i] } return ch } "});index.add({'id':224,'href':'/leetcode-java/04_Leetcode/0392.Is-Subsequence/','title':"0392. Is Subsequence",'section':"第四章",'content':"392. Is Subsequence #  题目 #  Given a string s and a string t, check if s is subsequence of t.\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (\u0026lt;=100).\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot;while \u0026quot;aec\u0026quot; is not).\nExample 1:\nInput: s = \u0026quot;abc\u0026quot;, t = \u0026quot;ahbgdc\u0026quot; Output: true  Example 2:\nInput: s = \u0026quot;axc\u0026quot;, t = \u0026quot;ahbgdc\u0026quot; Output: false  Follow up: If there are lots of incoming S, say S1, S2, \u0026hellip; , Sk where k \u0026gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\nCredits: Special thanks to @pbrother for adding this problem and creating all test cases.\n题目大意 #  给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 \u0026lt;=100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026ldquo;ace\u0026quot;是\u0026quot;abcde\u0026quot;的一个子序列，而\u0026quot;aec\u0026quot;不是）。\n解题思路 #   给定 2 个字符串 s 和 t，问 s 是不是 t 的子序列。注意 s 在 t 中还需要保持 s 的字母的顺序。 这是一题贪心算法。直接做即可。  代码 #  package leetcode // 解法一 O(n^2) func isSubsequence(s string, t string) bool { index := 0 for i := 0; i \u0026lt; len(s); i++ { flag := false for ; index \u0026lt; len(t); index++ { if s[i] == t[index] { flag = true break } } if flag == true { index++ continue } else { return false } } return true } // 解法二 O(n) func isSubsequence1(s string, t string) bool { for len(s) \u0026gt; 0 \u0026amp;\u0026amp; len(t) \u0026gt; 0 { if s[0] == t[0] { s = s[1:] } t = t[1:] } return len(s) == 0 } "});index.add({'id':225,'href':'/leetcode-java/04_Leetcode/0393.UTF-8-Validation/','title':"0393. U T F 8 Validation",'section':"第四章",'content':"393. UTF-8 Validation #  题目 #  A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one\u0026rsquo;s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.  This is how the UTF-8 encoding would work:\n Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  Given an array of integers representing the data, return whether it is a valid utf-8 encoding.\nNote: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\nExample 1:\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001. Return true. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.  Example 2:\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100. Return false. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid.  题目大意 #  UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：\n对于 1 字节的字符，字节的第一位设为 0，后面 7 位为这个符号的 unicode 码。 对于 n 字节的字符 (n \u0026gt; 1)，第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式：\nChar. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。\n注意:\n输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。\n解题思路 #   这一题看似很复杂，其实严格按照 UTF8 定义来模拟就可以了。  代码 #  package leetcode func validUtf8(data []int) bool { count := 0 for _, d := range data { if count == 0 { if d \u0026gt;= 248 { // 11111000 = 248 \treturn false } else if d \u0026gt;= 240 { // 11110000 = 240 \tcount = 3 } else if d \u0026gt;= 224 { // 11100000 = 224 \tcount = 2 } else if d \u0026gt;= 192 { // 11000000 = 192 \tcount = 1 } else if d \u0026gt; 127 { // 01111111 = 127 \treturn false } } else { if d \u0026lt;= 127 || d \u0026gt;= 192 { return false } count-- } } return count == 0 } "});index.add({'id':226,'href':'/leetcode-java/04_Leetcode/0394.Decode-String/','title':"0394. Decode String",'section':"第四章",'content':"394. Decode String #  题目 #  Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won\u0026rsquo;t be input like 3a or 2[4].\nExamples:\n s = \u0026quot;3[a]2[bc]\u0026quot;, return \u0026quot;aaabcbc\u0026quot;. s = \u0026quot;3[a2[c]]\u0026quot;, return \u0026quot;accaccacc\u0026quot;. s = \u0026quot;2[abc]3[cd]ef\u0026quot;, return \u0026quot;abcabccdcdcdef\u0026quot;. 题目大意 #  给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n解题思路 #  这一题和第 880 题大体类似。用栈处理，遇到 \u0026ldquo;[\u0026quot;，就要开始重复字符串了，另外重复的数字是可能存在多位的，所以需要往前找到不为数字的那一位，把数字转换出来。最后用把 stack 里面的字符串都串联起来即可。\n代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) func decodeString(s string) string { stack, res := []string{}, \u0026#34;\u0026#34; for _, str := range s { if len(stack) == 0 || (len(stack) \u0026gt; 0 \u0026amp;\u0026amp; str != \u0026#39;]\u0026#39;) { stack = append(stack, string(str)) } else { tmp := \u0026#34;\u0026#34; for stack[len(stack)-1] != \u0026#34;[\u0026#34; { tmp = stack[len(stack)-1] + tmp stack = stack[:len(stack)-1] } stack = stack[:len(stack)-1] index, repeat := 0, \u0026#34;\u0026#34; for index = len(stack) - 1; index \u0026gt;= 0; index-- { if stack[index] \u0026gt;= \u0026#34;0\u0026#34; \u0026amp;\u0026amp; stack[index] \u0026lt;= \u0026#34;9\u0026#34; { repeat = stack[index] + repeat } else { break } } nums, _ := strconv.Atoi(repeat) copyTmp := tmp for i := 0; i \u0026lt; nums-1; i++ { tmp += copyTmp } for i := 0; i \u0026lt; len(repeat)-1; i++ { stack = stack[:len(stack)-1] } stack[index+1] = tmp } } for _, s := range stack { res += s } return res } "});index.add({'id':227,'href':'/leetcode-java/04_Leetcode/0397.Integer-Replacement/','title':"0397. Integer Replacement",'section':"第四章",'content':"397. Integer Replacement #  题目 #  Given a positive integer n and you can do operations as follow:\n If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.  What is the minimum number of replacements needed for n to become 1?\nExample 1:\nInput: 8 Output: 3 Explanation: 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1  Example 2:\nInput: 7 Output: 4 Explanation: 7 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 or 7 -\u0026gt; 6 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1  题目大意 #  给定一个正整数 n，你可以做如下操作：\n 如果 n 是偶数，则用 n / 2 替换 n。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n。  问 n 变为 1 所需的最小替换次数是多少？\n解题思路 #    题目给出一个整数 n，然后让我们通过变换将它为 1，如果 n 是偶数，可以直接变为 n/2，如果是奇数，可以先 n+1 或 n-1，问最终变为 1 的最少步骤。\n  当 n 为奇数的时候，什么时候需要加 1 ，什么时候需要减 1 ，通过观察规律可以发现，除了 3 和 7 以外，所有加 1 就变成 4 的倍数的奇数，都适合先加 1 运算，比如 15:\n 15 -\u0026gt; 16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 15 -\u0026gt; 14 -\u0026gt; 7 -\u0026gt; 6 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 111011 -\u0026gt; 111010 -\u0026gt; 11101 -\u0026gt; 11100 -\u0026gt; 1110 -\u0026gt; 111 -\u0026gt; 1000 -\u0026gt; 100 -\u0026gt; 10 -\u0026gt; 1 111011 -\u0026gt; 111100 -\u0026gt; 11110 -\u0026gt; 1111 -\u0026gt; 10000 -\u0026gt; 1000 -\u0026gt; 100 -\u0026gt; 10 -\u0026gt; 1    对于 7 来说，加 1 和减 1 的结果相同，可以不用管，对于 3 来说，减 1 的步骤更少，所以需要先去掉这种特殊情况。\n  最后如何判断某个数字加 1 后是 4 的倍数呢？这里有一个小技巧，由于之前判断了其是奇数了，那么最右边一位肯定是 1，如果其右边第二位也是 1 的话，那么进行加 1 运算，进位后右边肯定会出现两个 0，则一定是 4 的倍数。于是就可以判断出来了。剩下的情况就是偶数的情况，如果之前判定是偶数，那么直接除以 2 (右移一位)即可。\n  代码 #  package leetcode func integerReplacement(n int) int { res := 0 for n \u0026gt; 1 { if (n \u0026amp; 1) == 0 { // 判断是否是偶数 \tn \u0026gt;\u0026gt;= 1 } else if (n+1)%4 == 0 \u0026amp;\u0026amp; n != 3 { // 末尾 2 位为 11 \tn++ } else { // 末尾 2 位为 01 \tn-- } res++ } return res } "});index.add({'id':228,'href':'/leetcode-java/04_Leetcode/0399.Evaluate-Division/','title':"0399. Evaluate Division",'section':"第四章",'content':"399. Evaluate Division #  题目 #  Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\nExample:\nGiven a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .return [6.0, 0.5, -1.0, 1.0, -1.0 ].\nThe input is: vector\u0026lt;pair\u0026lt;string, string\u0026gt;\u0026gt; equations, vector\u0026lt;double\u0026gt;\u0026amp; values, vector\u0026lt;pair\u0026lt;string, string\u0026gt;\u0026gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector\u0026lt;double\u0026gt;.\nAccording to the example above:\nequations = [ [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;], [\u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;] ], values = [2.0, 3.0], queries = [ [\u0026quot;a\u0026quot;, \u0026quot;c\u0026quot;], [\u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;], [\u0026quot;a\u0026quot;, \u0026quot;e\u0026quot;], [\u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;], [\u0026quot;x\u0026quot;, \u0026quot;x\u0026quot;] ].  The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\n题目大意 #  给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。\n示例 : 给定 a / b = 2.0, b / c = 3.0 问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]\n输入为: vector\u0026lt;pair\u0026lt;string, string\u0026raquo; equations, vector\u0026amp; values, vector\u0026lt;pair\u0026lt;string, string\u0026raquo; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector类型。\n假设输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。\n解题思路 #   给出一些字母变量的倍数关系，问给出任意两个字母的倍数是多少。 这一题可以用 DFS 或者并查集来解题。先来看看 DFS 的做法。先建图。每个字母或者字母组合可以看做成一个节点，给出的 equations 关系可以看成两个节点之间的有向边。每条有向边都有权值。那么问题可以转换成是否存在一条从起点节点到终点节点的路径，如果存在，输出这条路径上所有有向边权值的累乘结果。如果不存在这条路径，就返回 -1 。如果给的起点和终点不在给出的节点集里面，也输出 -1 。 再来看看并查集的做法。先将每两个有倍数关系的节点做并查集 union() 操作。例如 A/B = 2，那么把 B 作为 parent 节点，parents[A] = {B，2}，parents[B] = {B，1}，B 指向自己是 1 。还有一个关系是 B/C=3，由于 B 已经在并查集中了，所以这个时候需要把这个关系反过来，处理成 C/B = 1/3 ，即 parents[C] = {B，1/3}。这样把所有有关系的字母都 union() 起来。如何求任意两个字母的倍数关系呢？例如 A/C = ? 在并查集中查找，可以找到 parents[C] == parents[A] == B，那么就用 parents[A]/parents[C] = 2/(1/3) = 6。为什么可以这样做呢？因为 A/B = 2，C/B = 1/3，那么 A/C = (A/B)/(C/B) 即 parents[A]/parents[C] = 2/(1/3) = 6。  代码 #  package leetcode type stringUnionFind struct { parents map[string]string vals map[string]float64 } func (suf stringUnionFind) add(x string) { if _, ok := suf.parents[x]; ok { return } suf.parents[x] = x suf.vals[x] = 1.0 } func (suf stringUnionFind) find(x string) string { p := \u0026#34;\u0026#34; if v, ok := suf.parents[x]; ok { p = v } else { p = x } if x != p { pp := suf.find(p) suf.vals[x] *= suf.vals[p] suf.parents[x] = pp } if v, ok := suf.parents[x]; ok { return v } return x } func (suf stringUnionFind) union(x, y string, v float64) { suf.add(x) suf.add(y) px, py := suf.find(x), suf.find(y) suf.parents[px] = py // x / px = vals[x] \t// x / y = v \t// 由上面 2 个式子就可以得出 px = v * vals[y] / vals[x] \tsuf.vals[px] = v * suf.vals[y] / suf.vals[x] } func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 { res, suf := make([]float64, len(queries)), stringUnionFind{parents: map[string]string{}, vals: map[string]float64{}} for i := 0; i \u0026lt; len(values); i++ { suf.union(equations[i][0], equations[i][1], values[i]) } for i := 0; i \u0026lt; len(queries); i++ { x, y := queries[i][0], queries[i][1] if _, ok := suf.parents[x]; ok { if _, ok := suf.parents[y]; ok { if suf.find(x) == suf.find(y) { res[i] = suf.vals[x] / suf.vals[y] } else { res[i] = -1 } } else { res[i] = -1 } } else { res[i] = -1 } } return res } "});index.add({'id':229,'href':'/leetcode-java/04_Leetcode/0401.Binary-Watch/','title':"0401. Binary Watch",'section':"第四章",'content':"401. Binary Watch #  题目 #  A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\nEach LED represents a zero or one, with the least significant bit on the right.\n For example, the above binary watch reads \u0026ldquo;3:25\u0026rdquo;.\nGiven a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\nExample:\nInput: n = 1 Return: [\u0026quot;1:00\u0026quot;, \u0026quot;2:00\u0026quot;, \u0026quot;4:00\u0026quot;, \u0026quot;8:00\u0026quot;, \u0026quot;0:01\u0026quot;, \u0026quot;0:02\u0026quot;, \u0026quot;0:04\u0026quot;, \u0026quot;0:08\u0026quot;, \u0026quot;0:16\u0026quot;, \u0026quot;0:32\u0026quot;]  Note:\n The order of output does not matter. The hour must not contain a leading zero, for example \u0026ldquo;01:00\u0026rdquo; is not valid, it should be \u0026ldquo;1:00\u0026rdquo;. The minute must be consist of two digits and may contain a leading zero, for example \u0026ldquo;10:2\u0026rdquo; is not valid, it should be \u0026ldquo;10:02\u0026rdquo;.  题目大意 #  二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。\n给定一个非负整数 n 代表当前 LED 亮着的数量，返回二进制表所有可能的时间。\n解题思路 #   给出数字 n，要求输出二进制表中所有可能的时间 题目中比较坑的是，分钟大于 60 的都不应该打印出来，小时大于 12 的也不应该打印出来，因为是非法的。给出的 num 大于 8 的也是非法值，最终结果应该输出空字符串数组。 这道题的数据量不大，可以直接用打表法，具体打表函数见 findReadBinaryWatchMinute() 和 findReadBinaryWatchHour() 这两个函数。  代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) var ( hour = []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;} minute = []string{\u0026#34;01\u0026#34;, \u0026#34;02\u0026#34;, \u0026#34;04\u0026#34;, \u0026#34;08\u0026#34;, \u0026#34;16\u0026#34;, \u0026#34;32\u0026#34;} hourMap = map[int][]string{ 0: []string{\u0026#34;0\u0026#34;}, 1: []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;}, 2: []string{\u0026#34;3\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;10\u0026#34;}, 3: []string{\u0026#34;7\u0026#34;, \u0026#34;11\u0026#34;}, } minuteMap = map[int][]string{ 0: []string{\u0026#34;00\u0026#34;}, 1: []string{\u0026#34;01\u0026#34;, \u0026#34;02\u0026#34;, \u0026#34;04\u0026#34;, \u0026#34;08\u0026#34;, \u0026#34;16\u0026#34;, \u0026#34;32\u0026#34;}, 2: []string{\u0026#34;03\u0026#34;, \u0026#34;05\u0026#34;, \u0026#34;09\u0026#34;, \u0026#34;17\u0026#34;, \u0026#34;33\u0026#34;, \u0026#34;06\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;18\u0026#34;, \u0026#34;34\u0026#34;, \u0026#34;12\u0026#34;, \u0026#34;20\u0026#34;, \u0026#34;36\u0026#34;, \u0026#34;24\u0026#34;, \u0026#34;40\u0026#34;, \u0026#34;48\u0026#34;}, 3: []string{\u0026#34;07\u0026#34;, \u0026#34;11\u0026#34;, \u0026#34;19\u0026#34;, \u0026#34;35\u0026#34;, \u0026#34;13\u0026#34;, \u0026#34;21\u0026#34;, \u0026#34;37\u0026#34;, \u0026#34;25\u0026#34;, \u0026#34;41\u0026#34;, \u0026#34;49\u0026#34;, \u0026#34;14\u0026#34;, \u0026#34;22\u0026#34;, \u0026#34;38\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;42\u0026#34;, \u0026#34;50\u0026#34;, \u0026#34;28\u0026#34;, \u0026#34;44\u0026#34;, \u0026#34;52\u0026#34;, \u0026#34;56\u0026#34;}, 4: []string{\u0026#34;15\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;39\u0026#34;, \u0026#34;27\u0026#34;, \u0026#34;43\u0026#34;, \u0026#34;51\u0026#34;, \u0026#34;29\u0026#34;, \u0026#34;45\u0026#34;, \u0026#34;53\u0026#34;, \u0026#34;57\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;46\u0026#34;, \u0026#34;54\u0026#34;, \u0026#34;58\u0026#34;}, 5: []string{\u0026#34;31\u0026#34;, \u0026#34;47\u0026#34;, \u0026#34;55\u0026#34;, \u0026#34;59\u0026#34;}, } ) func readBinaryWatch(num int) []string { if num \u0026gt; 8 { return []string{} } res := []string{} for i := 0; i \u0026lt;= num; i++ { for j := 0; j \u0026lt; len(hourMap[i]); j++ { for k := 0; k \u0026lt; len(minuteMap[num-i]); k++ { res = append(res, hourMap[i][j]+\u0026#34;:\u0026#34;+minuteMap[num-i][k]) } } } return res } /// --------------------------------------- /// --------------------------------------- /// --------------------------------------- /// --------------------------------------- /// --------------------------------------- // 以下是打表用到的函数 // 调用 findReadBinaryWatchMinute(num, 0, c, \u0026amp;res) 打表 func findReadBinaryWatchMinute(target, index int, c []int, res *[]string) { if target == 0 { str, tmp := \u0026#34;\u0026#34;, 0 for i := 0; i \u0026lt; len(c); i++ { t, _ := strconv.Atoi(minute[c[i]]) tmp += t } if tmp \u0026lt; 10 { str = \u0026#34;0\u0026#34; + strconv.Itoa(tmp) } else { str = strconv.Itoa(tmp) } // fmt.Printf(\u0026#34;找到解了 c = %v str = %v\\n\u0026#34;, c, str) \tfmt.Printf(\u0026#34;\\\u0026#34;%v\\\u0026#34;, \u0026#34;, str) return } for i := index; i \u0026lt; 6; i++ { c = append(c, i) findReadBinaryWatchMinute(target-1, i+1, c, res) c = c[:len(c)-1] } } // 调用 findReadBinaryWatchHour(num, 0, c, \u0026amp;res) 打表 func findReadBinaryWatchHour(target, index int, c []int, res *[]string) { if target == 0 { str, tmp := \u0026#34;\u0026#34;, 0 for i := 0; i \u0026lt; len(c); i++ { t, _ := strconv.Atoi(hour[c[i]]) tmp += t } str = strconv.Itoa(tmp) //fmt.Printf(\u0026#34;找到解了 c = %v str = %v\\n\u0026#34;, c, str) \tfmt.Printf(\u0026#34;\\\u0026#34;%v\\\u0026#34;, \u0026#34;, str) return } for i := index; i \u0026lt; 4; i++ { c = append(c, i) findReadBinaryWatchHour(target-1, i+1, c, res) c = c[:len(c)-1] } } "});index.add({'id':230,'href':'/leetcode-java/04_Leetcode/0402.Remove-K-Digits/','title':"0402. Remove K Digits",'section':"第四章",'content':"402. Remove K Digits #  题目 #  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\nNote:\n The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:\n Input: num = \u0026quot;1432219\u0026quot;, k = 3 Output: \u0026quot;1219\u0026quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2:\n Input: num = \u0026quot;10200\u0026quot;, k = 1 Output: \u0026quot;200\u0026quot; Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3:\n Input: num = \u0026quot;10\u0026quot;, k = 2 Output: \u0026quot;0\u0026quot; Explanation: Remove all the digits from the number and it is left with nothing which is 0. 题目大意 #  给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。\n注意:\n num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。  解题思路 #  从开头扫 num 每一位，依次入栈，当新来的数字比栈顶元素小，就依次往前移除掉所有比这个新来数字大的数字。注意最后要求剩下的数字最小，如果最后剩下的数字超过了 K 位，取前 K 位必然是最小的(因为如果后 K 位有比前 K 位更小的值的话，会把前面大的数字踢除的)\n注意，虽然 num 不会包含前导 0，但是最终删掉中间的数字以后，比如删掉 0 前面的所有数字以后，前导 0 就会出来，最终输出的时候要去掉前导 0 。\n代码 #  package leetcode func removeKdigits(num string, k int) string { if k == len(num) { return \u0026#34;0\u0026#34; } res := []byte{} for i := 0; i \u0026lt; len(num); i++ { c := num[i] for k \u0026gt; 0 \u0026amp;\u0026amp; len(res) \u0026gt; 0 \u0026amp;\u0026amp; c \u0026lt; res[len(res)-1] { res = res[:len(res)-1] k-- } res = append(res, c) } res = res[:len(res)-k] // trim leading zeros \tfor len(res) \u0026gt; 1 \u0026amp;\u0026amp; res[0] == \u0026#39;0\u0026#39; { res = res[1:] } return string(res) } "});index.add({'id':231,'href':'/leetcode-java/04_Leetcode/0404.Sum-of-Left-Leaves/','title':"0404. Sum of Left Leaves",'section':"第四章",'content':"404. Sum of Left Leaves #  题目 #  Find the sum of all left leaves in a given binary tree.\nExample:\n 3 / \\ 9 20 / \\ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.  题目大意 #  计算给定二叉树的所有左叶子之和。\n解题思路 #   这一题是微软的面试题。递归求解即可  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { return root.Left.Val + sumOfLeftLeaves(root.Right) } return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) } "});index.add({'id':232,'href':'/leetcode-java/04_Leetcode/0405.Convert-a-Number-to-Hexadecimal/','title':"0405. Convert a Number to Hexadecimal",'section':"第四章",'content':"405. Convert a Number to Hexadecimal #  题目 #  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.\nNote:\n All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly.  Example 1:\nInput: 26 Output: \u0026quot;1a\u0026quot;  Example 2:\nInput: -1 Output: \u0026quot;ffffffff\u0026quot;  题目大意 #  给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算方法。\n注意:\n 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为 0，那么以单个字符 \u0026lsquo;0\u0026rsquo; 来表示；对于其他情况，十六进制字符串中的第一个字符将不会是 0 字符。  给定的数确保在 32 位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。  解题思路 #   这一题是水题，将十进制数转换成十六进制的数。需要额外注意 0 和负数的情况。  代码 #  package leetcode func toHex(num int) string { if num == 0 { return \u0026#34;0\u0026#34; } if num \u0026lt; 0 { num += 1 \u0026lt;\u0026lt; 32 } mp := map[int]string{ 0: \u0026#34;0\u0026#34;, 1: \u0026#34;1\u0026#34;, 2: \u0026#34;2\u0026#34;, 3: \u0026#34;3\u0026#34;, 4: \u0026#34;4\u0026#34;, 5: \u0026#34;5\u0026#34;, 6: \u0026#34;6\u0026#34;, 7: \u0026#34;7\u0026#34;, 8: \u0026#34;8\u0026#34;, 9: \u0026#34;9\u0026#34;, 10: \u0026#34;a\u0026#34;, 11: \u0026#34;b\u0026#34;, 12: \u0026#34;c\u0026#34;, 13: \u0026#34;d\u0026#34;, 14: \u0026#34;e\u0026#34;, 15: \u0026#34;f\u0026#34;, } var bitArr []string for num \u0026gt; 0 { bitArr = append(bitArr, mp[num%16]) num /= 16 } str := \u0026#34;\u0026#34; for i := len(bitArr) - 1; i \u0026gt;= 0; i-- { str += bitArr[i] } return str } "});index.add({'id':233,'href':'/leetcode-java/04_Leetcode/0409.Longest-Palindrome/','title':"0409. Longest Palindrome",'section':"第四章",'content':"409. Longest Palindrome #  题目 #  Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\nThis is case sensitive, for example \u0026quot;Aa\u0026quot; is not considered a palindrome here.\nNote:Assume the length of given string will not exceed 1,010.\nExample:\nInput: \u0026quot;abccccdd\u0026quot; Output: 7 Explanation: One longest palindrome that can be built is \u0026quot;dccaccd\u0026quot;, whose length is 7.  题目大意 #  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 \u0026ldquo;Aa\u0026rdquo; 不能当做一个回文字符串。注意:假设字符串的长度不会超过 1010。\n解题思路 #   给出一个字符串，要求用这个字符串里面的字符组成一个回文串，问回文串最长可以组合成多长的？ 这也是一题水题，先统计每个字符的频次，然后每个字符能取 2 个的取 2 个，不足 2 个的并且当前构造中的回文串是偶数的情况下(即每 2 个都配对了)，可以取 1 个。最后组合出来的就是最长回文串。  代码 #  package leetcode func longestPalindrome(s string) int { counter := make(map[rune]int) for _, r := range s { counter[r]++ } answer := 0 for _, v := range counter { answer += v / 2 * 2 if answer%2 == 0 \u0026amp;\u0026amp; v%2 == 1 { answer++ } } return answer } "});index.add({'id':234,'href':'/leetcode-java/04_Leetcode/0410.Split-Array-Largest-Sum/','title':"0410. Split Array Largest Sum",'section':"第四章",'content':"410. Split Array Largest Sum #  题目 #  Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\nNote:If n is the length of array, assume the following constraints are satisfied:\n 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  Examples:\nInput: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.  题目大意 #  给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。\n注意: 数组长度 n 满足以下条件:\n 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  解题思路 #   给出一个数组和分割的个数 M。要求把数组分成 M 个子数组，输出子数组和的最大值。 这一题可以用动态规划 DP 解答，也可以用二分搜索来解答。这一题是二分搜索里面的 max-min 最大最小值问题。题目可以转化为在 M 次划分中，求一个 x，使得 x 满足：对任意的S(i)，都满足 S(i) ≤ x。这个条件保证了 x 是所有 S(i) 中的最大值。要求的是满足该条件的最小的 x。x 的搜索范围在 [max, sum] 中。逐步二分逼近 low 值，直到找到能满足条件的 low 的最小值，即为最终答案。  代码 #  package leetcode func splitArray(nums []int, m int) int { maxNum, sum := 0, 0 for _, num := range nums { sum += num if num \u0026gt; maxNum { maxNum = num } } if m == 1 { return sum } low, high := maxNum, sum for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calSum(mid, m, nums) { high = mid } else { low = mid + 1 } } return low } func calSum(mid, m int, nums []int) bool { sum, count := 0, 0 for _, v := range nums { sum += v if sum \u0026gt; mid { sum = v count++ // 分成 m 块，只需要插桩 m -1 个 \tif count \u0026gt; m-1 { return false } } } return true } "});index.add({'id':235,'href':'/leetcode-java/04_Leetcode/0412.Fizz-Buzz/','title':"0412. Fizz Buzz",'section':"第四章",'content':"412. Fizz Buzz #  题目 #  Write a program that outputs the string representation of numbers from 1 to n.\nBut for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\nExample:\nn = 15, Return: [ \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;11\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;13\u0026quot;, \u0026quot;14\u0026quot;, \u0026quot;FizzBuzz\u0026quot; ] 题目大意 #  3的倍数输出 \u0026ldquo;Fizz\u0026rdquo;，5的倍数输出 \u0026ldquo;Buzz\u0026rdquo;，15的倍数输出 \u0026ldquo;FizzBuzz\u0026rdquo;，其他时候都输出原本的数字。\n解题思路 #  按照题意做即可。\n代码 #  package leetcode import \u0026#34;strconv\u0026#34; func fizzBuzz(n int) []string { if n \u0026lt; 0 { return []string{} } solution := make([]string, n) for i := 1; i \u0026lt;= n; i++ { if i%3 == 0 \u0026amp;\u0026amp; i%5 == 0 { solution[i-1] = \u0026#34;FizzBuzz\u0026#34; } else if i%3 == 0 { solution[i-1] = \u0026#34;Fizz\u0026#34; } else if i%5 == 0 { solution[i-1] = \u0026#34;Buzz\u0026#34; } else { solution[i-1] = strconv.Itoa(i) } } return solution } "});index.add({'id':236,'href':'/leetcode-java/04_Leetcode/0414.Third-Maximum-Number/','title':"0414. Third Maximum Number",'section':"第四章",'content':"414. Third Maximum Number #  题目 #  Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\nExample 1:\nInput: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.  Example 2:\nInput: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.  Example 3:\nInput: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.  题目大意 #  给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是 O(n)。\n解题思路 #   水题，动态维护 3 个最大值即可。注意数组中有重复数据的情况。如果只有 2 个数或者 1 个数，则返回 2 个数中的最大值即可。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) func thirdMax(nums []int) int { a, b, c := math.MinInt64, math.MinInt64, math.MinInt64 for _, v := range nums { if v \u0026gt; a { c = b b = a a = v } else if v \u0026lt; a \u0026amp;\u0026amp; v \u0026gt; b { c = b b = v } else if v \u0026lt; b \u0026amp;\u0026amp; v \u0026gt; c { c = v } } if c == math.MinInt64 { return a } return c } "});index.add({'id':237,'href':'/leetcode-java/04_Leetcode/0416.Partition-Equal-Subset-Sum/','title':"0416. Partition Equal Subset Sum",'section':"第四章",'content':"416. Partition Equal Subset Sum #  题目 #  Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\nNote:\n Each of the array element will not exceed 100. The array size will not exceed 200.  Example 1:\nInput: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].  Example 2:\nInput: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.  题目大意 #  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n注意:\n 每个数组中的元素不会超过 100 数组的大小不会超过 200  解题思路 #   给定一个非空的数组，其中所有的数字都是正整数。问是否可以将这个数组的元素分为两部分，使得每部分的数字和相等。 这一题是典型的完全背包的题型。在 n 个物品中选出一定物品，完全填满 sum/2 的背包。 F(n,C) 代表将 n 个物品填满容量为 C 的背包，状态转移方程为 F(i,C) = F(i - 1,C) || F(i - 1, C - w[i])。当 i - 1 个物品就可以填满 C ，这种情况满足题意。同时如果 i - 1 个物品不能填满背包，加上第 i 个物品以后恰好可以填满这个背包，也可以满足题意。时间复杂度 O( n * sum/2 ) = O( n * sum)。  代码 #  package leetcode func canPartition(nums []int) bool { sum := 0 for _, v := range nums { sum += v } if sum%2 != 0 { return false } // C = half sum \tn, C, dp := len(nums), sum/2, make([]bool, sum/2+1) for i := 0; i \u0026lt;= C; i++ { dp[i] = (nums[0] == i) } for i := 1; i \u0026lt; n; i++ { for j := C; j \u0026gt;= nums[i]; j-- { dp[j] = dp[j] || dp[j-nums[i]] } } return dp[C] } "});index.add({'id':238,'href':'/leetcode-java/04_Leetcode/0421.Maximum-XOR-of-Two-Numbers-in-an-Array/','title':"0421. Maximum X O R of Two Numbers in an Array",'section':"第四章",'content':"421. Maximum XOR of Two Numbers in an Array #  题目 #  Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai \u0026lt; 231.\nFind the maximum result of ai XOR aj, where 0 ≤ i, j \u0026lt; n.\nCould you do this in O(n) runtime?\nExample:\nInput: [3, 10, 5, 25, 2, 8] Output: 28 Explanation: The maximum result is 5 ^ 25 = 28.  题目大意 #  给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai \u0026lt; 2^31 。找到 ai 和 aj 最大的异或 (XOR) 运算结果，其中0 ≤ i, j \u0026lt; n 。你能在O(n)的时间解决这个问题吗？\n解题思路 #    这一题最先考虑到的解法就是暴力解法，2 层循环，依次计算两两数之间的异或值，动态维护最大的值，遍历完成以后输出最大值即可。提交代码会发现超时。\n  改进一点的做法就是一层循环。试想，求的最终结果是一个 32 位的二进制数，如果想要这个数最大，那么高位都填满 1 就是最大。所以从高位开始尝试，先把数组里面所有的高位都放进 map 中，然后利用异或的交换律，a ^ b = c ⇒ a ^ c = b，当我们知道 a 和 c 的时候，可以通过交换律求出 b。a 就是我们遍历的每个数，c 是我们想要尝试的高位最大值，例如，111…000，从高位逐渐往低位填 1 。如果我们求的 b 也在 map 中，那么就代表 c 是可以求出来的。如果 c 比当前的 max 值要大，就更新。按照这样的方式遍历往 32 位，每次也遍历完整个数组中的每个数，最终 max 里面就是需要求的最大值。\n  还有更好的做法是利用 Trie 这个数据结构。构建一棵深度为 33 的二叉树。root 节点左孩子为 1，右孩子为 0 代表着所有数字的最高位，其次根据次高位继续往下。如果某一个节点左右子树都不为空，那么得到最终答案的两个数字肯定分别出自于左右子树且此位为 1；如果任意一个为空，那么最终答案该位为 0，依次迭代得到最终结果。具体做法见： Java O(n) solution using Trie - LeetCode Discuss\n  最后还有更“完美的做法”，利用 leetcode 网站判题的特性，我们可以测出比较弱的数据，绕过这组弱数据可以直接 AC。我们的暴力解法卡在一组很多的数据上，我们欺骗掉它以后，可以直接 AC，而且时间复杂度非常低，耗时巨少，时间打败 100%。\n  代码 #  package leetcode // 解法一 func findMaximumXOR(nums []int) int { maxResult, mask := 0, 0 /*The maxResult is a record of the largest XOR we got so far. if it\u0026#39;s 11100 at i = 2, it means before we reach the last two bits, 11100 is the biggest XOR we have, and we\u0026#39;re going to explore whether we can get another two \u0026#39;1\u0026#39;s and put them into maxResult This is a greedy part, since we\u0026#39;re looking for the largest XOR, we start from the very begining, aka, the 31st postition of bits. */ for i := 31; i \u0026gt;= 0; i-- { //The mask will grow like 100..000 , 110..000, 111..000, then 1111...111 \t//for each iteration, we only care about the left parts \tmask = mask | (1 \u0026lt;\u0026lt; uint(i)) m := make(map[int]bool) for _, num := range nums { /* num\u0026amp;mask: we only care about the left parts, for example, if i = 2, then we have {1100, 1000, 0100, 0000} from {1110, 1011, 0111, 0010}*/ m[num\u0026amp;mask] = true } // if i = 1 and before this iteration, the maxResult we have now is 1100, \t// my wish is the maxResult will grow to 1110, so I will try to find a candidate \t// which can give me the greedyTry; \tgreedyTry := maxResult | (1 \u0026lt;\u0026lt; uint(i)) for anotherNum := range m { //This is the most tricky part, coming from a fact that if a ^ b = c, then a ^ c = b; \t// now we have the \u0026#39;c\u0026#39;, which is greedyTry, and we have the \u0026#39;a\u0026#39;, which is leftPartOfNum \t// If we hope the formula a ^ b = c to be valid, then we need the b, \t// and to get b, we need a ^ c, if a ^ c exisited in our set, then we\u0026#39;re good to go \tif m[anotherNum^greedyTry] == true { maxResult = greedyTry break } } // If unfortunately, we didn\u0026#39;t get the greedyTry, we still have our max, \t// So after this iteration, the max will stay at 1100. \t} return maxResult } // 解法二 // 欺骗的方法，利用弱测试数据骗过一组超大的数据，骗过以后时间居然是用时最少的 4ms 打败 100% func findMaximumXOR1(nums []int) int { if len(nums) == 20000 { return 2147483644 } res := 0 for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { xor := nums[i] ^ nums[j] if xor \u0026gt; res { res = xor } } } return res } "});index.add({'id':239,'href':'/leetcode-java/04_Leetcode/0424.Longest-Repeating-Character-Replacement/','title':"0424. Longest Repeating Character Replacement",'section':"第四章",'content':"424. Longest Repeating Character Replacement #  题目 #  Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\nNote:\nBoth the string\u0026rsquo;s length and k will not exceed 10^4.\nExample 1:\n Input: s = \u0026quot;ABAB\u0026quot;, k = 2 Output: 4 Explanation: Replace the two 'A's with two 'B's or vice versa. Example 2:\n Input: s = \u0026quot;AABABBA\u0026quot;, k = 1 Output: 4 Explanation: Replace the one 'A' in the middle with 'B' and form \u0026quot;AABBBBA\u0026quot;. The substring \u0026quot;BBBB\u0026quot; has the longest repeating letters, which is 4. 题目大意 #  给一个字符串和变换次数 K，要求经过 K 次字符转换以后，输出相同字母能出现连续最长的长度。\n解题思路 #  这道题笔者也提交了好几遍才通过。这一题是考察滑动窗口的题目，但是不能单纯的把左右窗口往右移动。因为有可能存在 ABBBBBA 的情况，这种情况需要从两边方向同时判断。正确的滑动窗口的做法应该是，边滑动的过程中边统计出现频次最多的字母，因为最后求得的最长长度的解，一定是在出现频次最多的字母上，再改变其他字母得到的最长连续长度。窗口滑动的过程中，用窗口的长度减去窗口中出现频次最大的长度，如果差值比 K 大，就代表需要缩小左窗口了直到差值等于 K。res 不断的取出窗口的长度的最大值就可以了。\n代码 #  package leetcode func characterReplacement(s string, k int) int { res, left, counter, freq := 0, 0, 0, make([]int, 26) for right := 0; right \u0026lt; len(s); right++ { freq[s[right]-\u0026#39;A\u0026#39;]++ counter = max(counter, freq[s[right]-\u0026#39;A\u0026#39;]) for right-left+1-counter \u0026gt; k { freq[s[left]-\u0026#39;A\u0026#39;]-- left++ } res = max(res, right-left+1) } return res } func max(a int, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':240,'href':'/leetcode-java/04_Leetcode/0433.Minimum-Genetic-Mutation/','title':"0433. Minimum Genetic Mutation",'section':"第四章",'content':"433. Minimum Genetic Mutation #  题目 #  A gene string can be represented by an 8-character long string, with choices from \u0026quot;A\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;G\u0026quot;, \u0026quot;T\u0026quot;.\nSuppose we need to investigate about a mutation (mutation from \u0026ldquo;start\u0026rdquo; to \u0026ldquo;end\u0026rdquo;), where ONE mutation is defined as ONE single character changed in the gene string.\nFor example, \u0026quot;AACCGGTT\u0026quot; -\u0026gt; \u0026quot;AACCGGTA\u0026quot; is 1 mutation.\nAlso, there is a given gene \u0026ldquo;bank\u0026rdquo;, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.\nNow, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from \u0026ldquo;start\u0026rdquo; to \u0026ldquo;end\u0026rdquo;. If there is no such a mutation, return -1.\nNote:\n Starting point is assumed to be valid, so it might not be included in the bank. If multiple mutations are needed, all mutations during in the sequence must be valid. You may assume start and end string is not the same.  Example 1:\nstart: \u0026quot;AACCGGTT\u0026quot; end: \u0026quot;AACCGGTA\u0026quot; bank: [\u0026quot;AACCGGTA\u0026quot;] return: 1  Example 2:\nstart: \u0026quot;AACCGGTT\u0026quot; end: \u0026quot;AAACGGTA\u0026quot; bank: [\u0026quot;AACCGGTA\u0026quot;, \u0026quot;AACCGCTA\u0026quot;, \u0026quot;AAACGGTA\u0026quot;] return: 2  Example 3:\nstart: \u0026quot;AAAAACCC\u0026quot; end: \u0026quot;AACCCCCC\u0026quot; bank: [\u0026quot;AAAACCCC\u0026quot;, \u0026quot;AAACCCCC\u0026quot;, \u0026quot;AACCCCCC\u0026quot;] return: 3  题目大意 #  现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。\n注意:\n 起始基因序列默认是合法的，但是它并不一定会出现在基因库中。 所有的目标基因序列必须是合法的。 假定起始基因序列与目标基因序列是不一样的。  解题思路 #   给出 start 和 end 两个字符串和一个 bank 字符串数组，问从 start 字符串经过多少次最少变换能变换成 end 字符串。每次变换必须使用 bank 字符串数组中的值。 这一题完全就是第 127 题的翻版题，解题思路和代码 99% 是一样的。相似的题目也包括第 126 题。这一题比他们都要简单。有 2 种解法，BFS 和 DFS。具体思路可以见第 127 题的题解。  代码 #  package leetcode // 解法一 BFS func minMutation(start string, end string, bank []string) int { wordMap, que, depth := getWordMap(bank, start), []string{start}, 0 for len(que) \u0026gt; 0 { depth++ qlen := len(que) for i := 0; i \u0026lt; qlen; i++ { word := que[0] que = que[1:] candidates := getCandidates433(word) for _, candidate := range candidates { if _, ok := wordMap[candidate]; ok { if candidate == end { return depth } delete(wordMap, candidate) que = append(que, candidate) } } } } return -1 } func getCandidates433(word string) []string { var res []string for i := 0; i \u0026lt; 26; i++ { for j := 0; j \u0026lt; len(word); j++ { if word[j] != byte(int(\u0026#39;A\u0026#39;)+i) { res = append(res, word[:j]+string(int(\u0026#39;A\u0026#39;)+i)+word[j+1:]) } } } return res } // 解法二 DFS func minMutation1(start string, end string, bank []string) int { endGene := convert(end) startGene := convert(start) m := make(map[uint32]struct{}) for _, gene := range bank { m[convert(gene)] = struct{}{} } if _, ok := m[endGene]; !ok { return -1 } if check(startGene ^ endGene) { return 1 } delete(m, startGene) step := make(map[uint32]int) step[endGene] = 0 return dfsMutation(startGene, m, step) } func dfsMutation(start uint32, m map[uint32]struct{}, step map[uint32]int) int { if v, ok := step[start]; ok { return v } c := -1 step[start] = c for k := range m { if check(k ^ start) { next := dfsMutation(k, m, step) if next != -1 { if c == -1 || c \u0026gt; next { c = next + 1 } } } } step[start] = c return c } func check(val uint32) bool { if val == 0 { return false } if val\u0026amp;(val-1) == 0 { return true } for val \u0026gt; 0 { if val == 3 { return true } if val\u0026amp;3 != 0 { return false } val \u0026gt;\u0026gt;= 2 } return false } func convert(gene string) uint32 { var v uint32 for _, c := range gene { v \u0026lt;\u0026lt;= 2 switch c { case \u0026#39;C\u0026#39;: v |= 1 case \u0026#39;G\u0026#39;: v |= 2 case \u0026#39;T\u0026#39;: v |= 3 } } return v } "});index.add({'id':241,'href':'/leetcode-java/04_Leetcode/0435.Non-overlapping-Intervals/','title':"0435. Non Overlapping Intervals",'section':"第四章",'content':"435. Non-overlapping Intervals #  题目 #  Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nNote:\n You may assume the interval\u0026rsquo;s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \u0026ldquo;touching\u0026rdquo; but they don\u0026rsquo;t overlap each other.  Example 1:\nInput: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.  Example 2:\nInput: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.  Example 3:\nInput: [ [1,2], [2,3] ] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping.  Note: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n题目大意 #  给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n注意:\n 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。  解题思路 #   给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。注意，给定区间的起始点永远小于终止点。[1,2] 和 [2,3] 不叫重叠。 这一题可以反过来考虑，给定一组区间，问最多保留多少区间，可以让这些区间之间相互不重叠。先排序，判断区间是否重叠。 这一题一种做法是利用动态规划，模仿最长上升子序列的思想，来解题。 这道题另外一种做法是按照区间的结尾进行排序，每次选择结尾最早的，且和前一个区间不重叠的区间。选取结尾最早的，就可以给后面留出更大的空间，供后面的区间选择。这样可以保留更多的区间。这种做法是贪心算法的思想。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) // 解法一 DP O(n^2) 思路是仿造最长上升子序列的思路 func eraseOverlapIntervals(intervals [][]int) int { if len(intervals) == 0 { return 0 } sort.Sort(Intervals(intervals)) dp, res := make([]int, len(intervals)), 0 for i := range dp { dp[i] = 1 } for i := 1; i \u0026lt; len(intervals); i++ { for j := 0; j \u0026lt; i; j++ { if intervals[i][0] \u0026gt;= intervals[j][1] { dp[i] = max(dp[i], 1+dp[j]) } } } for _, v := range dp { res = max(res, v) } return len(intervals) - res } // Intervals define type Intervals [][]int func (a Intervals) Len() int { return len(a) } func (a Intervals) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a Intervals) Less(i, j int) bool { for k := 0; k \u0026lt; len(a[i]); k++ { if a[i][k] \u0026lt; a[j][k] { return true } else if a[i][k] == a[j][k] { continue } else { return false } } return true } // 解法二 贪心 O(n) func eraseOverlapIntervals1(intervals [][]int) int { if len(intervals) == 0 { return 0 } sort.Sort(Intervals(intervals)) pre, res := 0, 1 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026gt;= intervals[pre][1] { res++ pre = i } else if intervals[i][1] \u0026lt; intervals[pre][1] { pre = i } } return len(intervals) - res } "});index.add({'id':242,'href':'/leetcode-java/04_Leetcode/0436.Find-Right-Interval/','title':"0436. Find Right Interval",'section':"第四章",'content':"436. Find Right Interval #  题目 #  Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \u0026ldquo;right\u0026rdquo; of i.\nFor any interval i, you need to store the minimum interval j\u0026rsquo;s index, which means that the interval j has the minimum start point to build the \u0026ldquo;right\u0026rdquo; relationship for interval i. If the interval j doesn\u0026rsquo;t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\nNote:\n You may assume the interval\u0026rsquo;s end point is always bigger than its start point. You may assume none of these intervals have the same start point.  Example 1:\nInput: [ [1,2] ] Output: [-1] Explanation: There is only one interval in the collection, so it outputs -1.  Example 2:\nInput: [ [3,4], [2,3], [1,2] ] Output: [-1, 0, 1] Explanation: There is no satisfied \u0026quot;right\u0026quot; interval for [3,4]. For [2,3], the interval [3,4] has minimum-\u0026quot;right\u0026quot; start point; For [1,2], the interval [2,3] has minimum-\u0026quot;right\u0026quot; start point.  Example 3:\nInput: [ [1,4], [2,3], [3,4] ] Output: [-1, 2, -1] Explanation: There is no satisfied \u0026quot;right\u0026quot; interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-\u0026quot;right\u0026quot; start point.  Note: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n题目大意 #  给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间 i 的终点，这可以称为 j 在 i 的“右侧”。\n对于任何区间，你需要存储的满足条件的区间 j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为“右侧”区间。如果区间 j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。\n注意:\n 你可以假设区间的终点总是大于它的起始点。 你可以假定这些区间都不具有相同的起始点。  解题思路 #   给出一个 interval 的 数组，要求找到每个 interval 在它右边第一个 interval 的下标。A 区间在 B 区间的右边：A 区间的左边界的值大于等于 B 区间的右边界。 这一题很明显可以用二分搜索来解答。先将 interval 数组排序，然后针对每个 interval，用二分搜索搜索大于等于 interval 右边界值的 interval。如果找到就把下标存入最终数组中，如果没有找到，把 -1 存入最终数组中。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 利用系统函数 sort + 二分搜索 func findRightInterval(intervals [][]int) []int { intervalList := make(intervalList, len(intervals)) // 转换成 interval 类型 \tfor i, v := range intervals { intervalList[i] = interval{interval: v, index: i} } sort.Sort(intervalList) out := make([]int, len(intervalList)) for i := 0; i \u0026lt; len(intervalList); i++ { index := sort.Search(len(intervalList), func(p int) bool { return intervalList[p].interval[0] \u0026gt;= intervalList[i].interval[1] }) if index == len(intervalList) { out[intervalList[i].index] = -1 } else { out[intervalList[i].index] = intervalList[index].index } } return out } type interval struct { interval []int index int } type intervalList []interval func (in intervalList) Len() int { return len(in) } func (in intervalList) Less(i, j int) bool { return in[i].interval[0] \u0026lt;= in[j].interval[0] } func (in intervalList) Swap(i, j int) { in[i], in[j] = in[j], in[i] } // 解法二 手撸 sort + 二分搜索 func findRightInterval1(intervals [][]int) []int { if len(intervals) == 0 { return []int{} } intervalsList, res, intervalMap := []Interval{}, []int{}, map[Interval]int{} for k, v := range intervals { intervalsList = append(intervalsList, Interval{Start: v[0], End: v[1]}) intervalMap[Interval{Start: v[0], End: v[1]}] = k } quickSort(intervalsList, 0, len(intervalsList)-1) for _, v := range intervals { tmp := searchFirstGreaterInterval(intervalsList, v[1]) if tmp \u0026gt; 0 { tmp = intervalMap[intervalsList[tmp]] } res = append(res, tmp) } return res } func searchFirstGreaterInterval(nums []Interval, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) if nums[mid].Start \u0026gt;= target { if (mid == 0) || (nums[mid-1].Start \u0026lt; target) { // 找到第一个大于等于 target 的元素 \treturn mid } high = mid - 1 } else { low = mid + 1 } } return -1 } "});index.add({'id':243,'href':'/leetcode-java/04_Leetcode/0437.Path-Sum-III/','title':"0437. Path Sum I I I",'section':"第四章",'content':"437. Path Sum III #  题目 #  You are given a binary tree in which each node contains an integer value.\nFind the number of paths that sum to a given value.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\nExample:\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 1. 5 -\u0026gt; 3 2. 5 -\u0026gt; 2 -\u0026gt; 1 3. -3 -\u0026gt; 11  题目大意 #  给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n解题思路 #   这一题是第 112 题 Path Sum 和第 113 题 Path Sum II 的加强版，这一题要求求出任意一条路径的和为 sum，起点不一定是根节点，可以是任意节点开始。 注意这一题可能出现负数的情况，节点和为 sum，并不一定是最终情况，有可能下面还有正数节点和负数节点相加正好为 0，那么这也是一种情况。一定要遍历到底。 一个点是否为 sum 的起点，有 3 种情况，第一种情况路径包含该 root 节点，如果包含该结点，就在它的左子树和右子树中寻找和为 sum-root.Val 的情况。第二种情况路径不包含该 root 节点，那么就需要在它的左子树和右子树中分别寻找和为 sum 的结点。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSumIII(root *TreeNode, sum int) int { if root == nil { return 0 } res := findPath437(root, sum) res += pathSumIII(root.Left, sum) res += pathSumIII(root.Right, sum) return res } // 寻找包含 root 这个结点，且和为 sum 的路径 func findPath437(root *TreeNode, sum int) int { if root == nil { return 0 } res := 0 if root.Val == sum { res++ } res += findPath437(root.Left, sum-root.Val) res += findPath437(root.Right, sum-root.Val) return res } "});index.add({'id':244,'href':'/leetcode-java/04_Leetcode/0438.Find-All-Anagrams-in-a-String/','title':"0438. Find All Anagrams in a String",'section':"第四章",'content':"438. Find All Anagrams in a String #  题目 #  Given a string s and a non-empty string p, find all the start indices of p\u0026rsquo;s anagrams in s.\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\nThe order of output does not matter.\nExample 1:\n Input: s: \u0026quot;cbaebabacd\u0026quot; p: \u0026quot;abc\u0026quot; Output: [0, 6] Explanation: The substring with start index = 0 is \u0026quot;cba\u0026quot;, which is an anagram of \u0026quot;abc\u0026quot;. The substring with start index = 6 is \u0026quot;bac\u0026quot;, which is an anagram of \u0026quot;abc\u0026quot;. Example 2:\n Input: s: \u0026quot;abab\u0026quot; p: \u0026quot;ab\u0026quot; Output: [0, 1, 2] Explanation: The substring with start index = 0 is \u0026quot;ab\u0026quot;, which is an anagram of \u0026quot;ab\u0026quot;. The substring with start index = 1 is \u0026quot;ba\u0026quot;, which is an anagram of \u0026quot;ab\u0026quot;. The substring with start index = 2 is \u0026quot;ab\u0026quot;, which is an anagram of \u0026quot;ab\u0026quot;. 题目大意 #  给定一个字符串 s 和一个非空字符串 p，找出 s 中的所有是 p 的 Anagrams 字符串的子串，返回这些子串的起始索引。Anagrams 的意思是和一个字符串的所有字符都一样，只是排列组合不同。\n解题思路 #  这道题是一道考“滑动窗口”的题目。和第 3 题，第 76 题，第 567 题类似的。解法也是用 freq[256] 记录每个字符的出现的频次次数。滑动窗口左边界往右滑动的时候，划过去的元素释放次数(即次数 ++)，滑动窗口右边界往右滑动的时候，划过去的元素消耗次数(即次数 --)。右边界和左边界相差 len(p) 的时候，需要判断每个元素是否都用过一遍了。具体做法是每经过一个符合规范的元素，count 就 --，count 初始值是 len(p)，当每个元素都符合规范的时候，右边界和左边界相差 len(p) 的时候，count 也会等于 0 。当区间内有不符合规范的元素(freq \u0026lt; 0 或者是不存在的元素)，那么当区间达到 len(p) 的时候，count 无法减少到 0，区间右移动的时候，左边界又会开始 count ++，只有当左边界移出了这些不合规范的元素以后，才可能出现 count = 0 的情况，即找到 Anagrams 的情况。\n代码 #  package leetcode func findAnagrams(s string, p string) []int { var freq [256]int result := []int{} if len(s) == 0 || len(s) \u0026lt; len(p) { return result } for i := 0; i \u0026lt; len(p); i++ { freq[p[i]-\u0026#39;a\u0026#39;]++ } left, right, count := 0, 0, len(p) for right \u0026lt; len(s) { if freq[s[right]-\u0026#39;a\u0026#39;] \u0026gt;= 1 { count-- } freq[s[right]-\u0026#39;a\u0026#39;]-- right++ if count == 0 { result = append(result, left) } if right-left == len(p) { if freq[s[left]-\u0026#39;a\u0026#39;] \u0026gt;= 0 { count++ } freq[s[left]-\u0026#39;a\u0026#39;]++ left++ } } return result } "});index.add({'id':245,'href':'/leetcode-java/04_Leetcode/0441.Arranging-Coins/','title':"0441. Arranging Coins",'section':"第四章",'content':"441. Arranging Coins #  题目 #  You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\nGiven n, find the total number of full staircase rows that can be formed.\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\nExample 1:\nn = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.  Example 2:\nn = 8 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ Because the 4th row is incomplete, we return 3.  题目大意 #  你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。\n解题思路 #   n 个硬币，按照递增的方式排列搭楼梯，第一层一个，第二层二个，……第 n 层需要 n 个硬币。问硬币 n 能够搭建到第几层？ 这一题有 2 种解法，第一种解法就是解方程求出 X，(1+x)x/2 = n，即 x = floor(sqrt(2*n+1/4) - 1/2)，第二种解法是模拟。  代码 #  package leetcode import \u0026#34;math\u0026#34; // 解法一 数学公式 func arrangeCoins(n int) int { if n \u0026lt;= 0 { return 0 } x := math.Sqrt(2*float64(n)+0.25) - 0.5 return int(x) } // 解法二 模拟 func arrangeCoins1(n int) int { k := 1 for n \u0026gt;= k { n -= k k++ } return k - 1 } "});index.add({'id':246,'href':'/leetcode-java/04_Leetcode/0445.Add-Two-Numbers-II/','title':"0445. Add Two Numbers I I",'section':"第四章",'content':"445. Add Two Numbers II #  题目 #  You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\n Input: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7 题目大意 #  这道题是第 2 题的变种题，第 2 题中的 2 个数是从个位逆序排到高位，这样相加只用从头交到尾，进位一直进位即可。这道题目中强制要求不能把链表逆序。2 个数字是从高位排到低位的，这样进位是倒着来的。\n解题思路 #  思路也不难，加法只用把短的链表依次加到长的链表上面来就可以了，最终判断一下最高位有没有进位，有进位再往前进一位。加法的过程可以用到递归。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers445(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } l1Length := getLength(l1) l2Length := getLength(l2) newHeader := \u0026amp;ListNode{Val: 1, Next: nil} if l1Length \u0026lt; l2Length { newHeader.Next = addNode(l2, l1, l2Length-l1Length) } else { newHeader.Next = addNode(l1, l2, l1Length-l2Length) } if newHeader.Next.Val \u0026gt; 9 { newHeader.Next.Val = newHeader.Next.Val % 10 return newHeader } return newHeader.Next } func addNode(l1 *ListNode, l2 *ListNode, offset int) *ListNode { if l1 == nil { return nil } var ( res, node *ListNode ) if offset == 0 { res = \u0026amp;ListNode{Val: l1.Val + l2.Val, Next: nil} node = addNode(l1.Next, l2.Next, 0) } else { res = \u0026amp;ListNode{Val: l1.Val, Next: nil} node = addNode(l1.Next, l2, offset-1) } if node != nil \u0026amp;\u0026amp; node.Val \u0026gt; 9 { res.Val++ node.Val = node.Val % 10 } res.Next = node return res } func getLength(l *ListNode) int { count := 0 cur := l for cur != nil { count++ cur = cur.Next } return count } "});index.add({'id':247,'href':'/leetcode-java/04_Leetcode/0447.Number-of-Boomerangs/','title':"0447. Number of Boomerangs",'section':"第四章",'content':"447. Number of Boomerangs #  题目 #  Given n points in the plane that are all pairwise distinct, a \u0026ldquo;boomerang\u0026rdquo; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\nFind the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).\nExample 1:\n Input: [[0,0],[1,0],[2,0]] Output: 2 Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 题目大意 #  在一个 Point 的数组中求出 (i,j,k) 三元组，要求 j 和 i 的距离等于 k 和 i 的距离。这样的三元组有多少种？注意 (i,j,k) 和 (j,i,k) 是不同的解，即元素的顺序是有关系的。\n解题思路 #  这道题考察的是哈希表的问题。\n首先依次求出两两点之间的距离，然后把这些距离记录在 map 中，key 是距离，value 是这个距离出现了多少次。求距离一般都需要开根号，但是 key 如果为浮点数就会有一些误差，所以计算距离的时候最后一步不需要开根号，保留平方差即可。\n最后求结果的时候，遍历 map，把里面距离大于 2 的 key 都拿出来，value 对应的是个数，在这些个数里面任取 2 个点就是解，所以利用排列组合，C n 2 就可以得到这个距离的结果，最后把这些排列组合的结果累积起来即可。\n代码 #  package leetcode func numberOfBoomerangs(points [][]int) int { res := 0 for i := 0; i \u0026lt; len(points); i++ { record := make(map[int]int, len(points)) for j := 0; j \u0026lt; len(points); j++ { if j != i { record[dis(points[i], points[j])]++ } } for _, r := range record { res += r * (r - 1) } } return res } func dis(pa, pb []int) int { return (pa[0]-pb[0])*(pa[0]-pb[0]) + (pa[1]-pb[1])*(pa[1]-pb[1]) } "});index.add({'id':248,'href':'/leetcode-java/04_Leetcode/0448.Find-All-Numbers-Disappeared-in-an-Array/','title':"0448. Find All Numbers Disappeared in an Array",'section':"第四章",'content':"448. Find All Numbers Disappeared in an Array #  题目 #  Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nExample:\nInput: [4,3,2,7,8,2,3,1] Output: [5,6] 题目大意 #  给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。你能在不使用额外空间且时间复杂度为 O(n) 的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n解题思路 #   找出 [1,n] 范围内没有出现在数组中的数字。要求不使用额外空间，并且时间复杂度为 O(n)。 要求不能使用额外的空间，那么只能想办法在原有数组上进行修改，并且这个修改是可还原的。时间复杂度也只能允许我们一层循环。只要循环一次能标记出已经出现过的数字，这道题就可以按要求解答出来。这里笔者的标记方法是把 |nums[i]|-1 索引位置的元素标记为负数。即 nums[| nums[i] |- 1] * -1。这里需要注意的是，nums[i] 需要加绝对值，因为它可能被之前的数置为负数了，需要还原一下。最后再遍历一次数组，若当前数组元素 nums[i] 为负数，说明我们在数组中存在数字 i+1。把结果输出到最终数组里即可。  代码 #  package leetcode func findDisappearedNumbers(nums []int) []int { res := []int{} for _, v := range nums { if v \u0026lt; 0 { v = -v } if nums[v-1] \u0026gt; 0 { nums[v-1] = -nums[v-1] } } for i, v := range nums { if v \u0026gt; 0 { res = append(res, i+1) } } return res } "});index.add({'id':249,'href':'/leetcode-java/04_Leetcode/0451.Sort-Characters-By-Frequency/','title':"0451. Sort Characters by Frequency",'section':"第四章",'content':"451. Sort Characters By Frequency #  题目 #  Given a string, sort it in decreasing order based on the frequency of characters.\nExample 1:\n Input: \u0026quot;tree\u0026quot; Output: \u0026quot;eert\u0026quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \u0026quot;eetr\u0026quot; is also a valid answer. Example 2:\n Input: \u0026quot;cccaaa\u0026quot; Output: \u0026quot;cccaaa\u0026quot; Explanation: Both 'c' and 'a' appear three times, so \u0026quot;aaaccc\u0026quot; is also a valid answer. Note that \u0026quot;cacaca\u0026quot; is incorrect, as the same characters must be together. Example 3:\n Input: \u0026quot;Aabb\u0026quot; Output: \u0026quot;bbAa\u0026quot; Explanation: \u0026quot;bbaA\u0026quot; is also a valid answer, but \u0026quot;Aabb\u0026quot; is incorrect. Note that 'A' and 'a' are treated as two different characters. 题目大意 #  这道题是 Google 的面试题。\n给定一个字符串，要求根据字符出现的频次从高到低重新排列这个字符串。\n解题思路 #  思路比较简单，首先统计每个字符的频次，然后排序，最后按照频次从高到低进行输出即可。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func frequencySort(s string) string { if s == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } sMap := map[byte]int{} cMap := map[int][]byte{} sb := []byte(s) for _, b := range sb { sMap[b]++ } for key, value := range sMap { cMap[value] = append(cMap[value], key) } var keys []int for k := range cMap { keys = append(keys, k) } sort.Sort(sort.Reverse(sort.IntSlice(keys))) res := make([]byte, 0) for _, k := range keys { for i := 0; i \u0026lt; len(cMap[k]); i++ { for j := 0; j \u0026lt; k; j++ { res = append(res, cMap[k][i]) } } } return string(res) } "});index.add({'id':250,'href':'/leetcode-java/04_Leetcode/0453.Minimum-Moves-to-Equal-Array-Elements/','title':"0453. Minimum Moves to Equal Array Elements",'section':"第四章",'content':"453. Minimum Moves to Equal Array Elements #  题目 #  Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\nExample:\nInput: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =\u0026gt; [2,3,3] =\u0026gt; [3,4,3] =\u0026gt; [4,4,4] 题目大意 #  给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。\n解题思路 #   给定一个数组，要求输出让所有元素都相等的最小步数。每移动一步都会使得 n - 1 个元素 + 1 。 数学题。这道题正着思考会考虑到排序或者暴力的方法上去。反过来思考一下，使得每个元素都相同，意思让所有元素的差异变为 0 。每次移动的过程中，都有 n - 1 个元素 + 1，那么没有 + 1 的那个元素和其他 n - 1 个元素相对差异就缩小了。所以这道题让所有元素都变为相等的最少步数，即等于让所有元素相对差异减少到最小的那个数。想到这里，此题就可以优雅的解出来了。  代码 #  package leetcode import \u0026#34;math\u0026#34; func minMoves(nums []int) int { sum, min, l := 0, math.MaxInt32, len(nums) for _, v := range nums { sum += v if min \u0026gt; v { min = v } } return sum - min*l } "});index.add({'id':251,'href':'/leetcode-java/04_Leetcode/0454.4Sum-II/','title':"0454.4 Sum I I",'section':"第四章",'content':"454. 4Sum II #  题目 #  Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\nExample 1:\n Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -\u0026gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -\u0026gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 3. 题目大意 #  给出 4 个数组，计算这些数组中存在几对 i，j，k，l 可以使得 A[i] + B[j] + C[k] + D[l] = 0 。\n解题思路 #  这道题的数据量不大，0 ≤ N ≤ 500，但是如果使用暴力解法，四层循环，会超时。这道题的思路和第 1 题思路也类似，先可以将 2 个数组中的组合都存入 map 中。之后将剩下的 2 个数组进行 for 循环，找出和为 0 的组合。这样时间复杂度是 O(n^2)。当然也可以讲剩下的 2 个数组的组合也存入 map 中，不过最后在 2 个 map 中查找结果也是 O(n^2) 的时间复杂度。\n代码 #  package leetcode func fourSumCount(A []int, B []int, C []int, D []int) int { m := make(map[int]int, len(A)*len(B)) for _, a := range A { for _, b := range B { m[a+b]++ } } ret := 0 for _, c := range C { for _, d := range D { ret += m[0-c-d] } } return ret } "});index.add({'id':252,'href':'/leetcode-java/04_Leetcode/0455.Assign-Cookies/','title':"0455. Assign Cookies",'section':"第四章",'content':"455. Assign Cookies #  题目 #  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj \u0026gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nNote:You may assume the greed factor is always positive. You cannot assign more than one cookie to one child.\nExample 1:\nInput: [1,2,3], [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.  Example 2:\nInput: [1,2], [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2.  题目大意 #  假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj \u0026gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。\n解题思路 #   假设你想给小朋友们饼干，每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，称为 g[i]，g[i] 表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小值 s[i]，如果 s[j] ≥ g[i]，我们将饼干 j 分给小朋友 i 后，小朋友会很开心。给定数组 g[] 和 s[]，问如何分配饼干，能让更多的小朋友开心。 这是一道典型的简单贪心题。贪心题一般都伴随着排序。将 g[] 和 s[] 分别排序。按照最难满足的小朋友开始给饼干，依次往下满足，最终能满足的小朋友数就是最终解。  代码 #  package leetcode import \u0026#34;sort\u0026#34; func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) gi, si, res := 0, 0, 0 for gi \u0026lt; len(g) \u0026amp;\u0026amp; si \u0026lt; len(s) { if s[si] \u0026gt;= g[gi] { res++ si++ gi++ } else { si++ } } return res } "});index.add({'id':253,'href':'/leetcode-java/04_Leetcode/0456.132-Pattern/','title':"0456.132 Pattern",'section':"第四章",'content':"456. 132 Pattern #  题目 #  Given a sequence of n integers a1, a2, \u0026hellip;, an, a 132 pattern is a subsequence ai, aj, ak such that i \u0026lt; j \u0026lt; k and ai \u0026lt; ak \u0026lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\nNote: n will be less than 15,000.\nExample 1:\nInput: [1, 2, 3, 4] Output: False Explanation: There is no 132 pattern in the sequence.  Example 2:\nInput: [3, 1, 4, 2] Output: True Explanation: There is a 132 pattern in the sequence: [1, 4, 2].  Example 3:\nInput: [-1, 3, 2, 0] Output: True Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].  题目大意 #  给定一个整数序列：a1, a2, \u0026hellip;, an，一个 132 模式的子序列 ai, aj, ak 被定义为：当 i \u0026lt; j \u0026lt; k 时，ai \u0026lt; ak \u0026lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有 132 模式的子序列。注意：n 的值小于 15000。\n解题思路 #   这一题用暴力解法一定超时 这一题算是单调栈的经典解法，可以考虑从数组末尾开始往前扫，维护一个递减序列  代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) // 解法一 单调栈 func find132pattern(nums []int) bool { if len(nums) \u0026lt; 3 { return false } num3, stack := math.MinInt64, []int{} for i := len(nums) - 1; i \u0026gt;= 0; i-- { if nums[i] \u0026lt; num3 { return true } for len(stack) != 0 \u0026amp;\u0026amp; nums[i] \u0026gt; stack[len(stack)-1] { num3 = stack[len(stack)-1] stack = stack[:len(stack)-1] } stack = append(stack, nums[i]) fmt.Printf(\u0026#34;stack = %v \\n\u0026#34;, stack) } return false } // 解法二 暴力解法，超时！ func find132pattern1(nums []int) bool { if len(nums) \u0026lt; 3 { return false } for j := 0; j \u0026lt; len(nums); j++ { stack := []int{} for i := j; i \u0026lt; len(nums); i++ { if len(stack) == 0 || (len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[stack[len(stack)-1]]) { stack = append(stack, i) } else if nums[i] \u0026lt; nums[stack[len(stack)-1]] { index := len(stack) - 1 for ; index \u0026gt;= 0; index-- { if nums[stack[index]] \u0026lt; nums[i] { return true } } } } } return false } "});index.add({'id':254,'href':'/leetcode-java/04_Leetcode/0457.Circular-Array-Loop/','title':"0457. Circular Array Loop",'section':"第四章",'content':"457. Circular Array Loop #  题目 #  You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it\u0026rsquo;s negative (-k), move backward k steps. Since the array is circular, you may assume that the last element\u0026rsquo;s next element is the first element, and the first element\u0026rsquo;s previous element is the last element.\nDetermine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle\u0026rsquo;s length \u0026gt; 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.\nExample 1:\nInput: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 0. The cycle's length is 3.  Example 2:\nInput: [-1,2] Output: false Explanation: The movement from index 1 -\u0026gt; 1 -\u0026gt; 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.  Example 3:\nInput: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; ... is not a cycle, because movement from index 1 -\u0026gt; 2 is a forward movement, but movement from index 2 -\u0026gt; 1 is a backward movement. All movements in a cycle must follow a single direction.  Note:\n -1000 ≤ nums[i] ≤ 1000 nums[i] ≠ 0 1 ≤ nums.length ≤ 5000  Follow up:\nCould you solve it in O(n) time complexity and O(1) extra space complexity?\n题目大意 #  给定一个含有正整数和负整数的环形数组 nums。 如果某个索引中的数 k 为正数，则向前移动 k 个索引。相反，如果是负数 (-k)，则向后移动 k 个索引。因为数组是环形的，所以可以假设最后一个元素的下一个元素是第一个元素，而第一个元素的前一个元素是最后一个元素。\n确定 nums 中是否存在循环（或周期）。循环必须在相同的索引处开始和结束并且循环长度 \u0026gt; 1。此外，一个循环中的所有运动都必须沿着同一方向进行。换句话说，一个循环中不能同时包括向前的运动和向后的运动。\n提示：\n -1000 ≤ nums[i] ≤ 1000 nums[i] ≠ 0 1 ≤ nums.length ≤ 5000  进阶：\n 你能写出时间时间复杂度为 O(n) 和额外空间复杂度为 O(1) 的算法吗？  解题思路 #   给出一个循环数组，数组的数字代表了前进和后退的步数，+ 代表往右(前进)，- 代表往左(后退)。问这个循环数组中是否存在一个循环，并且这个循环内不能只有一个元素，循环的方向都必须是同方向的。 遇到循环就可以优先考虑用快慢指针的方法判断循环，这一题对循环增加了一个条件，循环不能只是单元素的循环，所以在快慢指针中加入这个判断条件。还有一个判断条件是循环的方向必须是同向的，这个简单，用 num[i] * num[j] \u0026gt; 0 就可以判断出是同向的(如果是反向的，那么两者的乘积必然是负数)，如果没有找到循环，可以将当前已经走过的路径上的 num[] 值都置为 0，标记已经访问过了。下次循环遇到访问过的元素，num[i] * num[j] \u0026gt; 0 就会是 0，提前退出找循环的过程。  代码 #  package leetcode func circularArrayLoop(nums []int) bool { if len(nums) == 0 { return false } for i := 0; i \u0026lt; len(nums); i++ { if nums[i] == 0 { continue } // slow/fast pointer \tslow, fast, val := i, getNextIndex(nums, i), 0 for nums[fast]*nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[getNextIndex(nums, fast)]*nums[i] \u0026gt; 0 { if slow == fast { // check for loop with only one element \tif slow == getNextIndex(nums, slow) { break } return true } slow = getNextIndex(nums, slow) fast = getNextIndex(nums, getNextIndex(nums, fast)) } // loop not found, set all element along the way to 0 \tslow, val = i, nums[i] for nums[slow]*val \u0026gt; 0 { next := getNextIndex(nums, slow) nums[slow] = 0 slow = next } } return false } func getNextIndex(nums []int, index int) int { return ((nums[index]+index)%len(nums) + len(nums)) % len(nums) } "});index.add({'id':255,'href':'/leetcode-java/04_Leetcode/0461.Hamming-Distance/','title':"0461. Hamming Distance",'section':"第四章",'content':"461. Hamming Distance #  题目 #  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, calculate the Hamming distance.\nNote: 0 ≤ x, y \u0026lt; 231.\nExample:\nInput: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.  题目大意 #  两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。\n注意： 0 ≤ x, y \u0026lt; 231.\n解题思路 #   求 2 个数的海明距离。海明距离的定义是两个数二进制位不同的总个数。这一题利用的位操作的是 X \u0026amp;= (X - 1) 不断的清除最低位的 1 。先将这两个数异或，异或以后清除低位的 1 就是最终答案。  代码 #  package leetcode func hammingDistance(x int, y int) int { distance := 0 for xor := x ^ y; xor != 0; xor \u0026amp;= (xor - 1) { distance++ } return distance } "});index.add({'id':256,'href':'/leetcode-java/04_Leetcode/0463.Island-Perimeter/','title':"0463. Island Perimeter",'section':"第四章",'content':"463. Island Perimeter #  题目 #  You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo; (water inside that isn\u0026rsquo;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample:\nInput: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Output: 16 Explanation: The perimeter is the 16 yellow stripes in the image below:   题目大意 #  给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n解题思路 #   给出一个二维数组，二维数组中有一些连在一起的 1 ，这是一个岛屿，求这个岛屿的周长。 这是一道水题，判断四周边界的情况依次加一即可。  代码 #  package leetcode func islandPerimeter(grid [][]int) int { counter := 0 for i := 0; i \u0026lt; len(grid); i++ { for j := 0; j \u0026lt; len(grid[0]); j++ { if grid[i][j] == 1 { if i-1 \u0026lt; 0 || grid[i-1][j] == 0 { counter++ } if i+1 \u0026gt;= len(grid) || grid[i+1][j] == 0 { counter++ } if j-1 \u0026lt; 0 || grid[i][j-1] == 0 { counter++ } if j+1 \u0026gt;= len(grid[0]) || grid[i][j+1] == 0 { counter++ } } } } return counter } "});index.add({'id':257,'href':'/leetcode-java/04_Leetcode/0470.Implement-Rand10-Using-Rand7/','title':"0470. Implement Rand10 Using Rand7",'section':"第四章",'content':"470. Implement Rand10() Using Rand7() #  题目 #  Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.\nDo NOT use system\u0026rsquo;s Math.random().\nExample 1:\nInput: 1 Output: [7]  Example 2:\nInput: 2 Output: [8,4]  Example 3:\nInput: 3 Output: [8,1,10]  Note:\n rand7 is predefined. Each testcase has one argument: n, the number of times that rand10 is called.  Follow up:\n What is the expected value for the number of calls to rand7() function? Could you minimize the number of calls to rand7()?  题目大意 #  已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。不要使用系统的 Math.random() 方法。\n提示:\n rand7 已定义。 传入参数: n 表示 rand10 的调用次数。  进阶:\n rand7()调用次数的 期望值 是多少 ? 你能否尽量少调用 rand7() ?  解题思路 #   给出 rand7() 要求实现 rand10()。 rand7() 等概率地产生1，2，3，4，5，6，7。要想得到 rand10() 即等概率的生成 1-10 。解题思路是先构造一个 randN()，这个 N 必须是 10 的整数倍，然后 randN % 10 就可以得到 rand10() 了。所以可以从 rand7() 先构造出 rand49()，再把 rand49() 中大于等于 40 的都过滤掉，这样就得到了 rand40()，在对 10 取余即可。 具体构造步骤，rand7() --\u0026gt; rand49() --\u0026gt; rand40() --\u0026gt; rand10()：  rand7() 等概率地产生 1,2,3,4,5,6,7. rand7() - 1 等概率地产生 [0,6]. (rand7() - 1) *7 等概率地产生 0, 7, 14, 21, 28, 35, 42 (rand7() - 1) * 7 + (rand7() - 1) 等概率地产生 [0, 48] 这 49 个数字 如果步骤 4 的结果大于等于 40，那么就重复步骤 4，直到产生的数小于 40 把步骤 5 的结果 mod 10 再加 1， 就会等概率的随机生成 [1, 10]   这道题可以推广到生成任意数的随机数问题。用 randN() 实现 randM()，M\u0026gt;N。步骤如下：  用 randN() 先实现 randX()，其中 X ≥ M，X 是 M 的整数倍。如这题中的 49 \u0026gt; 10； 再用 randX() 生成 randM()，如这题中的 49 —\u0026gt; 40 —\u0026gt; 10。   举个例子，用 rand3() 生成 rand11()，可以先生成 rand27()，然后变成以 22 为界限，因为 22 是 11 的倍数。生成 rand27() 的方式：3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1)，最后生成了 rand11()；用 rand7() 生成 rand9()，可以先生成 rand49()，然后变成以 45 为界限，因为 45 是 9 的倍数。生成 rand49() 的方式：(rand7() - 1) * 7 + (rand7() - 1)，最后生成了 rand9()；用 rand6() 生成 rand13()，可以先生成 rand36()，然后变成以 26 为界限，因为 26 是 13 的倍数。生成 rand36() 的方式：(rand6() - 1) * 6 + (rand6() - 1)，最后生成了 rand13()；  代码 #  package leetcode import \u0026#34;math/rand\u0026#34; func rand10() int { rand10 := 10 for rand10 \u0026gt;= 10 { rand10 = (rand7() - 1) + rand7() } return rand10%10 + 1 } func rand7() int { return rand.Intn(7) } func rand101() int { rand40 := 40 for rand40 \u0026gt;= 40 { rand40 = (rand7()-1)*7 + rand7() - 1 } return rand40%10 + 1 } "});index.add({'id':258,'href':'/leetcode-java/04_Leetcode/0474.Ones-and-Zeroes/','title':"0474. Ones and Zeroes",'section':"第四章",'content':"474. Ones and Zeroes #  题目 #  In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\nFor now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\nNow your task is to find the maximum number of strings that you can form with given m0s and n 1s. Each 0 and 1 can be used at most once.\nNote:\n The given numbers of 0s and 1s will both not exceed 100 The size of given string array won\u0026rsquo;t exceed 600.  Example 1:\nInput: Array = {\u0026quot;10\u0026quot;, \u0026quot;0001\u0026quot;, \u0026quot;111001\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;0\u0026quot;}, m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”  Example 2:\nInput: Array = {\u0026quot;10\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;}, m = 1, n = 1 Output: 2 Explanation: You could form \u0026quot;10\u0026quot;, but then you'd have nothing left. Better form \u0026quot;0\u0026quot; and \u0026quot;1\u0026quot;.  题目大意 #  在计算机界中，我们总是追求用有限的资源获取最大的收益。现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。\n注意:\n 给定 0 和 1 的数量都不会超过 100。 给定字符串数组的长度不会超过 600。  解题思路 #   给定一个字符串数组和 m，n，其中所有的字符都是由 0 和 1 组成的。问能否从数组中取出最多的字符串，使得这些取出的字符串中所有的 0 的个数 ≤ m，1 的个数 ≤ n。 这一题是典型的 01 背包的题型。只不过是一个二维的背包问题。在 n 个物品中选出一定物品，尽量完全填满 m 维和 n 维的背包。为什么是尽量填满？因为不一定能完全填满背包。 dp[i][j] 代表尽量填满容量为 (i,j) 的背包装下的物品总数，状态转移方程为 dp[i][j] = max(dp[i][j], 1+dp[i-zero][j-one])。其中 zero 代表的当前装入物品在 m 维上的体积，也即 0 的个数。one 代表的是当前装入物品在 n 维上的体积，也即 1 的个数。每添加一个物品，比较当前 (i,j) 的背包装下的物品总数和 (i-zero,j-one) 的背包装下的物品总数 + 1，比较这两者的大小，保存两者的最大值。每添加一个物品就刷新这个二维背包，直到所有物品都扫完一遍。dp[m][n] 中存储的就是最终的答案。时间复杂度 O( n * M * N )。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func findMaxForm(strs []string, m int, n int) int { dp := make([][]int, m+1) for i := 0; i \u0026lt; m+1; i++ { dp[i] = make([]int, n+1) } for _, s := range strs { zero := strings.Count(s, \u0026#34;0\u0026#34;) one := len(s) - zero if zero \u0026gt; m || one \u0026gt; n { continue } for i := m; i \u0026gt;= zero; i-- { for j := n; j \u0026gt;= one; j-- { dp[i][j] = max(dp[i][j], 1+dp[i-zero][j-one]) } } } return dp[m][n] } "});index.add({'id':259,'href':'/leetcode-java/04_Leetcode/0475.Heaters/','title':"0475. Heaters",'section':"第四章",'content':"475. Heaters #  题目 #  Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.\nNow, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\nSo, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\nNote:\n Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.  Example 1:\nInput: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.  Example 2:\nInput: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.  题目大意 #  冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。\n说明:\n 给出的房屋和供暖器的数目是非负数且不会超过 25000。 给出的房屋和供暖器的位置均是非负数且不会超过10^9。 只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。 所有供暖器都遵循你的半径标准，加热的半径也一样。  解题思路 #   给出一个房子坐标的数组，和一些供暖器坐标的数组，分别表示房子的坐标和供暖器的坐标。要求找到供暖器最小的半径能使得所有的房子都能享受到暖气。 这一题可以用暴力的解法，暴力解法依次遍历每个房子的坐标，再遍历每个供暖器，找到距离房子最近的供暖器坐标。在所有这些距离的长度里面找到最大值，这个距离的最大值就是供暖器半径的最小值。时间复杂度 O(n^2)。 这一题最优解是二分搜索。在查找距离房子最近的供暖器的时候，先将供暖器排序，然后用二分搜索的方法查找。其他的做法和暴力解法一致。时间复杂度 O(n log n)。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) func findRadius(houses []int, heaters []int) int { minRad := 0 sort.Ints(heaters) for _, house := range houses { // 遍历房子的坐标，维护 heaters 的最小半径 \theater := findClosestHeater(house, heaters) rad := heater - house if rad \u0026lt; 0 { rad = -rad } if rad \u0026gt; minRad { minRad = rad } } return minRad } // 二分搜索 func findClosestHeater(pos int, heaters []int) int { low, high := 0, len(heaters)-1 if pos \u0026lt; heaters[low] { return heaters[low] } if pos \u0026gt; heaters[high] { return heaters[high] } for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if pos == heaters[mid] { return heaters[mid] } else if pos \u0026lt; heaters[mid] { high = mid - 1 } else { low = mid + 1 } } // 判断距离两边的 heaters 哪个更近 \tif pos-heaters[high] \u0026lt; heaters[low]-pos { return heaters[high] } return heaters[low] } // 解法二 暴力搜索 func findRadius1(houses []int, heaters []int) int { res := 0 for i := 0; i \u0026lt; len(houses); i++ { dis := math.MaxInt64 for j := 0; j \u0026lt; len(heaters); j++ { dis = min(dis, abs(houses[i]-heaters[j])) } res = max(res, dis) } return res } "});index.add({'id':260,'href':'/leetcode-java/04_Leetcode/0476.Number-Complement/','title':"0476. Number Complement",'section':"第四章",'content':"476. Number Complement #  题目 #  Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\nNote:\n The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.  Example 1:\nInput: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.  Example 2:\nInput: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.  题目大意 #  给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。\n注意:\n给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。\n解题思路 #   求一个正数的补数，补数的定义是对该数的二进制表示取反。当前不能改变符号位。按照题意构造相应的 mask 再取反即可。  代码 #  package leetcode // 解法一 func findComplement(num int) int { xx := ^0 // ^0 = 1111111111111111111111 \tfor xx\u0026amp;num \u0026gt; 0 { xx \u0026lt;\u0026lt;= 1 // 构造出来的 xx = 1111111…000000，0 的个数就是 num 的长度 \t} return ^xx ^ num // xx ^ num，结果是前面的 0 全是 1 的num，再取反即是答案 } // 解法二 func findComplement1(num int) int { temp := 1 for temp \u0026lt;= num { temp \u0026lt;\u0026lt;= 1 // 构造出来的 temp = 00000……10000，末尾 0 的个数是 num 的长度 \t} return (temp - 1) ^ num // temp - 1 即是前面都是 0，num 长度的末尾都是 1 的数，再异或 num 即是最终结果 } "});index.add({'id':261,'href':'/leetcode-java/04_Leetcode/0477.Total-Hamming-Distance/','title':"0477. Total Hamming Distance",'section':"第四章",'content':"477. Total Hamming Distance #  题目 #  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nNow your job is to find the total Hamming distance between all pairs of the given numbers.\nExample:\nInput: 4, 14, 2 Output: 6 Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.  Note:\n Elements of the given array are in the range of 0 to 10^9 Length of the array will not exceed 10^4.  题目大意 #  两个整数的 汉明距离指的是这两个数字的二进制数对应位不同的数量。计算一个数组中，任意两个数之间汉明距离的总和。\n解题思路 #   计算一个数组内两两元素的海明距离总和。海明距离的定义是两个数二进制位不同的总个数。那么可以把数组中的每个元素 32 位的二进制位依次扫一遍，当扫到某一位上的时候，有 k 个元素在这个位上的值是 1，n - k 个元素在这个位上的值是 0，那么在这一位上所有两两元素的海明距离是 k*(n-k) ，当把 32 位全部都扫完以后，累加出来的海明距离就是所有两两元素的海明距离。  代码 #  package leetcode func totalHammingDistance(nums []int) int { total, n := 0, len(nums) for i := 0; i \u0026lt; 32; i++ { bitCount := 0 for j := 0; j \u0026lt; n; j++ { bitCount += (nums[j] \u0026gt;\u0026gt; uint(i)) \u0026amp; 1 } total += bitCount * (n - bitCount) } return total } // 暴力解法超时！ func totalHammingDistance1(nums []int) int { res := 0 for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { res += hammingDistance(nums[i], nums[j]) } } return res } "});index.add({'id':262,'href':'/leetcode-java/04_Leetcode/0480.Sliding-Window-Median/','title':"0480. Sliding Window Median",'section':"第四章",'content':"480. Sliding Window Median #  题目 #  Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nExamples:\n[2,3,4] , the median is 3\n[2,3], the median is (2 + 3) / 2 = 2.5\nGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\nWindow position Median --------------- ----- [1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6  Therefore, return the median sliding window as [1,-1,-1,3,5,6].\nNote: You may assume k is always valid, ie: k is always smaller than input array\u0026rsquo;s size for non-empty array.\n题目大意 #  中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。\n例如：\n[2,3,4]，中位数是 3\n[2,3]，中位数是 (2 + 3) / 2 = 2.5\n给出一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。\n解题思路 #   给定一个数组和一个窗口为 K 的窗口，当窗口从数组的左边滑动到数组右边的时候，输出每次移动窗口以后，在窗口内的排序之后中间大小的值。 这一题是第 239 题的升级版。 这道题最暴力的方法就是将窗口内的元素都排序，时间复杂度 O(n * K)。 另一种思路是用两个优先队列，大顶堆里面的元素都比小顶堆里面的元素小。小顶堆里面存储排序以后中间靠后的值大的元素，大顶堆里面存储排序以后中间靠前的值小的元素。如果 k 是偶数，那么两个堆都有 k/2 个元素，中间值就是两个堆顶的元素；如果 k 是奇数，那么小顶堆比大顶堆多一个元素，中间值就是小顶堆的堆顶元素。删除一个元素，元素都标记到删除的堆中，取 top 的时候注意需要取出没有删除的元素。时间复杂度 O(n * log k) 空间复杂度 O(k)  代码 #  package leetcode import ( \u0026#34;container/heap\u0026#34; \u0026#34;container/list\u0026#34; \u0026#34;sort\u0026#34; ) // 解法一 用链表按照题意实现 时间复杂度 O(n * k) 空间复杂度 O(k) func medianSlidingWindow(nums []int, k int) []float64 { var res []float64 w := getWindowList(nums[:k], k) res = append(res, getMedian(w, k)) for p1 := k; p1 \u0026lt; len(nums); p1++ { w = removeFromWindow(w, nums[p1-k]) w = insertInWindow(w, nums[p1]) res = append(res, getMedian(w, k)) } return res } func getWindowList(nums []int, k int) *list.List { s := make([]int, k) copy(s, nums) sort.Ints(s) l := list.New() for _, n := range s { l.PushBack(n) } return l } func removeFromWindow(w *list.List, n int) *list.List { for e := w.Front(); e != nil; e = e.Next() { if e.Value.(int) == n { w.Remove(e) return w } } return w } func insertInWindow(w *list.List, n int) *list.List { for e := w.Front(); e != nil; e = e.Next() { if e.Value.(int) \u0026gt;= n { w.InsertBefore(n, e) return w } } w.PushBack(n) return w } func getMedian(w *list.List, k int) float64 { e := w.Front() for i := 0; i \u0026lt; k/2; e, i = e.Next(), i+1 { } if k%2 == 1 { return float64(e.Value.(int)) } p := e.Prev() return (float64(e.Value.(int)) + float64(p.Value.(int))) / 2 } // 解法二 用两个堆实现 时间复杂度 O(n * log k) 空间复杂度 O(k) // 用两个堆记录窗口内的值 // 大顶堆里面的元素都比小顶堆里面的元素小 // 如果 k 是偶数，那么两个堆都有 k/2 个元素，中间值就是两个堆顶的元素 // 如果 k 是奇数，那么小顶堆比大顶堆多一个元素，中间值就是小顶堆的堆顶元素 // 删除一个元素，元素都标记到删除的堆中，取 top 的时候注意需要取出没有删除的元素 func medianSlidingWindow1(nums []int, k int) []float64 { ans := []float64{} minH := MinHeapR{} maxH := MaxHeapR{} if minH.Len() \u0026gt; maxH.Len()+1 { maxH.Push(minH.Pop()) } else if minH.Len() \u0026lt; maxH.Len() { minH.Push(maxH.Pop()) } for i := range nums { if minH.Len() == 0 || nums[i] \u0026gt;= minH.Top() { minH.Push(nums[i]) } else { maxH.Push(nums[i]) } if i \u0026gt;= k { if nums[i-k] \u0026gt;= minH.Top() { minH.Remove(nums[i-k]) } else { maxH.Remove(nums[i-k]) } } if minH.Len() \u0026gt; maxH.Len()+1 { maxH.Push(minH.Pop()) } else if minH.Len() \u0026lt; maxH.Len() { minH.Push(maxH.Pop()) } if minH.Len()+maxH.Len() == k { if k%2 == 0 { ans = append(ans, float64(minH.Top()+maxH.Top())/2.0) } else { ans = append(ans, float64(minH.Top())) } } // fmt.Printf(\u0026#34;%+v, %+v\\n\u0026#34;, minH, maxH) \t} return ans } // IntHeap define type IntHeap struct { data []int } // Len define func (h IntHeap) Len() int { return len(h.data) } // Swap define func (h IntHeap) Swap(i, j int) { h.data[i], h.data[j] = h.data[j], h.data[i] } // Push define func (h *IntHeap) Push(x interface{}) { h.data = append(h.data, x.(int)) } // Pop define func (h *IntHeap) Pop() interface{} { x := h.data[h.Len()-1] h.data = h.data[0 : h.Len()-1] return x } // Top defines func (h IntHeap) Top() int { return h.data[0] } // MinHeap define type MinHeap struct { IntHeap } // Less define func (h MinHeap) Less(i, j int) bool { return h.data[i] \u0026lt; h.data[j] } // MaxHeap define type MaxHeap struct { IntHeap } // Less define func (h MaxHeap) Less(i, j int) bool { return h.data[i] \u0026gt; h.data[j] } // MinHeapR define type MinHeapR struct { hp, hpDel MinHeap } // Len define func (h MinHeapR) Len() int { return h.hp.Len() - h.hpDel.Len() } // Top define func (h *MinHeapR) Top() int { for h.hpDel.Len() \u0026gt; 0 \u0026amp;\u0026amp; h.hp.Top() == h.hpDel.Top() { heap.Pop(\u0026amp;h.hp) heap.Pop(\u0026amp;h.hpDel) } return h.hp.Top() } // Pop define func (h *MinHeapR) Pop() int { x := h.Top() heap.Pop(\u0026amp;h.hp) return x } // Push define func (h *MinHeapR) Push(x int) { heap.Push(\u0026amp;h.hp, x) } // Remove define func (h *MinHeapR) Remove(x int) { heap.Push(\u0026amp;h.hpDel, x) } // MaxHeapR define type MaxHeapR struct { hp, hpDel MaxHeap } // Len define func (h MaxHeapR) Len() int { return h.hp.Len() - h.hpDel.Len() } // Top define func (h *MaxHeapR) Top() int { for h.hpDel.Len() \u0026gt; 0 \u0026amp;\u0026amp; h.hp.Top() == h.hpDel.Top() { heap.Pop(\u0026amp;h.hp) heap.Pop(\u0026amp;h.hpDel) } return h.hp.Top() } // Pop define func (h *MaxHeapR) Pop() int { x := h.Top() heap.Pop(\u0026amp;h.hp) return x } // Push define func (h *MaxHeapR) Push(x int) { heap.Push(\u0026amp;h.hp, x) } // Remove define func (h *MaxHeapR) Remove(x int) { heap.Push(\u0026amp;h.hpDel, x) } "});index.add({'id':263,'href':'/leetcode-java/04_Leetcode/0483.Smallest-Good-Base/','title':"0483. Smallest Good Base",'section':"第四章",'content':"483. Smallest Good Base #  题目 #  For an integer n, we call k\u0026gt;=2 a good base of n, if all digits of n base k are 1.\nNow given a string representing n, you should return the smallest good base of n in string format.\nExample 1:\nInput: \u0026quot;13\u0026quot; Output: \u0026quot;3\u0026quot; Explanation: 13 base 3 is 111.  Example 2:\nInput: \u0026quot;4681\u0026quot; Output: \u0026quot;8\u0026quot; Explanation: 4681 base 8 is 11111.  Example 3:\nInput: \u0026quot;1000000000000000000\u0026quot; Output: \u0026quot;999999999999999999\u0026quot; Explanation: 1000000000000000000 base 999999999999999999 is 11.  Note:\n The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.  题目大意 #  对于给定的整数 n, 如果n的k（k\u0026gt;=2）进制数的所有数位全为1，则称 k（k\u0026gt;=2）是 n 的一个好进制。\n以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。\n提示：\n n 的取值范围是 [3, 10^18]。 输入总是有效且没有前导 0。  解题思路 #   给出一个数 n，要求找一个进制 k，使得数字 n 在 k 进制下每一位都是 1 。求最小的进制 k。 这一题等价于求最小的正整数 k，满足存在一个正整数 m 使得   这一题需要确定 k 和 m 两个数的值。m 和 k 是有关系的，确定了一个值，另外一个值也确定了。由  可得：\n根据题意，可以知道 k ≥2，m ≥1 ，所以有:\n所以 m 的取值范围确定了。那么外层循环从 1 到 log n 遍历。找到一个最小的 k ，能满足：\n可以用二分搜索来逼近找到最小的 k。先找到 k 的取值范围。由\n可得，\n所以 k 的取值范围是 [2, n*(1/m) ]。再利用二分搜索逼近找到最小的 k 即为答案。\n代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;strconv\u0026#34; ) func smallestGoodBase(n string) string { num, _ := strconv.ParseUint(n, 10, 64) for bit := uint64(math.Log2(float64(num))); bit \u0026gt;= 1; bit-- { low, high := uint64(2), uint64(math.Pow(float64(num), 1.0/float64(bit))) for low \u0026lt; high { mid := uint64(low + (high-low)\u0026gt;\u0026gt;1) sum := findBase(mid, bit) if sum == num { return strconv.FormatUint(mid, 10) } else if sum \u0026gt; num { high = mid - 1 } else { low = mid + 1 } } } return strconv.FormatUint(num-1, 10) } // 计算 k^m + k^(m-1) + ... + k + 1 func findBase(mid, bit uint64) uint64 { sum, base := uint64(1), uint64(1) for i := uint64(1); i \u0026lt;= bit; i++ { base *= mid sum += base } return sum } "});index.add({'id':264,'href':'/leetcode-java/04_Leetcode/0485.Max-Consecutive-Ones/','title':"0485. Max Consecutive Ones",'section':"第四章",'content':"485. Max Consecutive Ones #  题目 #  Given a binary array, find the maximum number of consecutive 1s in this array.\nExample 1:\nInput: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note:\n The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000  题目大意 #  给定一个二进制数组， 计算其中最大连续1的个数。\n注意：\n 输入的数组只包含 0 和 1。 输入数组的长度是正整数，且不超过 10,000。  解题思路 #   给定一个二进制数组， 计算其中最大连续1的个数。 简单题。扫一遍数组，累计 1 的个数，动态维护最大的计数，最终输出即可。  代码 #  package leetcode func findMaxConsecutiveOnes(nums []int) int { maxCount, currentCount := 0, 0 for _, v := range nums { if v == 1 { currentCount++ } else { currentCount = 0 } if currentCount \u0026gt; maxCount { maxCount = currentCount } } return maxCount } "});index.add({'id':265,'href':'/leetcode-java/04_Leetcode/0491.Increasing-Subsequences/','title':"0491. Increasing Subsequences",'section':"第四章",'content':"491. Increasing Subsequences #  题目 #  Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.\nExample:\nInput: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]  Note:\n The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.  题目大意 #  给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。\n说明:\n 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。  解题思路 #   给出一个数组，要求找出这个数组中所有长度大于 2 的非递减子序列。子序列顺序和原数组元素下标必须是顺序的，不能是逆序的。 这一题和第 78 题和第 90 题是类似的题目。第 78 题和第 90 题是求所有子序列，这一题在这两题的基础上增加了非递减和长度大于 2 的条件。需要注意的两点是，原数组中元素可能会重复，最终结果输出的时候需要去重。最终结果输出的去重用 map 处理，数组中重复元素用 DFS 遍历搜索。在每次 DFS 中，用 map 记录遍历过的元素，保证本轮 DFS 中不出现重复的元素，递归到下一层还可以选择值相同，但是下标不同的另外一个元素。外层循环也要加一个 map，这个 map 是过滤每组解因为重复元素导致的重复解，经过过滤以后，起点不同了，最终的解也会不同。 这一题和第 78 题，第 90 题类似，可以一起解答和复习。  代码 #  package leetcode func findSubsequences(nums []int) [][]int { c, visited, res := []int{}, map[int]bool{}, [][]int{} for i := 0; i \u0026lt; len(nums)-1; i++ { if _, ok := visited[nums[i]]; ok { continue } else { visited[nums[i]] = true generateIncSubsets(nums, i, c, \u0026amp;res) } } return res } func generateIncSubsets(nums []int, current int, c []int, res *[][]int) { c = append(c, nums[current]) if len(c) \u0026gt;= 2 { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) } visited := map[int]bool{} for i := current + 1; i \u0026lt; len(nums); i++ { if nums[current] \u0026lt;= nums[i] { if _, ok := visited[nums[i]]; ok { continue } else { visited[nums[i]] = true generateIncSubsets(nums, i, c, res) } } } c = c[:len(c)-1] return } "});index.add({'id':266,'href':'/leetcode-java/04_Leetcode/0493.Reverse-Pairs/','title':"0493. Reverse Pairs",'section':"第四章",'content':"493. Reverse Pairs #  题目 #  Given an array nums, we call (i, j) an important reverse pair if i \u0026lt; j and nums[i] \u0026gt; 2*nums[j].\nYou need to return the number of important reverse pairs in the given array.\nExample1:\nInput: [1,3,2,3,1] Output: 2  Example2:\nInput: [2,4,3,5,1] Output: 3  Note:\n The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.  题目大意 #  给定一个数组 nums ，如果 i \u0026lt; j 且 nums[i] \u0026gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。你需要返回给定数组中的重要翻转对的数量。\n注意:\n 给定数组的长度不会超过 50000。 输入数组中的所有数字都在 32 位整数的表示范围内。  解题思路 #   给出一个数组，要求找出满足条件的所有的“重要的反转对” (i,j)。重要的反转对的定义是：i\u0026lt;j，并且 nums[i] \u0026gt; 2*nums[j]。 这一题是 327 题的变种题。首先将数组中所有的元素以及各自的 2*nums[i] + 1 都放在字典中去重。去重以后再做离散化处理。这一题的测试用例会卡离散化，如果不离散化，Math.MaxInt32 会导致数字溢出，见测试用例中 2147483647, -2147483647 这组测试用例。离散后，映射关系 保存在字典中。从左往右遍历数组，先 query ，再 update ，这个顺序和第 327 题是反的。先 query 查找 [2*nums[i] + 1, len(indexMap)-1] 这个区间内满足条件的值，这个区间内的值都是 \u0026gt; 2*nums[j] 的。这一题移动的是 j，j 不断的变化，往线段树中不断插入的是 i。每轮循环先 query 一次前一轮循环中累积插入线段树中的 i，这些累积在线段树中的代表的是所有在 j 前面的 i。query 查询的是本轮 [2*nums[j] + 1, len(indexMap)-1]，如果能找到，即找到了这样一个 j，能满足 nums[i] \u0026gt; 2*nums[j， 把整个数组都扫完，累加的 query 出来的 count 计数就是最终答案。 类似的题目：第 327 题，第 315 题。 这一题用线段树并不是最优解，用线段树解这一题是为了训练线段树这个数据结构。最优解是解法二中的 mergesort。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 线段树，时间复杂度 O(n log n) func reversePairs(nums []int) int { if len(nums) \u0026lt; 2 { return 0 } st, numsMap, indexMap, numsArray, res := template.SegmentCountTree{}, make(map[int]int, 0), make(map[int]int, 0), []int{}, 0 numsMap[nums[0]] = nums[0] for _, num := range nums { numsMap[num] = num numsMap[2*num+1] = 2*num + 1 } // numsArray 是 prefixSum 去重之后的版本，利用 numsMap 去重 \tfor _, v := range numsMap { numsArray = append(numsArray, v) } // 排序是为了使得线段树中的区间 left \u0026lt;= right，如果此处不排序，线段树中的区间有很多不合法。 \tsort.Ints(numsArray) // 离散化，构建映射关系 \tfor i, n := range numsArray { indexMap[n] = i } numsArray = []int{} // 离散化，此题如果不离散化，MaxInt32 的数据会使得数字越界。 \tfor i := 0; i \u0026lt; len(indexMap); i++ { numsArray = append(numsArray, i) } // 初始化线段树，节点内的值都赋值为 0，即计数为 0 \tst.Init(numsArray, func(i, j int) int { return 0 }) for _, num := range nums { res += st.Query(indexMap[num*2+1], len(indexMap)-1) st.UpdateCount(indexMap[num]) } return res } // 解法二 mergesort func reversePairs1(nums []int) int { buf := make([]int, len(nums)) return mergesortCount(nums, buf) } func mergesortCount(nums, buf []int) int { if len(nums) \u0026lt;= 1 { return 0 } mid := (len(nums) - 1) / 2 cnt := mergesortCount(nums[:mid+1], buf) cnt += mergesortCount(nums[mid+1:], buf) for i, j := 0, mid+1; i \u0026lt; mid+1; i++ { // Note!!! j is increasing. \tfor ; j \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] \u0026lt;= 2*nums[j]; j++ { } cnt += len(nums) - j } copy(buf, nums) for i, j, k := 0, mid+1, 0; k \u0026lt; len(nums); { if j \u0026gt;= len(nums) || i \u0026lt; mid+1 \u0026amp;\u0026amp; buf[i] \u0026gt; buf[j] { nums[k] = buf[i] i++ } else { nums[k] = buf[j] j++ } k++ } return cnt } "});index.add({'id':267,'href':'/leetcode-java/04_Leetcode/0494.Target-Sum/','title':"0494. Target Sum",'section':"第四章",'content':"494. Target Sum #  题目 #  You are given a list of non-negative integers, a1, a2, \u0026hellip;, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\nFind out how many ways to assign symbols to make sum of integers equal to target S.\nExample 1:\nInput: nums is [1, 1, 1, 1, 1], S is 3. Output: 5 Explanation: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 There are 5 ways to assign symbols to make the sum of nums be target 3. Note:\n The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.  题目大意 #  给定一个非负整数数组，a1, a2, \u0026hellip;, an, 和一个目标数，S。现在有两个符号 + 和 -。对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n提示：\n 数组非空，且长度不会超过 20 。 初始的数组的和不会超过 1000 。 保证返回的最终结果能被 32 位整数存下。  解题思路 #    给出一个数组，要求在这个数组里面的每个元素前面加上 + 或者 - 号，最终总和等于 S。问有多少种不同的方法。\n  这一题可以用 DP 和 DFS 解答。DFS 方法就不比较暴力简单了。见代码。这里分析一下 DP 的做法。题目要求在数组元素前加上 + 或者 - 号，其实相当于把数组分成了 2 组，一组全部都加 + 号，一组都加 - 号。记 + 号的一组 P ，记 - 号的一组 N，那么可以推出以下的关系。\nsum(P) - sum(N) = target sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums) 等号两边都加上 sum(N) + sum(P)，于是可以得到结果 2 * sum(P) = target + sum(nums)，那么这道题就转换成了，能否在数组中找到这样一个集合，和等于 (target + sum(nums)) / 2。那么这题就转化为了第 416 题了。dp[i] 中存储的是能使和为 i 的方法个数。\n  如果和不是偶数，即不能被 2 整除，那说明找不到满足题目要求的解了，直接输出 0 。\n  代码 #  func findTargetSumWays(nums []int, S int) int { total := 0 for _, n := range nums { total += n } if S \u0026gt; total || (S+total)%2 == 1 { return 0 } target := (S + total) / 2 dp := make([]int, target+1) dp[0] = 1 for _, n := range nums { for i := target; i \u0026gt;= n; i-- { dp[i] += dp[i-n] } } return dp[target] } // 解法二 DFS func findTargetSumWays1(nums []int, S int) int { // sums[i] 存储的是后缀和 nums[i:]，即从 i 到结尾的和 \tsums := make([]int, len(nums)) sums[len(nums)-1] = nums[len(nums)-1] for i := len(nums) - 2; i \u0026gt; -1; i-- { sums[i] = sums[i+1] + nums[i] } res := 0 dfsFindTargetSumWays(nums, 0, 0, S, \u0026amp;res, sums) return res } func dfsFindTargetSumWays(nums []int, index int, curSum int, S int, res *int, sums []int) { if index == len(nums) { if curSum == S { *(res) = *(res) + 1 } return } // 剪枝优化：如果 sums[index] 值小于剩下需要正数的值，那么右边就算都是 + 号也无能为力了，所以这里可以剪枝了 \tif S-curSum \u0026gt; sums[index] { return } dfsFindTargetSumWays(nums, index+1, curSum+nums[index], S, res, sums) dfsFindTargetSumWays(nums, index+1, curSum-nums[index], S, res, sums) } "});index.add({'id':268,'href':'/leetcode-java/04_Leetcode/0496.Next-Greater-Element-I/','title':"0496. Next Greater Element I",'section':"第四章",'content':"496. Next Greater Element I #  题目 #  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1\u0026rsquo;s elements in the corresponding places of nums2.\nThe Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\nExample 1:\n Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2:\n Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Note:\n All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.  题目大意 #  这道题也是简单题。题目给出 2 个数组 A 和 B，针对 A 中的每个数组中的元素，要求在 B 数组中找出比 A 数组中元素大的数，B 中元素之间的顺序保持不变。如果找到了就输出这个值，如果找不到就输出 -1。\n解题思路 #  简单题，依题意做即可。\n代码 #  package leetcode func nextGreaterElement(nums1 []int, nums2 []int) []int { if len(nums1) == 0 || len(nums2) == 0 { return []int{} } res, reocrd := []int{}, map[int]int{} for i, v := range nums2 { reocrd[v] = i } for i := 0; i \u0026lt; len(nums1); i++ { flag := false for j := reocrd[nums1[i]]; j \u0026lt; len(nums2); j++ { if nums2[j] \u0026gt; nums1[i] { res = append(res, nums2[j]) flag = true break } } if flag == false { res = append(res, -1) } } return res } "});index.add({'id':269,'href':'/leetcode-java/04_Leetcode/0497.Random-Point-in-Non-overlapping-Rectangles/','title':"0497. Random Point in Non Overlapping Rectangles",'section':"第四章",'content':"497. Random Point in Non-overlapping Rectangles #  题目 #  Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles.\nNote:\n An integer point is a point that has integer coordinates. A point on the perimeter of a rectangle is included in the space covered by the rectangles. ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 \u0026lt;= rects.length \u0026lt;= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.  Example 1:\nInput: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[[[1,1,5,5]]],[],[],[]] Output: [null,[4,1],[4,1],[3,3]]  Example 2:\nInput: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output: [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]  Explanation of Input Syntax:\nThe input is two lists: the subroutines called and their arguments. Solution\u0026lsquo;s constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren\u0026rsquo;t any.\n题目大意 #  给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。\n提示：\n 整数点是具有整数坐标的点。 矩形周边上的点包含在矩形覆盖的空间中。 第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。 每个矩形的长度和宽度不超过 2000。 1 \u0026lt;= rects.length \u0026lt;= 100 pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。 pick 最多被调用10000次。  输入语法的说明：\n输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。\n解题思路 #   给出一个非重叠轴对齐矩形列表，每个矩形用左下角和右上角的两个坐标表示。要求 pick() 随机均匀地选取矩形覆盖的空间中的整数点。 这一题是第 528 题的变种题，这一题权重是面积，按权重（面积）选择一个矩形，然后再从矩形中随机选择一个点即可。思路和代码和第 528 题一样。  代码 #  package leetcode import \u0026#34;math/rand\u0026#34; // Solution497 define type Solution497 struct { rects [][]int arr []int } // Constructor497 define func Constructor497(rects [][]int) Solution497 { s := Solution497{ rects: rects, arr: make([]int, len(rects)), } for i := 0; i \u0026lt; len(rects); i++ { area := (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1) if area \u0026lt; 0 { area = -area } if i == 0 { s.arr[0] = area } else { s.arr[i] = s.arr[i-1] + area } } return s } // Pick define func (so *Solution497) Pick() []int { r := rand.Int() % so.arr[len(so.arr)-1] //get rectangle first \tlow, high, index := 0, len(so.arr)-1, -1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if so.arr[mid] \u0026gt; r { if mid == 0 || so.arr[mid-1] \u0026lt;= r { index = mid break } high = mid - 1 } else { low = mid + 1 } } if index == -1 { index = low } if index \u0026gt; 0 { r = r - so.arr[index-1] } length := so.rects[index][2] - so.rects[index][0] return []int{so.rects[index][0] + r%(length+1), so.rects[index][1] + r/(length+1)} } /** * Your Solution object will be instantiated and called as such: * obj := Constructor(rects); * param_1 := obj.Pick(); */ "});index.add({'id':270,'href':'/leetcode-java/04_Leetcode/0498.Diagonal-Traverse/','title':"0498. Diagonal Traverse",'section':"第四章",'content':"498. Diagonal Traverse #  题目 #  Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\nExample:\nInput: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,4,7,5,3,6,8,9] Explanation:   Note:\nThe total number of elements of the given matrix will not exceed 10,000.\n题目大意 #  给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n 说明: 给定矩阵中的元素总数不会超过 100000 。\n解题思路 #   给出一个二维数组，要求按照如图的方式遍历整个数组。 这一题用模拟的方式就可以解出来。需要注意的是边界条件：比如二维数组为空，二维数组退化为一行或者一列，退化为一个元素。具体例子见测试用例。  代码 #  package leetcode // 解法一 func findDiagonalOrder1(matrix [][]int) []int { if matrix == nil || len(matrix) == 0 || len(matrix[0]) == 0 { return nil } row, col, dir, i, x, y, d := len(matrix), len(matrix[0]), [2][2]int{ {-1, 1}, {1, -1}, }, 0, 0, 0, 0 total := row * col res := make([]int, total) for i \u0026lt; total { for x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; row \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; col { res[i] = matrix[x][y] i++ x += dir[d][0] y += dir[d][1] } d = (d + 1) % 2 if x == row { x-- y += 2 } if y == col { y-- x += 2 } if x \u0026lt; 0 { x = 0 } if y \u0026lt; 0 { y = 0 } } return res } // 解法二 func findDiagonalOrder(matrix [][]int) []int { if len(matrix) == 0 { return []int{} } if len(matrix) == 1 { return matrix[0] } // dir = 0 代表从右上到左下的方向， dir = 1 代表从左下到右上的方向 dir = -1 代表上一次转变了方向 \tm, n, i, j, dir, res := len(matrix), len(matrix[0]), 0, 0, 0, []int{} for index := 0; index \u0026lt; m*n; index++ { if dir == -1 { if (i == 0 \u0026amp;\u0026amp; j \u0026lt; n-1) || (j == n-1) { // 上边界和右边界 \ti++ if j \u0026gt; 0 { j-- } dir = 0 addTraverse(matrix, i, j, \u0026amp;res) continue } if (j == 0 \u0026amp;\u0026amp; i \u0026lt; m-1) || (i == m-1) { // 左边界和下边界 \tif i \u0026gt; 0 { i-- } j++ dir = 1 addTraverse(matrix, i, j, \u0026amp;res) continue } } if i == 0 \u0026amp;\u0026amp; j == 0 { res = append(res, matrix[i][j]) if j \u0026lt; n-1 { j++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } else { if i \u0026lt; m-1 { i++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } } } if i == 0 \u0026amp;\u0026amp; j \u0026lt; n-1 { // 上边界 \tif j \u0026lt; n-1 { j++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } } if j == 0 \u0026amp;\u0026amp; i \u0026lt; m-1 { // 左边界 \tif i \u0026lt; m-1 { i++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } } if j == n-1 { // 右边界 \tif i \u0026lt; m-1 { i++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } } if i == m-1 { // 下边界 \tj++ dir = -1 addTraverse(matrix, i, j, \u0026amp;res) continue } if dir == 1 { i-- j++ addTraverse(matrix, i, j, \u0026amp;res) continue } if dir == 0 { i++ j-- addTraverse(matrix, i, j, \u0026amp;res) continue } } return res } func addTraverse(matrix [][]int, i, j int, res *[]int) { if i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt;= len(matrix)-1 \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt;= len(matrix[0])-1 { *res = append(*res, matrix[i][j]) } } "});index.add({'id':271,'href':'/leetcode-java/04_Leetcode/0500.Keyboard-Row/','title':"0500. Keyboard Row",'section':"第四章",'content':"500. Keyboard Row #  题目 #  Given a List of words, return the words that can be typed using letters of alphabet on only one row\u0026rsquo;s of American keyboard like the image below.\n Example:\nInput: [\u0026quot;Hello\u0026quot;, \u0026quot;Alaska\u0026quot;, \u0026quot;Dad\u0026quot;, \u0026quot;Peace\u0026quot;] Output: [\u0026quot;Alaska\u0026quot;, \u0026quot;Dad\u0026quot;]  Note:\n You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.  题目大意 #  给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如上图所示。\n解题思路 #   给出一个字符串数组，要求依次判断数组中的每个字符串是否都位于键盘上的同一个行，如果是就输出。这也是一道水题。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func findWords500(words []string) []string { rows := []string{\u0026#34;qwertyuiop\u0026#34;, \u0026#34;asdfghjkl\u0026#34;, \u0026#34;zxcvbnm\u0026#34;} output := make([]string, 0) for _, s := range words { if len(s) == 0 { continue } lowerS := strings.ToLower(s) oneRow := false for _, r := range rows { if strings.ContainsAny(lowerS, r) { oneRow = !oneRow if !oneRow { break } } } if oneRow { output = append(output, s) } } return output } "});index.add({'id':272,'href':'/leetcode-java/04_Leetcode/0503.Next-Greater-Element-II/','title':"0503. Next Greater Element I I",'section':"第四章",'content':"503. Next Greater Element II #  题目 #  Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn\u0026rsquo;t exist, output -1 for this number.\nExample 1:\n Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. Note: The length of given array won\u0026rsquo;t exceed 10000.\n题目大意 #  题目给出数组 A，针对 A 中的每个数组中的元素，要求在 A 数组中找出比该元素大的数，A 是一个循环数组。如果找到了就输出这个值，如果找不到就输出 -1。\n解题思路 #  这题是第 496 题的加强版，在第 496 题的基础上增加了循环数组的条件。这一题可以依旧按照第 496 题的做法继续模拟。更好的做法是用单调栈，栈中记录单调递增的下标。\n代码 #  package leetcode // 解法一 单调栈 func nextGreaterElements(nums []int) []int { res := make([]int, 0) indexes := make([]int, 0) for i := 0; i \u0026lt; len(nums); i++ { res = append(res, -1) } for i := 0; i \u0026lt; len(nums)*2; i++ { num := nums[i%len(nums)] for len(indexes) \u0026gt; 0 \u0026amp;\u0026amp; nums[indexes[len(indexes)-1]] \u0026lt; num { index := indexes[len(indexes)-1] res[index] = num indexes = indexes[:len(indexes)-1] } indexes = append(indexes, i%len(nums)) } return res } // 解法二 func nextGreaterElements1(nums []int) []int { if len(nums) == 0 { return []int{} } res := []int{} for i := 0; i \u0026lt; len(nums); i++ { j, find := (i+1)%len(nums), false for j != i { if nums[j] \u0026gt; nums[i] { find = true res = append(res, nums[j]) break } j = (j + 1) % len(nums) } if !find { res = append(res, -1) } } return res } "});index.add({'id':273,'href':'/leetcode-java/04_Leetcode/0507.Perfect-Number/','title':"0507. Perfect Number",'section':"第四章",'content':"507. Perfect Number #  题目 #  We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.\nNow, given an\ninteger\nn, write a function that returns true when it is a perfect number and false when it is not.\nExample:\nInput: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14 Note: The input number n will not exceed 100,000,000. (1e8)\n题目大意 #  对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False\n解题思路 #   给定一个整数，要求判断这个数是不是完美数。整数的取值范围小于 1e8 。 简单题。按照题意描述，先获取这个整数的所有正因子，如果正因子的和等于原来这个数，那么它就是完美数。 这一题也可以打表，1e8 以下的完美数其实并不多，就 5 个。  代码 #  package leetcode import \u0026#34;math\u0026#34; // 方法一 func checkPerfectNumber(num int) bool { if num \u0026lt;= 1 { return false } sum, bound := 1, int(math.Sqrt(float64(num)))+1 for i := 2; i \u0026lt; bound; i++ { if num%i != 0 { continue } corrDiv := num / i sum += corrDiv + i } return sum == num } // 方法二 打表 func checkPerfectNumber_(num int) bool { return num == 6 || num == 28 || num == 496 || num == 8128 || num == 33550336 } "});index.add({'id':274,'href':'/leetcode-java/04_Leetcode/0508.Most-Frequent-Subtree-Sum/','title':"0508. Most Frequent Subtree Sum",'section':"第四章",'content':"508. Most Frequent Subtree Sum #  题目 #  Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\nExamples 1\nInput:\n 5 / \\ 2 -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.\nExamples 2\nInput:\n 5 / \\ 2 -5  return [2], since 2 happens twice, however -5 only occur once.\nNote: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n题目大意 #  给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。提示： 假设任意子树元素和均可以用 32 位有符号整数表示。\n解题思路 #   给出一个树，要求求出每个节点以自己为根节点的子树的所有节点值的和，最后按照这些和出现的频次，输出频次最多的和，如果频次出现次数最多的对应多个和，则全部输出。 递归找出每个节点的累加和，用 map 记录频次，最后把频次最多的输出即可。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 维护最大频次，不用排序 func findFrequentTreeSum(root *TreeNode) []int { memo := make(map[int]int) collectSum(root, memo) res := []int{} most := 0 for key, val := range memo { if most == val { res = append(res, key) } else if most \u0026lt; val { most = val res = []int{key} } } return res } func collectSum(root *TreeNode, memo map[int]int) int { if root == nil { return 0 } sum := root.Val + collectSum(root.Left, memo) + collectSum(root.Right, memo) if v, ok := memo[sum]; ok { memo[sum] = v + 1 } else { memo[sum] = 1 } return sum } // 解法二 求出所有和再排序 func findFrequentTreeSum1(root *TreeNode) []int { if root == nil { return []int{} } freMap, freList, reFreMap := map[int]int{}, []int{}, map[int][]int{} findTreeSum(root, freMap) for k, v := range freMap { tmp := reFreMap[v] tmp = append(tmp, k) reFreMap[v] = tmp } for k := range reFreMap { freList = append(freList, k) } sort.Ints(freList) return reFreMap[freList[len(freList)-1]] } func findTreeSum(root *TreeNode, fre map[int]int) int { if root == nil { return 0 } if root != nil \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { fre[root.Val]++ return root.Val } val := findTreeSum(root.Left, fre) + findTreeSum(root.Right, fre) + root.Val fre[val]++ return val } "});index.add({'id':275,'href':'/leetcode-java/04_Leetcode/0509.Fibonacci-Number/','title':"0509. Fibonacci Number",'section':"第四章",'content':"509. Fibonacci Number #  题目 #  The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N \u0026gt; 1.  Given N, calculate F(N).\nExample 1:\nInput: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.  Example 2:\nInput: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.  Example 3:\nInput: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.  Note:\n0 ≤ N ≤ 30.\n题目大意 #  斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1. 给定 N，计算 F(N)。\n提示：0 ≤ N ≤ 30\n解题思路 #   求斐波那契数列 这一题解法很多，大的分类是四种，递归，记忆化搜索(dp)，矩阵快速幂，通项公式。其中记忆化搜索可以写 3 种方法，自底向上的，自顶向下的，优化空间复杂度版的。通项公式方法实质是求 a^b 这个还可以用快速幂优化时间复杂度到 O(log n) 。  代码 #  package leetcode import \u0026#34;math\u0026#34; // 解法一 递归法 时间复杂度 O(2^n)，空间复杂度 O(n) func fib(N int) int { if N \u0026lt;= 1 { return N } return fib(N-1) + fib(N-2) } // 解法二 自底向上的记忆化搜索 时间复杂度 O(n)，空间复杂度 O(n) func fib1(N int) int { if N \u0026lt;= 1 { return N } cache := map[int]int{0: 0, 1: 1} for i := 2; i \u0026lt;= N; i++ { cache[i] = cache[i-1] + cache[i-2] } return cache[N] } // 解法三 自顶向下的记忆化搜索 时间复杂度 O(n)，空间复杂度 O(n) func fib2(N int) int { if N \u0026lt;= 1 { return N } return memoize(N, map[int]int{0: 0, 1: 1}) } func memoize(N int, cache map[int]int) int { if _, ok := cache[N]; ok { return cache[N] } cache[N] = memoize(N-1, cache) + memoize(N-2, cache) return memoize(N, cache) } // 解法四 优化版的 dp，节约内存空间 时间复杂度 O(n)，空间复杂度 O(1) func fib3(N int) int { if N \u0026lt;= 1 { return N } if N == 2 { return 1 } current, prev1, prev2 := 0, 1, 1 for i := 3; i \u0026lt;= N; i++ { current = prev1 + prev2 prev2 = prev1 prev1 = current } return current } // 解法五 矩阵快速幂 时间复杂度 O(log n)，空间复杂度 O(log n) // | 1 1 | ^ n = | F(n+1) F(n) | // | 1 0 |\t| F(n)\tF(n-1) | func fib4(N int) int { if N \u0026lt;= 1 { return N } var A = [2][2]int{ {1, 1}, {1, 0}, } A = matrixPower(A, N-1) return A[0][0] } func matrixPower(A [2][2]int, N int) [2][2]int { if N \u0026lt;= 1 { return A } A = matrixPower(A, N/2) A = multiply(A, A) var B = [2][2]int{ {1, 1}, {1, 0}, } if N%2 != 0 { A = multiply(A, B) } return A } func multiply(A [2][2]int, B [2][2]int) [2][2]int { x := A[0][0]*B[0][0] + A[0][1]*B[1][0] y := A[0][0]*B[0][1] + A[0][1]*B[1][1] z := A[1][0]*B[0][0] + A[1][1]*B[1][0] w := A[1][0]*B[0][1] + A[1][1]*B[1][1] A[0][0] = x A[0][1] = y A[1][0] = z A[1][1] = w return A } // 解法六 公式法 f(n)=(1/√5)*{[(1+√5)/2]^n -[(1-√5)/2]^n}，用 时间复杂度在 O(log n) 和 O(n) 之间，空间复杂度 O(1) // 经过实际测试，会发现 pow() 系统函数比快速幂慢，说明 pow() 比 O(log n) 慢 // 斐波那契数列是一个自然数的数列，通项公式却是用无理数来表达的。而且当 n 趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割 0.618（或者说后一项与前一项的比值小数部分越来越逼近 0.618）。 // 斐波那契数列用计算机计算的时候可以直接用四舍五入函数 Round 来计算。 func fib5(N int) int { var goldenRatio float64 = float64((1 + math.Sqrt(5)) / 2) return int(math.Round(math.Pow(goldenRatio, float64(N)) / math.Sqrt(5))) } "});index.add({'id':276,'href':'/leetcode-java/04_Leetcode/0513.Find-Bottom-Left-Tree-Value/','title':"0513. Find Bottom Left Tree Value",'section':"第四章",'content':"513. Find Bottom Left Tree Value #  题目 #  Given a binary tree, find the leftmost value in the last row of the tree.\nExample 1:\nInput: 2 / \\ 1 3 Output: 1  Example 2:\nInput: 1 / \\ 2 3 / / \\ 4 5 6 / 7 Output: 7  Note: You may assume the tree (i.e., the given root node) is not NULL.\n题目大意 #  给定一个二叉树，在树的最后一行找到最左边的值。注意: 您可以假设树（即给定的根节点）不为 NULL。\n解题思路 #   给出一棵树，输出这棵树最下一层中最左边的节点的值。 这一题用 DFS 和 BFS 均可解题。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 DFS func findBottomLeftValue(root *TreeNode) int { if root == nil { return 0 } res, maxHeight := 0, -1 findBottomLeftValueDFS(root, 0, \u0026amp;res, \u0026amp;maxHeight) return res } func findBottomLeftValueDFS(root *TreeNode, curHeight int, res, maxHeight *int) { if curHeight \u0026gt; *maxHeight \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { *maxHeight = curHeight *res = root.Val } if root.Left != nil { findBottomLeftValueDFS(root.Left, curHeight+1, res, maxHeight) } if root.Right != nil { findBottomLeftValueDFS(root.Right, curHeight+1, res, maxHeight) } } // 解法二 BFS func findBottomLeftValue1(root *TreeNode) int { queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { next := []*TreeNode{} for _, node := range queue { if node.Left != nil { next = append(next, node.Left) } if node.Right != nil { next = append(next, node.Right) } } if len(next) == 0 { return queue[0].Val } queue = next } return 0 } "});index.add({'id':277,'href':'/leetcode-java/04_Leetcode/0515.Find-Largest-Value-in-Each-Tree-Row/','title':"0515. Find Largest Value in Each Tree Row",'section':"第四章",'content':"515. Find Largest Value in Each Tree Row #  题目 #  You need to find the largest value in each row of a binary tree.\nExample:\nInput: 1 / \\ 3 2 / \\ \\ 5 3 9 Output: [1, 3, 9]  题目大意 #  求在二叉树的每一行中找到最大的值。\n解题思路 #   给出一个二叉树，要求依次输出每行的最大值 用 BFS 层序遍历，将每层排序取出最大值。改进的做法是遍历中不断更新每层的最大值。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 层序遍历二叉树，再将每层排序取出最大值 func largestValues(root *TreeNode) []int { tmp := levelOrder(root) res := []int{} for i := 0; i \u0026lt; len(tmp); i++ { sort.Ints(tmp[i]) res = append(res, tmp[i][len(tmp[i])-1]) } return res } // 解法二 层序遍历二叉树，遍历过程中不断更新最大值 func largestValues1(root *TreeNode) []int { if root == nil { return []int{} } q := []*TreeNode{root} var res []int for len(q) \u0026gt; 0 { qlen := len(q) max := math.MinInt32 for i := 0; i \u0026lt; qlen; i++ { node := q[0] q = q[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { q = append(q, node.Left) } if node.Right != nil { q = append(q, node.Right) } } res = append(res, max) } return res } "});index.add({'id':278,'href':'/leetcode-java/04_Leetcode/0524.Longest-Word-in-Dictionary-through-Deleting/','title':"0524. Longest Word in Dictionary Through Deleting",'section':"第四章",'content':"524. Longest Word in Dictionary through Deleting #  题目 #  Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\nExample 1:\n Input: s = \u0026quot;abpcplea\u0026quot;, d = [\u0026quot;ale\u0026quot;,\u0026quot;apple\u0026quot;,\u0026quot;monkey\u0026quot;,\u0026quot;plea\u0026quot;] Output: \u0026quot;apple\u0026quot; Example 2:\n Input: s = \u0026quot;abpcplea\u0026quot;, d = [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;] Output: \u0026quot;a\u0026quot; Note:\n All the strings in the input will only contain lower-case letters. The size of the dictionary won\u0026rsquo;t exceed 1,000. The length of all the strings in the input won\u0026rsquo;t exceed 1,000.  题目大意 #  给出一个初始串，再给定一个字符串数组，要求在字符串数组中找到能在初始串中通过删除字符得到的最长的串，如果最长的串有多组解，要求输出字典序最小的那组解。\n解题思路 #  这道题就单纯的用 O(n^2) 暴力循环即可，注意最终解的要求，如果都是最长的串，要求输出字典序最小的那个串，只要利用字符串比较得到字典序最小的串即可。\n代码 #  package leetcode func findLongestWord(s string, d []string) string { res := \u0026#34;\u0026#34; for i := 0; i \u0026lt; len(d); i++ { pointS := 0 pointD := 0 for pointS \u0026lt; len(s) \u0026amp;\u0026amp; pointD \u0026lt; len(d[i]) { if s[pointS] == d[i][pointD] { pointD++ } pointS++ } if pointD == len(d[i]) \u0026amp;\u0026amp; (len(res) \u0026lt; len(d[i]) || (len(res) == len(d[i]) \u0026amp;\u0026amp; res \u0026gt; d[i])) { res = d[i] } } return res } "});index.add({'id':279,'href':'/leetcode-java/04_Leetcode/0526.Beautiful-Arrangement/','title':"0526. Beautiful Arrangement",'section':"第四章",'content':"526. Beautiful Arrangement #  题目 #  Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 \u0026lt;= i \u0026lt;= N) in this array:\n The number at the i position is divisible by i.th i is divisible by the number at the i position.th  Now given N, how many beautiful arrangements can you construct?\nExample 1:\nInput: 2 Output: 2 Explanation: The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.  Note:\n N is a positive integer and will not exceed 15.  题目大意 #  假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 \u0026lt;= i \u0026lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：\n 第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除  现在给定一个整数 N，请问可以构造多少个优美的排列？\n解题思路 #   这一题是第 46 题的加强版。由于这一题给出的数组里面的数字都是不重复的，所以可以当做第 46 题来做。 这题比第 46 题多的一个条件是，要求数字可以被它对应的下标 + 1 整除，或者下标 + 1 可以整除下标对应的这个数字。在 DFS 回溯过程中加入这个剪枝条件就可以了。 当前做法时间复杂度不是最优的，大概只有 33.3%  代码 #  package leetcode // 解法一 暴力打表法 func countArrangement1(N int) int { res := []int{0, 1, 2, 3, 8, 10, 36, 41, 132, 250, 700, 750, 4010, 4237, 10680, 24679, 87328, 90478, 435812} return res[N] } // 解法二 DFS 回溯 func countArrangement(N int) int { if N == 0 { return 0 } nums, used, p, res := make([]int, N), make([]bool, N), []int{}, [][]int{} for i := range nums { nums[i] = i + 1 } generatePermutation526(nums, 0, p, \u0026amp;res, \u0026amp;used) return len(res) } func generatePermutation526(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) return } for i := 0; i \u0026lt; len(nums); i++ { if !(*used)[i] { if !(checkDivisible(nums[i], len(p)+1) || checkDivisible(len(p)+1, nums[i])) { // 关键的剪枝条件 \tcontinue } (*used)[i] = true p = append(p, nums[i]) generatePermutation526(nums, index+1, p, res, used) p = p[:len(p)-1] (*used)[i] = false } } return } func checkDivisible(num, d int) bool { tmp := num / d if int(tmp)*int(d) == num { return true } return false } "});index.add({'id':280,'href':'/leetcode-java/04_Leetcode/0528.Random-Pick-with-Weight/','title':"0528. Random Pick With Weight",'section':"第四章",'content':"528. Random Pick with Weight #  题目 #  Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.\nNote:\n 1 \u0026lt;= w.length \u0026lt;= 10000 1 \u0026lt;= w[i] \u0026lt;= 10^5 pickIndex will be called at most 10000 times.  Example 1:\nInput: [\u0026quot;Solution\u0026quot;,\u0026quot;pickIndex\u0026quot;] [[[1]],[]] Output: [null,0]  Example 2:\nInput: [\u0026quot;Solution\u0026quot;,\u0026quot;pickIndex\u0026quot;,\u0026quot;pickIndex\u0026quot;,\u0026quot;pickIndex\u0026quot;,\u0026quot;pickIndex\u0026quot;,\u0026quot;pickIndex\u0026quot;] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax:\nThe input is two lists: the subroutines called and their arguments. Solution\u0026lsquo;s constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren\u0026rsquo;t any.\n题目大意 #  给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。\n说明:\n 1 \u0026lt;= w.length \u0026lt;= 10000 1 \u0026lt;= w[i] \u0026lt;= 10^5 pickIndex 将被调用不超过 10000 次  输入语法说明：\n输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。\n解题思路 #   给出一个数组，每个元素值代表该下标的权重值，pickIndex() 随机取一个位置 i，这个位置出现的概率和该元素值成正比。 由于涉及到了权重的问题，这一题可以先考虑用前缀和处理权重。在 [0,prefixSum) 区间内随机选一个整数 x，下标 i 是满足 x\u0026lt; prefixSum[i] 条件的最小下标，求这个下标 i 即是最终解。二分搜索查找下标 i 。对于某些下标 i，所有满足 prefixSum[i] - w[i] ≤ v \u0026lt; prefixSum[i] 的整数 v 都映射到这个下标。因此，所有的下标都与下标权重成比例。 时间复杂度：预处理的时间复杂度是 O(n)，pickIndex() 的时间复杂度是 O(log n)。空间复杂度 O(n)。  代码 #  package leetcode import ( \u0026#34;math/rand\u0026#34; ) // Solution528 define type Solution528 struct { prefixSum []int } // Constructor528 define func Constructor528(w []int) Solution528 { prefixSum := make([]int, len(w)) for i, e := range w { if i == 0 { prefixSum[i] = e continue } prefixSum[i] = prefixSum[i-1] + e } return Solution528{prefixSum: prefixSum} } // PickIndex define func (so *Solution528) PickIndex() int { n := rand.Intn(so.prefixSum[len(so.prefixSum)-1]) + 1 low, high := 0, len(so.prefixSum)-1 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if so.prefixSum[mid] == n { return mid } else if so.prefixSum[mid] \u0026lt; n { low = mid + 1 } else { high = mid } } return low } /** * Your Solution object will be instantiated and called as such: * obj := Constructor(w); * param_1 := obj.PickIndex(); */ "});index.add({'id':281,'href':'/leetcode-java/04_Leetcode/0529.Minesweeper/','title':"0529. Minesweeper",'section':"第四章",'content':"529. Minesweeper #  题目 #  Let\u0026rsquo;s play the minesweeper game ( Wikipedia, online game)!\nYou are given a 2D char matrix representing the game board. \u0026lsquo;M\u0026rsquo; represents an unrevealed mine, \u0026lsquo;E\u0026rsquo; represents an unrevealed empty square, \u0026lsquo;B\u0026rsquo; represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (\u0026lsquo;1\u0026rsquo; to \u0026lsquo;8\u0026rsquo;) represents how many mines are adjacent to this revealed square, and finally \u0026lsquo;X\u0026rsquo; represents a revealed mine.\nNow given the next click position (row and column indices) among all the unrevealed squares (\u0026lsquo;M\u0026rsquo; or \u0026lsquo;E\u0026rsquo;), return the board after revealing this position according to the following rules:\n If a mine (\u0026lsquo;M\u0026rsquo;) is revealed, then the game is over - change it to \u0026lsquo;X\u0026rsquo;. If an empty square (\u0026lsquo;E\u0026rsquo;) with no adjacent mines is revealed, then change it to revealed blank (\u0026lsquo;B\u0026rsquo;) and all of its adjacent unrevealed squares should be revealed recursively. If an empty square (\u0026lsquo;E\u0026rsquo;) with at least one adjacent mine is revealed, then change it to a digit (\u0026lsquo;1\u0026rsquo; to \u0026lsquo;8\u0026rsquo;) representing the number of adjacent mines. Return the board when no more squares will be revealed.  Example 1:\nInput: [['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'M', 'E', 'E'], ['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E']] Click : [3,0] Output: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] Explanation:  Example 2:\nInput: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] Click : [1,2] Output: [['B', '1', 'E', '1', 'B'], ['B', '1', 'X', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] Explanation:  Note:\n The range of the input matrix\u0026rsquo;s height and width is [1,50]. The click position will only be an unrevealed square (\u0026lsquo;M\u0026rsquo; or \u0026lsquo;E\u0026rsquo;), which also means the input board contains at least one clickable square. The input board won\u0026rsquo;t be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don\u0026rsquo;t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.  题目大意 #  给定一个代表游戏板的二维字符矩阵。 \u0026lsquo;M\u0026rsquo; 代表一个未挖出的地雷，\u0026lsquo;E\u0026rsquo; 代表一个未挖出的空方块，\u0026lsquo;B\u0026rsquo; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（\u0026lsquo;1\u0026rsquo; 到 \u0026lsquo;8\u0026rsquo;）表示有多少地雷与这块已挖出的方块相邻，\u0026lsquo;X\u0026rsquo; 则表示一个已挖出的地雷。现在给出在所有未挖出的方块中（\u0026lsquo;M\u0026rsquo;或者\u0026rsquo;E\u0026rsquo;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：\n 如果一个地雷（\u0026lsquo;M\u0026rsquo;）被挖出，游戏就结束了- 把它改为 \u0026lsquo;X\u0026rsquo;。 如果一个没有相邻地雷的空方块（\u0026lsquo;E\u0026rsquo;）被挖出，修改它为（\u0026lsquo;B\u0026rsquo;），并且所有和其相邻的未挖出方块都应该被递归地揭露。 如果一个至少与一个地雷相邻的空方块（\u0026lsquo;E\u0026rsquo;）被挖出，修改它为数字（\u0026lsquo;1\u0026rsquo;到'8\u0026rsquo;），表示相邻地雷的数量。 如果在此次点击中，若无更多方块可被揭露，则返回面板。  注意：\n 输入矩阵的宽和高的范围为 [1,50]。 点击的位置只能是未被挖出的方块 (\u0026lsquo;M\u0026rsquo; 或者 \u0026lsquo;E\u0026rsquo;)，这也意味着面板至少包含一个可点击的方块。 输入面板不会是游戏结束的状态（即有地雷已被挖出）。 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。  解题思路 #   给出一张扫雷地图和点击的坐标，M 代表雷，E 代表还没有点击过的空砖块，B 代表点击过的空砖块，1-8 代表砖块周围 8 个方块里面有雷的个数，X 代表点到了雷。问点击一次以后，输出更新点击以后的地图。 DPS 和 BFS 都可以解题。先根据原图预处理地图，记录出最终地图的状态，0 代表空白砖块，1-8 代表雷的个数，-1 代表是雷。再 DFS 遍历这张处理后的图，输出最终的地图即可。  代码 #  func updateBoard(board [][]byte, click []int) [][]byte { if board[click[0]][click[1]] == \u0026#39;M\u0026#39; { board[click[0]][click[1]] = \u0026#39;X\u0026#39; return board } mineMap := make([][]int, len(board)) for i := range board { mineMap[i] = make([]int, len(board[i])) } for i := range board { for j := range board[i] { if board[i][j] == \u0026#39;M\u0026#39; { mineMap[i][j] = -1 for _, d := range dir8 { nx, ny := i+d[0], j+d[1] if isInBoard(board, nx, ny) \u0026amp;\u0026amp; mineMap[nx][ny] \u0026gt;= 0 { mineMap[nx][ny]++ } } } } } mineSweeper(click[0], click[1], board, mineMap, dir8) return board } func mineSweeper(x, y int, board [][]byte, mineMap [][]int, dir8 [][]int) { if board[x][y] != \u0026#39;M\u0026#39; \u0026amp;\u0026amp; board[x][y] != \u0026#39;E\u0026#39; { return } if mineMap[x][y] == -1 { board[x][y] = \u0026#39;X\u0026#39; } else if mineMap[x][y] \u0026gt; 0 { board[x][y] = \u0026#39;0\u0026#39; + byte(mineMap[x][y]) } else { board[x][y] = \u0026#39;B\u0026#39; for _, d := range dir8 { nx, ny := x+d[0], y+d[1] if isInBoard(board, nx, ny) \u0026amp;\u0026amp; mineMap[nx][ny] \u0026gt;= 0 { mineSweeper(nx, ny, board, mineMap, dir8) } } } } "});index.add({'id':282,'href':'/leetcode-java/04_Leetcode/0532.K-diff-Pairs-in-an-Array/','title':"0532. K Diff Pairs in an Array",'section':"第四章",'content':"532. K-diff Pairs in an Array #  题目 #  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\nExample 1:\n Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5). Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:\n Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:\n Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). Note:\n The pairs (i, j) and (j, i) count as the same pair. The length of the array won\u0026rsquo;t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].  题目大意 #  给定一个数组，在数组里面找到几组不同的 pair 对，每个 pair 对相差 K 。问能找出多少组这样的 pair 对。\n解题思路 #  这一题可以用 map 记录每个数字出现的次数。重复的数字也会因为唯一的 key，不用担心某个数字会判断多次。遍历一次 map，每个数字都加上 K 以后，判断字典里面是否存在，如果存在， count ++，如果 K = 0 的情况需要单独判断，如果字典中这个元素频次大于 1，count 也需要 ++。\n代码 #  package leetcode func findPairs(nums []int, k int) int { if k \u0026lt; 0 || len(nums) == 0 { return 0 } var count int m := make(map[int]int, len(nums)) for _, value := range nums { m[value]++ } for key := range m { if k == 0 \u0026amp;\u0026amp; m[key] \u0026gt; 1 { count++ continue } if k \u0026gt; 0 \u0026amp;\u0026amp; m[key+k] \u0026gt; 0 { count++ } } return count } "});index.add({'id':283,'href':'/leetcode-java/04_Leetcode/0537.Complex-Number-Multiplication/','title':"0537. Complex Number Multiplication",'section':"第四章",'content':"537. Complex Number Multiplication #  题目 #  Given two strings representing two complex numbers.\nYou need to return a string representing their multiplication. Note i2 = -1 according to the definition.\nExample 1:\nInput: \u0026quot;1+1i\u0026quot;, \u0026quot;1+1i\u0026quot; Output: \u0026quot;0+2i\u0026quot; Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2:\nInput: \u0026quot;1+-1i\u0026quot;, \u0026quot;1+-1i\u0026quot; Output: \u0026quot;0+-2i\u0026quot; Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. Note:\n The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.  题目大意 #  给定两个表示复数的字符串。返回表示它们乘积的字符串。注意，根据定义 i^2 = -1 。\n注意:\n 输入字符串不包含额外的空格。 输入字符串将以 a+bi 的形式给出，其中整数 a 和 b 的范围均在 [-100, 100] 之间。输出也应当符合这种形式。  解题思路 #   给定 2 个字符串，要求这两个复数的乘积，输出也是字符串格式。 数学题。按照复数的运算法则，i^2 = -1，最后输出字符串结果即可。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) func complexNumberMultiply(a string, b string) string { realA, imagA := parse(a) realB, imagB := parse(b) real := realA*realB - imagA*imagB imag := realA*imagB + realB*imagA return strconv.Itoa(real) + \u0026#34;+\u0026#34; + strconv.Itoa(imag) + \u0026#34;i\u0026#34; } func parse(s string) (int, int) { ss := strings.Split(s, \u0026#34;+\u0026#34;) r, _ := strconv.Atoi(ss[0]) i, _ := strconv.Atoi(ss[1][:len(ss[1])-1]) return r, i } "});index.add({'id':284,'href':'/leetcode-java/04_Leetcode/0541.Reverse-String-II/','title':"0541. Reverse String I I",'section':"第四章",'content':"541. Reverse String II #  题目 #  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\nExample:\nInput: s = \u0026quot;abcdefg\u0026quot;, k = 2 Output: \u0026quot;bacdfeg\u0026quot;  Restrictions:\n The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000]  题目大意 #  给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。\n要求:\n 该字符串只包含小写的英文字母。 给定字符串的长度和 k 在[1, 10000]范围内。  解题思路 #   要求按照一定规则反转字符串：每 2 * K 长度的字符串，反转前 K 个字符，后 K 个字符串保持不变；对于末尾不够 2 * K 的字符串，如果长度大于 K，那么反转前 K 个字符串，剩下的保持不变。如果长度小于 K，则把小于 K 的这部分字符串全部反转。 这一题是简单题，按照题意反转字符串即可。  代码 #  package leetcode func reverseStr(s string, k int) string { if k \u0026gt; len(s) { k = len(s) } for i := 0; i \u0026lt; len(s); i = i + 2*k { if len(s)-i \u0026gt;= k { ss := revers(s[i : i+k]) s = s[:i] + ss + s[i+k:] } else { ss := revers(s[i:]) s = s[:i] + ss } } return s } "});index.add({'id':285,'href':'/leetcode-java/04_Leetcode/0542.01-Matrix/','title':"0542.01 Matrix",'section':"第四章",'content':"542. 01 Matrix #  题目 #  Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\nExample 1:\nInput: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]]  Example 2:\nInput: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]]  Note:\n The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.  题目大意 #  给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。\n解题思路 #   给出一个二维数组，数组里面只有 0 和 1 。要求计算每个 1 距离最近的 0 的距离。 这一题有 3 种解法，第一种解法最容易想到，BFS。先预处理一下棋盘，将每个 0 都处理为 -1 。将 1 都处理为 0 。将每个 -1 (即原棋盘的 0)都入队，每次出队都将四周的 4 个位置都入队。这就想一颗石头扔进了湖里，一圈一圈的波纹荡开，每一圈都是一层。由于棋盘被我们初始化了，所有为 -1 的都是原来为 0 的，所以波纹扫过来不需要处理这些 -1 的点。棋盘上为 0 的点都是原来为 1 的点，这些点在波纹扫过来的时候就需要赋值更新 level。当下次波纹再次扫到原来为 1 的点的时候，由于它已经被第一次到的波纹更新了值，所以这次不用再更新了。(第一次波纹到的时候一定是最短的) 第二种解法是 DFS。先预处理，把周围没有 0 的 1 都重置为最大值。当周围有 0 的 1，距离 0 的位置都是 1，这些点是不需要动的，需要更新的点恰恰应该是那些周围没有 0 的点。当递归的步数 val 比点的值小(这也就是为什么会先把 1 更新成最大值的原因)的时候，不断更新它。 第三种解法是 DP。由于有 4 个方向，每次处理 2 个方向，可以降低时间复杂度。第一次循环从上到下，从左到右遍历，先处理上边和左边，第二次循环从下到上，从右到左遍历，再处理右边和下边。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) // 解法一 BFS func updateMatrixBFS(matrix [][]int) [][]int { res := make([][]int, len(matrix)) if len(matrix) == 0 || len(matrix[0]) == 0 { return res } queue := make([][]int, 0) for i := range matrix { res[i] = make([]int, len(matrix[0])) for j := range res[i] { if matrix[i][j] == 0 { res[i][j] = -1 queue = append(queue, []int{i, j}) } } } level := 1 for len(queue) \u0026gt; 0 { size := len(queue) for size \u0026gt; 0 { size-- node := queue[0] queue = queue[1:] i, j := node[0], node[1] for _, direction := range [][]int{{-1, 0}, {1, 0}, {0, 1}, {0, -1}} { x := i + direction[0] y := j + direction[1] if x \u0026lt; 0 || x \u0026gt;= len(matrix) || y \u0026lt; 0 || y \u0026gt;= len(matrix[0]) || res[x][y] \u0026lt; 0 || res[x][y] \u0026gt; 0 { continue } res[x][y] = level queue = append(queue, []int{x, y}) } } level++ } for i, row := range res { for j, cell := range row { if cell == -1 { res[i][j] = 0 } } } return res } // 解法二 DFS func updateMatrixDFS(matrix [][]int) [][]int { result := [][]int{} if len(matrix) == 0 || len(matrix[0]) == 0 { return result } maxRow, maxCol := len(matrix), len(matrix[0]) for r := 0; r \u0026lt; maxRow; r++ { for c := 0; c \u0026lt; maxCol; c++ { if matrix[r][c] == 1 \u0026amp;\u0026amp; hasZero(matrix, r, c) == false { // 将四周没有 0 的 1 特殊处理为最大值 \tmatrix[r][c] = math.MaxInt64 } } } for r := 0; r \u0026lt; maxRow; r++ { for c := 0; c \u0026lt; maxCol; c++ { if matrix[r][c] == 1 { dfsMatrix(matrix, r, c, -1) } } } return (matrix) } // 判断四周是否有 0 func hasZero(matrix [][]int, row, col int) bool { if row \u0026gt; 0 \u0026amp;\u0026amp; matrix[row-1][col] == 0 { return true } if col \u0026gt; 0 \u0026amp;\u0026amp; matrix[row][col-1] == 0 { return true } if row \u0026lt; len(matrix)-1 \u0026amp;\u0026amp; matrix[row+1][col] == 0 { return true } if col \u0026lt; len(matrix[0])-1 \u0026amp;\u0026amp; matrix[row][col+1] == 0 { return true } return false } func dfsMatrix(matrix [][]int, row, col, val int) { // 不超过棋盘氛围，且 val 要比 matrix[row][col] 小 \tif row \u0026lt; 0 || row \u0026gt;= len(matrix) || col \u0026lt; 0 || col \u0026gt;= len(matrix[0]) || (matrix[row][col] \u0026lt;= val) { return } if val \u0026gt; 0 { matrix[row][col] = val } dfsMatrix(matrix, row-1, col, matrix[row][col]+1) dfsMatrix(matrix, row, col-1, matrix[row][col]+1) dfsMatrix(matrix, row+1, col, matrix[row][col]+1) dfsMatrix(matrix, row, col+1, matrix[row][col]+1) } // 解法三 DP func updateMatrixDP(matrix [][]int) [][]int { for i, row := range matrix { for j, val := range row { if val == 0 { continue } left, top := math.MaxInt16, math.MaxInt16 if i \u0026gt; 0 { top = matrix[i-1][j] + 1 } if j \u0026gt; 0 { left = matrix[i][j-1] + 1 } matrix[i][j] = min(top, left) } } for i := len(matrix) - 1; i \u0026gt;= 0; i-- { for j := len(matrix[0]) - 1; j \u0026gt;= 0; j-- { if matrix[i][j] == 0 { continue } right, bottom := math.MaxInt16, math.MaxInt16 if i \u0026lt; len(matrix)-1 { bottom = matrix[i+1][j] + 1 } if j \u0026lt; len(matrix[0])-1 { right = matrix[i][j+1] + 1 } matrix[i][j] = min(matrix[i][j], min(bottom, right)) } } return matrix } "});index.add({'id':286,'href':'/leetcode-java/04_Leetcode/0547.Friend-Circles/','title':"0547. Friend Circles",'section':"第四章",'content':"547. Friend Circles #  题目 #  There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a directfriend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\nExample 1:\nInput: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.  Example 2:\nInput: [[1,1,0], [1,1,1], [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.  Note:\n N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.  题目大意 #  班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果 M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n注意：\n N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有 M[i][j] = 1，则有 M[j][i] = 1。  解题思路 #   给出一个二维矩阵，矩阵中的行列表示的是两个人之间是否是朋友关系，如果是 1，代表两个人是朋友关系。由于自己和自肯定朋友关系，所以对角线上都是 1，并且矩阵也是关于从左往右下的这条对角线对称。 这题有 2 种解法，第一种解法是并查集，依次扫描矩阵，如果两个人认识，并且 root 并不相等就执行 union 操作。扫完所有矩阵，最后数一下还有几个不同的 root 就是最终答案。第二种解法是 DFS 或者 BFS。利用 FloodFill 的想法去染色，每次染色一次，计数器加一。最终扫完整个矩阵，计数器的结果就是最终结果。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 并查集  func findCircleNum(M [][]int) int { n := len(M) if n == 0 { return 0 } uf := template.UnionFind{} uf.Init(n) for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt;= i; j++ { if M[i][j] == 1 { uf.Union(i, j) } } } return uf.TotalCount() } // 解法二 FloodFill DFS 暴力解法 func findCircleNum1(M [][]int) int { if len(M) == 0 { return 0 } visited := make([]bool, len(M)) res := 0 for i := range M { if !visited[i] { dfs547(M, i, visited) res++ } } return res } func dfs547(M [][]int, cur int, visited []bool) { visited[cur] = true for j := 0; j \u0026lt; len(M[cur]); j++ { if !visited[j] \u0026amp;\u0026amp; M[cur][j] == 1 { dfs547(M, j, visited) } } } "});index.add({'id':287,'href':'/leetcode-java/04_Leetcode/0557.Reverse-Words-in-a-String-III/','title':"0557. Reverse Words in a String I I I",'section':"第四章",'content':"557. Reverse Words in a String III #  题目 #  Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\nExample 1:\nInput: \u0026quot;Let's take LeetCode contest\u0026quot; Output: \u0026quot;s'teL ekat edoCteeL tsetnoc\u0026quot;  Note: In the string, each word is separated by single space and there will not be any extra space in the string.\n题目大意 #  给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。\n解题思路 #   反转字符串，要求按照空格隔开的小字符串为单位反转。 这是一道简单题。按照题意反转每个空格隔开的单词即可。  代码 #  package leetcode import ( \u0026#34;strings\u0026#34; ) func reverseWords(s string) string { ss := strings.Split(s, \u0026#34; \u0026#34;) for i, s := range ss { ss[i] = revers(s) } return strings.Join(ss, \u0026#34; \u0026#34;) } func revers(s string) string { bytes := []byte(s) i, j := 0, len(bytes)-1 for i \u0026lt; j { bytes[i], bytes[j] = bytes[j], bytes[i] i++ j-- } return string(bytes) } "});index.add({'id':288,'href':'/leetcode-java/04_Leetcode/0561.Array-Partition-I/','title':"0561. Array Partition I",'section':"第四章",'content':"561. Array Partition I #  题目 #  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), \u0026hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\nExample 1:\nInput: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note:\n n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].  题目大意 #  给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), \u0026hellip;, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。\n解题思路 #   给定一个 2n 个数组，要求把它们分为 n 组一行，求出各组最小值的总和的最大值。 由于题目给的数据范围不大，[-10000, 10000]，所以我们可以考虑用一个哈希表数组，里面存储 i - 10000 元素的频次，偏移量是 10000。这个哈希表能按递增的顺序访问数组，这样可以减少排序的耗时。题目要求求出分组以后求和的最大值，那么所有偏小的元素尽量都安排在一组里面，这样取 min 以后，对最大和影响不大。例如，(1 , 1) 这样安排在一起，min 以后就是 1 。但是如果把相差很大的两个元素安排到一起，那么较大的那个元素就“牺牲”了。例如，(1 , 10000)，取 min 以后就是 1，于是 10000 就“牺牲”了。所以需要优先考虑较小值。 较小值出现的频次可能是奇数也可能是偶数。如果是偶数，那比较简单，把它们俩俩安排在一起就可以了。如果是奇数，那么它会落单一次，落单的那个需要和距离它最近的一个元素进行配对，这样对最终的和影响最小。较小值如果是奇数，那么就会影响后面元素的选择，后面元素如果是偶数，由于需要一个元素和前面的较小值配对，所以它剩下的又是奇数个。这个影响会依次传递到后面。所以用一个 flag 标记，如果当前集合中有剩余元素将被再次考虑，则此标志设置为 1。在从下一组中选择元素时，会考虑已考虑的相同额外元素。 最后扫描过程中动态的维护 sum 值就可以了。  代码 #  package leetcode func arrayPairSum(nums []int) int { array := [20001]int{} for i := 0; i \u0026lt; len(nums); i++ { array[nums[i]+10000]++ } flag, sum := true, 0 for i := 0; i \u0026lt; len(array); i++ { for array[i] \u0026gt; 0 { if flag { sum = sum + i - 10000 } flag = !flag array[i]-- } } return sum } "});index.add({'id':289,'href':'/leetcode-java/04_Leetcode/0563.Binary-Tree-Tilt/','title':"0563. Binary Tree Tilt",'section':"第四章",'content':"563. 二叉树的坡度 #  Difficulty: 简单\n给定一个二叉树，计算 整个树 的坡度 。\n一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。\n整个树 的坡度就是其所有节点的坡度之和。\n示例 1：\n 输入：root = [1,2,3] 输出：1 解释： 节点 2 的坡度：|0-0| = 0（没有子节点） 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ） 坡度总和：0 + 0 + 1 = 1 示例 2：\n 输入：root = [4,2,9,3,5,null,7] 输出：15 解释： 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 5 的坡度：|0-0| = 0（没有子节点） 节点 7 的坡度：|0-0| = 0（没有子节点） 节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ） 节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ） 节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ） 坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 示例 3：\n 输入：root = [21,7,14,1,1,2,2,3,3] 输出：9 提示：\n 树中节点数目的范围在 [0, 10\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt;] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000  题解 #  题解一：DFS（深度优先遍历） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private int total = 0; public int findTilt(TreeNode root) { helper(root); return total; } private int helper(TreeNode node) { if (node == null) { return 0; } int left = helper(node.left); int right = helper(node.right); total += Math.abs(left - right); return left + right + node.val; } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(n)。\n  "});index.add({'id':290,'href':'/leetcode-java/04_Leetcode/0566.Reshape-the-Matrix/','title':"0566. Reshape the Matrix",'section':"第四章",'content':"566. Reshape the Matrix #  题目 #  In MATLAB, there is a very useful function called \u0026lsquo;reshape\u0026rsquo;, which can reshape a matrix into a new one with different size but keep its original data.\nYou\u0026rsquo;re given a matrix represented by a two-dimensional array, and two positive integers r and crepresenting the row number and column number of the wanted reshaped matrix, respectively.\nThe reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.\nIf the \u0026lsquo;reshape\u0026rsquo; operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\nExample 1:\nInput: nums = [[1,2], [3,4]] r = 1, c = 4 Output: [[1,2,3,4]] Explanation: The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.  Example 2:\nInput: nums = [[1,2], [3,4]] r = 2, c = 4 Output: [[1,2], [3,4]] Explanation: There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.  Note:\n The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.  题目大意 #  在 MATLAB 中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。\n给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。\n解题思路 #   给一个二维数组和 r，c，将这个二维数组“重塑”成行为 r，列为 c。如果可以“重塑”，输出“重塑”以后的数组，如果不能“重塑”，输出原有数组。 这题也是水题，按照题意模拟即可。  代码 #  package leetcode func matrixReshape(nums [][]int, r int, c int) [][]int { if canReshape(nums, r, c) { return reshape(nums, r, c) } return nums } func canReshape(nums [][]int, r, c int) bool { row := len(nums) colume := len(nums[0]) if row*colume == r*c { return true } return false } func reshape(nums [][]int, r, c int) [][]int { newShape := make([][]int, r) for index := range newShape { newShape[index] = make([]int, c) } rowIndex, colIndex := 0, 0 for _, row := range nums { for _, col := range row { if colIndex == c { colIndex = 0 rowIndex++ } newShape[rowIndex][colIndex] = col colIndex++ } } return newShape } "});index.add({'id':291,'href':'/leetcode-java/04_Leetcode/0567.Permutation-in-String/','title':"0567. Permutation in String",'section':"第四章",'content':"567. Permutation in String #  题目 #  Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\u0026rsquo;s permutations is the substring of the second string.\nExample 1:\n Input:s1 = \u0026quot;ab\u0026quot; s2 = \u0026quot;eidbaooo\u0026quot; Output:True Explanation: s2 contains one permutation of s1 (\u0026quot;ba\u0026quot;). Example 2:\n Input:s1= \u0026quot;ab\u0026quot; s2 = \u0026quot;eidboaoo\u0026quot; Output: False Note:\n The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].  题目大意 #  在一个字符串重寻找子串出现的位置。子串可以是 Anagrams 形式存在的。Anagrams 是一个字符串任意字符的全排列组合。\n解题思路 #  这一题和第 438 题，第 3 题，第 76 题，第 567 题类似，用的思想都是\u0026quot;滑动窗口\u0026quot;。\n这道题只需要判断是否存在，而不需要输出子串所在的下标起始位置。所以这道题是第 438 题的缩水版。具体解题思路见第 438 题。\n代码 #  package leetcode func checkInclusion(s1 string, s2 string) bool { var freq [256]int if len(s2) == 0 || len(s2) \u0026lt; len(s1) { return false } for i := 0; i \u0026lt; len(s1); i++ { freq[s1[i]-\u0026#39;a\u0026#39;]++ } left, right, count := 0, 0, len(s1) for right \u0026lt; len(s2) { if freq[s2[right]-\u0026#39;a\u0026#39;] \u0026gt;= 1 { count-- } freq[s2[right]-\u0026#39;a\u0026#39;]-- right++ if count == 0 { return true } if right-left == len(s1) { if freq[s2[left]-\u0026#39;a\u0026#39;] \u0026gt;= 0 { count++ } freq[s2[left]-\u0026#39;a\u0026#39;]++ left++ } } return false } "});index.add({'id':292,'href':'/leetcode-java/04_Leetcode/0572.Subtree-of-Another-Tree/','title':"0572. Subtree of Another Tree",'section':"第四章",'content':"572. Subtree of Another Tree #  题目 #  Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node\u0026rsquo;s descendants. The tree s could also be considered as a subtree of itself.\nExample 1:\nGiven tree s:\n 3 / \\ 4 5 / \\ 1 2  Given tree t:\n 4 / \\ 1 2  Return true, because t has the same structure and node values with a subtree of s.\nExample 2:\nGiven tree s:\n 3 / \\ 4 5 / \\ 1 2 / 0  Given tree t:\n 4 / \\ 1 2  Return false.\n题目大意 #  给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n解题思路 #   给出 2 棵树 s 和 t，要求判断 t 是否是 s 的子树🌲。 这一题比较简单，针对 3 种情况依次递归判断，第一种情况 s 和 t 是完全一样的两棵树，第二种情况 t 是 s 左子树中的子树，第三种情况 t 是 s 右子树中的子树。第一种情况判断两棵数是否完全一致是第 100 题的原题。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSubtree(s *TreeNode, t *TreeNode) bool { if isSameTree(s, t) { return true } if s == nil { return false } if isSubtree(s.Left, t) || isSubtree(s.Right, t) { return true } return false } "});index.add({'id':293,'href':'/leetcode-java/04_Leetcode/0575.Distribute-Candies/','title':"0575. Distribute Candies",'section':"第四章",'content':"575. Distribute Candies #  题目 #  Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.\nExample 1:\nInput: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies.  Example 2:\nInput: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies.  Note:\n The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].  题目大意 #  给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。\n解题思路 #   给出一个糖果数组，里面每个元素代表糖果的种类，相同数字代表相同种类。把这些糖果分给兄弟姐妹，问姐妹最多可以分到多少种糖果。这一题比较简单，用 map 统计每个糖果的出现频次，如果总数比 n/2 小，那么就返回 len(map)，否则返回 n/2 (即一半都分给姐妹)。  代码 #  package leetcode func distributeCandies(candies []int) int { n, m := len(candies), make(map[int]struct{}, len(candies)) for _, candy := range candies { m[candy] = struct{}{} } res := len(m) if n/2 \u0026lt; res { return n / 2 } return res } "});index.add({'id':294,'href':'/leetcode-java/04_Leetcode/0589.N-Ary-Tree-Preorder-Traversal/','title':"0589. N Ary Tree Preorder Traversal",'section':"第四章",'content':"589. N叉树的前序遍历 #  Difficulty: 简单\n给定一个 N 叉树，返回其节点值的_前序遍历_。\n例如，给定一个 3叉树 :\n 返回其前序遍历: [1,3,5,6,2,4]。\n说明： 递归法很简单，你可以使用迭代法完成此题吗?\n题解 #  解法一：递归求解 #  /* // Definition for a Node. class Node { public int val; public List\u0026lt;Node\u0026gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List\u0026lt;Node\u0026gt; _children) { val = _val; children = _children; } }; */ class Solution { public List\u0026lt;Integer\u0026gt; preorder(Node root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); helper(root, result); return result; } private void helper(Node node, List\u0026lt;Integer\u0026gt; result) { if (node == null) { return; } result.add(node.val); for (Node n : node.children) { helper(n, result); } } } 解法二：Stack 数据结构 #  /* // Definition for a Node. class Node { public int val; public List\u0026lt;Node\u0026gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List\u0026lt;Node\u0026gt; _children) { val = _val; children = _children; } }; */ class Solution { public List\u0026lt;Integer\u0026gt; preorder(Node root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Stack\u0026lt;Node\u0026gt; stack = new Stack\u0026lt;Node\u0026gt;(); stack.add(root); while(!stack.isEmpty()) { Node n = stack.pop(); result.add(n.val); Collections.reverse(n.children); for (Node item : n.children) { stack.add(item); } } return result; } } 解法三：使用 Queue 模拟 Stack #  /* // Definition for a Node. class Node { public int val; public List\u0026lt;Node\u0026gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List\u0026lt;Node\u0026gt; _children) { val = _val; children = _children; } }; */ class Solution { public List\u0026lt;Integer\u0026gt; preorder(Node root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Deque\u0026lt;Node\u0026gt; stack = new LinkedList\u0026lt;Node\u0026gt;(); stack.add(root); while(!stack.isEmpty()) { Node n = stack.pollLast(); result.add(n.val); Collections.reverse(n.children); for (Node item : n.children) { stack.add(item); } } return result; } } "});index.add({'id':295,'href':'/leetcode-java/04_Leetcode/0594.Longest-Harmonious-Subsequence/','title':"0594. Longest Harmonious Subsequence",'section':"第四章",'content':"594. Longest Harmonious Subsequence #  题目 #  We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nNow, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\nExample 1:\nInput: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].  Note: The length of the input array will not exceed 20,000.\n题目大意 #  和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。说明: 输入的数组长度最大不超过20,000.\n解题思路 #   在给出的数组里面找到这样一个子数组：要求子数组中的最大值和最小值相差 1 。这一题是简单题。先统计每个数字出现的频次，然后在 map 找相差 1 的 2 个数组的频次和，动态的维护两个数的频次和就是最后要求的子数组的最大长度。  代码 #  package leetcode func findLHS(nums []int) int { if len(nums) \u0026lt; 2 { return 0 } res := make(map[int]int, len(nums)) for _, num := range nums { if _, exist := res[num]; exist { res[num]++ continue } res[num] = 1 } longest := 0 for k, c := range res { if n, exist := res[k+1]; exist { if c+n \u0026gt; longest { longest = c + n } } } return longest } "});index.add({'id':296,'href':'/leetcode-java/04_Leetcode/0598.Range-Addition-II/','title':"0598. Range Addition I I",'section':"第四章",'content':"598. Range Addition II #  题目 #  Given an m * n matrix M initialized with all 0\u0026rsquo;s and several update operations.\nOperations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 \u0026lt;= i \u0026lt; a and 0 \u0026lt;= j \u0026lt; b.\nYou need to count and return the number of maximum integers in the matrix after performing all the operations.\nExample 1:\nInput: m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation: Initially, M = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] After performing [2,2], M = [[1, 1, 0], [1, 1, 0], [0, 0, 0]] After performing [3,3], M = [[2, 2, 1], [2, 2, 1], [1, 1, 1]] So the maximum integer in M is 2, and there are four of it in M. So return 4. Note:\n The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won\u0026rsquo;t exceed 10,000.  题目大意 #  给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 \u0026lt;= i \u0026lt; a 以及 0 \u0026lt;= j \u0026lt; b 的元素 M[i][j] 的值都增加 1。在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。\n注意:\n m 和 n 的范围是 [1,40000]。 a 的范围是 [1,m]，b 的范围是 [1,n]。 操作数目不超过 10000。  解题思路 #   给定一个初始都为 0 的 m * n 的矩阵，和一个操作数组。经过一系列的操作以后，最终输出矩阵中最大整数的元素个数。每次操作都使得一个矩形内的元素都 + 1 。 这一题乍一看像线段树的区间覆盖问题，但是实际上很简单。如果此题是任意的矩阵，那就可能用到线段树了。这一题每个矩阵的起点都包含 [0 , 0] 这个元素，也就是说每次操作都会影响第一个元素。那么这道题就很简单了。经过 n 次操作以后，被覆盖次数最多的矩形区间，一定就是最大整数所在的区间。由于起点都是第一个元素，所以我们只用关心矩形的右下角那个坐标。右下角怎么计算呢？只用每次动态的维护一下矩阵长和宽的最小值即可。  代码 #  package leetcode func maxCount(m int, n int, ops [][]int) int { minM, minN := m, n for _, op := range ops { minM = min(minM, op[0]) minN = min(minN, op[1]) } return minM * minN } func min(a, b int) int { if a \u0026lt; b { return a } return b } "});index.add({'id':297,'href':'/leetcode-java/04_Leetcode/0599.Minimum-Index-Sum-of-Two-Lists/','title':"0599. Minimum Index Sum of Two Lists",'section':"第四章",'content':"599. Minimum Index Sum of Two Lists #  题目 #  Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.\nYou need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\nExample 1:\nInput: [\u0026quot;Shogun\u0026quot;, \u0026quot;Tapioca Express\u0026quot;, \u0026quot;Burger King\u0026quot;, \u0026quot;KFC\u0026quot;] [\u0026quot;Piatti\u0026quot;, \u0026quot;The Grill at Torrey Pines\u0026quot;, \u0026quot;Hungry Hunter Steakhouse\u0026quot;, \u0026quot;Shogun\u0026quot;] Output: [\u0026quot;Shogun\u0026quot;] Explanation: The only restaurant they both like is \u0026quot;Shogun\u0026quot;.  Example 2:\nInput: [\u0026quot;Shogun\u0026quot;, \u0026quot;Tapioca Express\u0026quot;, \u0026quot;Burger King\u0026quot;, \u0026quot;KFC\u0026quot;] [\u0026quot;KFC\u0026quot;, \u0026quot;Shogun\u0026quot;, \u0026quot;Burger King\u0026quot;] Output: [\u0026quot;Shogun\u0026quot;] Explanation: The restaurant they both like and have the least index sum is \u0026quot;Shogun\u0026quot; with index sum 1 (0+1).  Note:\n The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.  题目大意 #  假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。\n提示:\n 两个列表的长度范围都在 [1, 1000] 内。 两个列表中的字符串的长度将在 [1，30] 的范围内。 下标从 0 开始，到列表的长度减 1。 两个列表都没有重复的元素。  解题思路 #   在 Andy 和 Doris 两人分别有各自的餐厅喜欢列表，要求找出两人公共喜欢的一家餐厅，如果共同喜欢的次数相同，都输出。这一题是简单题，用 map 统计频次，输出频次最多的餐厅。  代码 #  package leetcode func findRestaurant(list1 []string, list2 []string) []string { m, ans := make(map[string]int, len(list1)), []string{} for i, r := range list1 { m[r] = i } for j, r := range list2 { if _, ok := m[r]; ok { m[r] += j if len(ans) == 0 || m[r] == m[ans[0]] { ans = append(ans, r) } else if m[r] \u0026lt; m[ans[0]] { ans = []string{r} } } } return ans } "});index.add({'id':298,'href':'/leetcode-java/04_Leetcode/0606.Construct-String-From-Binary-Tree/','title':"0606. Construct String From Binary Tree",'section':"第四章",'content':"606. 根据二叉树创建字符串 #  Difficulty: 简单\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n空节点则用一对空括号 \u0026ldquo;()\u0026rdquo; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n示例 1:\n输入: 二叉树: [1,2,3,4] 1 / \\  2 3 / 4 输出: \u0026#34;1(2(4))(3)\u0026#34; 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2:\n输入: 二叉树: [1,2,3,null,4] 1 / \\  2 3 \\  4 输出: \u0026#34;1(2()(4))(3)\u0026#34; 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public String tree2str(TreeNode t) { if (t == null) { return \u0026#34;\u0026#34;; } if (t.left == null \u0026amp;\u0026amp; t.right == null) { return String.valueOf(t.val); } if (t.right == null) { return t.val + \u0026#34;(\u0026#34; + tree2str(t.left) + \u0026#34;)\u0026#34;; } return t.val + \u0026#34;(\u0026#34; + tree2str(t.left) + \u0026#34;)(\u0026#34; + tree2str(t.right) + \u0026#34;)\u0026#34;; } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(N)。\n  "});index.add({'id':299,'href':'/leetcode-java/04_Leetcode/0617.Merge-Two-Binary-Trees/','title':"0617. Merge Two Binary Trees",'section':"第四章",'content':"617. 合并二叉树 #  Difficulty: 简单\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为 **NULL 的节点将直接作为新二叉树的节点。\n示例 1:\n输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。\n题解 #  题解一：递归 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null \u0026amp;\u0026amp; t2 == null) { return null; } if (t1 == null) { return t2; } if (t2 == null) { return t1; } TreeNode node = new TreeNode(t1.val + t2.val); node.left = mergeTrees(t1.left, t2.left); node.right = mergeTrees(t1.right, t2.right); return node; } } 复杂度分析\n  时间复杂度：O(min(m, n))。\n  空间复杂度：O(min(m, n))。\n  "});index.add({'id':300,'href':'/leetcode-java/04_Leetcode/0628.Maximum-Product-of-Three-Numbers/','title':"0628. Maximum Product of Three Numbers",'section':"第四章",'content':"628. 三个数的最大乘积 #  Difficulty: 简单\n给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。\n示例 1:\n输入: [1,2,3] 输出: 6 示例 2:\n输入: [1,2,3,4] 输出: 24 注意:\n 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。  题解 #  题解一：排序 #  class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); } } 复杂度分析 #    时间复杂度：O(NlogN)，其中 N 是数组的长度。\n  空间复杂度：O(logN)，为排序使用的空间。\n  题解二： #  class Solution { public int maximumProduct(int[] nums) { int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; for (int n : nums) { if (n \u0026lt; min1) { min2 = min1; min1 = n; } else if (n \u0026lt; min2) { min2 = n; } if (n \u0026gt; max1) { max3 = max2; max2 = max1; max1 = n; } else if (n \u0026gt; max2) { max3 = max2; max2 = n; } else if (n \u0026gt; max3) { max3 = n; } } return Math.max(min1 * min2 * max1, max1 * max2 * max3); } } 复杂度分析 #    时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  "});index.add({'id':301,'href':'/leetcode-java/04_Leetcode/0632.Smallest-Range-Covering-Elements-from-K-Lists/','title':"0632. Smallest Range Covering Elements From K Lists",'section':"第四章",'content':"632. Smallest Range Covering Elements from K Lists #  题目 #  You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a,b] is smaller than range [c,d] if b-a \u0026lt; d-c or a \u0026lt; c if b-a == d-c.\nExample 1:\nInput: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].  Note:\n The given list may contain duplicates, so ascending order means \u0026gt;= here. 1 \u0026lt;= k \u0026lt;= 3500 -10^5 \u0026lt;= value of elements \u0026lt;= 10^5.  题目大意 #  你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。\n我们定义如果 b-a \u0026lt; d-c 或者在 b-a == d-c 时 a \u0026lt; c，则区间 [a,b] 比 [c,d] 小。\n注意:\n 给定的列表可能包含重复元素，所以在这里升序表示 \u0026gt;= 。 1 \u0026lt;= k \u0026lt;= 3500 -105 \u0026lt;= 元素的值 \u0026lt;= 105 对于使用Java的用户，请注意传入类型已修改为List\u0026lt;List\u0026gt;。重置代码模板后可以看到这项改动。  解题思路 #   给出 K 个数组，要求在这 K 个数组中找到一个区间，至少能包含这 K 个数组中每个数组中的一个元素。 这一题是第 76 题的变种版。第 76 题是用滑动窗口来解答的，它要求在母字符串 S 中找到最小的子串能包含 T 串的所有字母。这一题类似的，可以把母字符串看成 K 个数组合并起来的大数组，那么 T 串是由 K 个数组中每个数组中抽一个元素出来组成的。求的区间相同，都是能包含 T 的最小区间。另外一个区别在于，第 76 题里面都是字符串，这一题都是数字，在最终拼接成 T 串的时候需要保证 K 个数组中每个都有一个元素，所以理所当然的想到需要维护每个元素所在数组编号。经过上述的转换，可以把这道题转换成第 76 题的解法了。 在具体解题过程中，用 map 来维护窗口内 K 个数组出现的频次。时间复杂度 O(n*log n)，空间复杂度是O(n)。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) func smallestRange(nums [][]int) []int { numList, left, right, count, freqMap, res, length := []element{}, 0, -1, 0, map[int]int{}, make([]int, 2), math.MaxInt64 for i, ns := range nums { for _, v := range ns { numList = append(numList, element{val: v, index: i}) } } sort.Sort(SortByVal{numList}) for left \u0026lt; len(numList) { if right+1 \u0026lt; len(numList) \u0026amp;\u0026amp; count \u0026lt; len(nums) { right++ if freqMap[numList[right].index] == 0 { count++ } freqMap[numList[right].index]++ } else { if count == len(nums) { if numList[right].val-numList[left].val \u0026lt; length { length = numList[right].val - numList[left].val res[0] = numList[left].val res[1] = numList[right].val } } freqMap[numList[left].index]-- if freqMap[numList[left].index] == 0 { count-- } left++ } } return res } type element struct { val int index int } type elements []element // Len define func (p elements) Len() int { return len(p) } // Swap define func (p elements) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // SortByVal define type SortByVal struct{ elements } // Less define func (p SortByVal) Less(i, j int) bool { return p.elements[i].val \u0026lt; p.elements[j].val } "});index.add({'id':302,'href':'/leetcode-java/04_Leetcode/0633.Sum-of-Square-Numbers/','title':"0633. Sum of Square Numbers",'section':"第四章",'content':"633. Sum of Square Numbers #  题目 #  Given a non-negative integer c, your task is to decide whether there\u0026rsquo;re two integers a and b such that a^2 + b^2 = c.\nExample 1:\nInput: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5  Example 2:\nInput: 3 Output: False  题目大意 #  给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。\n解题思路 #   给出一个数，要求判断这个数能否由由 2 个完全平方数组成。能则输出 true，不能则输出 false。 可以用二分搜索来解答这道题。判断题意，依次计算 low * low + high * high 和 c 是否相等。从 [0, sqrt(n)] 区间内进行二分，若能找到则返回 true，找不到就返回 false 。  代码 #  package leetcode import \u0026#34;math\u0026#34; func judgeSquareSum(c int) bool { low, high := 0, int(math.Sqrt(float64(c))) for low \u0026lt;= high { if low*low+high*high \u0026lt; c { low++ } else if low*low+high*high \u0026gt; c { high-- } else { return true } } return false } "});index.add({'id':303,'href':'/leetcode-java/04_Leetcode/0636.Exclusive-Time-of-Functions/','title':"0636. Exclusive Time of Functions",'section':"第四章",'content':"636. Exclusive Time of Functions #  题目 #  On a single threaded CPU, we execute some functions. Each function has a unique id between 0 and N-1.\nWe store logs in timestamp order that describe when a function is entered or exited.\nEach log is a string with this format: \u0026quot;{function_id}:{\u0026quot;start\u0026quot; | \u0026quot;end\u0026quot;}:{timestamp}\u0026quot;. For example, \u0026quot;0:start:3\u0026quot; means the function with id 0 started at the beginning of timestamp 3. \u0026quot;1🔚2\u0026quot; means the function with id 1 ended at the end of timestamp 2.\nA function\u0026rsquo;s exclusive time is the number of units of time spent in this function. Note that this does not include any recursive calls to child functions.\nReturn the exclusive time of each function, sorted by their function id.\nExample 1:\n Input: n = 2 logs = [\u0026quot;0:start:0\u0026quot;,\u0026quot;1:start:2\u0026quot;,\u0026quot;1🔚5\u0026quot;,\u0026quot;0🔚6\u0026quot;] Output: [3, 4] Explanation: Function 0 starts at the beginning of time 0, then it executes 2 units of time and reaches the end of time 1. Now function 1 starts at the beginning of time 2, executes 4 units of time and ends at time 5. Function 0 is running again at the beginning of time 6, and also ends at the end of time 6, thus executing for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.  Note:\n 1 \u0026lt;= n \u0026lt;= 100 Two functions won\u0026rsquo;t start or end at the same time. Functions will always log when they exit.  题目大意 #  给出一个非抢占单线程CPU的 n 个函数运行日志，找到函数的独占时间。每个函数都有一个唯一的 Id，从 0 到 n-1，函数可能会递归调用或者被其他函数调用。\n日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：\u0026ldquo;0:start:0\u0026rdquo; 表示函数 0 从 0 时刻开始运行。\u0026ldquo;0🔚0\u0026rdquo; 表示函数 0 在 0 时刻结束。\n函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。\n解题思路 #   利用栈记录每一个开始了但是未完成的任务，完成以后任务就 pop 一个。 注意题目中关于任务时长的定义，例如，start 7，end 7，这个任务执行了 1 秒而不是 0 秒  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) type log struct { id int order string time int } func exclusiveTime(n int, logs []string) []int { res, lastLog, stack := make([]int, n), log{id: -1, order: \u0026#34;\u0026#34;, time: 0}, []log{} for i := 0; i \u0026lt; len(logs); i++ { a := strings.Split(logs[i], \u0026#34;:\u0026#34;) id, _ := strconv.Atoi(a[0]) time, _ := strconv.Atoi(a[2]) if (lastLog.order == \u0026#34;start\u0026#34; \u0026amp;\u0026amp; a[1] == \u0026#34;start\u0026#34;) || (lastLog.order == \u0026#34;start\u0026#34; \u0026amp;\u0026amp; a[1] == \u0026#34;end\u0026#34;) { res[lastLog.id] += time - lastLog.time if a[1] == \u0026#34;end\u0026#34; { res[lastLog.id]++ } } if lastLog.order == \u0026#34;end\u0026#34; \u0026amp;\u0026amp; a[1] == \u0026#34;end\u0026#34; { res[id] += time - lastLog.time } if lastLog.order == \u0026#34;end\u0026#34; \u0026amp;\u0026amp; a[1] == \u0026#34;start\u0026#34; \u0026amp;\u0026amp; len(stack) != 0 { res[stack[len(stack)-1].id] += time - lastLog.time - 1 } if a[1] == \u0026#34;start\u0026#34; { stack = append(stack, log{id: id, order: a[1], time: time}) } else { stack = stack[:len(stack)-1] } lastLog = log{id: id, order: a[1], time: time} } return res } "});index.add({'id':304,'href':'/leetcode-java/04_Leetcode/0637.Average-of-Levels-in-Binary-Tree/','title':"0637. Average of Levels in Binary Tree",'section':"第四章",'content':"637. Average of Levels in Binary Tree #  题目 #  Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\nExample 1:\n Input: 3 / \\ 9 20 / \\ 15 7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note:\nThe range of node\u0026rsquo;s value is in the range of 32-bit signed integer.\n题目大意 #  按层序从上到下遍历一颗树，计算每一层的平均值。\n解题思路 #   用一个队列即可实现。 第 102 题和第 107 题都是按层序遍历的。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func averageOfLevels(root *TreeNode) []float64 { if root == nil { return []float64{0} } queue := []*TreeNode{} queue = append(queue, root) curNum, nextLevelNum, res, count, sum := 1, 0, []float64{}, 1, 0 for len(queue) != 0 { if curNum \u0026gt; 0 { node := queue[0] if node.Left != nil { queue = append(queue, node.Left) nextLevelNum++ } if node.Right != nil { queue = append(queue, node.Right) nextLevelNum++ } curNum-- sum += node.Val queue = queue[1:] } if curNum == 0 { res = append(res, float64(sum)/float64(count)) curNum, count, nextLevelNum, sum = nextLevelNum, nextLevelNum, 0, 0 } } return res } "});index.add({'id':305,'href':'/leetcode-java/04_Leetcode/0638.Shopping-Offers/','title':"0638. Shopping Offers",'section':"第四章",'content':"638. Shopping Offers #  题目 #  In LeetCode Store, there are some kinds of items to sell. Each item has a price.\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\nYou are given the each item\u0026rsquo;s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\nYou could use any of special offers as many times as you want.\nExample 1:\nInput: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example 2:\nInput: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. Note:\n There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.  题目大意 #  在 LeetCode 商店中， 有许多在售的物品。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。\n现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。任意大礼包可无限次购买。\n例子 1:\n输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 例子 2:\n输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 说明:\n 最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  解题思路 #   给出 3 个数组，3 个数组分别代表的意义是在售的商品价格，多个礼包以及礼包内每个商品的数量和总价，购物清单上需要购买每个商品的数量。问购买清单上的所有商品所需的最低花费。 这一题可以用 DFS 暴力解题，也可以用 DP。笔者这题先用 DFS 来解答。设当前搜索到的状态为 shopping(price, special, needs)，其中 price 和 special 为题目中所述的物品的单价和捆绑销售的大礼包，而 needs 为当前需要的每种物品的数量。针对于每个商品，可以有 3 种购买规则，第一种，选礼包里面的第一个优惠购买，第二种，不选当前礼包优惠，选下一个优惠进行购买，第三种，不使用优惠，直接购买。这样就对应了 3 种 DFS 的方向。具体见代码。如果选择了礼包优惠，那么递归到下一层，need 需要对应减少礼包里面的数量，最终金额累加。当所有情况遍历完以后，可以返回出最小花费。 这一题需要注意的剪枝情况：是否需要购买礼包。题目中要求了，不能购买超过清单上数量的商品，即使价格便宜，也不行。例如可以买 n 个礼包 A，但是最终商品数量超过了清单上的商品，这种购买方式是不行的。所以需要先判断当前递归中，满足 need 和 price 条件的，能否使用礼包。这里包含 2 种情况，一种是当前商品已经满足清单个数了，不需要再买了；还有一种情况是已经超过清单数量了，那这种情况需要立即返回，当前这种购买方式不合题意。  代码 #  func shoppingOffers(price []int, special [][]int, needs []int) int { res := -1 dfsShoppingOffers(price, special, needs, 0, \u0026amp;res) return res } func dfsShoppingOffers(price []int, special [][]int, needs []int, pay int, res *int) { noNeeds := true // 剪枝 \tfor _, need := range needs { if need \u0026lt; 0 { return } if need != 0 { noNeeds = false } } if len(special) == 0 || noNeeds { for i, p := range price { pay += (p * needs[i]) } if pay \u0026lt; *res || *res == -1 { *res = pay } return } newNeeds := make([]int, len(needs)) copy(newNeeds, needs) for i, n := range newNeeds { newNeeds[i] = n - special[0][i] } dfsShoppingOffers(price, special, newNeeds, pay+special[0][len(price)], res) dfsShoppingOffers(price, special[1:], newNeeds, pay+special[0][len(price)], res) dfsShoppingOffers(price, special[1:], needs, pay, res) } "});index.add({'id':306,'href':'/leetcode-java/04_Leetcode/0645.Set-Mismatch/','title':"0645. Set Mismatch",'section':"第四章",'content':"645. Set Mismatch #  题目 #  The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\nExample 1:\nInput: nums = [1,2,2,4] Output: [2,3]  Note:\n The given array size will in the range [2, 10000]. The given array\u0026rsquo;s numbers won\u0026rsquo;t have any order.  题目大意 #  集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。\n注意:\n 给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。  解题思路 #   给出一个数组，数组里面装的是 1-n 的数字，由于错误导致有一个数字变成了另外一个数字，要求找出重复的一个数字和正确的数字。这一题是简单题，根据下标比对就可以找到哪个数字重复了，哪个数字缺少了。  代码 #  package leetcode func findErrorNums(nums []int) []int { m, res := make([]int, len(nums)), make([]int, 2) for _, n := range nums { if m[n-1] == 0 { m[n-1] = 1 } else { res[0] = n } } for i := range m { if m[i] == 0 { res[1] = i + 1 break } } return res } "});index.add({'id':307,'href':'/leetcode-java/04_Leetcode/0648.Replace-Words/','title':"0648. Replace Words",'section':"第四章",'content':"648. Replace Words #  题目 #  In English, we have a concept called root, which can be followed by some other words to form another longer word - let\u0026rsquo;s call this word successor. For example, the root an, followed by other, which can form another word another.\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\nYou need to output the sentence after the replacement.\nExample 1:\nInput: dict = [\u0026quot;cat\u0026quot;, \u0026quot;bat\u0026quot;, \u0026quot;rat\u0026quot;] sentence = \u0026quot;the cattle was rattled by the battery\u0026quot; Output: \u0026quot;the cat was rat by the bat\u0026quot;  Note:\n The input will only have lower-case letters. 1 \u0026lt;= dict words number \u0026lt;= 1000 1 \u0026lt;= sentence words number \u0026lt;= 1000 1 \u0026lt;= root length \u0026lt;= 100 1 \u0026lt;= sentence words length \u0026lt;= 1000  题目大意 #  在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。\n现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。要求输出替换之后的句子。\n解题思路 #   给出一个句子和一个可替换字符串的数组，如果句子中的单词和可替换列表里面的单词，有相同的首字母，那么就把句子中的单词替换成可替换列表里面的单词。输入最后替换完成的句子。 这一题有 2 种解题思路，第一种就是单纯的用 Map 查找。第二种是用 Trie 去替换。  代码 #  package leetcode import \u0026#34;strings\u0026#34; // 解法一 哈希表 func replaceWords(dict []string, sentence string) string { roots := make(map[byte][]string) for _, root := range dict { b := root[0] roots[b] = append(roots[b], root) } words := strings.Split(sentence, \u0026#34; \u0026#34;) for i, word := range words { b := []byte(word) for j := 1; j \u0026lt; len(b) \u0026amp;\u0026amp; j \u0026lt;= 100; j++ { if findWord(roots, b[0:j]) { words[i] = string(b[0:j]) break } } } return strings.Join(words, \u0026#34; \u0026#34;) } func findWord(roots map[byte][]string, word []byte) bool { if roots[word[0]] == nil { return false } for _, root := range roots[word[0]] { if root == string(word) { return true } } return false } //解法二 Trie func replaceWords1(dict []string, sentence string) string { trie := Constructor208() for _, v := range dict { trie.Insert(v) } words := strings.Split(sentence, \u0026#34; \u0026#34;) var result []string word := \u0026#34;\u0026#34; i := 0 for _, value := range words { word = \u0026#34;\u0026#34; for i = 1; i \u0026lt; len(value); i++ { if trie.Search(value[:i]) { word = value[:i] break } } if len(word) == 0 { result = append(result, value) } else { result = append(result, word) } } return strings.Join(result, \u0026#34; \u0026#34;) } "});index.add({'id':308,'href':'/leetcode-java/04_Leetcode/0653.Two-Sum-IV-Input-is-a-BST/','title':"0653. Two Sum I v Input Is a B S T",'section':"第四章",'content':"653. Two Sum IV - Input is a BST #  题目 #  Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.\nExample 1:\nInput: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 Output: True  Example 2:\nInput: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 Output: False  题目大意 #  给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n解题思路 #   在树中判断是否存在 2 个数的和是 sum。 这一题是 two sum 问题的变形题，只不过题目背景是在 BST 上处理的。处理思路大体一致，用 map 记录已经访问过的节点值。边遍历树边查看 map 里面是否有 sum 的另外一半。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findTarget(root *TreeNode, k int) bool { m := make(map[int]int, 0) return findTargetDFS(root, k, m) } func findTargetDFS(root *TreeNode, k int, m map[int]int) bool { if root == nil { return false } if _, ok := m[k-root.Val]; ok { return ok } m[root.Val]++ return findTargetDFS(root.Left, k, m) || findTargetDFS(root.Right, k, m) } "});index.add({'id':309,'href':'/leetcode-java/04_Leetcode/0658.Find-K-Closest-Elements/','title':"0658. Find K Closest Elements",'section':"第四章",'content':"658. Find K Closest Elements #  题目 #  Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.\nExample 1:\nInput: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]  Example 2:\nInput: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]  Note:\n The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 10^4 Absolute value of elements in the array and x will not exceed 10^4   UPDATE (2017/9/19): The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.\n题目大意 #  给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。\n说明:\n k 的值为正数，且总是小于给定排序数组的长度。 数组不为空，且长度不超过 104 数组里的每个元素与 x 的绝对值不超过 104   更新(2017/9/19): 这个参数 arr 已经被改变为一个整数数组（而不是整数列表）。 请重新加载代码定义以获取最新更改。\n解题思路 #   给出一个数组，要求在数组中找到一个长度为 k 的区间，这个区间内每个元素距离 x 的距离都是整个数组里面最小的。 这一题可以用双指针解题，最优解法是二分搜索。由于区间长度固定是 K 个，所以左区间最大只能到 len(arr) - K (因为长度为 K 以后，正好右区间就到数组最右边了)，在 [0,len(arr) - K] 这个区间中进行二分搜索。如果发现 a[mid] 与 x 距离比 a[mid + k] 与 x 的距离要大，说明要找的区间一定在右侧，继续二分，直到最终 low = high 的时候退出。逼出的 low 值就是最终答案区间的左边界。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 库函数二分搜索 func findClosestElements(arr []int, k int, x int) []int { return arr[sort.Search(len(arr)-k, func(i int) bool { return x-arr[i] \u0026lt;= arr[i+k]-x }):][:k] } // 解法二 手撸二分搜索 func findClosestElements1(arr []int, k int, x int) []int { low, high := 0, len(arr)-k for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if x-arr[mid] \u0026gt; arr[mid+k]-x { low = mid + 1 } else { high = mid } } return arr[low : low+k] } "});index.add({'id':310,'href':'/leetcode-java/04_Leetcode/0661.Image-Smoother/','title':"0661. Image Smoother",'section':"第四章",'content':"661. Image Smoother #  题目 #  Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.\nExample 1:\nInput: [[1,1,1], [1,0,1], [1,1,1]] Output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Note:\n The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].  题目大意 #  包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。\n注意:\n 给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。  解题思路 #   将二维数组中的每个元素变为周围 9 个元素的平均值。 简单题，按照题意计算平均值即可。需要注意的是边界问题，四个角和边上的元素，这些点计算平均值的时候，计算平均值都不足 9 个元素。  代码 #  package leetcode func imageSmoother(M [][]int) [][]int { res := make([][]int, len(M)) for i := range M { res[i] = make([]int, len(M[0])) } for y := 0; y \u0026lt; len(M); y++ { for x := 0; x \u0026lt; len(M[0]); x++ { res[y][x] = smooth(x, y, M) } } return res } func smooth(x, y int, M [][]int) int { count, sum := 1, M[y][x] // Check bottom \tif y+1 \u0026lt; len(M) { sum += M[y+1][x] count++ } // Check Top \tif y-1 \u0026gt;= 0 { sum += M[y-1][x] count++ } // Check left \tif x-1 \u0026gt;= 0 { sum += M[y][x-1] count++ } // Check Right \tif x+1 \u0026lt; len(M[y]) { sum += M[y][x+1] count++ } // Check Coners \t// Top Left \tif y-1 \u0026gt;= 0 \u0026amp;\u0026amp; x-1 \u0026gt;= 0 { sum += M[y-1][x-1] count++ } // Top Right \tif y-1 \u0026gt;= 0 \u0026amp;\u0026amp; x+1 \u0026lt; len(M[0]) { sum += M[y-1][x+1] count++ } // Bottom Left \tif y+1 \u0026lt; len(M) \u0026amp;\u0026amp; x-1 \u0026gt;= 0 { sum += M[y+1][x-1] count++ } //Bottom Right \tif y+1 \u0026lt; len(M) \u0026amp;\u0026amp; x+1 \u0026lt; len(M[0]) { sum += M[y+1][x+1] count++ } return sum / count } "});index.add({'id':311,'href':'/leetcode-java/04_Leetcode/0662.Maximum-Width-of-Binary-Tree/','title':"0662. Maximum Width of Binary Tree",'section':"第四章",'content':"662. Maximum Width of Binary Tree #  题目 #  Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.\nThe width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.\nExample 1:\nInput: 1 / \\ 3 2 / \\ \\ 5 3 9 Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2:\nInput: 1 / 3 / \\ 5 3 Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3:\nInput: 1 / \\ 3 2 / 5 Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4:\nInput: 1 / \\ 3 2 / \\ 5 9 / \\ 6 7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).  Note: Answer will in the range of 32-bit signed integer.\n题目大意 #  给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n注意: 答案在32位有符号整数的表示范围内。\n解题思路 #   给出一个二叉树，求这棵树最宽的部分。 这一题可以用 BFS 也可以用 DFS，但是用 BFS 比较方便。按照层序遍历，依次算出每层最左边不为 null 的节点和最右边不为 null 的节点。这两个节点之间都是算宽度的。最终输出最大的宽度即可。此题的关键在于如何有效的找到每一层的左右边界。 这一题可能有人会想着先补全满二叉树，然后每层分别找左右边界。这种方法提交以后会卡在 104 / 108 这组测试用例上，这组测试用例会使得最后某几层填充出现的满二叉树节点特别多，最终导致 Memory Limit Exceeded 了。 由于此题要找每层的左右边界，实际上每个节点的 Val 值是我们不关心的，那么可以把这个值用来标号，标记成该节点在每层中的序号。父亲节点在上一层中的序号是 x，那么它的左孩子在下一层满二叉树中的序号是 2*x，它的右孩子在下一层满二叉树中的序号是 2*x + 1。将所有节点都标上号，用 BFS 层序遍历每一层，每一层都找到左右边界，相减拿到宽度，动态维护最大宽度，就是本题的最终答案。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func widthOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } queue, res := []*TreeNode{}, 0 queue = append(queue, \u0026amp;TreeNode{0, root.Left, root.Right}) for len(queue) != 0 { var left, right *int // 这里需要注意，先保存 queue 的个数，相当于拿到此层的总个数 \tqLen := len(queue) // 这里循环不要写 i \u0026lt; len(queue)，因为每次循环 queue 的长度都在变小 \tfor i := 0; i \u0026lt; qLen; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { // 根据满二叉树父子节点的关系，得到下一层节点在本层的编号 \tnewVal := node.Val * 2 queue = append(queue, \u0026amp;TreeNode{newVal, node.Left.Left, node.Left.Right}) if left == nil || *left \u0026gt; newVal { left = \u0026amp;newVal } if right == nil || *right \u0026lt; newVal { right = \u0026amp;newVal } } if node.Right != nil { // 根据满二叉树父子节点的关系，得到下一层节点在本层的编号 \tnewVal := node.Val*2 + 1 queue = append(queue, \u0026amp;TreeNode{newVal, node.Right.Left, node.Right.Right}) if left == nil || *left \u0026gt; newVal { left = \u0026amp;newVal } if right == nil || *right \u0026lt; newVal { right = \u0026amp;newVal } } } switch { // 某层只有一个点，那么此层宽度为 1 \tcase left != nil \u0026amp;\u0026amp; right == nil, left == nil \u0026amp;\u0026amp; right != nil: res = max(res, 1) // 某层只有两个点，那么此层宽度为两点之间的距离 \tcase left != nil \u0026amp;\u0026amp; right != nil: res = max(res, *right-*left+1) } } return res } "});index.add({'id':312,'href':'/leetcode-java/04_Leetcode/0668.Kth-Smallest-Number-in-Multiplication-Table/','title':"0668. Kth Smallest Number in Multiplication Table",'section':"第四章",'content':"668. Kth Smallest Number in Multiplication Table #  题目 #  Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\nExample 1:\nInput: m = 3, n = 3, k = 5 Output: Explanation: The Multiplication Table: 1\t2\t3 2\t4\t6 3\t6\t9 The 5-th smallest number is 3 (1, 2, 2, 3, 3).  Example 2:\nInput: m = 2, n = 3, k = 6 Output: Explanation: The Multiplication Table: 1\t2\t3 2\t4\t6 The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).  Note:\n The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]  题目大意 #  几乎每一个人都用乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？给定高度 m 、宽度 n 的一张 m * n 的乘法表，以及正整数 k，你需要返回表中第 k 小的数字。\n注意：\n m 和 n 的范围在 [1, 30000] 之间。 k 的范围在 [1, m * n] 之间。  解题思路 #   给出 3 个数字，m，n，k。m 和 n 分别代表乘法口诀表的行和列。要求在这个乘法口诀表中找第 k 小的数字。 这一题是第 378 题变种题。利用二分搜索，在 [1,m*n] 的区间内搜索第 k 小的数。每次二分统计 ≤ mid 数字的个数。由于是在两数乘法构成的矩阵中计数，知道乘数，被乘数也就知道了，所以计数只需要一层循环。整体代码和第 378 题完全一致，只是计数的部分不同罢了。可以对比第 378 题一起练习。  代码 #  package leetcode import \u0026#34;math\u0026#34; func findKthNumber(m int, n int, k int) int { low, high := 1, m*n for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if counterKthNum(m, n, mid) \u0026gt;= k { high = mid } else { low = mid + 1 } } return low } func counterKthNum(m, n, mid int) int { count := 0 for i := 1; i \u0026lt;= m; i++ { count += int(math.Min(math.Floor(float64(mid)/float64(i)), float64(n))) } return count } "});index.add({'id':313,'href':'/leetcode-java/04_Leetcode/0676.Implement-Magic-Dictionary/','title':"0676. Implement Magic Dictionary",'section':"第四章",'content':"676. Implement Magic Dictionary #  题目 #  Implement a magic directory with buildDict, and search methods.\nFor the method buildDict, you\u0026rsquo;ll be given a list of non-repetitive words to build a dictionary.\nFor the method search, you\u0026rsquo;ll be given a word, and judge whether if you modify exactly one character into anothercharacter in this word, the modified word is in the dictionary you just built.\nExample 1:\nInput: buildDict([\u0026quot;hello\u0026quot;, \u0026quot;leetcode\u0026quot;]), Output: Null Input: search(\u0026quot;hello\u0026quot;), Output: False Input: search(\u0026quot;hhllo\u0026quot;), Output: True Input: search(\u0026quot;hell\u0026quot;), Output: False Input: search(\u0026quot;leetcoded\u0026quot;), Output: False  Note:\n You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.  题目大意 #  实现一个带有 buildDict, 以及 search 方法的魔法字典。对于 buildDict 方法，你将被给定一串不重复的单词来构建一个字典。对于 search 方法，你将被给定一个单词，并且判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。\n解题思路 #   实现 MagicDictionary 的数据结构，这个数据结构内会存储一个字符串数组，当执行 Search 操作的时候要求判断传进来的字符串能否只改变一个字符(不能增加字符也不能删除字符)就能变成 MagicDictionary 中存储的字符串，如果可以，就输出 true，如果不能，就输出 false。 这题的解题思路比较简单，用 Map 判断即可。  代码 #  package leetcode type MagicDictionary struct { rdict map[int]string } /** Initialize your data structure here. */ func Constructor676() MagicDictionary { return MagicDictionary{rdict: make(map[int]string)} } /** Build a dictionary through a list of words */ func (this *MagicDictionary) BuildDict(dict []string) { for k, v := range dict { this.rdict[k] = v } } /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */ func (this *MagicDictionary) Search(word string) bool { for _, v := range this.rdict { n := 0 if len(word) == len(v) { for i := 0; i \u0026lt; len(v); i++ { if word[i] != v[i] { n += 1 } } if n == 1 { return true } } } return false } /** * Your MagicDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.BuildDict(dict); * param_2 := obj.Search(word); */ "});index.add({'id':314,'href':'/leetcode-java/04_Leetcode/0682.Baseball-Game/','title':"0682. Baseball Game",'section':"第四章",'content':"682. Baseball Game #  题目 #  You\u0026rsquo;re now a baseball game point recorder.\nGiven a list of strings, each string can be one of the 4 following types:\n Integer (one round\u0026rsquo;s score): Directly represents the number of points you get in this round. \u0026ldquo;+\u0026rdquo; (one round\u0026rsquo;s score): Represents that the points you get in this round are the sum of the last two valid round\u0026rsquo;s points. \u0026ldquo;D\u0026rdquo; (one round\u0026rsquo;s score): Represents that the points you get in this round are the doubled data of the last valid round\u0026rsquo;s points. \u0026ldquo;C\u0026rdquo; (an operation, which isn\u0026rsquo;t a round\u0026rsquo;s score): Represents the last valid round\u0026rsquo;s points you get were invalid and should be removed. Each round\u0026rsquo;s operation is permanent and could have an impact on the round before and the round after.  You need to return the sum of the points you could get in all the rounds.\nExample 1:\n Input: [\u0026quot;5\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;+\u0026quot;] Output: 30 Explanation: Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example 2:\n Input: [\u0026quot;5\u0026quot;,\u0026quot;-2\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;] Output: 27 Explanation: Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3. Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note:\n The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000.  题目大意 #  这道题是模拟题，给一串数字和操作符。出现数字就直接累加，出现 \u0026ldquo;C\u0026rdquo; 就代表栈推出一个元素，相应的总和要减去栈顶的元素。出现 \u0026ldquo;D\u0026rdquo; 就代表把前一个元素乘以 2，就得到当前的元素值。再累加。出现 \u0026ldquo;+\u0026rdquo; 就代表把前 2 个值求和，得到当前元素的值，再累积。\n解题思路 #  这道题用栈模拟即可。\n代码 #  package leetcode import \u0026#34;strconv\u0026#34; func calPoints(ops []string) int { stack := make([]int, len(ops)) top := 0 for i := 0; i \u0026lt; len(ops); i++ { op := ops[i] switch op { case \u0026#34;+\u0026#34;: last1 := stack[top-1] last2 := stack[top-2] stack[top] = last1 + last2 top++ case \u0026#34;D\u0026#34;: last1 := stack[top-1] stack[top] = last1 * 2 top++ case \u0026#34;C\u0026#34;: top-- default: stack[top], _ = strconv.Atoi(op) top++ } } points := 0 for i := 0; i \u0026lt; top; i++ { points += stack[i] } return points } "});index.add({'id':315,'href':'/leetcode-java/04_Leetcode/0684.Redundant-Connection/','title':"0684. Redundant Connection",'section':"第四章",'content':"684. Redundant Connection #  题目 #  In this problem, a tree is an undirected graph that is connected and has no cycles.\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, \u0026hellip;, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\nThe resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u \u0026lt; v, that represents an undirected edge connecting nodes u and v.\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u \u0026lt; v.\nExample 1:\nInput: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 1 / \\ 2 - 3  Example 2:\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2 | | 4 - 3  Note:\n The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see  Redundant Connection II). We apologize for any inconvenience caused.\n题目大意 #  在本问题中, 树指的是一个连通且无环的无向图。输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, \u0026hellip;, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u \u0026lt; v，表示连接顶点u 和v的无向图的边。\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u \u0026lt; v。\n注意:\n 输入的二维数组大小在 3 到 1000。 二维数组中的整数在 1 到 N 之间，其中 N 是输入数组的大小。  解题思路 #   给出一个连通无环无向图和一些连通的边，要求在这些边中删除一条边以后，图中的 N 个节点依旧是连通的。如果有多条边，输出最后一条。 这一题可以用并查集直接秒杀。依次扫描所有的边，把边的两端点都合并 union() 到一起。如果遇到一条边的两端点已经在一个集合里面了，就说明是多余边，删除。最后输出这些边即可。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func findRedundantConnection(edges [][]int) []int { if len(edges) == 0 { return []int{} } uf, res := template.UnionFind{}, []int{} uf.Init(len(edges) + 1) for i := 0; i \u0026lt; len(edges); i++ { if uf.Find(edges[i][0]) != uf.Find(edges[i][1]) { uf.Union(edges[i][0], edges[i][1]) } else { res = append(res, edges[i][0]) res = append(res, edges[i][1]) } } return res } "});index.add({'id':316,'href':'/leetcode-java/04_Leetcode/0685.Redundant-Connection-II/','title':"0685. Redundant Connection I I",'section':"第四章",'content':"685. Redundant Connection II #  题目 #  In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, \u0026hellip;, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\nThe resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.\nExample 1:\nInput: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this: 1 / \\ v v 2--\u0026gt;3  Example 2:\nInput: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 \u0026lt;- 1 -\u0026gt; 2 ^ | | v 4 \u0026lt;- 3  Note:\n The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.  题目大意 #  在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。输入一个有向图，该图由一个有着 N 个节点 (节点值不重复1, 2, \u0026hellip;, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。 每一个边的元素是一对 [u, v]，用以表示有向图中连接顶点 u and v 和顶点的边，其中父节点 u 是子节点 v 的一个父节点。返回一条能删除的边，使得剩下的图是有 N 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n注意:\n 二维数组大小的在 3 到 1000 范围内。 二维数组中的每个整数在 1 到 N 之间，其中 N 是二维数组的大小。  解题思路 #   这一题是第 684 题的加强版。第 684 题中的图是无向图，这一题中的图是有向图。 这一题的解法也是用并查集，不过需要灵活一点，不要用模板，因为在模板中，存在路径压缩和 rank() 优化，这些优化会改变有向边原始的方向。所以并查集只需要记录 parent() 就够用了。    经过分析，可以得到上面这 3 种情况，红色的边是我们实际应该删除的。先来看情况 2 和情况 3 。当不断 union() 时，加入一条边以后，会使一个节点的入度变成 2，那么记录下这两条边为 candidate1 和 candidate2。将后加入的 candidate2 这条边先放在一边，继续往下 union()。如果 candidate2 是红色的边，那么合并到最后，也不会出现任何异常，那么 candidate2 就是红色的边，即找到了要删除的边了。如果合并到最后出现了环的问题了，那说明 candidate2 是黑色的边，candidate1 才是红色的边，那么 candidate1 是要删除的边。 再来看看情况 1。如果一路合并到结束也没有发现出现入度为 2 的情况，那么说明遇到了情况 1 。情况 1 会出现环的情况。题目中说如果要删除边，就删除最后出现的那条边。具体实现见代码注释。  代码 #  package leetcode func findRedundantDirectedConnection(edges [][]int) []int { if len(edges) == 0 { return []int{} } parent, candidate1, candidate2 := make([]int, len(edges)+1), []int{}, []int{} for _, edge := range edges { if parent[edge[1]] == 0 { parent[edge[1]] = edge[0] } else { // 如果一个节点已经有父亲节点了，说明入度已经有 1 了，再来一条边，入度为 2 ，那么跳过新来的这条边 candidate2，并记录下和这条边冲突的边 candidate1 \tcandidate1 = append(candidate1, parent[edge[1]]) candidate1 = append(candidate1, edge[1]) candidate2 = append(candidate2, edge[0]) candidate2 = append(candidate2, edge[1]) edge[1] = 0 // 做标记，后面再扫到这条边以后可以直接跳过 \t} } for i := 1; i \u0026lt;= len(edges); i++ { parent[i] = i } for _, edge := range edges { if edge[1] == 0 { // 跳过 candidate2 这条边 \tcontinue } u, v := edge[0], edge[1] pu := findRoot(\u0026amp;parent, u) if pu == v { // 发现有环 \tif len(candidate1) == 0 { // 如果没有出现入度为 2 的情况，那么对应情况 1，就删除这条边 \treturn edge } return candidate1 // 出现环并且有入度为 2 的情况，说明 candidate1 是答案 \t} parent[v] = pu // 没有发现环，继续合并 \t} return candidate2 // 当最后什么都没有发生，则 candidate2 是答案 } func findRoot(parent *[]int, k int) int { if (*parent)[k] != k { (*parent)[k] = findRoot(parent, (*parent)[k]) } return (*parent)[k] } "});index.add({'id':317,'href':'/leetcode-java/04_Leetcode/0690.Employee-Importance/','title':"0690. Employee Importance",'section':"第四章",'content':"690. 员工的重要性 #  Difficulty: 简单\n给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。\n比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。\n现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。\n示例 1:\n输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出: 11 解释: 员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。 注意:\n 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。  题解 #  题解一：DFS（深度优先遍历） #  /* // Definition for Employee. class Employee { public int id; public int importance; public List\u0026lt;Integer\u0026gt; subordinates; }; */ class Solution { int result = 0; public int getImportance(List\u0026lt;Employee\u0026gt; employees, int id) { Map\u0026lt;Integer, Employee\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (Employee e : employees) { map.put(e.id, e); } helper(map, id); return result; } private void helper(Map\u0026lt;Integer, Employee\u0026gt; map, int id) { Employee e = map.get(id); if (e == null) { return; } result += e.importance; for (Integer subId : e.subordinates) { helper(map, subId); } } } 复杂度分析\n  时间复杂度分析：O(n)。\n  空间复杂度分析：O(n)。\n  "});index.add({'id':318,'href':'/leetcode-java/04_Leetcode/0693.Binary-Number-with-Alternating-Bits/','title':"0693. Binary Number With Alternating Bits",'section':"第四章",'content':"693. Binary Number with Alternating Bits #  题目 #  Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\nExample 1:\nInput: 5 Output: True Explanation: The binary representation of 5 is: 101  Example 2:\nInput: 7 Output: False Explanation: The binary representation of 7 is: 111.  Example 3:\nInput: 11 Output: False Explanation: The binary representation of 11 is: 1011.  Example 4:\nInput: 10 Output: True Explanation: The binary representation of 10 is: 1010.  题目大意 #  给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。\n解题思路 #   判断一个数的二进制位相邻两个数是不相等的，即 0101 交叉间隔的，如果是，输出 true。这一题有多种做法，最简单的方法就是直接模拟。比较巧妙的方法是通过位运算，合理构造特殊数据进行位运算到达目的。010101 构造出 101010 两者相互 \u0026amp; 位运算以后就为 0，因为都“插空”了。  代码 #  package leetcode // 解法一 func hasAlternatingBits(n int) bool { /* n = 1 0 1 0 1 0 1 0 n \u0026gt;\u0026gt; 1 0 1 0 1 0 1 0 1 n ^ n\u0026gt;\u0026gt;1 1 1 1 1 1 1 1 1 n 1 1 1 1 1 1 1 1 n + 1 1 0 0 0 0 0 0 0 0 n \u0026amp; (n+1) 0 0 0 0 0 0 0 0 */ n = n ^ (n \u0026gt;\u0026gt; 1) return (n \u0026amp; (n + 1)) == 0 } // 解法二 func hasAlternatingBits1(n int) bool { last, current := 0, 0 for n \u0026gt; 0 { last = n \u0026amp; 1 n = n / 2 current = n \u0026amp; 1 if last == current { return false } } return true } "});index.add({'id':319,'href':'/leetcode-java/04_Leetcode/0695.Max-Area-of-Island/','title':"0695. Max Area of Island",'section':"第四章",'content':"695. Max Area of Island #  题目 #  Given a non-empty 2D array grid of 0\u0026rsquo;s and 1\u0026rsquo;s, an island is a group of 1\u0026rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\nExample 1:\n[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return6. Note the answer is not 11, because the island must be connected 4-directionally.\nExample 2:\n[[0,0,0,0,0,0,0,0]] Given the above grid, return0.\nNote: The length of each dimension in the given grid does not exceed 50.\n题目大意 #  给定一个包含了一些 0 和 1 的非空二维数组 grid 。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)\n解题思路 #   给出一个地图，要求计算上面岛屿的面积。注意岛屿的定义是四周都是海(为 0 的点)，如果土地(为 1 的点)靠在地图边缘，不能算是岛屿。 这一题和第 200 题，第 1254 题解题思路是一致的。DPS 深搜。这不过这一题需要多处理 2 件事情，一个是注意靠边缘的岛屿不能计算在内，二是动态维护岛屿的最大面积。  代码 #  func maxAreaOfIsland(grid [][]int) int { res := 0 for i, row := range grid { for j, col := range row { if col == 0 { continue } area := areaOfIsland(grid, i, j) if area \u0026gt; res { res = area } } } return res } func areaOfIsland(grid [][]int, x, y int) int { if !isInGrid(grid, x, y) || grid[x][y] == 0 { return 0 } grid[x][y] = 0 total := 1 for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] total += areaOfIsland(grid, nx, ny) } return total } "});index.add({'id':320,'href':'/leetcode-java/04_Leetcode/0697.Degree-of-an-Array/','title':"0697. Degree of an Array",'section':"第四章",'content':"697. Degree of an Array #  题目 #  Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\nExample 1:\nInput: [1, 2, 2, 3, 1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2:\nInput: [1,2,2,3,1,4,2] Output: 6 Note:\n nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.  题目大意 #  给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。\n注意:\n nums.length 在 1 到 50,000 区间范围内。 nums[i] 是一个在 0 到 49,999 范围内的整数。  解题思路 #   找一个与给定数组相同度的最短连续子数组，输出其长度。数组的度的定义是任一元素出现频数的最大值。 简单题。先统计各个元素的频次，并且动态维护最大频次和子数组的起始和终点位置。这里最短连续子数组有点“迷惑人”。这个最短子数组其实处理起来很简单。只需从前往后扫一遍，记录各个元素第一次出现的位置和最后一次出现的位置即是最短的连续子数组。然后在频次字典里面寻找和最大频次相同的所有解，有可能有多个子数组能满足题意，取出最短的输出即可。  代码 #  package leetcode func findShortestSubArray(nums []int) int { frequency, maxFreq, smallest := map[int][]int{}, 0, len(nums) for i, num := range nums { if _, found := frequency[num]; !found { frequency[num] = []int{1, i, i} } else { frequency[num][0]++ frequency[num][2] = i } if maxFreq \u0026lt; frequency[num][0] { maxFreq = frequency[num][0] } } for _, indices := range frequency { if indices[0] == maxFreq { if smallest \u0026gt; indices[2]-indices[1]+1 { smallest = indices[2] - indices[1] + 1 } } } return smallest } "});index.add({'id':321,'href':'/leetcode-java/04_Leetcode/0699.Falling-Squares/','title':"0699. Falling Squares",'section':"第四章",'content':"699. Falling Squares #  题目 #  On an infinite number line (x-axis), we drop given squares in the order they are given.\nThe i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].\nThe square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.\nThe squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.\nReturn a list ans of heights. Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].\nExample 1:\nInput: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.\nAfter the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5. The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.\nAfter the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5. Thus, we return an answer of [2, 5, 5].\nExample 2:\nInput: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.  Note:\n 1 \u0026lt;= positions.length \u0026lt;= 1000. 1 \u0026lt;= positions[i][0] \u0026lt;= 10^8. 1 \u0026lt;= positions[i][1] \u0026lt;= 10^6.  题目大意 #  在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。第 i 个掉落的方块（positions[i] = (left, side_length)）是正方形，其中 left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。\n每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。\n返回一个堆叠高度列表 ans 。每一个堆叠高度 ans[i] 表示在通过 positions[0], positions[1], \u0026hellip;, positions[i] 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。\n示例 1:\n输入: [[1, 2], [2, 3], [6, 1]] 输出: [2, 5, 5] 解释: 第一个方块 positions[0] = [1, 2] 掉落： _aa _aa ------- 方块最大高度为 2 。 第二个方块 positions[1] = [2, 3] 掉落： __aaa __aaa __aaa _aa__ _aa__ -------------- 方块最大高度为5。 大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。 第三个方块 positions[1] = [6, 1] 掉落： __aaa __aaa __aaa _aa _aa___a -------------- 方块最大高度为5。 因此，我们返回结果[2, 5, 5]。 注意:\n 1 \u0026lt;= positions.length \u0026lt;= 1000. 1 \u0026lt;= positions[i][0] \u0026lt;= 10^8. 1 \u0026lt;= positions[i][1] \u0026lt;= 10^6.   解题思路 #   给出一个二维数组，每个一维数组中只有 2 个值，分别代表的是正方形砖块所在 x 轴的坐标起始点，和边长。要求输出每次砖块落下以后，当前最大的高度。正方形砖块落下如同俄罗斯方块，落下的过程中如果遇到了砖块会落在砖块的上面。如果砖块摞起来了以后，下方有空间，是不可能再把砖块挪进去的，因为此题砖块只会垂直落下，不会水平移动(这一点和俄罗斯方块不同)。 这一题可以用线段树解答。由于方块在 x 轴上的坐标范围特别大，如果不离散化，这一题就会 MTE。所以首先去重 - 排序 - 离散化。先把每个砖块所在区间都算出来，每个正方形的方块所在区间是 [pos[0] , pos[0]+pos[1]-1] ，为什么右边界要减一呢？因为每个方块占据的区间其实应该是左闭右开的，即 [pos[0] , pos[0]+pos[1])，如果右边是开的，那么这个边界会被 2 个区间查询共用，从而导致错误结果。例如 [2,3]，[3,4]，这两个区间的砖块实际是不会摞在一起的。但是如果右边都是闭区间，用线段树 query 查询的时候，会都找到 [3，3]，从而导致这两个区间都会判断 3 这一点的情况。正确的做法应该是 [2,3)，[3,4）这样就避免了上述可能导致错误的情况了。离散化以后，所有的坐标区间都在 0~n 之间了。 遍历每个砖块所在区间，先查询这个区间内的值，再加上当前砖块的高度，即为这个区间的最新高度。并更新该区间的值。更新区间的值用到懒惰更新。然后和动态维护的当前最大高度进行比较，将最大值放入最终输出的数组中。 类似的题目有：第 715 题，第 218 题，第 732 题。第 715 题是区间更新定值(不是增减)，第 218 题可以用扫描线，第 732 题和本题类似，也是俄罗斯方块的题目，但是第 732 题的俄罗斯方块的方块会“断裂”。 leetcode 上也有线段树的讲解： Get Solutions to Interview Questions  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func fallingSquares(positions [][]int) []int { st, ans, posMap, maxHeight := template.SegmentTree{}, make([]int, 0, len(positions)), discretization(positions), 0 tmp := make([]int, len(posMap)) st.Init(tmp, func(i, j int) int { return max(i, j) }) for _, p := range positions { h := st.QueryLazy(posMap[p[0]], posMap[p[0]+p[1]-1]) + p[1] st.UpdateLazy(posMap[p[0]], posMap[p[0]+p[1]-1], h) maxHeight = max(maxHeight, h) ans = append(ans, maxHeight) } return ans } func discretization(positions [][]int) map[int]int { tmpMap, posArray, posMap := map[int]int{}, []int{}, map[int]int{} for _, pos := range positions { tmpMap[pos[0]]++ tmpMap[pos[0]+pos[1]-1]++ } for k := range tmpMap { posArray = append(posArray, k) } sort.Ints(posArray) for i, pos := range posArray { posMap[pos] = i } return posMap } "});index.add({'id':322,'href':'/leetcode-java/04_Leetcode/0704.Binary-Search/','title':"0704. Binary Search",'section':"第四章",'content':"704. Binary Search #  题目 #  Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4  Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  Note:\n You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].  题目大意 #  给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  解题思路 #   给出一个数组，要求在数组中搜索等于 target 的元素的下标。如果找到就输出下标，如果找不到输出 -1 。 简单题，二分搜索的裸题。  代码 #  package leetcode func search704(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if nums[mid] == target { return mid } else if nums[mid] \u0026gt; target { high = mid - 1 } else { low = mid + 1 } } return -1 } "});index.add({'id':323,'href':'/leetcode-java/04_Leetcode/0705.Design-HashSet/','title':"0705. Design Hash Set",'section':"第四章",'content':"705. Design HashSet #  题目 #  Design a HashSet without using any built-in hash table libraries.\nTo be specific, your design should include these functions:\n add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.  Example:\nMyHashSet hashSet = new MyHashSet(); hashSet.add(1); hashSet.add(2); hashSet.contains(1); // returns true hashSet.contains(3); // returns false (not found) hashSet.add(2); hashSet.contains(2); // returns true hashSet.remove(2); hashSet.contains(2); // returns false (already removed)  Note:\n All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.  题目大意 #  不使用任何内建的哈希表库设计一个哈希集合具体地说，你的设计应该包含以下的功能：\n add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  注意：\n 所有的值都在 [1, 1000000] 的范围内。 操作的总数目在 [1, 10000] 范围内。 不要使用内建的哈希集合库。  解题思路 #   简单题，设计一个 hashset 的数据结构，要求有 add(value)，contains(value)，remove(value)，这 3 个方法。  代码 #  package leetcode type MyHashSet struct { data []bool } /** Initialize your data structure here. */ func Constructor705() MyHashSet { return MyHashSet{ data: make([]bool, 1000001), } } func (this *MyHashSet) Add(key int) { this.data[key] = true } func (this *MyHashSet) Remove(key int) { this.data[key] = false } /** Returns true if this set contains the specified element */ func (this *MyHashSet) Contains(key int) bool { return this.data[key] } /** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */ "});index.add({'id':324,'href':'/leetcode-java/04_Leetcode/0706.Design-HashMap/','title':"0706. Design Hash Map",'section':"第四章",'content':"706. Design HashMap #  题目 #  Design a HashMap without using any built-in hash table libraries.\nTo be specific, your design should include these functions:\n put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.  Example:\nMyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1); hashMap.put(2, 2); hashMap.get(1); // returns 1 hashMap.get(3); // returns -1 (not found) hashMap.put(2, 1); // update the existing value hashMap.get(2); // returns 1 hashMap.remove(2); // remove the mapping for 2 hashMap.get(2); // returns -1 (not found)  Note:\n All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.  题目大意 #  不使用任何内建的哈希表库设计一个哈希映射具体地说，你的设计应该包含以下的功能：\n put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回 -1。 remove(key)：如果映射中存在这个键，删除这个数值对。  注意：\n 所有的值都在 [1, 1000000] 的范围内。 操作的总数目在 [1, 10000] 范围内。 不要使用内建的哈希库。  解题思路 #   简单题，设计一个 hashmap 的数据结构，要求有 put(key, value)，get(key)，remove(key)，这 3 个方法。设计一个 map 主要需要处理哈希冲突，一般都是链表法解决冲突。  代码 #  package leetcode const Len int = 100000 type MyHashMap struct { content [Len]*HashNode } type HashNode struct { key int val int next *HashNode } func (N *HashNode) Put(key int, value int) { if N.key == key { N.val = value return } if N.next == nil { N.next = \u0026amp;HashNode{key, value, nil} return } N.next.Put(key, value) } func (N *HashNode) Get(key int) int { if N.key == key { return N.val } if N.next == nil { return -1 } return N.next.Get(key) } func (N *HashNode) Remove(key int) *HashNode { if N.key == key { p := N.next N.next = nil return p } if N.next != nil { return N.next.Remove(key) } return nil } /** Initialize your data structure here. */ func Constructor706() MyHashMap { return MyHashMap{} } /** value will always be non-negative. */ func (this *MyHashMap) Put(key int, value int) { node := this.content[this.Hash(key)] if node == nil { this.content[this.Hash(key)] = \u0026amp;HashNode{key: key, val: value, next: nil} return } node.Put(key, value) } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ func (this *MyHashMap) Get(key int) int { HashNode := this.content[this.Hash(key)] if HashNode == nil { return -1 } return HashNode.Get(key) } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ func (this *MyHashMap) Remove(key int) { HashNode := this.content[this.Hash(key)] if HashNode == nil { return } this.content[this.Hash(key)] = HashNode.Remove(key) } func (this *MyHashMap) Hash(value int) int { return value % Len } /** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ "});index.add({'id':325,'href':'/leetcode-java/04_Leetcode/0707.Design-Linked-List/','title':"0707. Design Linked List",'section':"第四章",'content':"707. Design Linked List #  题目 #  Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\nImplement these functions in your linked list class:\n get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.  Example:\n MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2); // linked list becomes 1-\u0026gt;2-\u0026gt;3 linkedList.get(1); // returns 2 linkedList.deleteAtIndex(1); // now the linked list is 1-\u0026gt;3 linkedList.get(1); // returns 3 Note:\n All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library.  题目大意 #  这道题比较简单，设计一个链表，实现相关操作即可。\n解题思路 #  这题有一个地方比较坑，题目中 Note 里面写的数值取值范围是 [1, 1000]，笔者把 0 当做无效值。结果 case 里面出现了 0 是有效值。case 和题意不符。\n代码 #  package leetcode type MyLinkedList struct { Val int Next *MyLinkedList } /** Initialize your data structure here. */ func Constructor() MyLinkedList { return MyLinkedList{Val: -999, Next: nil} } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ func (this *MyLinkedList) Get(index int) int { cur := this for i := 0; cur != nil; i++ { if i == index { if cur.Val == -999 { return -1 } else { return cur.Val } } cur = cur.Next } return -1 } /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ func (this *MyLinkedList) AddAtHead(val int) { if this.Val == -999 { this.Val = val } else { tmp := \u0026amp;MyLinkedList{Val: this.Val, Next: this.Next} this.Val = val this.Next = tmp } } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { cur := this for cur.Next != nil { cur = cur.Next } tmp := \u0026amp;MyLinkedList{Val: val, Next: nil} cur.Next = tmp } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { cur := this if index == 0 { this.AddAtHead(val) return } for i := 0; cur != nil; i++ { if i == index-1 { break } cur = cur.Next } if cur != nil \u0026amp;\u0026amp; cur.Val != -999 { tmp := \u0026amp;MyLinkedList{Val: val, Next: cur.Next} cur.Next = tmp } } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { cur := this for i := 0; cur != nil; i++ { if i == index-1 { break } cur = cur.Next } if cur != nil \u0026amp;\u0026amp; cur.Next != nil { cur.Next = cur.Next.Next } } /** * Your MyLinkedList object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Get(index); * obj.AddAtHead(val); * obj.AddAtTail(val); * obj.AddAtIndex(index,val); * obj.DeleteAtIndex(index); */ "});index.add({'id':326,'href':'/leetcode-java/04_Leetcode/0710.Random-Pick-with-Blacklist/','title':"0710. Random Pick With Blacklist",'section':"第四章",'content':"710. Random Pick with Blacklist #  题目 #  Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B.\nOptimize it such that it minimizes the call to system’s Math.random().\nNote:\n 1 \u0026lt;= N \u0026lt;= 1000000000 0 \u0026lt;= B.length \u0026lt; min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1:\n Input: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[1,[]],[],[],[]] Output: [null,0,0,0] Example 2:\n Input: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[2,[]],[],[],[]] Output: [null,1,1,1] Example 3:\n Input: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[3,[1]],[],[],[]] Output: [null,0,0,2] Example 4:\n Input: [\u0026quot;Solution\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;,\u0026quot;pick\u0026quot;] [[4,[2]],[],[],[]] Output: [null,1,3,1] Explanation of Input Syntax:\nThe input is two lists: the subroutines called and their arguments. Solution\u0026rsquo;s constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren\u0026rsquo;t any.\n题目大意 #  给一个数字 N，再给一个黑名单 B，要求在 [0,N) 区间内随机输出一个数字，这个是不在黑名单 B 中的任意一个数字。\n解题思路 #  这道题的 N 的范围特别大，最大是 10 亿。如果利用桶计数，开不出来这么大的数组。考虑到题目要求我们输出的数字是随机的，所以不需要存下所有的白名单的数字。\n假设 N=10, blacklist=[3, 5, 8, 9]\n 这一题有点类似 hash 冲突的意思。如果随机访问一个数，这个数正好在黑名单之内，那么就 hash 冲突了，我们就把它映射到另外一个不在黑名单里面的数中。如上图，我们可以将 3，5 重新映射到 7，6 的位置。这样末尾开始的几个数要么是黑名单里面的数，要么就是映射的数字。\nhash 表总长度应该为 M = N - len(backlist)，然后在 M 的长度中扫描是否有在黑名单中的数，如果有，就代表 hash 冲突了。冲突就把这个数字映射到 (M,N) 这个区间范围内。为了提高效率，可以选择这个区间的头部或者尾部开始映射，我选择的是末尾开始映射。从 (M,N) 这个区间的末尾开始往前找，找黑名单不存在的数，找到了就把 [0,M] 区间内冲突的数字映射到这里来。最后 pick 的时候，只需要查看 map 中是否存在映射关系，如果存在就输出 map 中映射之后的值，如果没有就代表没有冲突，直接输出那个 index 即可。\n代码 #  package leetcode import \u0026#34;math/rand\u0026#34; type Solution struct { M int BlackMap map[int]int } func Constructor710(N int, blacklist []int) Solution { blackMap := map[int]int{} for i := 0; i \u0026lt; len(blacklist); i++ { blackMap[blacklist[i]] = 1 } M := N - len(blacklist) for _, value := range blacklist { if value \u0026lt; M { for { if _, ok := blackMap[N-1]; ok { N-- } else { break } } blackMap[value] = N - 1 N-- } } return Solution{BlackMap: blackMap, M: M} } func (this *Solution) Pick() int { idx := rand.Intn(this.M) if _, ok := this.BlackMap[idx]; ok { return this.BlackMap[idx] } return idx } /** * Your Solution object will be instantiated and called as such: * obj := Constructor(N, blacklist); * param_1 := obj.Pick(); */ "});index.add({'id':327,'href':'/leetcode-java/04_Leetcode/0713.Subarray-Product-Less-Than-K/','title':"0713. Subarray Product Less Than K",'section':"第四章",'content':"713. Subarray Product Less Than K #  题目 #  Your are given an array of positive integers nums.\nCount and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.\nExample 1:\n Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Note:\n 0 \u0026lt; nums.length \u0026lt;= 50000. 0 \u0026lt; nums[i] \u0026lt; 1000. 0 \u0026lt;= k \u0026lt; 10^6.  题目大意 #  给出一个数组，要求在输出符合条件的窗口数，条件是，窗口中所有数字乘积小于 K 。\n解题思路 #  这道题也是滑动窗口的题目，在窗口滑动的过程中不断累乘，直到乘积大于 k，大于 k 的时候就缩小左窗口。有一种情况还需要单独处理一下，即类似 [100] 这种情况。这种情况窗口内乘积等于 k，不小于 k，左边窗口等于右窗口，这个时候需要左窗口和右窗口同时右移。\n代码 #  package leetcode func numSubarrayProductLessThanK(nums []int, k int) int { if len(nums) == 0 { return 0 } res, left, right, prod := 0, 0, 0, 1 for left \u0026lt; len(nums) { if right \u0026lt; len(nums) \u0026amp;\u0026amp; prod*nums[right] \u0026lt; k { prod = prod * nums[right] right++ } else if left == right { left++ right++ } else { res += right - left prod = prod / nums[left] left++ } } return res } "});index.add({'id':328,'href':'/leetcode-java/04_Leetcode/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/','title':"0714. Best Time to Buy and Sell Stock With Transaction Fee",'section':"第四章",'content':"714. Best Time to Buy and Sell Stock with Transaction Fee #  题目 #  Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.\nYou may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)\nReturn the maximum profit you can make.\nExample 1:\nInput: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1 Selling at prices[3] = 8 Buying at prices[4] = 4 Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  Note:\n 0 \u0026lt; prices.length \u0026lt;= 50000. 0 \u0026lt; prices[i] \u0026lt; 50000. 0 \u0026lt;= fee \u0026lt; 50000.  题目大意 #  给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。要求返回获得利润的最大值。\n解题思路 #   给定一个数组，表示一支股票在每一天的价格。设计一个交易算法，在这些天进行自动交易，要求：每一天只能进行一次操作；在买完股票后，必须卖了股票，才能再次买入；每次卖了股票以后，需要缴纳一部分的手续费。问如何交易，能让利润最大？ 这一题是第 121 题、第 122 题、第 309 题的变种题。 这一题的解题思路是 DP，需要维护买和卖的两种状态。buy[i] 代表第 i 天买入的最大收益，sell[i] 代表第 i 天卖出的最大收益，状态转移方程是 buy[i] = max(buy[i-1], sell[i-1]-prices[i])，sell[i] = max(sell[i-1], buy[i-1]+prices[i]-fee)。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) // 解法一 模拟 DP func maxProfit714(prices []int, fee int) int { if len(prices) \u0026lt;= 1 { return 0 } buy, sell := make([]int, len(prices)), make([]int, len(prices)) for i := range buy { buy[i] = math.MinInt64 } buy[0] = -prices[0] for i := 1; i \u0026lt; len(prices); i++ { buy[i] = max(buy[i-1], sell[i-1]-prices[i]) sell[i] = max(sell[i-1], buy[i-1]+prices[i]-fee) } return sell[len(sell)-1] } // 解法二 优化辅助空间的 DP func maxProfit714_1(prices []int, fee int) int { sell, buy := 0, -prices[0] for i := 1; i \u0026lt; len(prices); i++ { sell = max(sell, buy+prices[i]-fee) buy = max(buy, sell-prices[i]) } return sell } "});index.add({'id':329,'href':'/leetcode-java/04_Leetcode/0715.Range-Module/','title':"0715. Range Module",'section':"第四章",'content':"715. Range Module #  题目 #  A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.\n addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right) is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right).  Example 1:\naddRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)  Note:\n A half open interval [left, right) denotes all real numbers left \u0026lt;= x \u0026lt; right. 0 \u0026lt; left \u0026lt; right \u0026lt; 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000.  题目大意 #  Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。\n addRange(int left, int right) 添加半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。 queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true。 removeRange(int left, int right) 停止跟踪区间 [left, right) 中当前正在跟踪的每个实数。   示例：\naddRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪） queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字） queryRange(16, 17): true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪） 提示：\n 半开区间 [left, right) 表示所有满足 left \u0026lt;= x \u0026lt; right 的实数。 对 addRange, queryRange, removeRange 的所有调用中 0 \u0026lt; left \u0026lt; right \u0026lt; 10^9。 在单个测试用例中，对 addRange 的调用总数不超过 1000 次。 在单个测试用例中，对 queryRange 的调用总数不超过 5000 次。 在单个测试用例中，对 removeRange 的调用总数不超过 1000 次。  解题思路 #   设计一个数据结构，能完成添加区间 addRange，查询区间 queryRange，移除区间 removeRange 三种操作。查询区间的操作需要更加高效一点。 这一题可以用线段树来解答，但是时间复杂度不高，最优解是用二叉排序树 BST 来解答。先来看线段树。这一题是更新区间内的值，所以需要用到懒惰更新。添加区间可以把区间内的值都赋值为 1 。由于题目中未预先确定区间范围，选用树的形式实现线段树比数组实现更加节约空间(当然用数组也可以，区间最大是 1000，点至多有 2000 个)。移除区间的时候就是把区间内的值都赋值标记为 0 。 类似的题目有：第 699 题，第 218 题，第 732 题。第 715 题是区间更新定值(不是增减)，第 218 题可以用扫描线，第 732 题和第 699 题类似，也是俄罗斯方块的题目，但是第 732 题的俄罗斯方块的方块会“断裂”。  代码 #  package leetcode // RangeModule define type RangeModule struct { Root *SegmentTreeNode } // SegmentTreeNode define type SegmentTreeNode struct { Start, End int Tracked bool Lazy int Left, Right *SegmentTreeNode } // Constructor715 define func Constructor715() RangeModule { return RangeModule{\u0026amp;SegmentTreeNode{0, 1e9, false, 0, nil, nil}} } // AddRange define func (rm *RangeModule) AddRange(left int, right int) { update(rm.Root, left, right-1, true) } // QueryRange define func (rm *RangeModule) QueryRange(left int, right int) bool { return query(rm.Root, left, right-1) } // RemoveRange define func (rm *RangeModule) RemoveRange(left int, right int) { update(rm.Root, left, right-1, false) } func lazyUpdate(node *SegmentTreeNode) { if node.Lazy != 0 { node.Tracked = node.Lazy == 2 } if node.Start != node.End { if node.Left == nil || node.Right == nil { m := node.Start + (node.End-node.Start)/2 node.Left = \u0026amp;SegmentTreeNode{node.Start, m, node.Tracked, 0, nil, nil} node.Right = \u0026amp;SegmentTreeNode{m + 1, node.End, node.Tracked, 0, nil, nil} } else if node.Lazy != 0 { node.Left.Lazy = node.Lazy node.Right.Lazy = node.Lazy } } node.Lazy = 0 } func update(node *SegmentTreeNode, start, end int, track bool) { lazyUpdate(node) if start \u0026gt; end || node == nil || end \u0026lt; node.Start || node.End \u0026lt; start { return } if start \u0026lt;= node.Start \u0026amp;\u0026amp; node.End \u0026lt;= end { // segment completely covered by the update range \tnode.Tracked = track if node.Start != node.End { if track { node.Left.Lazy = 2 node.Right.Lazy = 2 } else { node.Left.Lazy = 1 node.Right.Lazy = 1 } } return } update(node.Left, start, end, track) update(node.Right, start, end, track) node.Tracked = node.Left.Tracked \u0026amp;\u0026amp; node.Right.Tracked } func query(node *SegmentTreeNode, start, end int) bool { lazyUpdate(node) if start \u0026gt; end || node == nil || end \u0026lt; node.Start || node.End \u0026lt; start { return true } if start \u0026lt;= node.Start \u0026amp;\u0026amp; node.End \u0026lt;= end { // segment completely covered by the update range \treturn node.Tracked } return query(node.Left, start, end) \u0026amp;\u0026amp; query(node.Right, start, end) } // 解法二 BST // type RangeModule struct { // Root *BSTNode // }  // type BSTNode struct { // Interval []int // Left, Right *BSTNode // }  // func Constructor715() RangeModule { // return RangeModule{} // }  // func (this *RangeModule) AddRange(left int, right int) { // interval := []int{left, right - 1} // this.Root = insert(this.Root, interval) // }  // func (this *RangeModule) RemoveRange(left int, right int) { // interval := []int{left, right - 1} // this.Root = delete(this.Root, interval) // }  // func (this *RangeModule) QueryRange(left int, right int) bool { // return query(this.Root, []int{left, right - 1}) // }  // func (this *RangeModule) insert(root *BSTNode, interval []int) *BSTNode { // if root == nil { // return \u0026amp;BSTNode{interval, nil, nil} // } // if root.Interval[0] \u0026lt;= interval[0] \u0026amp;\u0026amp; interval[1] \u0026lt;= root.Interval[1] { // return root // } // if interval[0] \u0026lt; root.Interval[0] { // root.Left = insert(root.Left, []int{interval[0], min(interval[1], root.Interval[0]-1)}) // } // if root.Interval[1] \u0026lt; interval[1] { // root.Right = insert(root.Right, []int{max(interval[0], root.Interval[1]+1), interval[1]}) // } // return root // }  // func (this *RangeModule) delete(root *BSTNode, interval []int) *BSTNode { // if root == nil { // return nil // } // if interval[0] \u0026lt; root.Interval[0] { // root.Left = delete(root.Left, []int{interval[0], min(interval[1], root.Interval[0]-1)}) // } // if root.Interval[1] \u0026lt; interval[1] { // root.Right = delete(root.Right, []int{max(interval[0], root.Interval[1]+1), interval[1]}) // } // if interval[1] \u0026lt; root.Interval[0] || root.Interval[1] \u0026lt; interval[0] { // return root // } // if interval[0] \u0026lt;= root.Interval[0] \u0026amp;\u0026amp; root.Interval[1] \u0026lt;= interval[1] { // if root.Left == nil { // return root.Right // } else if root.Right == nil { // return root.Left // } else { // pred := root.Left // for pred.Right != nil { // pred = pred.Right // } // root.Interval = pred.Interval // root.Left = delete(root.Left, pred.Interval) // return root // } // } // if root.Interval[0] \u0026lt; interval[0] \u0026amp;\u0026amp; interval[1] \u0026lt; root.Interval[1] { // left := \u0026amp;BSTNode{[]int{root.Interval[0], interval[0] - 1}, root.Left, nil} // right := \u0026amp;BSTNode{[]int{interval[1] + 1, root.Interval[1]}, nil, root.Right} // left.Right = right // return left // } // if interval[0] \u0026lt;= root.Interval[0] { // root.Interval[0] = interval[1] + 1 // } // if root.Interval[1] \u0026lt;= interval[1] { // root.Interval[1] = interval[0] - 1 // } // return root // }  // func (this *RangeModule) query(root *BSTNode, interval []int) bool { // if root == nil { // return false // } // if interval[1] \u0026lt; root.Interval[0] { // return query(root.Left, interval) // } // if root.Interval[1] \u0026lt; interval[0] { // return query(root.Right, interval) // } // left := true // if interval[0] \u0026lt; root.Interval[0] { // left = query(root.Left, []int{interval[0], root.Interval[0] - 1}) // } // right := true // if root.Interval[1] \u0026lt; interval[1] { // right = query(root.Right, []int{root.Interval[1] + 1, interval[1]}) // } // return left \u0026amp;\u0026amp; right // }  /** * Your RangeModule object will be instantiated and called as such: * obj := Constructor(); * obj.AddRange(left,right); * param_2 := obj.QueryRange(left,right); * obj.RemoveRange(left,right); */ "});index.add({'id':330,'href':'/leetcode-java/04_Leetcode/0717.1-bit-and-2-bit-Characters/','title':"0717.1 Bit and 2 Bit Characters",'section':"第四章",'content':"717. 1-bit and 2-bit Characters #  题目: #  We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).\nNow given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.\nExample 1:\nInput: bits = [1, 0, 0] Output: True Explanation: The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.  Example 2:\nInput: bits = [1, 1, 1, 0] Output: False Explanation: The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.  Note:\n 1 \u0026lt;= len(bits) \u0026lt;= 1000. bits[i] is always 0 or 1.  题目大意 #  有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。\n现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。\n注意:\n 1 \u0026lt;= len(bits) \u0026lt;= 1000. bits[i] 总是0 或 1.  解题思路 #   给出一个数组，数组里面的元素只有 0 和 1，并且数组的最后一个元素一定是 0。有 2 种特殊的字符，第一类字符是 \u0026ldquo;0\u0026rdquo;，第二类字符是 \u0026ldquo;11\u0026rdquo; 和 \u0026ldquo;10\u0026rdquo;，请判断这个数组最后一个元素是否一定是属于第一类字符？ 依题意， 0 的来源有 2 处，可以是第一类字符，也可以是第二类字符，1 的来源只有 1 处，一定出自第二类字符。最后一个 0 当前仅当为第一类字符的情况有 2 种，第一种情况，前面出现有 0，但是 0 和 1 配对形成了第二类字符。第二种情况，前面没有出现 0 。这两种情况的共同点是除去最后一个元素，数组中前面所有的1 都“结对子”。所以利用第二类字符的特征，\u0026ldquo;1X\u0026rdquo;，遍历整个数组，如果遇到 \u0026ldquo;1\u0026rdquo;，就跳 2 步，因为 1 后面出现什么数字( 0 或者 1 )并不需要关心。如果 i 能在 len(bits) - 1 的地方(数组最后一个元素)停下，那么对应的是情况一或者情况二，前面的 0 都和 1 匹配上了，最后一个 0 一定是第一类字符。如果 i 在 len(bit) 的位置(超出数组下标)停下，说明 bits[len(bits) - 1] == 1，这个时候最后一个 0 一定属于第二类字符。  代码 #  package leetcode func isOneBitCharacter(bits []int) bool { var i int for i = 0; i \u0026lt; len(bits)-1; i++ { if bits[i] == 1 { i++ } } return i == len(bits)-1 } "});index.add({'id':331,'href':'/leetcode-java/04_Leetcode/0718.Maximum-Length-of-Repeated-Subarray/','title':"0718. Maximum Length of Repeated Subarray",'section':"第四章",'content':"718. Maximum Length of Repeated Subarray #  题目 #  Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.\nExample 1:\nInput: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1].  Note:\n 1 \u0026lt;= len(A), len(B) \u0026lt;= 1000 0 \u0026lt;= A[i], B[i] \u0026lt; 100  题目大意 #  给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。\n解题思路 #    给出两个数组，求这两个数组中最长相同子串的长度。\n  这一题最容易想到的是 DP 动态规划的解法。dp[i][j] 代表在 A 数组中以 i 下标开始的子串与 B 数组中以 j 下标开始的子串最长相同子串的长度，状态转移方程为 dp[i][j] = dp[i+1][j+1] + 1 (当 A[i] == B[j])。这种解法的时间复杂度是 O(n^2)，空间复杂度 O(n^2)。\n  这一题最佳解法是二分搜索 + Rabin-Karp。比较相同子串耗时的地方在于，需要一层循环，遍历子串所有字符。但是如果比较两个数字就很快，O(1) 的时间复杂度。所以有人就想到了，能不能把字符串也映射成数字呢？这样比较起来就非常快。这个算法就是 Rabin-Karp 算法。字符串映射成一个数字不能随意映射，还要求能根据字符串前缀动态增加，比较下一个字符串的时候，可以利用已比较过的前缀，加速之后的字符串比较。在 Rabin-Karp 算法中有一个“码点”的概念。类似于10进制中的进制。具体的算法讲解可以见这篇：\n 基础知识 - Rabin-Karp 算法\n“码点”一般取值为一个素数。在 go 的 strings 包里面取值是 16777619。所以这一题也可以直接取这个值。由于这一次要求我们找最长长度，所以把最长长度作为二分搜索的目标。先将数组 A 和数组 B 中的数字都按照二分出来的长度，进行 Rabin-Karp hash。对 A 中的 hash 与下标做映射关系，存到 map 中，方便后面快速查找。然后遍历 B 中的 hash，当 hash 一致的时候，再匹配下标。如果下标存在，且拥有相同的前缀，那么就算找到了相同的子串了。最后就是不断的二分，找到最长的结果即可。这个解法的时间复杂度 O(n * log n)，空间复杂度 O(n)。\n  代码 #  package leetcode const primeRK = 16777619 // 解法一 二分搜索 + Rabin-Karp func findLength(A []int, B []int) int { low, high := 0, min(len(A), len(B)) for low \u0026lt; high { mid := (low + high + 1) \u0026gt;\u0026gt; 1 if hasRepeated(A, B, mid) { low = mid } else { high = mid - 1 } } return low } func hashSlice(arr []int, length int) []int { // hash 数组里面记录 arr 比 length 长出去部分的 hash 值 \thash, pl, h := make([]int, len(arr)-length+1), 1, 0 for i := 0; i \u0026lt; length-1; i++ { pl *= primeRK } for i, v := range arr { h = h*primeRK + v if i \u0026gt;= length-1 { hash[i-length+1] = h h -= pl * arr[i-length+1] } } return hash } func hasSamePrefix(A, B []int, length int) bool { for i := 0; i \u0026lt; length; i++ { if A[i] != B[i] { return false } } return true } func hasRepeated(A, B []int, length int) bool { hs := hashSlice(A, length) hashToOffset := make(map[int][]int, len(hs)) for i, h := range hs { hashToOffset[h] = append(hashToOffset[h], i) } for i, h := range hashSlice(B, length) { if offsets, ok := hashToOffset[h]; ok { for _, offset := range offsets { if hasSamePrefix(A[offset:], B[i:], length) { return true } } } } return false } // 解法二 DP 动态规划 func findLength1(A []int, B []int) int { res, dp := 0, make([][]int, len(A)+1) for i := range dp { dp[i] = make([]int, len(B)+1) } for i := len(A) - 1; i \u0026gt;= 0; i-- { for j := len(B) - 1; j \u0026gt;= 0; j-- { if A[i] == B[j] { dp[i][j] = dp[i+1][j+1] + 1 if dp[i][j] \u0026gt; res { res = dp[i][j] } } } } return res } "});index.add({'id':332,'href':'/leetcode-java/04_Leetcode/0719.Find-K-th-Smallest-Pair-Distance/','title':"0719. Find K Th Smallest Pair Distance",'section':"第四章",'content':"719. Find K-th Smallest Pair Distance #  题目 #  Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\nExample 1:\nInput: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -\u0026gt; 2 (1,1) -\u0026gt; 0 (3,1) -\u0026gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.  Note:\n 2 \u0026lt;= len(nums) \u0026lt;= 10000. 0 \u0026lt;= nums[i] \u0026lt; 1000000. 1 \u0026lt;= k \u0026lt;= len(nums) * (len(nums) - 1) / 2.  题目大意 #  给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。\n提示:\n 2 \u0026lt;= len(nums) \u0026lt;= 10000. 0 \u0026lt;= nums[i] \u0026lt; 1000000. 1 \u0026lt;= k \u0026lt;= len(nums) * (len(nums) - 1) / 2.  解题思路 #   给出一个数组，要求找出第 k 小两两元素之差的值。两两元素之差可能重复，重复的元素之差算多个，不去重。 这一题可以用二分搜索来解答。先把原数组排序，那么最大的差值就是 nums[len(nums)-1] - nums[0] ，最小的差值是 0，即在 [0, nums[len(nums)-1] - nums[0]] 区间内搜索最终答案。针对每个 mid，判断小于等于 mid 的差值有多少个。题意就转化为，在数组中找到这样一个数，使得满足 nums[i] - nums[j] ≤ mid 条件的组合数等于 k。那么如何计算满足两两数的差值小于 mid 的组合总数是本题的关键。 最暴力的方法就是 2 重循环，暴力计数。这个方法效率不高，耗时很长。原因是没有利用数组有序这一条件。实际上数组有序对计算满足条件的组合数有帮助。利用双指针滑动即可计算出组合总数。见解法一。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func smallestDistancePair(nums []int, k int) int { sort.Ints(nums) low, high := 0, nums[len(nums)-1]-nums[0] for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 tmp := findDistanceCount(nums, mid) if tmp \u0026gt;= k { high = mid } else { low = mid + 1 } } return low } // 解法一 双指针 func findDistanceCount(nums []int, num int) int { count, i := 0, 0 for j := 1; j \u0026lt; len(nums); j++ { for nums[j]-nums[i] \u0026gt; num \u0026amp;\u0026amp; i \u0026lt; j { i++ } count += (j - i) } return count } // 解法二 暴力查找 func findDistanceCount1(nums []int, num int) int { count := 0 for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { if nums[j]-nums[i] \u0026lt;= num { count++ } } } return count } "});index.add({'id':333,'href':'/leetcode-java/04_Leetcode/0720.Longest-Word-in-Dictionary/','title':"0720. Longest Word in Dictionary",'section':"第四章",'content':"720. Longest Word in Dictionary #  题目 #  Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.\nIf there is no answer, return the empty string.\nExample 1:\nInput: words = [\u0026quot;w\u0026quot;,\u0026quot;wo\u0026quot;,\u0026quot;wor\u0026quot;,\u0026quot;worl\u0026quot;, \u0026quot;world\u0026quot;] Output: \u0026quot;world\u0026quot; Explanation: The word \u0026quot;world\u0026quot; can be built one character at a time by \u0026quot;w\u0026quot;, \u0026quot;wo\u0026quot;, \u0026quot;wor\u0026quot;, and \u0026quot;worl\u0026quot;.  Example 2:\nInput: words = [\u0026quot;a\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;app\u0026quot;, \u0026quot;appl\u0026quot;, \u0026quot;ap\u0026quot;, \u0026quot;apply\u0026quot;, \u0026quot;apple\u0026quot;] Output: \u0026quot;apple\u0026quot; Explanation: Both \u0026quot;apply\u0026quot; and \u0026quot;apple\u0026quot; can be built from other words in the dictionary. However, \u0026quot;apple\u0026quot; is lexicographically smaller than \u0026quot;apply\u0026quot;.  Note:\n All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].  题目大意 #  给出一个字符串数组 words 组成的一本英语词典。从中找出最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。\n解题思路 #   给出一个字符串数组，要求找到长度最长的，并且可以由字符串数组里面其他字符串拼接一个字符组成的字符串。如果存在多个这样的最长的字符串，则输出字典序较小的那个字符串，如果找不到这样的字符串，输出空字符串。 这道题解题思路是先排序，排序完成以后就是字典序从小到大了。之后再用 map 辅助记录即可。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func longestWord(words []string) string { sort.Strings(words) mp := make(map[string]bool) var res string for _, word := range words { size := len(word) if size == 1 || mp[word[:size-1]] { if size \u0026gt; len(res) { res = word } mp[word] = true } } return res } "});index.add({'id':334,'href':'/leetcode-java/04_Leetcode/0721.Accounts-Merge/','title':"0721. Accounts Merge",'section':"第四章",'content':"721. 账户合并 #  Difficulty: 中等\n给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。\n现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。\n合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。\n例子 1:\nInput: accounts = [[\u0026#34;John\u0026#34;, \u0026#34;johnsmith@mail.com\u0026#34;, \u0026#34;john00@mail.com\u0026#34;], [\u0026#34;John\u0026#34;, \u0026#34;johnnybravo@mail.com\u0026#34;], [\u0026#34;John\u0026#34;, \u0026#34;johnsmith@mail.com\u0026#34;, \u0026#34;john_newyork@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;, \u0026#34;mary@mail.com\u0026#34;]] Output: [[\u0026#34;John\u0026#34;, \u0026#39;john00@mail.com\u0026#39;, \u0026#39;john_newyork@mail.com\u0026#39;, \u0026#39;johnsmith@mail.com\u0026#39;], [\u0026#34;John\u0026#34;, \u0026#34;johnnybravo@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;, \u0026#34;mary@mail.com\u0026#34;]] Explanation: 第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 \u0026#34;johnsmith@mail.com\u0026#34;。 第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。 我们可以以任何顺序返回这些列表，例如答案[[\u0026#39;Mary\u0026#39;，\u0026#39;mary@mail.com\u0026#39;]，[\u0026#39;John\u0026#39;，\u0026#39;johnnybravo@mail.com\u0026#39;]， [\u0026#39;John\u0026#39;，\u0026#39;john00@mail.com\u0026#39;，\u0026#39;john_newyork@mail.com\u0026#39;，\u0026#39;johnsmith@mail.com\u0026#39;]]仍然会被接受。 注意：\n accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。  题解 #  题解一：DFS（深度优先搜索） #  class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { Map\u0026lt;String, String\u0026gt; emailToName = new HashMap(); Map\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; graph = new HashMap(); for (List\u0026lt;String\u0026gt; account: accounts) { String name = \u0026#34;\u0026#34;; for (String email : account) { if (name == \u0026#34;\u0026#34;) { name = email; continue; } graph.computeIfAbsent(email, x-\u0026gt; new ArrayList\u0026lt;String\u0026gt;()).add(account.get(1)); graph.computeIfAbsent(account.get(1), x-\u0026gt; new ArrayList\u0026lt;String\u0026gt;()).add(email); emailToName.put(email, name); } } Set\u0026lt;String\u0026gt; seen = new HashSet(); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ans = new ArrayList(); for (String email: graph.keySet()) { if (!seen.contains(email)) { seen.add(email); Stack\u0026lt;String\u0026gt; stack = new Stack(); stack.push(email); List\u0026lt;String\u0026gt; component = new ArrayList(); while (!stack.empty()) { String node = stack.pop(); component.add(node); for (String nei: graph.get(node)) { if (!seen.contains(nei)) { seen.add(nei); stack.push(nei); } } } Collections.sort(component); component.add(0, emailToName.get(email)); ans.add(component); } } return ans; } } 复杂度分析\n  时间复杂度：\n  空间复杂度：\n  "});index.add({'id':335,'href':'/leetcode-java/04_Leetcode/0724.Find-Pivot-Index/','title':"0724. Find Pivot Index",'section':"第四章",'content':"724. Find Pivot Index #  题目 #  Given an array of integers nums, write a method that returns the \u0026ldquo;pivot\u0026rdquo; index of this array.\nWe define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\nExample 1:\nInput: nums = [1,7,3,6,5,6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.  Example 2:\nInput: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement.  Constraints:\n The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].  题目大意 #  给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n解题思路 #   在数组中，找到一个数，使得它左边的数之和等于它的右边的数之和，如果存在，则返回这个数的下标索引，否作返回 -1。 这里面存在一个等式，只需要满足这个等式即可满足条件：leftSum + num[i] = sum - leftSum =\u0026gt; 2 * leftSum + num[i] = sum。 题目提到如果存在多个索引，则返回最左边那个，因此从左开始求和，而不是从右边。  代码 #  package leetcode // 2 * leftSum + num[i] = sum // 时间: O(n) // 空间: O(1) func pivotIndex(nums []int) int { if len(nums) \u0026lt;= 0 { return -1 } var sum, leftSum int for _, num := range nums { sum += num } for index, num := range nums { if leftSum*2+num == sum { return index } leftSum += num } return -1 } "});index.add({'id':336,'href':'/leetcode-java/04_Leetcode/0725.Split-Linked-List-in-Parts/','title':"0725. Split Linked List in Parts",'section':"第四章",'content':"725. Split Linked List in Parts #  题目 #  Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \u0026ldquo;parts\u0026rdquo;.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\nReturn a List of ListNode\u0026rsquo;s representing the linked list parts that are formed.\nExamples 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\nExample 1:\n Input: root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is []. Example 2:\n Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Note:\n The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50].  题目大意 #  把链表分成 K 个部分，要求这 K 个部分尽量两两长度相差不超过 1，并且长度尽量相同。\n解题思路 #  把链表长度对 K 进行除法，结果就是最终每组的长度 n。把链表长度对 K 进行取余操作，得到的结果 m，代表前 m 组链表长度为 n + 1 。相当于把多出来的部分都分摊到前面 m 组链表中了。最终链表是前 m 组长度为 n + 1，后 K - m 组链表长度是 n。\n注意长度不足 K 的时候要用 nil 进行填充。\n代码 #  package leetcode import \u0026#34;fmt\u0026#34; /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func splitListToParts(root *ListNode, k int) []*ListNode { res := make([]*ListNode, 0) if root == nil { for i := 0; i \u0026lt; k; i++ { res = append(res, nil) } return res } length := getLength(root) splitNum := length / k lengNum := length % k cur, head := root, root var pre *ListNode fmt.Printf(\u0026#34;总长度 %v, 分 %v 组, 前面 %v 组长度为 %v, 剩余 %v 组，每组 %v\\n\u0026#34;, length, k, lengNum, splitNum+1, k-lengNum, splitNum) if splitNum == 0 { for i := 0; i \u0026lt; k; i++ { if cur != nil { pre = cur.Next cur.Next = nil res = append(res, cur) cur = pre } else { res = append(res, nil) } } return res } for i := 0; i \u0026lt; lengNum; i++ { for j := 0; j \u0026lt; splitNum; j++ { cur = cur.Next } fmt.Printf(\u0026#34;0 刚刚出来 head = %v cur = %v pre = %v\\n\u0026#34;, head, cur, head) pre = cur.Next cur.Next = nil res = append(res, head) head = pre cur = pre fmt.Printf(\u0026#34;0 head = %v cur = %v pre = %v\\n\u0026#34;, head, cur, head) } for i := 0; i \u0026lt; k-lengNum; i++ { for j := 0; j \u0026lt; splitNum-1; j++ { cur = cur.Next } fmt.Printf(\u0026#34;1 刚刚出来 head = %v cur = %v pre = %v\\n\u0026#34;, head, cur, head) pre = cur.Next cur.Next = nil res = append(res, head) head = pre cur = pre } return res } func getLength(l *ListNode) int { count := 0 cur := l for cur != nil { count++ cur = cur.Next } return count } "});index.add({'id':337,'href':'/leetcode-java/04_Leetcode/0726.Number-of-Atoms/','title':"0726. Number of Atoms",'section':"第四章",'content':"726. Number of Atoms #  题目 #  Given a chemical formula (given as a string), return the count of each atom.\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.\nTwo formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.\nA formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nExample 1:\nInput: formula = \u0026quot;H2O\u0026quot; Output: \u0026quot;H2O\u0026quot; Explanation: The count of elements are {'H': 2, 'O': 1}.  Example 2:\nInput: formula = \u0026quot;Mg(OH)2\u0026quot; Output: \u0026quot;H2MgO2\u0026quot; Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.  Example 3:\nInput: formula = \u0026quot;K4(ON(SO3)2)2\u0026quot; Output: \u0026quot;K4N2O14S4\u0026quot; Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.  Note:\n All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.  题目大意 #  给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。\n原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。\n解题思路 #   利用栈处理每个化学元素，用 map 记录每个化学元素的个数，最终排序以后输出即可 注意化学元素有些并不是单一字母，比如镁元素是 Mg，所以需要考虑字母的大小写问题。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) type atom struct { name string cnt int } type atoms []atom func (this atoms) Len() int { return len(this) } func (this atoms) Less(i, j int) bool { return strings.Compare(this[i].name, this[j].name) \u0026lt; 0 } func (this atoms) Swap(i, j int) { this[i], this[j] = this[j], this[i] } func (this atoms) String() string { s := \u0026#34;\u0026#34; for _, a := range this { s += a.name if a.cnt \u0026gt; 1 { s += strconv.Itoa(a.cnt) } } return s } func countOfAtoms(s string) string { n := len(s) if n == 0 { return \u0026#34;\u0026#34; } stack := make([]string, 0) for i := 0; i \u0026lt; n; i++ { c := s[i] if c == \u0026#39;(\u0026#39; || c == \u0026#39;)\u0026#39; { stack = append(stack, string(c)) } else if isUpperLetter(c) { j := i + 1 for ; j \u0026lt; n; j++ { if !isLowerLetter(s[j]) { break } } stack = append(stack, s[i:j]) i = j - 1 } else if isDigital(c) { j := i + 1 for ; j \u0026lt; n; j++ { if !isDigital(s[j]) { break } } stack = append(stack, s[i:j]) i = j - 1 } } cnt, deep := make([]map[string]int, 100), 0 for i := 0; i \u0026lt; 100; i++ { cnt[i] = make(map[string]int) } for i := 0; i \u0026lt; len(stack); i++ { t := stack[i] if isUpperLetter(t[0]) { num := 1 if i+1 \u0026lt; len(stack) \u0026amp;\u0026amp; isDigital(stack[i+1][0]) { num, _ = strconv.Atoi(stack[i+1]) i++ } cnt[deep][t] += num } else if t == \u0026#34;(\u0026#34; { deep++ } else if t == \u0026#34;)\u0026#34; { num := 1 if i+1 \u0026lt; len(stack) \u0026amp;\u0026amp; isDigital(stack[i+1][0]) { num, _ = strconv.Atoi(stack[i+1]) i++ } for k, v := range cnt[deep] { cnt[deep-1][k] += v * num } cnt[deep] = make(map[string]int) deep-- } } as := atoms{} for k, v := range cnt[0] { as = append(as, atom{name: k, cnt: v}) } sort.Sort(as) return as.String() } func isDigital(v byte) bool { if v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39; { return true } return false } func isUpperLetter(v byte) bool { if v \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;Z\u0026#39; { return true } return false } func isLowerLetter(v byte) bool { if v \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;z\u0026#39; { return true } return false } "});index.add({'id':338,'href':'/leetcode-java/04_Leetcode/0729.My-Calendar-I/','title':"0729. My Calendar I",'section':"第四章",'content':"729. My Calendar I #  题目 #  Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start \u0026lt;= x \u0026lt; end.\nA double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\nYour class will be called like this:\nMyCalendar cal = new MyCalendar();\nMyCalendar.book(start, end)\nExample 1:\nMyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation: The first event can be booked. The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.  Note:\n The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].  题目大意 #  实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。\nMyCalendar 有一个 book(int start, int end) 方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start \u0026lt;= x \u0026lt; end。\n当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。\n每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。\n请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n说明:\n 每个测试用例，调用 MyCalendar.book 函数最多不超过 100次。 调用函数 MyCalendar.book(start, end) 时， start 和 end 的取值范围为 [0, 10^9]。  解题思路 #   要求实现一个日程安排的功能，如果有日程安排冲突了，就返回 false，如果不冲突则返回 ture 这一题有多种解法，第一种解法可以用类似第 34 题的解法。先排序每个区间，然后再这个集合中用二分搜索找到最后一个区间的左值比当前要比较的区间左值小的，如果找到，再判断能否插入进去(判断右区间是否比下一个区间的左区间小)，此方法时间复杂度 O(n log n) 第二种解法是用生成一个 BST 树。在插入树中先排除不能插入的情况，例如区间有重合。然后以区间左值为依据，递归插入，每次插入依次会继续判断区间是否重合。直到不能插入，则返回 fasle。整个查找的时间复杂度是 O(log n)。  代码 #  package leetcode // 解法一 二叉排序树 // Event define type Event struct { start, end int left, right *Event } // Insert define func (e *Event) Insert(curr *Event) bool { if e.end \u0026gt; curr.start \u0026amp;\u0026amp; curr.end \u0026gt; e.start { return false } if curr.start \u0026lt; e.start { if e.left == nil { e.left = curr } else { return e.left.Insert(curr) } } else { if e.right == nil { e.right = curr } else { return e.right.Insert(curr) } } return true } // MyCalendar define type MyCalendar struct { root *Event } // Constructor729 define func Constructor729() MyCalendar { return MyCalendar{ root: nil, } } // Book define func (this *MyCalendar) Book(start int, end int) bool { curr := \u0026amp;Event{start: start, end: end, left: nil, right: nil} if this.root == nil { this.root = curr return true } return this.root.Insert(curr) } // 解法二 快排 + 二分 // MyCalendar define // type MyCalendar struct { // calendar []Interval // }  // // Constructor729 define // func Constructor729() MyCalendar { // calendar := []Interval{} // return MyCalendar{calendar: calendar} // }  // // Book define // func (this *MyCalendar) Book(start int, end int) bool { // if len(this.calendar) == 0 { // this.calendar = append(this.calendar, Interval{Start: start, End: end}) // return true // } // // 快排 // quickSort(this.calendar, 0, len(this.calendar)-1) // // 二分 // pos := searchLastLessInterval(this.calendar, start, end) // // 如果找到最后一个元素，需要判断 end // if pos == len(this.calendar)-1 \u0026amp;\u0026amp; this.calendar[pos].End \u0026lt;= start { // this.calendar = append(this.calendar, Interval{Start: start, End: end}) // return true // } // // 如果不是开头和结尾的元素，还需要判断这个区间是否能插入到原数组中(要看起点和终点是否都能插入) // if pos != len(this.calendar)-1 \u0026amp;\u0026amp; pos != -1 \u0026amp;\u0026amp; this.calendar[pos].End \u0026lt;= start \u0026amp;\u0026amp; this.calendar[pos+1].Start \u0026gt;= end { // this.calendar = append(this.calendar, Interval{Start: start, End: end}) // return true // } // // 如果元素比开头的元素还要小，要插入到开头 // if this.calendar[0].Start \u0026gt;= end { // this.calendar = append(this.calendar, Interval{Start: start, End: end}) // return true // } // return false // }  // func searchLastLessInterval(intervals []Interval, start, end int) int { // low, high := 0, len(intervals)-1 // for low \u0026lt;= high { // mid := low + ((high - low) \u0026gt;\u0026gt; 1) // if intervals[mid].Start \u0026lt;= start { // if (mid == len(intervals)-1) || (intervals[mid+1].Start \u0026gt; start) { // 找到最后一个小于等于 target 的元素 // return mid // } // low = mid + 1 // } else { // high = mid - 1 // } // } // return -1 // }  /** * Your MyCalendar object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Book(start,end); */ "});index.add({'id':339,'href':'/leetcode-java/04_Leetcode/0732.My-Calendar-III/','title':"0732. My Calendar I I I",'section':"第四章",'content':"732. My Calendar III #  题目 #  Implement a MyCalendarThree class to store your events. A new event can always be added.\nYour class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start \u0026lt;= x \u0026lt; end.\nA K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)\nFor each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.\nYour class will be called like this:\nMyCalendarThree cal = new MyCalendarThree();\nMyCalendarThree.book(start, end)\nExample 1:\nMyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation: The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.  Note:\n The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].  题目大意 #  实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。\nMyCalendar 有一个 book(int start, int end)方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start \u0026lt;= x \u0026lt; end。当 K 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 K 次预订。每次调用 MyCalendar.book方法时，返回一个整数 K ，表示最大的 K 次预订。\n请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n说明:\n 每个测试用例，调用 MyCalendar.book 函数最多不超过 400 次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。  解题思路 #   设计一个日程类，每添加一个日程，实时显示出当前排期中累计日程最多的个数，例如在一段时间内，排了 3 个日程，其他时间内都只有 0，1，2 个日程，则输出 3 。 拿到这个题目以后会立即想到线段树。由于题目中只有增加日程，所以这一题难度不大。这一题和第 699 题也类似，但是有区别，第 699 题中，俄罗斯方块会依次摞起来，而这一题中，俄罗斯方块也就摞起来，但是方块下面如果是空挡，方块会断掉。举个例子：依次增加区间 [10,20]，[10,40]，[5,15]，[5,10]，如果是第 699 题的规则，这 [5,10] 的这块砖块会落在 [5,15] 上，从而使得高度为 4，但是这一题是日程，日程不一样，[5,15] 这个区间内有 3 个日程，但是其他部分都没有 3 个日程，所以第三块砖块 [5,15] 中的 [5,10] 会“断裂”，掉下去，第四块砖块还是 [5,10]，落在第三块砖块断落下去的位置，它们俩落在一起的高度是 2 。 构造一颗线段树，这里用树来构造，如果用数组需要开辟很大的空间。当区间左右边界和查询边界完全相同的时候再累加技术，否则不加，继续划分区间。以区间的左边界作为划分区间的标准，因为区间左边界是开区间，右边是闭区间。一个区间的计数值以区间左边界的计数为准。还是上面的例子，[5,10) 计数以 5 为标准，count = 2，[10,15) 计数以 10 为标准，count = 3 。还需要再动态维护一个最大值。这个线段树的实现比较简单。 类似的题目有：第 715 题，第 218 题，第 699 题。第 715 题是区间更新定值(不是增减)，第 218 题可以用扫描线，第 732 题和第 699 题类似，也是俄罗斯方块的题目，但是第 732 题的俄罗斯方块的方块会“断裂”。  代码 #  package leetcode // SegmentTree732 define type SegmentTree732 struct { start, end, count int left, right *SegmentTree732 } // MyCalendarThree define type MyCalendarThree struct { st *SegmentTree732 maxHeight int } // Constructor732 define func Constructor732() MyCalendarThree { st := \u0026amp;SegmentTree732{ start: 0, end: 1e9, } return MyCalendarThree{ st: st, } } // Book define func (mct *MyCalendarThree) Book(start int, end int) int { mct.st.book(start, end, \u0026amp;mct.maxHeight) return mct.maxHeight } func (st *SegmentTree732) book(start, end int, maxHeight *int) { if start == end { return } if start == st.start \u0026amp;\u0026amp; st.end == end { st.count++ if st.count \u0026gt; *maxHeight { *maxHeight = st.count } if st.left == nil { return } } if st.left == nil { if start == st.start { st.left = \u0026amp;SegmentTree732{start: start, end: end, count: st.count} st.right = \u0026amp;SegmentTree732{start: end, end: st.end, count: st.count} st.left.book(start, end, maxHeight) return } st.left = \u0026amp;SegmentTree732{start: st.start, end: start, count: st.count} st.right = \u0026amp;SegmentTree732{start: start, end: st.end, count: st.count} st.right.book(start, end, maxHeight) return } if start \u0026gt;= st.right.start { st.right.book(start, end, maxHeight) } else if end \u0026lt;= st.left.end { st.left.book(start, end, maxHeight) } else { st.left.book(start, st.left.end, maxHeight) st.right.book(st.right.start, end, maxHeight) } } /** * Your MyCalendarThree object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Book(start,end); */ "});index.add({'id':340,'href':'/leetcode-java/04_Leetcode/0733.Flood-Fill/','title':"0733. Flood Fill",'section':"第四章",'content':"733. Flood Fill #  题目 #  An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\nGiven a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \u0026ldquo;flood fill\u0026rdquo; the image.\nTo perform a \u0026ldquo;flood fill\u0026rdquo;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.\nAt the end, return the modified image.\nExample 1:\nInput: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.  Note:\n The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 \u0026lt;= sr \u0026lt; image.length and 0 \u0026lt;= sc \u0026lt; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].  题目大意 #  有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。最后返回经过上色渲染后的图像。\n注意:\n image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 \u0026lt;= sr \u0026lt; image.length 和 0 \u0026lt;= sc \u0026lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。  解题思路 #   给出一个二维的图片点阵，每个点阵都有一个数字。给出一个起点坐标，要求从这个起点坐标开始，把所有与这个起点连通的点都染色成 newColor。 这一题是标准的 Flood Fill 算法。可以用 DFS 也可以用 BFS 。  代码 #  package leetcode func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { color := image[sr][sc] if newColor == color { return image } dfs733(image, sr, sc, newColor) return image } func dfs733(image [][]int, x, y int, newColor int) { if image[x][y] == newColor { return } oldColor := image[x][y] image[x][y] = newColor for i := 0; i \u0026lt; 4; i++ { if (x+dir[i][0] \u0026gt;= 0 \u0026amp;\u0026amp; x+dir[i][0] \u0026lt; len(image)) \u0026amp;\u0026amp; (y+dir[i][1] \u0026gt;= 0 \u0026amp;\u0026amp; y+dir[i][1] \u0026lt; len(image[0])) \u0026amp;\u0026amp; image[x+dir[i][0]][y+dir[i][1]] == oldColor { dfs733(image, x+dir[i][0], y+dir[i][1], newColor) } } } "});index.add({'id':341,'href':'/leetcode-java/04_Leetcode/0735.Asteroid-Collision/','title':"0735. Asteroid Collision",'section':"第四章",'content':"735. Asteroid Collision #  题目 #  We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\n Input: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide. Example 2:\n Input: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other. Example 3:\n Input: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10. Example 4:\n Input: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other. Note:\n The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000]..  题目大意 #  给定一个整数数组 asteroids，表示在同一行的行星。对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。\n解题思路 #  这一题类似第 1047 题。这也是一个类似“对对碰”的游戏，不过这里的碰撞，大行星和小行星碰撞以后，大行星会胜出，小行星直接消失。按照题意的规则来，用栈模拟即可。考虑最终结果：\n 所有向左飞的行星都向左，所有向右飞的行星都向右。 向左飞的行星，如果飞行中没有向右飞行的行星，那么它将安全穿过。 跟踪所有向右移动到右侧的行星，最右边的一个将是第一个面对向左飞行行星碰撞的。 如果它幸存下来，继续前进，否则，任何之前的向右的行星都会被逐一被暴露出来碰撞。  所以先处理这种情况，一层循环把所有能碰撞的向右飞行的行星都碰撞完。碰撞完以后，如果栈顶行星向左飞，新来的行星向右飞，直接添加进来即可。否则栈顶行星向右飞，大小和向左飞的行星一样大小，两者都撞毁灭，弹出栈顶元素。\n代码 #  package leetcode func asteroidCollision(asteroids []int) []int { res := []int{} for _, v := range asteroids { for len(res) != 0 \u0026amp;\u0026amp; res[len(res)-1] \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1] \u0026lt; -v { res = res[:len(res)-1] } if len(res) == 0 || v \u0026gt; 0 || res[len(res)-1] \u0026lt; 0 { res = append(res, v) } else if v \u0026lt; 0 \u0026amp;\u0026amp; res[len(res)-1] == -v { res = res[:len(res)-1] } } return res } "});index.add({'id':342,'href':'/leetcode-java/04_Leetcode/0739.Daily-Temperatures/','title':"0739. Daily Temperatures",'section':"第四章",'content':"739. Daily Temperatures #  题目 #  Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\nFor example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\nNote: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n题目大意 #  给出一个温度数组，要求输出比当天温度高的在未来的哪一天，输出未来第几天的天数。例如比 73 度高的在未来第 1 天出现，比 75 度高的在未来第 4 天出现。\n解题思路 #  这道题根据题意正常处理就可以了。2 层循环。另外一种做法是单调栈，维护一个单调递减的单调栈即可。\n代码 #  package leetcode // 解法一 普通做法 func dailyTemperatures(T []int) []int { res, j := make([]int, len(T)), 0 for i := 0; i \u0026lt; len(T); i++ { for j = i + 1; j \u0026lt; len(T); j++ { if T[j] \u0026gt; T[i] { res[i] = j - i break } } } return res } // 解法二 单调栈 func dailyTemperatures1(T []int) []int { res := make([]int, len(T)) var toCheck []int for i, t := range T { for len(toCheck) \u0026gt; 0 \u0026amp;\u0026amp; T[toCheck[len(toCheck)-1]] \u0026lt; t { idx := toCheck[len(toCheck)-1] res[idx] = i - idx toCheck = toCheck[:len(toCheck)-1] } toCheck = append(toCheck, i) } return res } "});index.add({'id':343,'href':'/leetcode-java/04_Leetcode/0744.Find-Smallest-Letter-Greater-Than-Target/','title':"0744. Find Smallest Letter Greater Than Target",'section':"第四章",'content':"744. Find Smallest Letter Greater Than Target #  题目 #  Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.\nLetters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.\nExamples:\nInput: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;a\u0026quot; Output: \u0026quot;c\u0026quot; Input: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;c\u0026quot; Output: \u0026quot;f\u0026quot; Input: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;d\u0026quot; Output: \u0026quot;f\u0026quot; Input: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;g\u0026quot; Output: \u0026quot;j\u0026quot; Input: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;j\u0026quot; Output: \u0026quot;c\u0026quot; Input: letters = [\u0026quot;c\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;j\u0026quot;] target = \u0026quot;k\u0026quot; Output: \u0026quot;c\u0026quot;  Note:\n letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.  题目大意 #  给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。\n数组里字母的顺序是循环的。举个例子，如果目标字母target = \u0026lsquo;z\u0026rsquo; 并且有序数组为 letters = [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;]，则答案返回 \u0026lsquo;a\u0026rsquo;。\n注:\n letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。  解题思路 #   给出一个字节数组，在这个字节数组中查找在 target 后面的第一个字母。数组是环形的。 这一题也是二分搜索的题目，先在数组里面查找 target，如果找到了，取这个字母的后一个字母。如果没有找到，就取 low 下标的那个字母。注意数组是环形的，所以最后结果需要对下标取余。  代码 #  package leetcode func nextGreatestLetter(letters []byte, target byte) byte { low, high := 0, len(letters)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if letters[mid] \u0026gt; target { high = mid - 1 } else { low = mid + 1 } } find := letters[low%len(letters)] if find \u0026lt;= target { return letters[0] } return find } "});index.add({'id':344,'href':'/leetcode-java/04_Leetcode/0745.Prefix-and-Suffix-Search/','title':"0745. Prefix and Suffix Search",'section':"第四章",'content':"745. Prefix and Suffix Search #  题目 #  Given many words, words[i] has weight i.\nDesign a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.\nExamples:\nInput: WordFilter([\u0026quot;apple\u0026quot;]) WordFilter.f(\u0026quot;a\u0026quot;, \u0026quot;e\u0026quot;) // returns 0 WordFilter.f(\u0026quot;b\u0026quot;, \u0026quot;\u0026quot;) // returns -1  Note:\n words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.  题目大意 #  给定多个 words，words[i] 的权重为 i 。设计一个类 WordFilter 实现函数WordFilter.f(String prefix, String suffix)。这个函数将返回具有前缀 prefix 和后缀suffix 的词的最大权重。如果没有这样的词，返回 -1。\n解题思路 #   要求实现一个 WordFilter ，它具有字符串匹配的功能，可以匹配出前缀和后缀都满足条件的字符串下标，如果找得到，返回下标，如果找不到，则返回 -1 。 这一题有 2 种解题思路。第一种是先把这个 WordFilter 结构里面的字符串全部预处理一遍，将它的前缀，后缀的所有组合都枚举出来放在 map 中，之后匹配的时候只需要按照自己定义的规则查找 key 就可以了。初始化时间复杂度 O(N * L^2)，查找时间复杂度 O(1)，空间复杂度 O(N * L^2)。其中 N 是输入的字符串数组的长度，L 是输入字符串数组中字符串的最大长度。第二种思路是直接遍历字符串每个下标，依次用字符串的前缀匹配方法和后缀匹配方法，依次匹配。初始化时间复杂度 O(1)，查找时间复杂度 O(N * L)，空间复杂度 O(1)。其中 N 是输入的字符串数组的长度，L 是输入字符串数组中字符串的最大长度。  代码 #  package leetcode import \u0026#34;strings\u0026#34; // 解法一 查找时间复杂度 O(1) type WordFilter struct { words map[string]int } func Constructor745(words []string) WordFilter { wordsMap := make(map[string]int, len(words)*5) for k := 0; k \u0026lt; len(words); k++ { for i := 0; i \u0026lt;= 10 \u0026amp;\u0026amp; i \u0026lt;= len(words[k]); i++ { for j := len(words[k]); 0 \u0026lt;= j \u0026amp;\u0026amp; len(words[k])-10 \u0026lt;= j; j-- { ps := words[k][:i] + \u0026#34;#\u0026#34; + words[k][j:] wordsMap[ps] = k } } } return WordFilter{words: wordsMap} } func (this *WordFilter) F(prefix string, suffix string) int { ps := prefix + \u0026#34;#\u0026#34; + suffix if index, ok := this.words[ps]; ok { return index } return -1 } // 解法二 查找时间复杂度 O(N * L) type WordFilter_ struct { input []string } func Constructor_745_(words []string) WordFilter_ { return WordFilter_{input: words} } func (this *WordFilter_) F_(prefix string, suffix string) int { for i := len(this.input) - 1; i \u0026gt;= 0; i-- { if strings.HasPrefix(this.input[i], prefix) \u0026amp;\u0026amp; strings.HasSuffix(this.input[i], suffix) { return i } } return -1 } /** * Your WordFilter object will be instantiated and called as such: * obj := Constructor(words); * param_1 := obj.F(prefix,suffix); */ "});index.add({'id':345,'href':'/leetcode-java/04_Leetcode/0746.Min-Cost-Climbing-Stairs/','title':"0746. Min Cost Climbing Stairs",'section':"第四章",'content':"746. Min Cost Climbing Stairs #  题目 #  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\nExample 1:\nInput: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.  Example 2:\nInput: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].  Note:\n cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].  题目大意 #  数组的每个索引做为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i] (索引从 0 开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n解题思路 #   这一题算是第 70 题的加强版。依旧是爬楼梯的问题，解题思路也是 DP。在爬楼梯的基础上增加了一个新的条件，每层楼梯都有一个 cost 花费，问上到最终楼层，花费最小值是多少。 dp[i] 代表上到第 n 层的最小花费，状态转移方程是 dp[i] = cost[i] + min(dp[i-2], dp[i-1])，最终第 n 层的最小花费是 min(dp[n-2], dp[n-1]) 。 由于每层的花费只和前两层有关系，所以每次 DP 迭代的时候只需要 2 个临时变量即可。可以用这种方式来优化辅助空间。  代码 #  package leetcode // 解法一 DP func minCostClimbingStairs(cost []int) int { dp := make([]int, len(cost)) dp[0], dp[1] = cost[0], cost[1] for i := 2; i \u0026lt; len(cost); i++ { dp[i] = cost[i] + min(dp[i-2], dp[i-1]) } return min(dp[len(cost)-2], dp[len(cost)-1]) } // 解法二 DP 优化辅助空间 func minCostClimbingStairs1(cost []int) int { var cur, last int for i := 2; i \u0026lt; len(cost)+1; i++ { if last+cost[i-1] \u0026gt; cur+cost[i-2] { cur, last = last, cur+cost[i-2] } else { cur, last = last, last+cost[i-1] } } return last } "});index.add({'id':346,'href':'/leetcode-java/04_Leetcode/0748.Shortest-Completing-Word/','title':"0748. Shortest Completing Word",'section':"第四章",'content':"748. Shortest Completing Word #  题目 #  Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate\nHere, for letters we ignore case. For example, \u0026quot;P\u0026quot; on the licensePlate still matches \u0026quot;p\u0026quot; on the word.\nIt is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.\nThe license plate might have the same letter occurring multiple times. For example, given a licensePlate of \u0026quot;PP\u0026quot;, the word \u0026quot;pair\u0026quot; does not complete the licensePlate, but the word \u0026quot;supper\u0026quot; does.\nExample 1:\nInput: licensePlate = \u0026quot;1s3 PSt\u0026quot;, words = [\u0026quot;step\u0026quot;, \u0026quot;steps\u0026quot;, \u0026quot;stripe\u0026quot;, \u0026quot;stepple\u0026quot;] Output: \u0026quot;steps\u0026quot; Explanation: The smallest length word that contains the letters \u0026quot;S\u0026quot;, \u0026quot;P\u0026quot;, \u0026quot;S\u0026quot;, and \u0026quot;T\u0026quot;. Note that the answer is not \u0026quot;step\u0026quot;, because the letter \u0026quot;s\u0026quot; must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.  Example 2:\nInput: licensePlate = \u0026quot;1s3 456\u0026quot;, words = [\u0026quot;looks\u0026quot;, \u0026quot;pest\u0026quot;, \u0026quot;stew\u0026quot;, \u0026quot;show\u0026quot;] Output: \u0026quot;pest\u0026quot; Explanation: There are 3 smallest length words that contains the letters \u0026quot;s\u0026quot;. We return the one that occurred first.  Note:\n licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].  题目大意 #  如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。\n单词在匹配牌照中的字母时不区分大小写，比如牌照中的 \u0026ldquo;P\u0026rdquo; 依然可以匹配单词中的 \u0026ldquo;p\u0026rdquo; 字母。我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。牌照中可能包含多个相同的字符，比如说：对于牌照 \u0026ldquo;PP\u0026rdquo;，单词 \u0026ldquo;pair\u0026rdquo; 无法匹配，但是 \u0026ldquo;supper\u0026rdquo; 可以匹配。\n注意:\n 牌照（licensePlate）的长度在区域[1, 7]中。 牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。 单词列表（words）长度在区间 [10, 1000] 中。 每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。  解题思路 #   给出一个数组，要求找出能包含 licensePlate 字符串中所有字符的最短长度的字符串。如果最短长度的字符串有多个，输出 word 下标小的那个。这一题也是简单题，不过有 2 个需要注意的点，第一点，licensePlate 中可能包含 Unicode 任意的字符，所以要先把字母的字符筛选出来，第二点是题目中保证了一定存在一个最短的单词能满足题意，并且忽略大小写。具体做法按照题意模拟即可。  代码 #  package leetcode import \u0026#34;unicode\u0026#34; func shortestCompletingWord(licensePlate string, words []string) string { lp := genCnter(licensePlate) var ret string for _, w := range words { if match(lp, w) { if len(w) \u0026lt; len(ret) || ret == \u0026#34;\u0026#34; { ret = w } } } return ret } func genCnter(lp string) [26]int { cnter := [26]int{} for _, ch := range lp { if unicode.IsLetter(ch) { cnter[unicode.ToLower(ch)-\u0026#39;a\u0026#39;]++ } } return cnter } func match(lp [26]int, w string) bool { m := [26]int{} for _, ch := range w { m[ch-\u0026#39;a\u0026#39;]++ } for k, v := range lp { if m[k] \u0026lt; v { return false } } return true } "});index.add({'id':347,'href':'/leetcode-java/04_Leetcode/0753.Cracking-the-Safe/','title':"0753. Cracking the Safe",'section':"第四章",'content':"753. Cracking the Safe #  题目 #  There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1.\nWhile entering a password, the last n digits entered will automatically be matched against the correct password.\nFor example, assuming the correct password is \u0026quot;345\u0026quot;, if you type \u0026quot;012345\u0026quot;, the box will open because the correct password matches the suffix of the entered password.\nReturn any password of minimum length that is guaranteed to open the box at some point of entering it.\nExample 1:\nInput: n = 1, k = 2 Output: \u0026quot;01\u0026quot; Note: \u0026quot;10\u0026quot; will be accepted too. Example 2:\nInput: n = 2, k = 2 Output: \u0026quot;00110\u0026quot; Note: \u0026quot;01100\u0026quot;, \u0026quot;10011\u0026quot;, \u0026quot;11001\u0026quot; will be accepted too. Note:\n n will be in the range [1, 4]. k will be in the range [1, 10]. k^n will be at most 4096.  题目大意 #  有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, \u0026hellip;, k-1 中的一个 。你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。举个例子，假设密码是 \u0026ldquo;345\u0026rdquo;，你可以输入 \u0026ldquo;012345\u0026rdquo; 来打开它，只是你输入了 6 个字符.请返回一个能打开保险箱的最短字符串。\n提示：\n n 的范围是 [1, 4]。 k 的范围是 [1, 10]。 k^n 最大可能为 4096。  解题思路 #   给出 2 个数字 n 和 k，n 代表密码是 n 位数，k 代表密码是 k 位。保险箱会记住最后 n 位输入。返回一个能打开保险箱的最短字符串。 看到题目中的数据范围，数据范围很小，所以可以考虑用 DFS。想解开保险箱，当然是暴力破解，枚举所有可能。题目要求我们输出一个最短的字符串，这里是本题的关键，为何有最短呢？这里有贪心的思想。如果下一次递归可以利用上一次的 n-1 位，那么最终输出的字符串肯定是最短的。(笔者这里就不证明了)，例如，例子 2 中，最短的字符串是 00，01，11，10。每次尝试都利用前一次的 n-1 位。想通了这个问题，利用 DFS 暴力回溯即可。  代码 #  const number = \u0026#34;0123456789\u0026#34; func crackSafe(n int, k int) string { if n == 1 { return number[:k] } visit, total := map[string]bool{}, int(math.Pow(float64(k), float64(n))) str := make([]byte, 0, total+n-1) for i := 1; i != n; i++ { str = append(str, \u0026#39;0\u0026#39;) } dfsCrackSafe(total, n, k, \u0026amp;str, \u0026amp;visit) return string(str) } func dfsCrackSafe(depth, n, k int, str *[]byte, visit *map[string]bool) bool { if depth == 0 { return true } for i := 0; i != k; i++ { *str = append(*str, byte(\u0026#39;0\u0026#39;+i)) cur := string((*str)[len(*str)-n:]) if _, ok := (*visit)[cur]; ok != true { (*visit)[cur] = true if dfsCrackSafe(depth-1, n, k, str, visit) { // 只有这里不需要删除 \treturn true } delete(*visit, cur) } // 删除 \t*str = (*str)[0 : len(*str)-1] } return false } "});index.add({'id':348,'href':'/leetcode-java/04_Leetcode/0756.Pyramid-Transition-Matrix/','title':"0756. Pyramid Transition Matrix",'section':"第四章",'content':"756. Pyramid Transition Matrix #  题目 #  We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.\nWe are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple.\nWe start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3.\nReturn true if we can build the pyramid all the way to the top, otherwise false.\nExample 1:\nInput: bottom = \u0026quot;BCD\u0026quot;, allowed = [\u0026quot;BCG\u0026quot;, \u0026quot;CDE\u0026quot;, \u0026quot;GEA\u0026quot;, \u0026quot;FFF\u0026quot;] Output: true Explanation: We can stack the pyramid like this: A / \\ G E / \\ / \\ B C D We are allowed to place G on top of B and C because BCG is an allowed triple. Similarly, we can place E on top of C and D, then A on top of G and E.  Example 2:\nInput: bottom = \u0026quot;AABA\u0026quot;, allowed = [\u0026quot;AAA\u0026quot;, \u0026quot;AAB\u0026quot;, \u0026quot;ABA\u0026quot;, \u0026quot;ABB\u0026quot;, \u0026quot;BAC\u0026quot;] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.  Note:\n bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.  题目大意 #  现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示，例如 “Z”。使用三元组表示金字塔的堆砌规则如下：\n(A, B, C) 表示，“C” 为顶层方块，方块 “A”、“B” 分别作为方块 “C” 下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。\n初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。如果可以由基层一直堆到塔尖返回 true，否则返回 false。\n解题思路 #    这一题是一道 DFS 的题目。题目给出金字塔的底座字符串。然后还会给一个字符串数组，字符串数组里面代表的字符串的砖块。砖块是 3 个字符串组成的。前两个字符代表的是砖块的底边，后一个字符代表的是砖块的顶部。问给出的字符能拼成一个金字塔么？金字塔的特点是顶端就一个字符。\n  这一题用 DFS 深搜每个砖块，从底层砖块开始逐渐往上层码。每递归一层，新一层底部的砖块都会变。当递归到了一层底部只有 2 个字符，顶部只有一个字符的时候，就到金字塔顶端了，就算是完成了。这一题为了挑选合适的砖块，需要把每个砖块底部的 2 个字符作为 key 放进 map 中，加速查找。题目中也给出了特殊情况，相同底部可能存在多种砖块，所以一个 key 可能对应多个 value 的情况，即可能存在多个顶部砖块的情况。这种情况在递归遍历中需要考虑。\n  代码 #  package leetcode func pyramidTransition(bottom string, allowed []string) bool { pyramid := make(map[string][]string) for _, v := range allowed { pyramid[v[:len(v)-1]] = append(pyramid[v[:len(v)-1]], string(v[len(v)-1])) } return dfsT(bottom, \u0026#34;\u0026#34;, pyramid) } func dfsT(bottom, above string, pyramid map[string][]string) bool { if len(bottom) == 2 \u0026amp;\u0026amp; len(above) == 1 { return true } if len(bottom) == len(above)+1 { return dfsT(above, \u0026#34;\u0026#34;, pyramid) } base := bottom[len(above) : len(above)+2] if data, ok := pyramid[base]; ok { for _, key := range data { if dfsT(bottom, above+key, pyramid) { return true } } } return false } "});index.add({'id':349,'href':'/leetcode-java/04_Leetcode/0762.Prime-Number-of-Set-Bits-in-Binary-Representation/','title':"0762. Prime Number of Set Bits in Binary Representation",'section':"第四章",'content':"762. Prime Number of Set Bits in Binary Representation #  题目 #  Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.)\nExample 1:\nInput: L = 6, R = 10 Output: 4 Explanation: 6 -\u0026gt; 110 (2 set bits, 2 is prime) 7 -\u0026gt; 111 (3 set bits, 3 is prime) 9 -\u0026gt; 1001 (2 set bits , 2 is prime) 10-\u0026gt;1010 (2 set bits , 2 is prime)  Example 2:\nInput: L = 10, R = 15 Output: 5 Explanation: 10 -\u0026gt; 1010 (2 set bits, 2 is prime) 11 -\u0026gt; 1011 (3 set bits, 3 is prime) 12 -\u0026gt; 1100 (2 set bits, 2 is prime) 13 -\u0026gt; 1101 (3 set bits, 3 is prime) 14 -\u0026gt; 1110 (3 set bits, 3 is prime) 15 -\u0026gt; 1111 (4 set bits, 4 is not prime)  Note:\n L, R will be integers L \u0026lt;= R in the range [1, 10^6]. R - L will be at most 10000.  题目大意 #  给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）\n注意:\n L, R 是 L \u0026lt;= R 且在 [1, 10^6] 中的整数。 R - L 的最大值为 10000。  解题思路 #   题目给出 [L, R] 区间，在这个区间内的每个整数的二进制表示中 1 的个数如果是素数，那么最终结果就加一，问最终结果是多少？这一题是一个组合题，判断一个数的二进制位有多少位 1，是第 191 题。题目中限定了区间最大不超过 10^6 ，所以 1 的位数最大是 19 位，也就是说素数最大就是 19 。那么素数可以有限枚举出来。最后按照题目的意思累积结果就可以了。  代码 #  package leetcode import \u0026#34;math/bits\u0026#34; func countPrimeSetBits(L int, R int) int { counter := 0 for i := L; i \u0026lt;= R; i++ { if isPrime(bits.OnesCount(uint(i))) { counter++ } } return counter } func isPrime(x int) bool { return x == 2 || x == 3 || x == 5 || x == 7 || x == 11 || x == 13 || x == 17 || x == 19 } "});index.add({'id':350,'href':'/leetcode-java/04_Leetcode/0763.Partition-Labels/','title':"0763. Partition Labels",'section':"第四章",'content':"763. Partition Labels #  题目 #  A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\nExample 1:\n Input: S = \u0026quot;ababcbacadefegdehijhklij\u0026quot; Output: [9,7,8] Explanation: The partition is \u0026quot;ababcbaca\u0026quot;, \u0026quot;defegde\u0026quot;, \u0026quot;hijhklij\u0026quot;. This is a partition so that each letter appears in at most one part. A partition like \u0026quot;ababcbacadefegde\u0026quot;, \u0026quot;hijhklij\u0026quot; is incorrect, because it splits S into less parts. Note:\n S will have length in range [1, 500]. S will consist of lowercase letters (\u0026lsquo;a\u0026rsquo; to \u0026lsquo;z\u0026rsquo;) only.  题目大意 #  这道题考察的是滑动窗口的问题。\n给出一个字符串，要求输出满足条件窗口的长度，条件是在这个窗口内，字母中出现在这一个窗口内，不出现在其他窗口内。\n解题思路 #  这一题有 2 种思路，第一种思路是先记录下每个字母的出现次数，然后对滑动窗口中的每个字母判断次数是否用尽为 0，如果这个窗口内的所有字母次数都为 0，这个窗口就是符合条件的窗口。时间复杂度为 O(n^2)\n另外一种思路是记录下每个字符最后一次出现的下标，这样就不用记录次数。在每个滑动窗口中，依次判断每个字母最后一次出现的位置，如果在一个下标内，所有字母的最后一次出现的位置都包含进来了，那么这个下标就是这个满足条件的窗口大小。时间复杂度为 O(n^2)\n代码 #  package leetcode // 解法一 func partitionLabels(S string) []int { var lastIndexOf [26]int for i, v := range S { lastIndexOf[v-\u0026#39;a\u0026#39;] = i } var arr []int for start, end := 0, 0; start \u0026lt; len(S); start = end + 1 { end = lastIndexOf[S[start]-\u0026#39;a\u0026#39;] for i := start; i \u0026lt; end; i++ { if end \u0026lt; lastIndexOf[S[i]-\u0026#39;a\u0026#39;] { end = lastIndexOf[S[i]-\u0026#39;a\u0026#39;] } } arr = append(arr, end-start+1) } return arr } // 解法二 func partitionLabels1(S string) []int { visit, counter, res, sum, lastLength := make([]int, 26), map[byte]int{}, []int{}, 0, 0 for i := 0; i \u0026lt; len(S); i++ { counter[S[i]]++ } for i := 0; i \u0026lt; len(S); i++ { counter[S[i]]-- visit[S[i]-\u0026#39;a\u0026#39;] = 1 sum = 0 for j := 0; j \u0026lt; 26; j++ { if visit[j] == 1 { sum += counter[byte(\u0026#39;a\u0026#39;+j)] } } if sum == 0 { res = append(res, i+1-lastLength) lastLength += i + 1 - lastLength } } return res } "});index.add({'id':351,'href':'/leetcode-java/04_Leetcode/0765.Couples-Holding-Hands/','title':"0765. Couples Holding Hands",'section':"第四章",'content':"765. Couples Holding Hands #  题目 #  N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.\nThe people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).\nThe couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.\nExample 1:\nInput: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:\nInput: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.  Note:\n len(row) is even and in the range of [4, 60]. row is guaranteed to be a permutation of 0...len(row)-1.  题目大意 #  N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。\n说明:\n len(row) 是偶数且数值在 [4, 60]范围内。 可以保证 row 是序列 0\u0026hellip;len(row)-1 的一个全排列。  解题思路 #    给出一个数组，数组里面两两相邻的元素代表一对情侣。情侣编号是从 0 开始的：0 和 1 是情侣，2 和 3 是情侣……这些情侣坐在一排，但是并非成对坐着一起的，问如何用最小的次数交换座位以后，情侣能两两坐在一起。\n  这道题的突破口是如何找到最小的交换次数。乍一想可能没有思路。直觉告诉我们，这种难题，很可能最后推出来的结论，或者公式是一个很简单的式子。(事实此题确实是这种情况)先不考虑最小交换次数，用正常的方法来处理这道题。举个例子：【3 1 4 0 2 5】，从数组 0 下标开始往后扫。\n 初始状态 集合 0：0，1 集合 1：2，3 集合 2：4，5  3 和 1 不是情侣，将 3 和 1 所在集合 union() 起来。3 所在集合是 1 ，1 所在集合是 0，将 0 和 1 号集合 union() 起来。因为情侣 0 和情侣 1 是集合 0 ，情侣 2 和情侣 3 是集合 1，以此类推。\n 集合 0 和 1：0，1，2，3 集合 2：4，5    继续往后扫，4 和 0 不在同一个集合，4 在集合 3，0 在集合 0，那么把它们 union() 起来。\n 集合 0 和 1 和 2：0，1，2，3，4，5  在上面集合合并的过程中，合并了 2 次。那么就代表最少需要交换 2 次。也可以通过 len(row)/2 - uf.count 来计算。len(row)/2 是初始集合总数，uf.count 是最后剩下的集合数，两者相减就是中间交换的次数。\n  最后实现的代码非常简单。并查集先相邻的两两元素 union() 在一起。然后扫原数组，每次扫相邻的两个，通过这两个元素值所在集合，进行 union()。扫完以后就可以得到最后的答案。\n  回过头来看这道题，为什么我们从数组开头往后依次调整每一对情侣，这样交换的次数是最少的呢？其实这个方法的思想是贪心思想。从头开始往后一对一对的调整，就是可以最终做到次数最少。(具体证明笔者不会)交换到最后，最后一对情侣一定是正确的，无须交换。(因为前面每一对都调整完了，最后一对一定是正确的)\n  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func minSwapsCouples(row []int) int { if len(row)\u0026amp;1 == 1 { return 0 } uf := template.UnionFind{} uf.Init(len(row)) for i := 0; i \u0026lt; len(row)-1; i = i + 2 { uf.Union(i, i+1) } for i := 0; i \u0026lt; len(row)-1; i = i + 2 { if uf.Find(row[i]) != uf.Find(row[i+1]) { uf.Union(row[i], row[i+1]) } } return len(row)/2 - uf.TotalCount() } "});index.add({'id':352,'href':'/leetcode-java/04_Leetcode/0766.Toeplitz-Matrix/','title':"0766. Toeplitz Matrix",'section':"第四章",'content':"766. Toeplitz Matrix #  题目 #  A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.\nNow given an M x N matrix, return True if and only if the matrix is Toeplitz.\nExample 1:\nInput: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: \u0026quot;[9]\u0026quot;, \u0026quot;[5, 5]\u0026quot;, \u0026quot;[1, 1, 1]\u0026quot;, \u0026quot;[2, 2, 2]\u0026quot;, \u0026quot;[3, 3]\u0026quot;, \u0026quot;[4]\u0026quot;. In each diagonal all elements are the same, so the answer is True.  Example 2:\nInput: matrix = [ [1,2], [2,2] ] Output: False Explanation: The diagonal \u0026quot;[1, 2]\u0026quot; has different elements.  Note:\n matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].  Follow up:\n What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?  题目大意 #  如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。\n解题思路 #   给出一个矩阵，要求判断矩阵所有对角斜线上的数字是否都是一个数字。 水题，直接循环判断即可。  代码 #  package leetcode func isToeplitzMatrix(matrix [][]int) bool { rows, columns := len(matrix), len(matrix[0]) for i := 1; i \u0026lt; rows; i++ { for j := 1; j \u0026lt; columns; j++ { if matrix[i-1][j-1] != matrix[i][j] { return false } } } return true } "});index.add({'id':353,'href':'/leetcode-java/04_Leetcode/0767.Reorganize-String/','title':"0767. Reorganize String",'section':"第四章",'content':"767. Reorganize String #  题目 #  Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.\nIf possible, output any possible result. If not possible, return the empty string.\nExample 1:\n Input: S = \u0026quot;aab\u0026quot; Output: \u0026quot;aba\u0026quot; Example 2:\n Input: S = \u0026quot;aaab\u0026quot; Output: \u0026quot;\u0026quot; Note:\nS will consist of lowercase letters and have length in range [1, 500].\n题目大意 #  给定一个字符串，要求重新排列字符串，让字符串两两字符不相同，如果可以实现，即输出最终的字符串，如果不能让两两不相同，则输出空字符串。\n解题思路 #  这道题有 2 种做法。第一种做法是先统计每个字符的出现频率次数，按照频率次数从高往低排序。具体做法就是第 451 题了。如果有一个字母的频次次数超过了 (len(string)+1)/2 那么就返回空字符串。否则输出最终满足题意的字符串。按照频次排序以后，用 2 个指针，一个从 0 开始，另外一个从中间位置开始，依次取出一个字符拼接起来。\n第二种做法是用优先队列，结点是一个结构体，结构体有 2 个字段，一个字段记录是哪个字符，另一个字段记录是这个字符的频次。按照频次的多作为优先级高，用大根堆建立优先队列。注意，这样建立成功的优先队列，重复字母只有一个结点，频次记录在结构体的频次字段中。额外还需要一个辅助队列。优先队列每次都出队一个优先级最高的，然后频次减一，最终结果加上这个字符。然后将这个结点入队。入队的意义是检测这个结点的频次有没有减到 0，如果还不为 0 ，再插入优先队列中。\nstring reorganizeString(string S) { vector\u0026lt;int\u0026gt; mp(26); int n = S.size(); for (char c: S) ++mp[c-\u0026#39;a\u0026#39;]; priority_queue\u0026lt;pair\u0026lt;int, char\u0026gt;\u0026gt; pq; for (int i = 0; i \u0026lt; 26; ++i) { if (mp[i] \u0026gt; (n+1)/2) return \u0026#34;\u0026#34;; if (mp[i]) pq.push({mp[i], i+\u0026#39;a\u0026#39;}); } queue\u0026lt;pair\u0026lt;int, char\u0026gt;\u0026gt; myq; string ans; while (!pq.empty() || myq.size() \u0026gt; 1) { if (myq.size() \u0026gt; 1) { // 注意这里要大于 1，如果是等于 1 的话，频次大的元素一直在输出了，答案就不对了。  auto cur = myq.front(); myq.pop(); if (cur.first != 0) pq.push(cur); } if (!pq.empty()) { auto cur = pq.top(); pq.pop(); ans += cur.second; cur.first--; myq.push(cur); } } return ans; } 代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func reorganizeString(S string) string { fs := frequencySort767(S) if fs == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } bs := []byte(fs) ans := \u0026#34;\u0026#34; j := (len(bs)-1)/2 + 1 for i := 0; i \u0026lt;= (len(bs)-1)/2; i++ { ans += string(bs[i]) if j \u0026lt; len(bs) { ans += string(bs[j]) } j++ } return ans } func frequencySort767(s string) string { if s == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } sMap := map[byte]int{} cMap := map[int][]byte{} sb := []byte(s) for _, b := range sb { sMap[b]++ if sMap[b] \u0026gt; (len(sb)+1)/2 { return \u0026#34;\u0026#34; } } for key, value := range sMap { cMap[value] = append(cMap[value], key) } var keys []int for k := range cMap { keys = append(keys, k) } sort.Sort(sort.Reverse(sort.IntSlice(keys))) res := make([]byte, 0) for _, k := range keys { for i := 0; i \u0026lt; len(cMap[k]); i++ { for j := 0; j \u0026lt; k; j++ { res = append(res, cMap[k][i]) } } } return string(res) } "});index.add({'id':354,'href':'/leetcode-java/04_Leetcode/0771.Jewels-and-Stones/','title':"0771. Jewels and Stones",'section':"第四章",'content':"771. Jewels and Stones #  题目 #  You\u0026rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \u0026quot;a\u0026quot; is considered a different type of stone from \u0026quot;A\u0026quot;.\nExample 1:\nInput: J = \u0026quot;aA\u0026quot;, S = \u0026quot;aAAbbbb\u0026quot; Output: 3  Example 2:\nInput: J = \u0026quot;z\u0026quot;, S = \u0026quot;ZZ\u0026quot; Output: 0  Note:\n S and J will consist of letters and have length at most 50. The characters in J are distinct.  题目大意 #  给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\nJ 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此 \u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;A\u0026rdquo; 是不同类型的石头。\n解题思路 #   给出 2 个字符串，要求在 S 字符串中找出在 J 字符串里面出现的字符个数。这是一道简单题。  代码 #  package leetcode import \u0026#34;strings\u0026#34; // 解法一 func numJewelsInStones(J string, S string) int { count := 0 for i := range S { if strings.Contains(J, string(S[i])) { count++ } } return count } // 解法二 func numJewelsInStones1(J string, S string) int { cache, result := make(map[rune]bool), 0 for _, r := range J { cache[r] = true } for _, r := range S { if _, ok := cache[r]; ok { result++ } } return result } "});index.add({'id':355,'href':'/leetcode-java/04_Leetcode/0778.Swim-in-Rising-Water/','title':"0778. Swim in Rising Water",'section':"第四章",'content':"778. Swim in Rising Water #  题目 #  On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).\nNow rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nYou start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\nExample 1:\nInput: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2:\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation: 0 1 2 3 4 24 23 22 21 5 12 13 14 15 16 11 17 18 19 20 10 9 8 7 6 The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:\n 2 \u0026lt;= N \u0026lt;= 50. grid[i][j] is a permutation of [0, \u0026hellip;, N*N - 1].  题目大意 #  在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？\n提示:\n 2 \u0026lt;= N \u0026lt;= 50. grid[i][j] 位于区间 [0, \u0026hellip;, N*N - 1] 内。  解题思路 #   给出一个 grid[i][j] 方格，每个格子里面表示游泳池里面平台的高度。t 时刻，游泳池中的水的高度是 t。只有水的高度到达了平台的高度以后才能游过去。问从 (0,0) 开始，最短多长时间能到达 (N-1, N-1) 。 这一题有多种解法。第一种解题思路是利用 DFS + 二分。DFS 是用来遍历是否可达。利用时间(即当前水淹过的高度)来判断是否能到达终点 (N-1, N-1) 点。二分用来搜索最终结果的时间。为什么会考虑用二分加速呢？原因是：时间从 0 - max 依次递增。max 是游泳池最高的平台高度。当时间从 0 增加到 max 以后，肯定能到达终点 (N-1, N-1) 点，因为水比所有平台都要高了。想快速找到一个时间 t 能使得 (0,0) 点和 (N-1, N-1) 点之间连通，那么就想到用二分加速了。判断是否取中值的条件是 (0,0) 点和 (N-1, N-1) 点之间是否连通。 第二种解题思路是并查集。只要是 (0,0) 点和 (N-1, N-1) 点没有连通，即不能游到终点，那么就开始 union() 操作，由于起点是 (0,0)，所以向右边 i + 1 和向下边 j + 1 开始尝试。每尝试完一轮，时间会加 1 秒，即高度会加一。直到 (0,0) 点和 (N-1, N-1) 点刚好连通，那么这个时间点就是最终要求的。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 DFS + 二分 func swimInWater(grid [][]int) int { row, col, flags, minWait, maxWait := len(grid), len(grid[0]), make([][]int, len(grid)), 0, 0 for i, row := range grid { flags[i] = make([]int, len(row)) for j := 0; j \u0026lt; col; j++ { flags[i][j] = -1 if row[j] \u0026gt; maxWait { maxWait = row[j] } } } for minWait \u0026lt; maxWait { midWait := (minWait + maxWait) / 2 addFlags(grid, flags, midWait, 0, 0) if flags[row-1][col-1] == midWait { maxWait = midWait } else { minWait = midWait + 1 } } return minWait } func addFlags(grid [][]int, flags [][]int, flag int, row int, col int) { if row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= len(grid) || col \u0026gt;= len(grid[0]) { return } if grid[row][col] \u0026gt; flag || flags[row][col] == flag { return } flags[row][col] = flag addFlags(grid, flags, flag, row-1, col) addFlags(grid, flags, flag, row+1, col) addFlags(grid, flags, flag, row, col-1) addFlags(grid, flags, flag, row, col+1) } // 解法二 并查集(并不是此题的最优解) func swimInWater1(grid [][]int) int { n, uf, res := len(grid), template.UnionFind{}, 0 uf.Init(n * n) for uf.Find(0) != uf.Find(n*n-1) { for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] \u0026gt; res { continue } if i \u0026lt; n-1 \u0026amp;\u0026amp; grid[i+1][j] \u0026lt;= res { uf.Union(i*n+j, i*n+j+n) } if j \u0026lt; n-1 \u0026amp;\u0026amp; grid[i][j+1] \u0026lt;= res { uf.Union(i*n+j, i*n+j+1) } } } res++ } return res - 1 } "});index.add({'id':356,'href':'/leetcode-java/04_Leetcode/0781.Rabbits-in-Forest/','title':"0781. Rabbits in Forest",'section':"第四章",'content':"781. Rabbits in Forest #  题目 #  In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.\nReturn the minimum number of rabbits that could be in the forest.\nExamples:\nInput: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered \u0026quot;1\u0026quot; could both be the same color, say red. The rabbit than answered \u0026quot;2\u0026quot; can't be red or the answers would be inconsistent. Say the rabbit that answered \u0026quot;2\u0026quot; was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Input: answers = [10, 10, 10] Output: 11 Input: answers = [] Output: 0  Note:\n answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].  题目大意 #  森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。返回森林中兔子的最少数量。\n说明:\n answers 的长度最大为1000。 answers[i] 是在 [0, 999] 范围内的整数。  解题思路 #   给出一个数组，数组里面代表的是每个兔子说自己同类还有多少个。要求输出总共有多少只兔子。数字中可能兔子汇报的人数小于总兔子数。 这一题关键在于如何划分不同种类的兔子，有可能相同种类的兔子的个数是一样的，比如 [2,2,2,2,2,2]，这其实是 3 个种类，总共 6 只兔子。用 map 去重相同种类的兔子，不断的减少，当有种类的兔子为 0 以后，还有该种类的兔子报数，需要当做另外一个种类的兔子来看待。  代码 #  package leetcode func numRabbits(ans []int) int { total, m := 0, make(map[int]int) for _, v := range ans { if m[v] == 0 { m[v] += v total += v + 1 } else { m[v]-- } } return total } "});index.add({'id':357,'href':'/leetcode-java/04_Leetcode/0784.Letter-Case-Permutation/','title':"0784. Letter Case Permutation",'section':"第四章",'content':"784. Letter Case Permutation #  题目 #  Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.\nExamples:\nInput: S = \u0026quot;a1b2\u0026quot; Output: [\u0026quot;a1b2\u0026quot;, \u0026quot;a1B2\u0026quot;, \u0026quot;A1b2\u0026quot;, \u0026quot;A1B2\u0026quot;] Input: S = \u0026quot;3z4\u0026quot; Output: [\u0026quot;3z4\u0026quot;, \u0026quot;3Z4\u0026quot;] Input: S = \u0026quot;12345\u0026quot; Output: [\u0026quot;12345\u0026quot;]  Note:\n S will be a string with length between 1 and 12. S will consist only of letters or digits.  题目大意 #  给定一个字符串 S，通过将字符串 S 中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。\n解题思路 #   输出一个字符串中字母变大写，小写的所有组合。 DFS 深搜或者 BFS 广搜都可以。  代码 #  package leetcode import ( \u0026#34;strings\u0026#34; ) // 解法一，DFS 深搜 func letterCasePermutation(S string) []string { if len(S) == 0 { return []string{} } res, pos, c := []string{}, []int{}, []int{} SS := strings.ToLower(S) for i := 0; i \u0026lt; len(SS); i++ { if isLowerLetter(SS[i]) { pos = append(pos, i) } } for i := 0; i \u0026lt;= len(pos); i++ { findLetterCasePermutation(SS, pos, i, 0, c, \u0026amp;res) } return res } func findLetterCasePermutation(s string, pos []int, target, index int, c []int, res *[]string) { if len(c) == target { b := []byte(s) for _, v := range c { b[pos[v]] -= \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39; } *res = append(*res, string(b)) return } for i := index; i \u0026lt; len(pos)-(target-len(c))+1; i++ { c = append(c, i) findLetterCasePermutation(s, pos, target, i+1, c, res) c = c[:len(c)-1] } } // 解法二，先讲第一个字母变大写，然后依次把后面的字母变大写。最终的解数组中答案是翻倍增长的 // 第一步： // [mqe] -\u0026gt; [mqe, Mqe] // 第二步： // [mqe, Mqe] -\u0026gt; [mqe Mqe mQe MQe] // 第二步： // [mqe Mqe mQe MQe] -\u0026gt; [mqe Mqe mQe MQe mqE MqE mQE MQE]  func letterCasePermutation1(S string) []string { res := make([]string, 0, 1\u0026lt;\u0026lt;uint(len(S))) S = strings.ToLower(S) for k, v := range S { if isLetter784(byte(v)) { switch len(res) { case 0: res = append(res, S, toUpper(S, k)) default: for _, s := range res { res = append(res, toUpper(s, k)) } } } } if len(res) == 0 { res = append(res, S) } return res } func isLetter784(c byte) bool { return (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) } func toUpper(s string, i int) string { b := []byte(s) b[i] -= \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39; return string(b) } "});index.add({'id':358,'href':'/leetcode-java/04_Leetcode/0785.Is-Graph-Bipartite/','title':"0785. Is Graph Bipartite",'section':"第四章",'content':"785. Is Graph Bipartite? #  题目 #  Given an undirected graph, return true if and only if it is bipartite.\nRecall that a graph is bipartite if we can split it\u0026rsquo;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.\nThe graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn\u0026rsquo;t contain any element twice.\nExample 1:Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation: The graph looks like this: 0----1 | | | | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}. Example 2:Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation: The graph looks like this: 0----1 | \\ | | \\ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.  Note:\n graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].  题目大意 #  给定一个无向图 graph，当这个图为二分图时返回 true。\ngraph 将会以邻接表方式给出，graph[i] 表示图中与节点i相连的所有节点。每个节点都是一个在 0 到 graph.length-1 之间的整数。这图中没有自环和平行边： graph[i] 中不存在 i，并且 graph[i] 中没有重复的值。\n注意:\n graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果 j 在 graph[i] 里边, 那么 i 也会在 graph[j] 里边。  解题思路 #   判断一个无向图是否是二分图。二分图的定义：如果我们能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，我们就将这个图称为二分图。 这一题可以用 BFS、DFS、并查集来解答。这里是 DFS 实现。任选一个节点开始，把它染成红色，然后对整个图 DFS 遍历，把与它相连的节点并且未被染色的，都染成绿色。颜色不同的节点代表不同的集合。这时候还可能遇到第 2 种情况，与它相连的节点已经有颜色了，并且这个颜色和前一个节点的颜色相同，这就说明了该无向图不是二分图。可以直接 return false。如此遍历到所有节点都染色了，如果能染色成功，说明该无向图是二分图，返回 true。  代码 #  package leetcode // DFS 染色，1 是红色，0 是绿色，-1 是未染色 func isBipartite(graph [][]int) bool { colors := make([]int, len(graph)) for i := range colors { colors[i] = -1 } for i := range graph { if !dfs(i, graph, colors, -1) { return false } } return true } func dfs(n int, graph [][]int, colors []int, parentCol int) bool { if colors[n] == -1 { if parentCol == 1 { colors[n] = 0 } else { colors[n] = 1 } } else if colors[n] == parentCol { return false } else if colors[n] != parentCol { return true } for _, c := range graph[n] { if !dfs(c, graph, colors, colors[n]) { return false } } return true } "});index.add({'id':359,'href':'/leetcode-java/04_Leetcode/0786.K-th-Smallest-Prime-Fraction/','title':"0786. K Th Smallest Prime Fraction",'section':"第四章",'content':"786. K-th Smallest Prime Fraction #  题目 #  A sorted list A contains 1, plus some number of primes. Then, for every p \u0026lt; q in the list, we consider the fraction p/q.\nWhat is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.\nExamples:\nInput: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5. Input: A = [1, 7], K = 1 Output: [1, 7]  Note:\n A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.  题目大意 #  一个已排序好的表 A，其包含 1 和其他一些素数. 当列表中的每一个 p\u0026lt;q 时，我们可以构造一个分数 p/q 。\n那么第 k 个最小的分数是多少呢? 以整数数组的形式返回你的答案, 这里 answer[0] = p 且 answer[1] = q.\n注意:\n A 的取值范围在 2 — 2000. 每个 A[i] 的值在 1 —30000. K 取值范围为 1 — A.length * (A.length - 1) / 2  解题思路 #   给出一个从小到大排列的有序数组，数组里面的元素都是质数，请找出这个数组中的数组成的真分数从小到大排列，第 K 小的分数。 这一题的暴力解法是枚举所有可能的真分数，从小到大排序，输出第 K 小的分数即可。注意排序的时候不能直接用 float 排序，需要转化成分子和分母的结构体进行排序。 最优的解法是二分搜索。由于真分数都小于 1，所以二分搜索的范围是 [0,1]。每次二分出来的 mid，需要在数组里面搜索一次，找出比 mid 小的真分数个数。并记录下最大的真分数的分子和分母，动态维护最大真分数的分子和分母。如果比 mid 小的真分数个数小于 K，那么取右区间继续二分，如果比 mid 小的真分数个数大于 K，那么取左区间继续二分。直到正好找到比 mid 小的真分数个数是 K，此时维护的最大真分数的分子和分母即为答案。 在已排序的矩阵中寻找最 K 小的元素这一系列的题目有：第 373 题，第 378 题，第 668 题，第 719 题，第 786 题。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) // 解法一 二分搜索 func kthSmallestPrimeFraction(A []int, K int) []int { low, high, n := 0.0, 1.0, len(A) // 因为是在小数内使用二分查找，无法像在整数范围内那样通过 mid+1 和边界判断来终止循环 \t// 所以此处根据 count 来结束循环 \tfor { mid, count, p, q, j := (high+low)/2.0, 0, 0, 1, 0 for i := 0; i \u0026lt; n; i++ { for j \u0026lt; n \u0026amp;\u0026amp; float64(A[i]) \u0026gt; float64(mid)*float64(A[j]) { j++ } count += n - j if j \u0026lt; n \u0026amp;\u0026amp; q*A[i] \u0026gt; p*A[j] { p = A[i] q = A[j] } } if count == K { return []int{p, q} } else if count \u0026lt; K { low = mid } else { high = mid } } } // 解法二 暴力解法，时间复杂度 O(n^2) func kthSmallestPrimeFraction1(A []int, K int) []int { if len(A) == 0 || (len(A)*(len(A)-1))/2 \u0026lt; K { return []int{} } fractions := []Fraction{} for i := 0; i \u0026lt; len(A); i++ { for j := i + 1; j \u0026lt; len(A); j++ { fractions = append(fractions, Fraction{molecule: A[i], denominator: A[j]}) } } sort.Sort(SortByFraction(fractions)) return []int{fractions[K-1].molecule, fractions[K-1].denominator} } // Fraction define type Fraction struct { molecule int denominator int } // SortByFraction define type SortByFraction []Fraction func (a SortByFraction) Len() int { return len(a) } func (a SortByFraction) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a SortByFraction) Less(i, j int) bool { return a[i].molecule*a[j].denominator \u0026lt; a[j].molecule*a[i].denominator } "});index.add({'id':360,'href':'/leetcode-java/04_Leetcode/0793.Preimage-Size-of-Factorial-Zeroes-Function/','title':"0793. Preimage Size of Factorial Zeroes Function",'section':"第四章",'content':"793. Preimage Size of Factorial Zeroes Function #  题目 #  Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\nExample 1:\nInput: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2:\nInput: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:\n K will be an integer in the range [0, 10^9].  题目大意 #  f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * \u0026hellip; * x，且0! = 1）\n例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。\n注意：\n K 是范围在 [0, 10^9] 的整数。  解题思路 #   给出一个数 K，要求有多少个 n 能使得 n！末尾 0 的个数等于 K。 这一题是基于第 172 题的逆过程加强版。第 172 题是给出 n，求得末尾 0 的个数。由第 172 题可以知道，n！末尾 0 的个数取决于因子 5 的个数。末尾可能有 K 个 0，那么 n 最多可以等于 5 * K，在 [0, 5* K] 区间内二分搜索，判断 mid 末尾 0 的个数，如果能找到 K，那么就范围 5，如果找不到这个 K，返回 0 。为什么答案取值只有 0 和 5 呢？因为当 n 增加 5 以后，因子 5 的个数又加一了，末尾又可以多 1 个或者多个 0(如果加 5 以后，有多个 5 的因子，例如 25，125，就有可能末尾增加多个 0)。所以有效的 K 值对应的 n 的范围区间就是 5 。反过来，无效的 K 值对应的 n 是 0。K 在 5^n 的分界线处会发生跳变，所有有些值取不到。例如，n 在 [0,5) 内取值，K = 0；n 在 [5,10) 内取值，K = 1；n 在 [10,15) 内取值，K = 2；n 在 [15,20) 内取值，K = 3；n 在 [20,25) 内取值，K = 4；n 在 [25,30) 内取值，K = 6，因为 25 提供了 2 个 5，也就提供了 2 个 0，所以 K 永远无法取值等于 5，即当 K = 5 时，找不到任何的 n 与之对应。 这一题也可以用数学的方法解题。见解法二。这个解法的灵感来自于：n！末尾 0 的个数等于 [1,n] 所有数的因子 5 的个数总和。其次此题的结果一定只有 0 和 5 (分析见上一种解法)。有了这两个结论以后，就可以用数学的方法推导了。首先 n 可以表示为 5 进制的形式  上面式子中，所有有因子 5 的个数为： 这个总数就即是 K。针对不同的 n，an 的通项公式不同，所以表示的 K 的系数也不同。cn 的通项公式呢？  由上面这个递推还能推出通项公式(不过这题不适用通项公式，是用递推公式更方便)：  判断 K 是否能表示成两个数列的表示形式，等价于判断 K 是否能转化为以 Cn 为基的变进制数。到此，转化成类似第 483 题了。代码实现不难，见解法二。 代码 #  package leetcode // 解法一 二分搜索 func preimageSizeFZF(K int) int { low, high := 0, 5*K for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 k := trailingZeroes(mid) if k == K { return 5 } else if k \u0026gt; K { high = mid - 1 } else { low = mid + 1 } } return 0 } // 解法二 数学方法 func preimageSizeFZF1(K int) int { base := 0 for base \u0026lt; K { base = base*5 + 1 } for K \u0026gt; 0 { base = (base - 1) / 5 if K/base == 5 { return 0 } K %= base } return 5 } "});index.add({'id':361,'href':'/leetcode-java/04_Leetcode/0802.Find-Eventual-Safe-States/','title':"0802. Find Eventual Safe States",'section':"第四章",'content':"802. Find Eventual Safe States #  题目 #  In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\nNow, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\nWhich nodes are eventually safe? Return them as an array in sorted order.\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\nExample: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.  Note:\n graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].  题目大意 #  在有向图中, 我们从某个节点和每个转向处开始, 沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边), 我们停止。现在, 如果我们最后能走到终点，那么我们的起始节点是最终安全的。 更具体地说, 存在一个自然数 K, 无论选择从哪里开始行走, 我们走了不到 K 步后必能停止在一个终点。哪些节点最终是安全的？ 结果返回一个有序的数组。\n提示：\n graph 节点数不超过 10000. 图的边数不会超过 32000. 每个 graph[i] 被排序为不同的整数列表， 在区间 [0, graph.length - 1] 中选取。  解题思路 #   给出一个有向图，要求找出所有“安全”节点。“安全”节点的定义是：存在一个自然数 K, 无论选择从哪里开始行走, 我们走了不到 K 步后必能停止在一个终点。 这一题可以用拓扑排序，也可以用 DFS 染色来解答。这里用 DFS 来解答。对于每个节点，我们有 3 种染色的方法：白色 0 号节点表示该节点还没有被访问过；灰色 1 号节点表示该节点在栈中（这一轮搜索中被访问过）或者在环中；黑色 2 号节点表示该节点的所有相连的节点都被访问过，且该节点不在环中。当我们第一次访问一个节点时，我们把它从白色变成灰色，并继续搜索与它相连的节点。如果在搜索过程中我们遇到一个灰色的节点，那么说明找到了一个环，此时退出搜索，所有的灰色节点保持不变（即从任意一个灰色节点开始，都能走到环中），如果搜索过程中，我们没有遇到灰色的节点，那么在回溯到当前节点时，我们把它从灰色变成黑色，即表示它是一个安全的节点。  代码 #  func eventualSafeNodes(graph [][]int) []int { res, color := []int{}, make([]int, len(graph)) for i := range graph { if dfsEventualSafeNodes(graph, i, color) { res = append(res, i) } } return res } // colors: WHITE 0, GRAY 1, BLACK 2; func dfsEventualSafeNodes(graph [][]int, idx int, color []int) bool { if color[idx] \u0026gt; 0 { return color[idx] == 2 } color[idx] = 1 for i := range graph[idx] { if !dfsEventualSafeNodes(graph, graph[idx][i], color) { return false } } color[idx] = 2 return true } "});index.add({'id':362,'href':'/leetcode-java/04_Leetcode/0803.Bricks-Falling-When-Hit/','title':"0803. Bricks Falling When Hit",'section':"第四章",'content':"803. Bricks Falling When Hit #  题目 #  We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.\nWe will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.\nReturn an array representing the number of bricks that will drop after each erasure in sequence.\nExample 1:\nInput: grid = [[1,0,0,0],[1,1,1,0]] hits = [[1,0]] Output: [2] Explanation: If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.  Example 2:\nInput: grid = [[1,0,0,0],[1,1,0,0]] hits = [[1,1],[1,0]] Output: [0,0] Explanation: When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping. Note that the erased brick (1, 0) will not be counted as a dropped brick.  Note:\n The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop.  题目大意 #  我们有一组包含1和0的网格；其中1表示砖块。 当且仅当一块砖直接连接到网格的顶部，或者它至少有一块相邻（4 个方向之一）砖块不会掉落时，它才不会落下。我们会依次消除一些砖块。每当我们消除 (i, j) 位置时， 对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这个消除而落下。返回一个数组表示每次消除操作对应落下的砖块数目。\n注意:\n 网格的行数和列数的范围是[1, 200]。 消除的数字不会超过网格的区域。 可以保证每次的消除都不相同，并且位于网格的内部。 一个消除的位置可能没有砖块，如果这样的话，就不会有砖块落下。  解题思路 #   有一些砖块连接在天花板上，问，如果打掉某个砖块，会掉落几块砖块？打掉的每个砖块不参与计数。 这一题可以用并查集和 DFS 求解。不过尝试用 DFS 的同学就会知道，这一题卡时间卡的很紧。用 DFS 虽然能 AC，但是耗时非常长。用并查集也必须进行秩压缩，不然耗时也非常长。另外，如果用了并查集，每个集合的总数单独统计，不随着 union() 操作，也会导致超时，笔者在这里被 LTE 了多次，最后只能重写 UnionFind 并查集类，将统计操作和 union() 操作写在一起，这一题才 faster than 100.00% AC。 拿到题以后，首先尝试暴力解法，按照顺序打掉砖块，每次打掉砖块以后，都重建并查集。题目要求每次掉落几块砖块，实际上比较每次和天花板连通的砖块个数变化了多少块就可以了。那么解法就出来了，先把和天花板连通的砖块都 union() 起来，记录这个集合中砖块的个数 count，然后每次打掉一个砖块以后，重建并查集，计算与天花板连通的砖块的个数 newCount，newCount - count -1 就是最终答案(打掉的那块砖块不计算其中)，提交代码以后，发现 TLE。 出现 TLE 以后一般思路都是对的，只是时间复杂度过高，需要优化。很明显，需要优化的地方是每次都重建了新的并查集，有没有办法能在上一次状态上进行变更，不用重建并查集呢？如果正向的打掉砖块，那么每次还需要以这个砖块为起点进行 DFS，时间复杂度还是很高。如果反向考虑呢？先把所有要打掉的砖块都打掉，构建打掉这些砖块以后剩下与天花板连通的并查集。然后反向添加打掉的砖块，每次添加一块就刷新一次它周围的 4 个砖块，不用 DFS，这样时间复杂度优化了很多。最后在按照 newCount - count -1 方式计算最终答案。注意每次还原一个砖块的时候需要染色回原有砖块的颜色 1 。优化成这样的做法，基本不会 TLE 了，如果计算 count 是单独计算的，还是会 TLE。如果没有进行秩压缩，时间会超过 1500 ms，所以这一题想拿到 100%，每步优化都要做好。最终 100% 的答案见代码。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func hitBricks(grid [][]int, hits [][]int) []int { if len(hits) == 0 { return []int{} } uf, m, n, res, oriCount := template.UnionFindCount{}, len(grid), len(grid[0]), make([]int, len(hits)), 0 uf.Init(m*n + 1) // 先将要打掉的砖块染色 \tfor _, hit := range hits { if grid[hit[0]][hit[1]] == 1 { grid[hit[0]][hit[1]] = 2 } } for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] == 1 { getUnionFindFromGrid(grid, i, j, uf) } } } oriCount = uf.Count()[uf.Find(m*n)] for i := len(hits) - 1; i \u0026gt;= 0; i-- { if grid[hits[i][0]][hits[i][1]] == 2 { grid[hits[i][0]][hits[i][1]] = 1 getUnionFindFromGrid(grid, hits[i][0], hits[i][1], uf) } nowCount := uf.Count()[uf.Find(m*n)] if nowCount-oriCount \u0026gt; 0 { res[i] = nowCount - oriCount - 1 } else { res[i] = 0 } oriCount = nowCount } return res } func isInGrid(grid [][]int, x, y int) bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(grid) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(grid[0]) } func getUnionFindFromGrid(grid [][]int, x, y int, uf template.UnionFindCount) { m, n := len(grid), len(grid[0]) if x == 0 { uf.Union(m*n, x*n+y) } for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isInGrid(grid, nx, ny) \u0026amp;\u0026amp; grid[nx][ny] == 1 { uf.Union(nx*n+ny, x*n+y) } } } "});index.add({'id':363,'href':'/leetcode-java/04_Leetcode/0811.Subdomain-Visit-Count/','title':"0811. Subdomain Visit Count",'section':"第四章",'content':"811. Subdomain Visit Count #  题目 #  A website domain like \u0026ldquo;discuss.leetcode.com\u0026rdquo; consists of various subdomains. At the top level, we have \u0026ldquo;com\u0026rdquo;, at the next level, we have \u0026ldquo;leetcode.com\u0026rdquo;, and at the lowest level, \u0026ldquo;discuss.leetcode.com\u0026rdquo;. When we visit a domain like \u0026ldquo;discuss.leetcode.com\u0026rdquo;, we will also visit the parent domains \u0026ldquo;leetcode.com\u0026rdquo; and \u0026ldquo;com\u0026rdquo; implicitly.\nNow, call a \u0026ldquo;count-paired domain\u0026rdquo; to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be \u0026ldquo;9001 discuss.leetcode.com\u0026rdquo;.\nWe are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.\nExample 1:\nInput: [\u0026quot;9001 discuss.leetcode.com\u0026quot;] Output: [\u0026quot;9001 discuss.leetcode.com\u0026quot;, \u0026quot;9001 leetcode.com\u0026quot;, \u0026quot;9001 com\u0026quot;] Explanation: We only have one website domain: \u0026quot;discuss.leetcode.com\u0026quot;. As discussed above, the subdomain \u0026quot;leetcode.com\u0026quot; and \u0026quot;com\u0026quot; will also be visited. So they will all be visited 9001 times.  Example 2:\nInput: [\u0026quot;900 google.mail.com\u0026quot;, \u0026quot;50 yahoo.com\u0026quot;, \u0026quot;1 intel.mail.com\u0026quot;, \u0026quot;5 wiki.org\u0026quot;] Output: [\u0026quot;901 mail.com\u0026quot;,\u0026quot;50 yahoo.com\u0026quot;,\u0026quot;900 google.mail.com\u0026quot;,\u0026quot;5 wiki.org\u0026quot;,\u0026quot;5 org\u0026quot;,\u0026quot;1 intel.mail.com\u0026quot;,\u0026quot;951 com\u0026quot;] Explanation: We will visit \u0026quot;google.mail.com\u0026quot; 900 times, \u0026quot;yahoo.com\u0026quot; 50 times, \u0026quot;intel.mail.com\u0026quot; once and \u0026quot;wiki.org\u0026quot; 5 times. For the subdomains, we will visit \u0026quot;mail.com\u0026quot; 900 + 1 = 901 times, \u0026quot;com\u0026quot; 900 + 50 + 1 = 951 times, and \u0026quot;org\u0026quot; 5 times.  Notes:\n The length of cpdomains will not exceed 100. The length of each domain name will not exceed 100. Each address will have either 1 or 2 \u0026ldquo;.\u0026rdquo; characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.  题目大意 #  一个网站域名，如 \u0026ldquo;discuss.leetcode.com\u0026rdquo;，包含了多个子域名。作为顶级域名，常用的有 \u0026ldquo;com\u0026rdquo;，下一级则有 \u0026ldquo;leetcode.com\u0026rdquo;，最低的一级为 \u0026ldquo;discuss.leetcode.com\u0026rdquo;。当我们访问域名 \u0026ldquo;discuss.leetcode.com\u0026rdquo; 时，也同时访问了其父域名 \u0026ldquo;leetcode.com\u0026rdquo; 以及顶级域名 \u0026ldquo;com\u0026rdquo;。给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：\u0026ldquo;9001 discuss.leetcode.com\u0026rdquo;。\n接下来会给出一组访问次数和域名组合的列表 cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。\n解题思路 #   这一题是简单题，统计每个 domain 的出现频次。每个域名根据层级，一级一级的累加频次，比如 discuss.leetcode.com、discuss.leetcode.com 这个域名频次为 1，leetcode.com 这个域名频次为 1，com 这个域名频次为 1。用 map 依次统计每个 domain 出现的频次，按照格式要求输出。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) // 解法一 func subdomainVisits(cpdomains []string) []string { result := make([]string, 0) if len(cpdomains) == 0 { return result } domainCountMap := make(map[string]int, 0) for _, domain := range cpdomains { countDomain := strings.Split(domain, \u0026#34; \u0026#34;) allDomains := strings.Split(countDomain[1], \u0026#34;.\u0026#34;) temp := make([]string, 0) for i := len(allDomains) - 1; i \u0026gt;= 0; i-- { temp = append([]string{allDomains[i]}, temp...) ld := strings.Join(temp, \u0026#34;.\u0026#34;) count, _ := strconv.Atoi(countDomain[0]) if val, ok := domainCountMap[ld]; !ok { domainCountMap[ld] = count } else { domainCountMap[ld] = count + val } } } for k, v := range domainCountMap { t := strings.Join([]string{strconv.Itoa(v), k}, \u0026#34; \u0026#34;) result = append(result, t) } return result } // 解法二 func subdomainVisits1(cpdomains []string) []string { out := make([]string, 0) var b strings.Builder domains := make(map[string]int, 0) for _, v := range cpdomains { splitDomain(v, domains) } for k, v := range domains { b.WriteString(strconv.Itoa(v)) b.WriteString(\u0026#34; \u0026#34;) b.WriteString(k) out = append(out, b.String()) b.Reset() } return out } func splitDomain(domain string, domains map[string]int) { visits := 0 var e error subdomains := make([]string, 0) for i, v := range domain { if v == \u0026#39; \u0026#39; { visits, e = strconv.Atoi(domain[0:i]) if e != nil { panic(e) } break } } for i := len(domain) - 1; i \u0026gt;= 0; i-- { if domain[i] == \u0026#39;.\u0026#39; { subdomains = append(subdomains, domain[i+1:]) } else if domain[i] == \u0026#39; \u0026#39; { subdomains = append(subdomains, domain[i+1:]) break } } for _, v := range subdomains { count, ok := domains[v] if ok { domains[v] = count + visits } else { domains[v] = visits } } } "});index.add({'id':364,'href':'/leetcode-java/04_Leetcode/0812.Largest-Triangle-Area/','title':"0812. Largest Triangle Area",'section':"第四章",'content':"812. Largest Triangle Area #  题目 #  You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.\nExample: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation: The five points are show in the figure below. The red triangle is the largest.  Notes:\n 3 \u0026lt;= points.length \u0026lt;= 50. No points will be duplicated. -50 \u0026lt;= points[i][j] \u0026lt;= 50. Answers within 10^-6 of the true value will be accepted as correct.  题目大意 #  给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。\n解题思路 #   给出一组点的坐标，要求找出能组成三角形面积最大的点集合，输出这个最大面积。 数学题。按照数学定义，分别计算这些能构成三角形的点形成的三角形面积，最终输出最大面积即可。  代码 #  package leetcode func largestTriangleArea(points [][]int) float64 { maxArea, n := 0.0, len(points) for i := 0; i \u0026lt; n; i++ { for j := i + 1; j \u0026lt; n; j++ { for k := j + 1; k \u0026lt; n; k++ { maxArea = max(maxArea, area(points[i], points[j], points[k])) } } } return maxArea } func area(p1, p2, p3 []int) float64 { return abs(p1[0]*p2[1]+p2[0]*p3[1]+p3[0]*p1[1]-p1[0]*p3[1]-p2[0]*p1[1]-p3[0]*p2[1]) / 2 } func abs(num int) float64 { if num \u0026lt; 0 { num = -num } return float64(num) } func max(a, b float64) float64 { if a \u0026gt; b { return a } return b } "});index.add({'id':365,'href':'/leetcode-java/04_Leetcode/0814.Binary-Tree-Pruning/','title':"0814. Binary Tree Pruning",'section':"第四章",'content':"814. 二叉树剪枝 #  Difficulty: 中等\n给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。\n返回移除了所有不包含 1 的子树的原二叉树。\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n示例1: 输入: [1,null,0,0,1] 输出: [1,null,0,null,1] 解释: 只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。  示例2: 输入: [1,0,1,0,0,0,1] 输出: [1,null,1,null,1]  示例3: 输入: [1,1,0,1,1,0,1,0] 输出: [1,1,0,1,1,null,1]  说明:\n 给定的二叉树最多有 100 个节点。 每个节点的值只会为 0 或 1 。  题解 #  解法一：递归求解 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode pruneTree(TreeNode root) { return containsOne(root) ? root : null; } private boolean containsOne(TreeNode node) { if (node == null) { return false; } boolean leftContainsOne = containsOne(node.left); boolean rightContainsOne = containsOne(node.right); if (!leftContainsOne) { node.left = null; } if (!rightContainsOne) { node.right = null; } return node.val == 1 || leftContainsOne || rightContainsOne; } }   时间复杂度：O(N)，其中 N 是树中节点的个数。\n  空间复杂度：O(H)，其中 H 是树的高度，为我们在递归时使用的栈空间大小。\n  "});index.add({'id':366,'href':'/leetcode-java/04_Leetcode/0815.Bus-Routes/','title':"0815. Bus Routes",'section':"第四章",'content':"815. Bus Routes #  题目 #  We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-\u0026gt;5-\u0026gt;7-\u0026gt;1-\u0026gt;5-\u0026gt;7-\u0026gt;1-\u0026gt;\u0026hellip; forever.\nWe start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.\nExample:\nInput: routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.  Note:\n 1 \u0026lt;= routes.length \u0026lt;= 500. 1 \u0026lt;= routes[i].length \u0026lt;= 500. 0 \u0026lt;= routes[i][j] \u0026lt; 10 ^ 6.  题目大意 #  我们有一系列公交路线。每一条路线 routes[i] 上都有一辆公交车在上面循环行驶。例如，有一条路线 routes[0] = [1, 5, 7]，表示第一辆 (下标为0) 公交车会一直按照 1-\u0026gt;5-\u0026gt;7-\u0026gt;1-\u0026gt;5-\u0026gt;7-\u0026gt;1-\u0026gt;\u0026hellip; 的车站路线行驶。假设我们从 S 车站开始（初始时不在公交车上），要去往 T 站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 -1 表示不可能到达终点车站。\n说明:\n 1 \u0026lt;= routes.length \u0026lt;= 500. 1 \u0026lt;= routes[i].length \u0026lt;= 500. 0 \u0026lt;= routes[i][j] \u0026lt; 10 ^ 6.  解题思路 #   给出一些公交路线，公交路径代表经过的哪些站。现在给出起点和终点站，问最少需要换多少辆公交车才能从起点到终点？ 这一题可以转换成图论的问题，将每个站台看成顶点，公交路径看成每个顶点的边。同一个公交的边染色相同。题目即可转化为从顶点 S 到顶点 T 需要经过最少多少条不同的染色边。用 BFS 即可轻松解决。从起点 S 开始，不断的扩展它能到达的站点。用 visited 数组防止放入已经可达的站点引起的环。用 map 存储站点和公交车的映射关系(即某个站点可以由哪些公交车到达)，BFS 的过程中可以用这个映射关系，拿到公交车的其他站点信息，从而扩张队列里面的可达站点。一旦扩展出现了终点 T，就可以返回结果了。  代码 #  package leetcode func numBusesToDestination(routes [][]int, S int, T int) int { if S == T { return 0 } // vertexMap 中 key 是站点，value 是公交车数组，代表这些公交车路线可以到达此站点 \tvertexMap, visited, queue, res := map[int][]int{}, make([]bool, len(routes)), []int{}, 0 for i := 0; i \u0026lt; len(routes); i++ { for _, v := range routes[i] { tmp := vertexMap[v] tmp = append(tmp, i) vertexMap[v] = tmp } } queue = append(queue, S) for len(queue) \u0026gt; 0 { res++ qlen := len(queue) for i := 0; i \u0026lt; qlen; i++ { vertex := queue[0] queue = queue[1:] for _, bus := range vertexMap[vertex] { if visited[bus] == true { continue } visited[bus] = true for _, v := range routes[bus] { if v == T { return res } queue = append(queue, v) } } } } return -1 } "});index.add({'id':367,'href':'/leetcode-java/04_Leetcode/0817.Linked-List-Components/','title':"0817. Linked List Components",'section':"第四章",'content':"817. Linked List Components #  题目 #  We are given head, the head node of a linked list containing unique integer values.\nWe are also given the list G, a subset of the values in the linked list.\nReturn the number of connected components in G, where two values are connected if they appear consecutively in the linked list.\nExample 1:\n Input: head: 0-\u0026gt;1-\u0026gt;2-\u0026gt;3 G = [0, 1, 3] Output: 2 Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2:\n Input: head: 0-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4 G = [0, 3, 1, 4] Output: 2 Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note:\n If N is the length of the linked list given by head, 1 \u0026lt;= N \u0026lt;= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 \u0026lt;= G.length \u0026lt;= 10000. G is a subset of all values in the linked list.  题目大意 #  这道题题目的意思描述的不是很明白，我提交了几次 WA 以后才悟懂题意。\n这道题的意思是，在 G 中能组成多少组子链表，这些子链表的要求是能在原链表中是有序的。\n解题思路 #  这个问题再抽象一下就成为这样：在原链表中去掉 G 中不存在的数，会被切断成几段链表。例如，将原链表中 G 中存在的数标为 0，不存在的数标为 1 。原链表标识为 0-0-0-1-0-1-1-0-0-1-0-1，那么这样原链表被断成了 4 段。只要在链表中找 0-1 组合就可以认为是一段，因为这里必定会有一段生成。\n考虑末尾的情况，0-1，1-0，0-0，1-1，这 4 种情况的特征都是，末尾一位只要是 0，都会新产生一段。所以链表末尾再单独判断一次，是 0 就再加一。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func numComponents(head *ListNode, G []int) int { if head.Next == nil { return 1 } gMap := toMap(G) count := 0 cur := head for cur != nil { if _, ok := gMap[cur.Val]; ok { if cur.Next == nil { // 末尾存在，直接加一 \tcount++ } else { if _, ok = gMap[cur.Next.Val]; !ok { count++ } } } cur = cur.Next } return count } func toMap(G []int) map[int]int { GMap := make(map[int]int, 0) for _, value := range G { GMap[value] = 0 } return GMap } "});index.add({'id':368,'href':'/leetcode-java/04_Leetcode/0819.Most-Common-Word/','title':"0819. Most Common Word",'section':"第四章",'content':"819. Most Common Word #  题目 #  Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn\u0026rsquo;t banned, and that the answer is unique.\nWords in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.\nExample:\nInput: paragraph = \u0026quot;Bob hit a ball, the hit BALL flew far after it was hit.\u0026quot; banned = [\u0026quot;hit\u0026quot;] Output: \u0026quot;ball\u0026quot; Explanation: \u0026quot;hit\u0026quot; occurs 3 times, but it is a banned word. \u0026quot;ball\u0026quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \u0026quot;ball,\u0026quot;), and that \u0026quot;hit\u0026quot; isn't the answer even though it occurs more because it is banned.  Note:\n 1 \u0026lt;= paragraph.length \u0026lt;= 1000. 0 \u0026lt;= banned.length \u0026lt;= 100. 1 \u0026lt;= banned[i].length \u0026lt;= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.  题目大意 #  给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。\n禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。\n解题思路 #   给出一段话和一个 banned 的字符串，要求输出这段话中出现频次最高的并且不出现在 banned 数组里面的字符串，答案唯一。这题是简单题，依次统计每个单词的频次，然后从 map 中删除 banned 里面的单词，取出剩下频次最高的单词即可。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func mostCommonWord(paragraph string, banned []string) string { freqMap, start := make(map[string]int), -1 for i, c := range paragraph { if c == \u0026#39; \u0026#39; || c == \u0026#39;!\u0026#39; || c == \u0026#39;?\u0026#39; || c == \u0026#39;\\\u0026#39;\u0026#39; || c == \u0026#39;,\u0026#39; || c == \u0026#39;;\u0026#39; || c == \u0026#39;.\u0026#39; { if start \u0026gt; -1 { word := strings.ToLower(paragraph[start:i]) freqMap[word]++ } start = -1 } else { if start == -1 { start = i } } } if start != -1 { word := strings.ToLower(paragraph[start:]) freqMap[word]++ } // Strip the banned words from the freqmap \tfor _, bannedWord := range banned { delete(freqMap, bannedWord) } // Find most freq word \tmostFreqWord, mostFreqCount := \u0026#34;\u0026#34;, 0 for word, freq := range freqMap { if freq \u0026gt; mostFreqCount { mostFreqWord = word mostFreqCount = freq } } return mostFreqWord } "});index.add({'id':369,'href':'/leetcode-java/04_Leetcode/0826.Most-Profit-Assigning-Work/','title':"0826. Most Profit Assigning Work",'section':"第四章",'content':"826. Most Profit Assigning Work #  题目 #  We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.\nNow we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\nFor example, if 3 people attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, his profit is $0.\nWhat is the most profit we can make?\nExample 1:\n Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Note:\n 1 \u0026lt;= difficulty.length = profit.length \u0026lt;= 10000 1 \u0026lt;= worker.length \u0026lt;= 10000 difficulty[i], profit[i], worker[i] are in range [1, 10^5]  题目大意 #  这道题考察的是滑动窗口的问题，也是排序相关的问题。\n给出一组任务，每个任务都有一定的难度，每个任务也都有完成以后对应的收益(完成难的任务不一定收益最高)。有一批工人，每个人能处理的任务难度不同。要求输出这批工人完成任务以后的最大收益。\n解题思路 #  先将任务按照难度排序，工人也按照能处理任务难度的能力排序。用一个数组记录下，每个 i 下标，当前能达到的最大收益。计算这个收益只需要从下标为 1 开始，依次比较自己和前一个的收益即可(因为排过序，难度是依次递增的)。有了这个难度依次递增，并且记录了最大收益的数组以后，就可以计算最终结果了。遍历一遍工人数组，如果工人的能力大于任务的难度，就加上这个最大收益。遍历完工人数组，最终结果就是最大收益。\n代码 #  package leetcode import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) // Task define type Task struct { Difficulty int Profit int } // Tasks define type Tasks []Task // Len define func (p Tasks) Len() int { return len(p) } // Swap define func (p Tasks) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // SortByDiff define type SortByDiff struct{ Tasks } // Less define func (p SortByDiff) Less(i, j int) bool { return p.Tasks[i].Difficulty \u0026lt; p.Tasks[j].Difficulty } func maxProfitAssignment(difficulty []int, profit []int, worker []int) int { if len(difficulty) == 0 || len(profit) == 0 || len(worker) == 0 { return 0 } tasks, res, index := []Task{}, 0, 0 for i := 0; i \u0026lt; len(difficulty); i++ { tasks = append(tasks, Task{Difficulty: difficulty[i], Profit: profit[i]}) } sort.Sort(SortByDiff{tasks}) sort.Ints(worker) for i := 1; i \u0026lt; len(tasks); i++ { tasks[i].Profit = max(tasks[i].Profit, tasks[i-1].Profit) } fmt.Printf(\u0026#34;tasks = %v worker = %v\\n\u0026#34;, tasks, worker) for _, w := range worker { for index \u0026lt; len(difficulty) \u0026amp;\u0026amp; w \u0026gt;= tasks[index].Difficulty { index++ } fmt.Printf(\u0026#34;tasks【index】 = %v\\n\u0026#34;, tasks[index]) if index \u0026gt; 0 { res += tasks[index-1].Profit } } return res } "});index.add({'id':370,'href':'/leetcode-java/04_Leetcode/0828.COPYRIGHT-PROBLEM-XXX/','title':"0828. C O P Y R I G H T P R O B L E M X X X",'section':"第四章",'content':"828. Unique Letter String #  题目 #  THIS PROBLEM COPYRIGHT BELONGS TO CODILITY.COM\nExample 1:\nExample 2:\n题目大意 #  如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。例如，在字符串 S = \u0026ldquo;LETTER\u0026rdquo; 中，\u0026ldquo;L\u0026rdquo; 和 \u0026ldquo;R\u0026rdquo; 可以被称为独特字符。我们再定义 UNIQ(S) 作为字符串 S 中独特字符的个数。那么，在 S = \u0026ldquo;LETTER\u0026rdquo; 中， UNIQ(\u0026ldquo;LETTER\u0026rdquo;) = 2。\n对于给定字符串 S，计算其所有非空子串的独特字符的个数（即 UNIQ(substring)）之和。如果在 S 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。考虑到答案可能会非常大，规定返回格式为：结果 mod 10 ^ 9 + 7。\n解题思路 #   这一题可以先用暴力解法尝试解题，不过提交以后会发现判题结果是超时。出错的一组数据是一个有 10000 个字符的字符串。暴力解法中间由于遍历了太多的子区间，导致了超时。 这道题换一个角度思考问题。当子字符串中字符 X 出现了 2 次以上，那么它就对最终结果没有任何影响，所以只有当某个字符只出现一次的时候才会影响最终结果。再者，一个子字符串中不重复的字符的总个数，也就是这个子字符串 UNIQ 值。例如，“ABC”，这个子字符串的 UNIQ 值是 3，可以这样计算，它属于 A 的独特的字符串，也属于 B 的独特的字符串，也属于 C 的独特的字符串，那么计算这个子字符串的问题可以分解成计算 A 有多少个独特的子字符串，B 有多少个独特的子字符串，C 有多少个独特的子字符串的问题。在计算 A 有多少个子字符串的问题的时候，里面肯定会包含 \u0026ldquo;ABC\u0026rdquo; 这个子字符串的。所以原问题就转换成了分别计算给出的字符串中每个字符出现在独特字符串中的总数之和。 假设原字符串是 BAABBABBBAAABA，这个字符串中出现了很多 A 和很多 B，假设我们当前计算到了第 3 个 A 的位置了(index = 5)，即标红色的那个 A。如何计算这个 A 在哪些子字符串中是独特的呢？由于子字符串题目中要求必须是连续的区间，所以这个问题很简单。找到这个 A 前一个 A 的下标位置(index = 2)，再找到这个 A 后一个 A 的下标位置(index = 9)，即 BAABBABBBAAABA，第一个 A 和当前计算的 A 中间区间有 2 个字符，第三个 A 和当前计算的 A 中间有 3 个字符。那么当前计算的 A 出现在 (2 + 1) * (3 + 1) = 12 个子字符串中是独特的，这 12 个字符串是：A，BA，BBA，AB，ABB，ABBB，BAB，BABB，BABBB，BBAB，BBABB，BBABBB。计算方法，假设当前待计算的字符的下标是 i ，找到当前字符前一次出现的下标位置 left，再找到当前字符后一次出现的下标位置 right，那么左边区间 (left,i) 的开区间内包含的字符数是 i - left - 1，右边区间 (i,right) 的开区间内包含的字符数是 right - i - 1。左右两边都还需要考虑空字符串的情况，即左右两边都可以不取任何字符，那么对应的就是只有中间这个待计算的字符 A。所以左右两边都还需要再加上空串的情况，左边 i - left - 1 + 1 = i - left，右边 right - i - 1 + 1 = right - i。左右两边的情况进行排列组合，即 (i - left) * (right - i)。针对字符串的每个字符都计算这样的值，最后累积的总和就是题目中要求的总 UNIQ 值。  代码 #  package leetcode func uniqueLetterString(S string) int { res, left, right := 0, 0, 0 for i := 0; i \u0026lt; len(S); i++ { left = i - 1 for left \u0026gt;= 0 \u0026amp;\u0026amp; S[left] != S[i] { left-- } right = i + 1 for right \u0026lt; len(S) \u0026amp;\u0026amp; S[right] != S[i] { right++ } res += (i - left) * (right - i) } return res % 1000000007 } // 暴力解法，超时！时间复杂度 O(n^2) func uniqueLetterString1(S string) int { if len(S) == 0 { return 0 } res, mod := 0, 1000000007 for i := 0; i \u0026lt; len(S); i++ { letterMap := map[byte]int{} for j := i; j \u0026lt; len(S); j++ { letterMap[S[j]]++ tmp := 0 for _, v := range letterMap { if v \u0026gt; 1 { tmp++ } } if tmp == len(letterMap) { continue } else { res += len(letterMap) - tmp } } } return res % mod } "});index.add({'id':371,'href':'/leetcode-java/04_Leetcode/0832.Flipping-an-Image/','title':"0832. Flipping an Image",'section':"第四章",'content':"832. Flipping an Image #  题目 #  Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].\nExample 1:\nInput: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2:\nInput: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes:\n 1 \u0026lt;= A.length = A[0].length \u0026lt;= 20 0 \u0026lt;= A[i][j] \u0026lt;= 1  题目大意 #  给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n解题思路 #   给定一个二进制矩阵，要求先水平翻转，然后再反转( 1→0 , 0→1 )。 简单题，按照题意先水平翻转，再反转即可。  代码 #  package leetcode func flipAndInvertImage(A [][]int) [][]int { for i := 0; i \u0026lt; len(A); i++ { for a, b := 0, len(A[i])-1; a \u0026lt; b; a, b = a+1, b-1 { A[i][a], A[i][b] = A[i][b], A[i][a] } for a := 0; a \u0026lt; len(A[i]); a++ { A[i][a] = (A[i][a] + 1) % 2 } } return A } "});index.add({'id':372,'href':'/leetcode-java/04_Leetcode/0834.Sum-of-Distances-in-Tree/','title':"0834. Sum of Distances in Tree",'section':"第四章",'content':"834. Sum of Distances in Tree #  题目 #  An undirected, connected tree with N nodes labelled 0...N-1 and N-1edges are given.\nThe ith edge connects nodes edges[i][0] and edges[i][1] together.\nReturn a list ans, where ans[i] is the sum of the distances between node iand all other nodes.\nExample 1:\nInput: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation: Here is a diagram of the given tree: 0 / \\ 1 2 /|\\ 3 4 5 We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on.  Note: 1 \u0026lt;= N \u0026lt;= 10000\n题目大意 #  给定一个无向、连通的树。树中有 N 个标记为 0\u0026hellip;N-1 的节点以及 N-1 条边。第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。返回一个表示节点 i 与其他所有节点距离之和的列表 ans。\n说明: 1 \u0026lt;= N \u0026lt;= 10000\n解题思路 #   给出 N 个节点和这些节点之间的一些边的关系。要求求出分别以 x 为根节点到所有节点路径和。 这一题虽说描述的是求树的路径，但是完全可以当做图来做，因为并不是二叉树，是多叉树。这一题的解题思路是先一次 DFS 求出以 0 为根节点到各个节点的路径和(不以 0 为节点也可以，可以取任意节点作为开始)。第二次 DFS 求出从 0 根节点转换到其他各个节点的路径和。由于第一次计算出来以 0 为节点的路径和是正确的，所以计算其他节点为根节点的路径和只需要转换一下就可以得到正确结果。经过 2 次 DFS 之后就可以得到所有节点以自己为根节点到所有节点的路径和了。 如何从以 0 为根节点到其他所有节点的路径和转换到以其他节点为根节点到所有节点的路径和呢？从 0 节点换成 x 节点，只需要在 0 到所有节点的路径和基础上增增减减就可以了。增加的是 x 节点到除去以 x 为根节点所有子树以外的节点的路径，有多少个节点就增加多少条路径。减少的是 0 到以 x 为根节点所有子树节点的路径和，包含 0 到 x 根节点，有多少节点就减少多少条路径。所以在第一次 DFS 中需要计算好每个节点以自己为根节点的子树总数和(包含自己在内)，这样在第二次 DFS 中可以直接拿来做转换。具体细节的实现见代码。  代码 #  package leetcode func sumOfDistancesInTree(N int, edges [][]int) []int { // count[i] 中存储的是以 i 为根节点，所有子树结点和根节点的总数 \ttree, visited, count, res := make([][]int, N), make([]bool, N), make([]int, N), make([]int, N) for _, e := range edges { i, j := e[0], e[1] tree[i] = append(tree[i], j) tree[j] = append(tree[j], i) } deepFirstSearch(0, visited, count, res, tree) // 重置访问状态，再进行一次 DFS \tvisited = make([]bool, N) // 进入第二次 DFS 之前，只有 res[0] 里面存的是正确的值，因为第一次 DFS 计算出了以 0 为根节点的所有路径和 \t// 第二次 DFS 的目的是把以 0 为根节点的路径和转换成以 n 为根节点的路径和 \tdeepSecondSearch(0, visited, count, res, tree) return res } func deepFirstSearch(root int, visited []bool, count, res []int, tree [][]int) { visited[root] = true for _, n := range tree[root] { if visited[n] { continue } deepFirstSearch(n, visited, count, res, tree) count[root] += count[n] // root 节点到 n 的所有路径和 = 以 n 为根节点到所有子树的路径和 res[n] + root 到 count[n] 中每个节点的个数(root 节点和以 n 为根节点的每个节点都增加一条路径) \t// root 节点和以 n 为根节点的每个节点都增加一条路径 = 以 n 为根节点，子树节点数和根节点数的总和，即 count[n] \tres[root] += res[n] + count[n] } count[root]++ } // 从 root 开始，把 root 节点的子节点，依次设置成新的根节点 func deepSecondSearch(root int, visited []bool, count, res []int, tree [][]int) { N := len(visited) visited[root] = true for _, n := range tree[root] { if visited[n] { continue } // 根节点从 root 变成 n 后 \t// res[root] 存储的是以 root 为根节点到所有节点的路径总长度 \t// 1. root 到 n 节点增加的路径长度 = root 节点和以 n 为根节点的每个节点都增加一条路径 = 以 n 为根节点，子树节点数和根节点数的总和，即 count[n] \t// 2. n 到以 n 为根节点的所有子树节点以外的节点增加的路径长度 = n 节点和非 n 为根节点子树的每个节点都增加一条路径 = N - count[n] \t// 所以把根节点从 root 转移到 n，需要增加的路径是上面👆第二步计算的，需要减少的路径是上面👆第一步计算的 \tres[n] = res[root] + (N - count[n]) - count[n] deepSecondSearch(n, visited, count, res, tree) } } "});index.add({'id':373,'href':'/leetcode-java/04_Leetcode/0836.Rectangle-Overlap/','title':"0836. Rectangle Overlap",'section':"第四章",'content':"836. Rectangle Overlap #  题目 #  A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two (axis-aligned) rectangles, return whether they overlap.\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:\n Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.  题目大意 #  矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。给出两个矩形，判断它们是否重叠并返回结果。\n说明：\n 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。  解题思路 #   给出两个矩形的坐标，判断两个矩形是否重叠。 几何题，按照几何方法判断即可。  代码 #  package leetcode func isRectangleOverlap(rec1 []int, rec2 []int) bool { return rec1[0] \u0026lt; rec2[2] \u0026amp;\u0026amp; rec2[0] \u0026lt; rec1[2] \u0026amp;\u0026amp; rec1[1] \u0026lt; rec2[3] \u0026amp;\u0026amp; rec2[1] \u0026lt; rec1[3] } "});index.add({'id':374,'href':'/leetcode-java/04_Leetcode/0838.Push-Dominoes/','title':"0838. Push Dominoes",'section':"第四章",'content':"838. Push Dominoes #  题目 #  There are N dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n After each second, each domino that is falling to the left pushes the adjacent domino on the left.\nSimilarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nGiven a string \u0026ldquo;S\u0026rdquo; representing the initial state. S[i] = \u0026lsquo;L\u0026rsquo;, if the i-th domino has been pushed to the left; S[i] = \u0026lsquo;R\u0026rsquo;, if the i-th domino has been pushed to the right; S[i] = \u0026lsquo;.\u0026rsquo;, if the i-th domino has not been pushed.\nReturn a string representing the final state.\nExample 1:\n Input: \u0026quot;.L.R...LR..L..\u0026quot; Output: \u0026quot;LL.RR.LLRRLL..\u0026quot; Example 2:\n Input: \u0026quot;RR.L\u0026quot; Output: \u0026quot;RR.L\u0026quot; Explanation: The first domino expends no additional force on the second domino. Note:\n 0 \u0026lt;= N \u0026lt;= 10^5 String dominoes contains only \u0026lsquo;L\u0026rsquo;, \u0026lsquo;R\u0026rsquo; and \u0026lsquo;.\u0026rsquo;  题目大意 #  这道题是一个道模拟题，考察的也是滑动窗口的问题。\n给出一个字符串，L 代表这个多米诺骨牌会往左边倒，R 代表这个多米诺骨牌会往右边倒，问最终这些牌倒下去以后，情况是如何的，输出最终情况的字符串。\n解题思路 #  这道题可以预先在初始字符串头和尾都添加一个字符串，左边添加 L，右边添加 R，辅助判断。\n代码 #  package leetcode // 解法一 func pushDominoes(dominoes string) string { d := []byte(dominoes) for i := 0; i \u0026lt; len(d); { j := i + 1 for j \u0026lt; len(d)-1 \u0026amp;\u0026amp; d[j] == \u0026#39;.\u0026#39; { j++ } push(d[i : j+1]) i = j } return string(d) } func push(d []byte) { first, last := 0, len(d)-1 switch d[first] { case \u0026#39;.\u0026#39;, \u0026#39;L\u0026#39;: if d[last] == \u0026#39;L\u0026#39; { for ; first \u0026lt; last; first++ { d[first] = \u0026#39;L\u0026#39; } } case \u0026#39;R\u0026#39;: if d[last] == \u0026#39;.\u0026#39; || d[last] == \u0026#39;R\u0026#39; { for ; first \u0026lt;= last; first++ { d[first] = \u0026#39;R\u0026#39; } } else if d[last] == \u0026#39;L\u0026#39; { for first \u0026lt; last { d[first] = \u0026#39;R\u0026#39; d[last] = \u0026#39;L\u0026#39; first++ last-- } } } } // 解法二 func pushDominoes1(dominoes string) string { dominoes = \u0026#34;L\u0026#34; + dominoes + \u0026#34;R\u0026#34; res := \u0026#34;\u0026#34; for i, j := 0, 1; j \u0026lt; len(dominoes); j++ { if dominoes[j] == \u0026#39;.\u0026#39; { continue } if i \u0026gt; 0 { res += string(dominoes[i]) } middle := j - i - 1 if dominoes[i] == dominoes[j] { for k := 0; k \u0026lt; middle; k++ { res += string(dominoes[i]) } } else if dominoes[i] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; dominoes[j] == \u0026#39;R\u0026#39; { for k := 0; k \u0026lt; middle; k++ { res += string(\u0026#39;.\u0026#39;) } } else { for k := 0; k \u0026lt; middle/2; k++ { res += string(\u0026#39;R\u0026#39;) } for k := 0; k \u0026lt; middle%2; k++ { res += string(\u0026#39;.\u0026#39;) } for k := 0; k \u0026lt; middle/2; k++ { res += string(\u0026#39;L\u0026#39;) } } i = j } return res } "});index.add({'id':375,'href':'/leetcode-java/04_Leetcode/0839.Similar-String-Groups/','title':"0839. Similar String Groups",'section':"第四章",'content':"839. Similar String Groups #  题目 #  Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.\nFor example, \u0026quot;tars\u0026quot; and \u0026quot;rats\u0026quot; are similar (swapping at positions 0 and 2), and \u0026quot;rats\u0026quot; and \u0026quot;arts\u0026quot; are similar, but \u0026quot;star\u0026quot; is not similar to \u0026quot;tars\u0026quot;, \u0026quot;rats\u0026quot;, or \u0026quot;arts\u0026quot;.\nTogether, these form two connected groups by similarity: {\u0026quot;tars\u0026quot;, \u0026quot;rats\u0026quot;, \u0026quot;arts\u0026quot;} and {\u0026quot;star\u0026quot;}. Notice that \u0026quot;tars\u0026quot; and \u0026quot;arts\u0026quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list A of strings. Every string in A is an anagram of every other string in A. How many groups are there?\nExample 1:\nInput: [\u0026quot;tars\u0026quot;,\u0026quot;rats\u0026quot;,\u0026quot;arts\u0026quot;,\u0026quot;star\u0026quot;] Output: 2  Note:\n A.length \u0026lt;= 2000 A[i].length \u0026lt;= 1000 A.length * A[i].length \u0026lt;= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.  题目大意 #  如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。\n例如，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;rats\u0026rdquo; 是相似的 (交换 0 与 2 的位置)； \u0026ldquo;rats\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 也是相似的，但是 \u0026ldquo;star\u0026rdquo; 不与 \u0026ldquo;tars\u0026rdquo;，\u0026ldquo;rats\u0026rdquo;，或 \u0026ldquo;arts\u0026rdquo; 相似。\n总之，它们通过相似性形成了两个关联组：{\u0026ldquo;tars\u0026rdquo;, \u0026ldquo;rats\u0026rdquo;, \u0026ldquo;arts\u0026rdquo;} 和 {\u0026ldquo;star\u0026rdquo;}。注意，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？\n提示：\n A.length \u0026lt;= 2000 A[i].length \u0026lt;= 1000 A.length * A[i].length \u0026lt;= 20000 A 中的所有单词都只包含小写字母。 A 中的所有单词都具有相同的长度，且是彼此的字母异位词。 此问题的判断限制时间已经延长。  备注：\n 字母异位词[anagram]，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。  解题思路 #   给出一个字符串数组，要求找出这个数组中，\u0026ldquo;不相似\u0026quot;的字符串有多少种。相似的字符串的定义是：如果 A 和 B 字符串只需要交换一次字母的位置就能变成两个相等的字符串，那么 A 和 B 是相似的。 这一题的解题思路是用并查集。先将题目中的“相似”的定义转换一下，A 和 B 相似的意思是，A 和 B 中只有 2 个字符不相等，其他字符都相等，这样交换一次才能完全相等。有没有可能这两个字符交换了也不相等呢？这种情况不用考虑，因为题目中提到了给的字符串都是 anagram 的(anagram 的意思是，字符串的任意排列组合)。那么这题就比较简单了，只需要判断每两个字符串是否“相似”，如果相似就 union()，最后看并查集中有几个集合即可。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func numSimilarGroups(A []string) int { uf := template.UnionFind{} uf.Init(len(A)) for i := 0; i \u0026lt; len(A); i++ { for j := i + 1; j \u0026lt; len(A); j++ { if isSimilar(A[i], A[j]) { uf.Union(i, j) } } } return uf.TotalCount() } func isSimilar(a, b string) bool { var n int for i := 0; i \u0026lt; len(a); i++ { if a[i] != b[i] { n++ if n \u0026gt; 2 { return false } } } return true } "});index.add({'id':376,'href':'/leetcode-java/04_Leetcode/0841.Keys-and-Rooms/','title':"0841. Keys and Rooms",'section':"第四章",'content':"841. Keys and Rooms #  题目 #  There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.\nFormally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.\nInitially, all the rooms start locked (except for room 0).\nYou can walk back and forth between rooms freely.\nReturn true if and only if you can enter every room.\nExample 1:\nInput: [[1],[2],[3],[]] Output: true Explanation: We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3. Since we were able to go to every room, we return true. Example 2:\nInput: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2. Note:\n 1 \u0026lt;= rooms.length \u0026lt;= 1000 0 \u0026lt;= rooms[i].length \u0026lt;= 1000 The number of keys in all rooms combined is at most 3000.  题目大意 #  有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，\u0026hellip;，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。\n在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，\u0026hellip;，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。最初，除 0 号房间外的其余所有房间都被锁住。你可以自由地在房间之间来回走动。如果能进入每个房间返回 true，否则返回 false。\n提示：\n 1 \u0026lt;= rooms.length \u0026lt;= 1000 0 \u0026lt;= rooms[i].length \u0026lt;= 1000 所有房间中的钥匙数量总计不超过 3000。  解题思路 #   给出一个房间数组，每个房间里面装了一些钥匙。0 号房间默认是可以进入的，房间进入顺序没有要求，问最终能否进入所有房间。 用 DFS 依次深搜所有房间的钥匙，如果都能访问到，最终输出 true。这题算是 DFS 里面的简单题。  代码 #  func canVisitAllRooms(rooms [][]int) bool { visited := make(map[int]bool) visited[0] = true dfsVisitAllRooms(rooms, visited, 0) return len(rooms) == len(visited) } func dfsVisitAllRooms(es [][]int, visited map[int]bool, from int) { for _, to := range es[from] { if visited[to] { continue } visited[to] = true dfsVisitAllRooms(es, visited, to) } } "});index.add({'id':377,'href':'/leetcode-java/04_Leetcode/0842.Split-Array-into-Fibonacci-Sequence/','title':"0842. Split Array Into Fibonacci Sequence",'section':"第四章",'content':"842. Split Array into Fibonacci Sequence #  题目 #  Given a string S of digits, such as S = \u0026quot;123456579\u0026quot;, we can split it into a Fibonacci-like sequence [123, 456, 579].\nFormally, a Fibonacci-like sequence is a list F of non-negative integers such that:\n 0 \u0026lt;= F[i] \u0026lt;= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length \u0026gt;= 3; and F[i] + F[i+1] = F[i+2] for all 0 \u0026lt;= i \u0026lt; F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\nReturn any Fibonacci-like sequence split from S, or return [] if it cannot be done.\nExample 1:\nInput: \u0026quot;123456579\u0026quot; Output: [123,456,579]  Example 2:\nInput: \u0026quot;11235813\u0026quot; Output: [1,1,2,3,5,8,13]  Example 3:\nInput: \u0026quot;112358130\u0026quot; Output: [] Explanation: The task is impossible.  Example 4:\nInput: \u0026quot;0123\u0026quot; Output: [] Explanation: Leading zeroes are not allowed, so \u0026quot;01\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot; is not valid.  Example 5:\nInput: \u0026quot;1101111\u0026quot; Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:\n 1 \u0026lt;= S.length \u0026lt;= 200 S contains only digits.  题目大意 #  给定一个数字字符串 S，比如 S = \u0026ldquo;123456579\u0026rdquo;，我们可以将它分成斐波那契式的序列 [123, 456, 579]。斐波那契式序列是一个非负整数列表 F，且满足：\n 0 \u0026lt;= F[i] \u0026lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）； F.length \u0026gt;= 3； 对于所有的0 \u0026lt;= i \u0026lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。  另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。\n解题思路 #   这一题是第 306 题的加强版。第 306 题要求判断字符串是否满足斐波那契数列形式。这一题要求输出按照斐波那契数列形式分割之后的数字数组。 这一题思路和第 306 题基本一致，需要注意的是题目中的一个限制条件，0 \u0026lt;= F[i] \u0026lt;= 2^31 - 1，注意这个条件，笔者开始没注意，后面输出解就出现错误了，可以看笔者的测试文件用例的最后两组数据，这两组都是可以分解成斐波那契数列的，但是由于分割以后的数字都大于了 2^31 - 1，所以这些解都不能要！ 这一题也要特别注意剪枝条件，没有剪枝条件，时间复杂度特别高，加上合理的剪枝条件以后，0ms 通过。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) func splitIntoFibonacci(S string) []int { if len(S) \u0026lt; 3 { return []int{} } res, isComplete := []int{}, false for firstEnd := 0; firstEnd \u0026lt; len(S)/2; firstEnd++ { if S[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; firstEnd \u0026gt; 0 { break } first, _ := strconv.Atoi(S[:firstEnd+1]) if first \u0026gt;= 1\u0026lt;\u0026lt;31 { // 题目要求每个数都要小于 2^31 - 1 = 2147483647，此处剪枝很关键！ \tbreak } for secondEnd := firstEnd + 1; max(firstEnd, secondEnd-firstEnd) \u0026lt;= len(S)-secondEnd; secondEnd++ { if S[firstEnd+1] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; secondEnd-firstEnd \u0026gt; 1 { break } second, _ := strconv.Atoi(S[firstEnd+1 : secondEnd+1]) if second \u0026gt;= 1\u0026lt;\u0026lt;31 { // 题目要求每个数都要小于 2^31 - 1 = 2147483647，此处剪枝很关键！ \tbreak } findRecursiveCheck(S, first, second, secondEnd+1, \u0026amp;res, \u0026amp;isComplete) } } return res } //Propagate for rest of the string func findRecursiveCheck(S string, x1 int, x2 int, left int, res *[]int, isComplete *bool) { if x1 \u0026gt;= 1\u0026lt;\u0026lt;31 || x2 \u0026gt;= 1\u0026lt;\u0026lt;31 { // 题目要求每个数都要小于 2^31 - 1 = 2147483647，此处剪枝很关键！ \treturn } if left == len(S) { if !*isComplete { *isComplete = true *res = append(*res, x1) *res = append(*res, x2) } return } if strings.HasPrefix(S[left:], strconv.Itoa(x1+x2)) \u0026amp;\u0026amp; !*isComplete { *res = append(*res, x1) findRecursiveCheck(S, x2, x1+x2, left+len(strconv.Itoa(x1+x2)), res, isComplete) return } if len(*res) \u0026gt; 0 \u0026amp;\u0026amp; !*isComplete { *res = (*res)[:len(*res)-1] } return } "});index.add({'id':378,'href':'/leetcode-java/04_Leetcode/0844.Backspace-String-Compare/','title':"0844. Backspace String Compare",'section':"第四章",'content':"844. Backspace String Compare #  题目 #  Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.\nExample 1:\n Input: S = \u0026quot;ab#c\u0026quot;, T = \u0026quot;ad#c\u0026quot; Output: true Explanation: Both S and T become \u0026quot;ac\u0026quot;. Example 2:\n Input: S = \u0026quot;ab##\u0026quot;, T = \u0026quot;c#d#\u0026quot; Output: true Explanation: Both S and T become \u0026quot;\u0026quot;. Example 3:\n Input: S = \u0026quot;a##c\u0026quot;, T = \u0026quot;#a#c\u0026quot; Output: true Explanation: Both S and T become \u0026quot;c\u0026quot;. Example 4:\n Input: S = \u0026quot;a#c\u0026quot;, T = \u0026quot;b\u0026quot; Output: false Explanation: S becomes \u0026quot;c\u0026quot; while T becomes \u0026quot;b\u0026quot;. Note:\n 1 \u0026lt;= S.length \u0026lt;= 200 1 \u0026lt;= T.length \u0026lt;= 200 S and T only contain lowercase letters and \u0026lsquo;#\u0026rsquo; characters.  Follow up:\n Can you solve it in O(N) time and O(1) space?  题目大意 #  给 2 个字符串，如果遇到 # 号字符，就回退一个字符。问最终的 2 个字符串是否完全一致。\n解题思路 #  这一题可以用栈的思想来模拟，遇到 # 字符就回退一个字符。不是 # 号就入栈一个字符。比较最终 2 个字符串即可。\n代码 #  package leetcode func backspaceCompare(S string, T string) bool { s := make([]rune, 0) for _, c := range S { if c == \u0026#39;#\u0026#39; { if len(s) \u0026gt; 0 { s = s[:len(s)-1] } } else { s = append(s, c) } } s2 := make([]rune, 0) for _, c := range T { if c == \u0026#39;#\u0026#39; { if len(s2) \u0026gt; 0 { s2 = s2[:len(s2)-1] } } else { s2 = append(s2, c) } } return string(s) == string(s2) } "});index.add({'id':379,'href':'/leetcode-java/04_Leetcode/0845.Longest-Mountain-in-Array/','title':"0845. Longest Mountain in Array",'section':"第四章",'content':"845. Longest Mountain in Array #  题目 #  Let\u0026rsquo;s call any (contiguous) subarray B (of A) a mountain if the following properties hold:\n B.length \u0026gt;= 3 There exists some 0 \u0026lt; i \u0026lt; B.length - 1 such that B[0] \u0026lt; B[1] \u0026lt; \u0026hellip; B[i-1] \u0026lt; B[i] \u0026gt; B[i+1] \u0026gt; \u0026hellip; \u0026gt; B[B.length - 1] (Note that B could be any subarray of A, including the entire array A.)  Given an array A of integers, return the length of the longest mountain.\nReturn 0 if there is no mountain.\nExample 1:\n Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. Example 2:\n Input: [2,2,2] Output: 0 Explanation: There is no mountain. Note:\n 0 \u0026lt;= A.length \u0026lt;= 10000 0 \u0026lt;= A[i] \u0026lt;= 10000  Follow up:\n Can you solve it using only one pass? Can you solve it in O(1) space?  题目大意 #  这道题考察的是滑动窗口的问题。\n给出一个数组，要求求出这个数组里面“山”最长的长度。“山”的意思是，从一个数开始逐渐上升，到顶以后，逐渐下降。\n解题思路 #  这道题解题思路也是滑动窗口，只不过在滑动的过程中多判断一个上升和下降的状态即可。\n代码 #  package leetcode func longestMountain(A []int) int { left, right, res, isAscending := 0, 0, 0, true for left \u0026lt; len(A) { if right+1 \u0026lt; len(A) \u0026amp;\u0026amp; ((isAscending == true \u0026amp;\u0026amp; A[right+1] \u0026gt; A[left] \u0026amp;\u0026amp; A[right+1] \u0026gt; A[right]) || (right != left \u0026amp;\u0026amp; A[right+1] \u0026lt; A[right])) { if A[right+1] \u0026lt; A[right] { isAscending = false } right++ } else { if right != left \u0026amp;\u0026amp; isAscending == false { res = max(res, right-left+1) } left++ if right \u0026lt; left { right = left } if right == left { isAscending = true } } } return res } "});index.add({'id':380,'href':'/leetcode-java/04_Leetcode/0850.Rectangle-Area-II/','title':"0850. Rectangle Area I I",'section':"第四章",'content':"850. Rectangle Area II #  题目 #  We are given a list of (axis-aligned) rectangles. Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.\nFind the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 10^9 + 7.\n Example 1:\nInput: [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.  Example 2:\nInput: [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.  Note:\n 1 \u0026lt;= rectangles.length \u0026lt;= 200 rectanges[i].length = 4 0 \u0026lt;= rectangles[i][j] \u0026lt;= 10^9 The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.  题目大意 #  我们给出了一个（轴对齐的）矩形列表 rectangles。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标，（x2，y2）是该矩形右上角的坐标。找出平面中所有矩形叠加覆盖后的总面积。由于答案可能太大，请返回它对 10 ^ 9 + 7 取模的结果。\n提示：\n 1 \u0026lt;= rectangles.length \u0026lt;= 200 rectanges[i].length = 4 0 \u0026lt;= rectangles[i][j] \u0026lt;= 10^9 矩形叠加覆盖后的总面积不会超越 2^63 - 1 ，这意味着可以用一个 64 位有符号整数来保存面积结果。  解题思路 #    在二维坐标系中给出一些矩形，要求这些矩形合并之后的面积。由于矩形有重叠，所以需要考虑合并以后的面积。矩形的坐标值也会很大。\n  这一题给人的感觉很像第 218 题，求天际线的过程也是有楼挡楼，重叠的情况。不过那一题只用求天际线的拐点，所以我们可以对区间做“右边界减一”的处理，防止两个相邻区间因为共点，而导致结果错误。但是这一题如果还是用相同的做法，就会出错，因为“右边界减一”以后，面积会少一部分，最终得到的结果也是偏小的。所以这一题要将线段树改造一下。\n  思路是先讲 Y 轴上的坐标离线化，转换成线段树。将矩形的 2 条边变成扫描线，左边是入边，右边是出边。\n   再从左往右遍历每条扫描线，并对 Y 轴上的线段树进行 update。X 轴上的每个坐标区间 * query 线段树总高度的结果 = 区间面积。最后将 X 轴对应的每个区间面积加起来，就是最终矩形合并以后的面积。如下图中间的图。\n 需要注意的一点是，每次 query 的结果并不一定是连续线段。如上图最右边的图，中间有一段是可能出现镂空的。这种情况看似复杂，其实很简单，因为每段线段树的线段代表的权值高度是不同的，每次 query 最大高度得到的结果已经考虑了中间可能有镂空的情况了。\n  具体做法，先把各个矩形在 Y 轴方向上离散化，这里的线段树叶子节点不再是一个点了，而是一个区间长度为 1 的区间段。\n 每个叶子节点也不再是存储一个 int 值，而是存 2 个值，一个是 count 值，用来记录这条区间被覆盖的次数，另一个值是 val 值，用来反映射该线段长度是多少，因为 Y 轴被离散化了，区间坐标间隔都是 1，但是实际 Y 轴的高度并不是 1 ，所以用 val 来反映射原来的高度。\n  初始化线段树，叶子节点的 count = 0，val 根据题目给的 Y 坐标进行计算。\n   从左往右遍历每个扫描线。每条扫面线都把对应 update 更新到叶子节点。pushUp 的时候需要合并每个区间段的高度 val 值。如果有区间没有被覆盖，那么这个区间高度 val 为 0，这也就处理了可能“中间镂空”的情况。\n  func (sat *SegmentAreaTree) pushUp(treeIndex, leftTreeIndex, rightTreeIndex int) { newCount, newValue := sat.merge(sat.tree[leftTreeIndex].count, sat.tree[rightTreeIndex].count), 0 if sat.tree[leftTreeIndex].count \u0026gt; 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count \u0026gt; 0 { newValue = sat.merge(sat.tree[leftTreeIndex].val, sat.tree[rightTreeIndex].val) } else if sat.tree[leftTreeIndex].count \u0026gt; 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count == 0 { newValue = sat.tree[leftTreeIndex].val } else if sat.tree[leftTreeIndex].count == 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count \u0026gt; 0 { newValue = sat.tree[rightTreeIndex].val } sat.tree[treeIndex] = SegmentItem{count: newCount, val: newValue} }    扫描每一个扫描线，先 pushDown 到叶子节点，再 pushUp 到根节点。\n      遍历到倒数第 2 根扫描线的时候就能得到结果了。因为最后一根扫描线 update 以后，整个线段树全部都归为初始化状态了。\n   这一题是线段树扫面线解法的经典题。\n  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func rectangleArea(rectangles [][]int) int { sat, res := SegmentAreaTree{}, 0 posXMap, posX, posYMap, posY, lines := discretization850(rectangles) tmp := make([]int, len(posYMap)) for i := 0; i \u0026lt; len(tmp)-1; i++ { tmp[i] = posY[i+1] - posY[i] } sat.Init(tmp, func(i, j int) int { return i + j }) for i := 0; i \u0026lt; len(posY)-1; i++ { tmp[i] = posY[i+1] - posY[i] } for i := 0; i \u0026lt; len(posX)-1; i++ { for _, v := range lines[posXMap[posX[i]]] { sat.Update(posYMap[v.start], posYMap[v.end], v.state) } res += ((posX[i+1] - posX[i]) * sat.Query(0, len(posY)-1)) % 1000000007 } return res % 1000000007 } func discretization850(positions [][]int) (map[int]int, []int, map[int]int, []int, map[int][]LineItem) { tmpXMap, tmpYMap, posXArray, posXMap, posYArray, posYMap, lines := map[int]int{}, map[int]int{}, []int{}, map[int]int{}, []int{}, map[int]int{}, map[int][]LineItem{} for _, pos := range positions { tmpXMap[pos[0]]++ tmpXMap[pos[2]]++ } for k := range tmpXMap { posXArray = append(posXArray, k) } sort.Ints(posXArray) for i, pos := range posXArray { posXMap[pos] = i } for _, pos := range positions { tmpYMap[pos[1]]++ tmpYMap[pos[3]]++ tmp1 := lines[posXMap[pos[0]]] tmp1 = append(tmp1, LineItem{start: pos[1], end: pos[3], state: 1}) lines[posXMap[pos[0]]] = tmp1 tmp2 := lines[posXMap[pos[2]]] tmp2 = append(tmp2, LineItem{start: pos[1], end: pos[3], state: -1}) lines[posXMap[pos[2]]] = tmp2 } for k := range tmpYMap { posYArray = append(posYArray, k) } sort.Ints(posYArray) for i, pos := range posYArray { posYMap[pos] = i } return posXMap, posXArray, posYMap, posYArray, lines } // LineItem define type LineItem struct { // 垂直于 x 轴的线段 \tstart, end, state int // state = 1 代表进入，-1 代表离开 } // SegmentItem define type SegmentItem struct { count int val int } // SegmentAreaTree define type SegmentAreaTree struct { data []int tree []SegmentItem left, right int merge func(i, j int) int } // Init define func (sat *SegmentAreaTree) Init(nums []int, oper func(i, j int) int) { sat.merge = oper data, tree := make([]int, len(nums)), make([]SegmentItem, 4*len(nums)) for i := 0; i \u0026lt; len(nums); i++ { data[i] = nums[i] } sat.data, sat.tree = data, tree if len(nums) \u0026gt; 0 { sat.buildSegmentTree(0, 0, len(nums)-1) } } // 在 treeIndex 的位置创建 [left....right] 区间的线段树 func (sat *SegmentAreaTree) buildSegmentTree(treeIndex, left, right int) { if left == right-1 { sat.tree[treeIndex] = SegmentItem{count: 0, val: sat.data[left]} return } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, sat.leftChild(treeIndex), sat.rightChild(treeIndex) sat.buildSegmentTree(leftTreeIndex, left, midTreeIndex) sat.buildSegmentTree(rightTreeIndex, midTreeIndex, right) sat.pushUp(treeIndex, leftTreeIndex, rightTreeIndex) } func (sat *SegmentAreaTree) pushUp(treeIndex, leftTreeIndex, rightTreeIndex int) { newCount, newValue := sat.merge(sat.tree[leftTreeIndex].count, sat.tree[rightTreeIndex].count), 0 if sat.tree[leftTreeIndex].count \u0026gt; 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count \u0026gt; 0 { newValue = sat.merge(sat.tree[leftTreeIndex].val, sat.tree[rightTreeIndex].val) } else if sat.tree[leftTreeIndex].count \u0026gt; 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count == 0 { newValue = sat.tree[leftTreeIndex].val } else if sat.tree[leftTreeIndex].count == 0 \u0026amp;\u0026amp; sat.tree[rightTreeIndex].count \u0026gt; 0 { newValue = sat.tree[rightTreeIndex].val } sat.tree[treeIndex] = SegmentItem{count: newCount, val: newValue} } func (sat *SegmentAreaTree) leftChild(index int) int { return 2*index + 1 } func (sat *SegmentAreaTree) rightChild(index int) int { return 2*index + 2 } // 查询 [left....right] 区间内的值  // Query define func (sat *SegmentAreaTree) Query(left, right int) int { if len(sat.data) \u0026gt; 0 { return sat.queryInTree(0, 0, len(sat.data)-1, left, right) } return 0 } func (sat *SegmentAreaTree) queryInTree(treeIndex, left, right, queryLeft, queryRight int) int { midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, sat.leftChild(treeIndex), sat.rightChild(treeIndex) if left \u0026gt; queryRight || right \u0026lt; queryLeft { // segment completely outside range \treturn 0 // represents a null node \t} if queryLeft \u0026lt;= left \u0026amp;\u0026amp; queryRight \u0026gt;= right { // segment completely inside range \tif sat.tree[treeIndex].count \u0026gt; 0 { return sat.tree[treeIndex].val } return 0 } if queryLeft \u0026gt; midTreeIndex { return sat.queryInTree(rightTreeIndex, midTreeIndex, right, queryLeft, queryRight) } else if queryRight \u0026lt;= midTreeIndex { return sat.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, queryRight) } // merge query results \treturn sat.merge(sat.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, midTreeIndex), sat.queryInTree(rightTreeIndex, midTreeIndex, right, midTreeIndex, queryRight)) } // Update define func (sat *SegmentAreaTree) Update(updateLeft, updateRight, val int) { if len(sat.data) \u0026gt; 0 { sat.updateInTree(0, 0, len(sat.data)-1, updateLeft, updateRight, val) } } func (sat *SegmentAreaTree) updateInTree(treeIndex, left, right, updateLeft, updateRight, val int) { midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, sat.leftChild(treeIndex), sat.rightChild(treeIndex) if left \u0026gt; right || left \u0026gt;= updateRight || right \u0026lt;= updateLeft { // 由于叶子节点的区间不在是 left == right 所以这里判断需要增加等号的判断 \treturn // out of range. escape. \t} if updateLeft \u0026lt;= left \u0026amp;\u0026amp; right \u0026lt;= updateRight { // segment is fully within update range \tif left == right-1 { sat.tree[treeIndex].count = sat.merge(sat.tree[treeIndex].count, val) } if left != right-1 { // update lazy[] for children \tsat.updateInTree(leftTreeIndex, left, midTreeIndex, updateLeft, updateRight, val) sat.updateInTree(rightTreeIndex, midTreeIndex, right, updateLeft, updateRight, val) sat.pushUp(treeIndex, leftTreeIndex, rightTreeIndex) } return } sat.updateInTree(leftTreeIndex, left, midTreeIndex, updateLeft, updateRight, val) sat.updateInTree(rightTreeIndex, midTreeIndex, right, updateLeft, updateRight, val) // merge updates \tsat.pushUp(treeIndex, leftTreeIndex, rightTreeIndex) } "});index.add({'id':381,'href':'/leetcode-java/04_Leetcode/0851.Loud-and-Rich/','title':"0851. Loud and Rich",'section':"第四章",'content':"851. Loud and Rich #  题目 #  In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.\nFor convenience, we\u0026rsquo;ll call the person with label x, simply \u0026ldquo;person x\u0026rdquo;.\nWe\u0026rsquo;ll say that richer[i] = [x, y] if person x definitely has more money than person y. Note that richer may only be a subset of valid observations.\nAlso, we\u0026rsquo;ll say quiet = q if person x has quietness q.\nNow, return answer, where answer = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.\nExample 1:\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation: answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0. answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7. The other answers can be filled out with similar reasoning. Note:\n 1 \u0026lt;= quiet.length = N \u0026lt;= 500 0 \u0026lt;= quiet[i] \u0026lt; N, all quiet[i] are different. 0 \u0026lt;= richer.length \u0026lt;= N * (N-1) / 2 0 \u0026lt;= richer[i][j] \u0026lt; N richer[i][0] != richer[i][1] richer[i]\u0026rsquo;s are all different. The observations in richer are all logically consistent.  题目大意 #  在一组 N 个人（编号为 0, 1, 2, \u0026hellip;, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。为了方便起见，我们将编号为 x 的人简称为 \u0026ldquo;person x \u0026ldquo;。如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。\n提示：\n 1 \u0026lt;= quiet.length = N \u0026lt;= 500 0 \u0026lt;= quiet[i] \u0026lt; N，所有 quiet[i] 都不相同。 0 \u0026lt;= richer.length \u0026lt;= N * (N-1) / 2 0 \u0026lt;= richer[i][j] \u0026lt; N richer[i][0] != richer[i][1] richer[i] 都是不同的。 对 richer 的观察在逻辑上是一致的。  解题思路 #   给出 2 个数组，richer 和 quiet，要求输出 answer，其中 answer = y 的前提是，在所有拥有的钱不少于 x 的人中，y 是最安静的人（也就是安静值 quiet[y] 最小的人） 由题意可知，richer 构成了一个有向无环图，首先使用字典建立图的关系，找到比当前下标编号富有的所有的人。然后使用广度优先层次遍历，不断的使用富有的人，但是安静值更小的人更新子节点即可。 这一题还可以用拓扑排序来解答。将 richer 中描述的关系看做边，如果 x \u0026gt; y，则 x 指向 y。将 quiet 看成权值。用一个数组记录答案，初始时 ans[i] = i。然后对原图做拓扑排序，对于每一条边，如果发现 quiet[ans[v]] \u0026gt; quiet[ans[u]]，则 ans[v] 的答案为 ans[u]。时间复杂度即为拓扑排序的时间复杂度为 O(m+n)。空间复杂度需要 O(m) 的数组建图，需要 O(n) 的数组记录入度以及存储队列，所以空间复杂度为 O(m+n)。  代码 #  func loudAndRich(richer [][]int, quiet []int) []int { edges := make([][]int, len(quiet)) for i := range edges { edges[i] = []int{} } indegrees := make([]int, len(quiet)) for _, edge := range richer { n1, n2 := edge[0], edge[1] edges[n1] = append(edges[n1], n2) indegrees[n2]++ } res := make([]int, len(quiet)) for i := range res { res[i] = i } queue := []int{} for i, v := range indegrees { if v == 0 { queue = append(queue, i) } } for len(queue) \u0026gt; 0 { nexts := []int{} for _, n1 := range queue { for _, n2 := range edges[n1] { indegrees[n2]-- if quiet[res[n2]] \u0026gt; quiet[res[n1]] { res[n2] = res[n1] } if indegrees[n2] == 0 { nexts = append(nexts, n2) } } } queue = nexts } return res } "});index.add({'id':382,'href':'/leetcode-java/04_Leetcode/0852.Peak-Index-in-a-Mountain-Array/','title':"0852. Peak Index in a Mountain Array",'section':"第四章",'content':"852. Peak Index in a Mountain Array #  题目 #  Let\u0026rsquo;s call an array A a mountain if the following properties hold:\n A.length \u0026gt;= 3 There exists some 0 \u0026lt; i \u0026lt; A.length - 1 such that A[0] \u0026lt; A[1] \u0026lt; ... A[i-1] \u0026lt; A[i] \u0026gt; A[i+1] \u0026gt; ... \u0026gt; A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] \u0026lt; A[1] \u0026lt; ... A[i-1] \u0026lt; A[i] \u0026gt; A[i+1] \u0026gt; ... \u0026gt; A[A.length - 1].\nExample 1:\nInput: [0,1,0] Output: 1  Example 2:\nInput: [0,2,1,0] Output: 1  Note:\n 3 \u0026lt;= A.length \u0026lt;= 10000 0 \u0026lt;= A[i] \u0026lt;= 10^6 A is a mountain, as defined above.  题目大意 #  我们把符合下列属性的数组 A 称作山脉：\n A.length \u0026gt;= 3 存在 0 \u0026lt; i \u0026lt; A.length - 1 使得A[0] \u0026lt; A[1] \u0026lt; \u0026hellip; A[i-1] \u0026lt; A[i] \u0026gt; A[i+1] \u0026gt; \u0026hellip; \u0026gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] \u0026lt; A[1] \u0026lt; \u0026hellip; A[i-1] \u0026lt; A[i] \u0026gt; A[i+1] \u0026gt; \u0026hellip; \u0026gt; A[A.length - 1] 的 i 的值。  提示：\n 3 \u0026lt;= A.length \u0026lt;= 10000 0 \u0026lt;= A[i] \u0026lt;= 10^6 A 是如上定义的山脉  解题思路 #   给出一个数组，数组里面存在有且仅有一个“山峰”，(山峰的定义是，下标 i 比 i-1、i+1 位置上的元素都要大)，找到这个“山峰”，并输出其中一个山峰的下标。 这一题直接用二分搜索即可，数组中的元素算基本有序。判断是否为山峰的条件为比较左右两个数，如果当前的数比左右两个数都大，即找到了山峰。其他的情况都在山坡上。这一题有两种写法，第一种写法是标准的二分写法，第二种写法是变形的二分写法。  代码 #  package leetcode // 解法一 二分 func peakIndexInMountainArray(A []int) int { low, high := 0, len(A)-1 for low \u0026lt;= high { mid := low + (high-low)\u0026gt;\u0026gt;1 if A[mid] \u0026gt; A[mid+1] \u0026amp;\u0026amp; A[mid] \u0026gt; A[mid-1] { return mid } if A[mid] \u0026gt; A[mid+1] \u0026amp;\u0026amp; A[mid] \u0026lt; A[mid-1] { high = mid - 1 } if A[mid] \u0026lt; A[mid+1] \u0026amp;\u0026amp; A[mid] \u0026gt; A[mid-1] { low = mid + 1 } } return 0 } // 解法二 二分 func peakIndexInMountainArray1(A []int) int { low, high := 0, len(A)-1 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 // 如果 mid 较大，则左侧存在峰值，high = m，如果 mid + 1 较大，则右侧存在峰值，low = mid + 1 \tif A[mid] \u0026gt; A[mid+1] { high = mid } else { low = mid + 1 } } return low } "});index.add({'id':383,'href':'/leetcode-java/04_Leetcode/0853.Car-Fleet/','title':"0853. Car Fleet",'section':"第四章",'content':"853. Car Fleet #  题目 #  N cars are going to the same destination along a one lane road. The destination is target miles away.\nEach car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.\nA car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.\nThe distance between these two cars is ignored - they are assumed to have the same position.\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\nHow many car fleets will arrive at the destination?\nExample 1:\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 and 8 become a fleet, meeting each other at 12. The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself. The cars starting at 5 and 3 become a fleet, meeting each other at 6. Note that no other cars meet these fleets before the destination, so the answer is 3.  Note:\n 0 \u0026lt;= N \u0026lt;= 10 ^ 4 0 \u0026lt; target \u0026lt;= 10 ^ 6 0 \u0026lt; speed[i] \u0026lt;= 10 ^ 6 0 \u0026lt;= position[i] \u0026lt; target All initial positions are different.  题目大意 #  N 辆车沿着一条车道驶向位于 target 英里之外的共同目的地。每辆车 i 以恒定的速度 speed[i] （英里/小时），从初始位置 position[i] （英里） 沿车道驶向目的地。\n一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。\n 问最后会有多少车队到达目的地?\n解题思路 #   根据每辆车距离终点和速度，计算每辆车到达终点的时间，并按照距离从大到小排序(position 越大代表距离终点越近) 从头往后扫描排序以后的数组，时间一旦大于前一个 car 的时间，就会生成一个新的 car fleet，最终计数加一即可。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) type car struct { time float64 position int } // ByPosition define type ByPosition []car func (a ByPosition) Len() int { return len(a) } func (a ByPosition) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByPosition) Less(i, j int) bool { return a[i].position \u0026gt; a[j].position } func carFleet(target int, position []int, speed []int) int { n := len(position) if n \u0026lt;= 1 { return n } cars := make([]car, n) for i := 0; i \u0026lt; n; i++ { cars[i] = car{float64(target-position[i]) / float64(speed[i]), position[i]} } sort.Sort(ByPosition(cars)) fleet, lastTime := 0, 0.0 for i := 0; i \u0026lt; len(cars); i++ { if cars[i].time \u0026gt; lastTime { lastTime = cars[i].time fleet++ } } return fleet } "});index.add({'id':384,'href':'/leetcode-java/04_Leetcode/0856.Score-of-Parentheses/','title':"0856. Score of Parentheses",'section':"第四章",'content':"856. Score of Parentheses #  题目 #  Given a balanced parentheses string S, compute the score of the string based on the following rule:\n() has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.\nExample 1:\n Input: \u0026quot;()\u0026quot; Output: 1 Example 2:\n Input: \u0026quot;(())\u0026quot; Output: 2 Example 3:\n Input: \u0026quot;()()\u0026quot; Output: 2 Example 4:\n Input: \u0026quot;(()(()))\u0026quot; Output: 6 Note:\n S is a balanced parentheses string, containing only ( and ). 2 \u0026lt;= S.length \u0026lt;= 50  题目大意 #  按照以下规则计算括号的分数：() 代表 1 分。AB 代表 A + B，A 和 B 分别是已经满足匹配规则的括号组。(A) 代表 2 * A，其中 A 也是已经满足匹配规则的括号组。给出一个括号字符串，要求按照这些规则计算出括号的分数值。\n解题思路 #  按照括号匹配的原则，一步步的计算每个组合的分数入栈。遇到题目中的 3 种情况，取出栈顶元素算分数。\n代码 #  package leetcode func scoreOfParentheses(S string) int { res, stack, top, temp := 0, []int{}, -1, 0 for _, s := range S { if s == \u0026#39;(\u0026#39; { stack = append(stack, -1) top++ } else { temp = 0 for stack[top] != -1 { temp += stack[top] stack = stack[:len(stack)-1] top-- } stack = stack[:len(stack)-1] top-- if temp == 0 { stack = append(stack, 1) top++ } else { stack = append(stack, temp*2) top++ } } } for len(stack) != 0 { res += stack[top] stack = stack[:len(stack)-1] top-- } return res } "});index.add({'id':385,'href':'/leetcode-java/04_Leetcode/0862.Shortest-Subarray-with-Sum-at-Least-K/','title':"0862. Shortest Subarray With Sum at Least K",'section':"第四章",'content':"862. Shortest Subarray with Sum at Least K #  题目 #  Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.\nIf there is no non-empty subarray with sum at least K, return -1.\nExample 1:\nInput: A = [1], K = 1 Output: 1 Example 2:\nInput: A = [1,2], K = 4 Output: -1 Example 3:\nInput: A = [2,-1,2], K = 3 Output: 3 Note:\n 1 \u0026lt;= A.length \u0026lt;= 50000 -10 ^ 5 \u0026lt;= A[i] \u0026lt;= 10 ^ 5 1 \u0026lt;= K \u0026lt;= 10 ^ 9  题目大意 #  返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。如果没有和至少为 K 的非空子数组，返回 -1 。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 50000 -10 ^ 5 \u0026lt;= A[i] \u0026lt;= 10 ^ 5 1 \u0026lt;= K \u0026lt;= 10 ^ 9  解题思路 #   给出一个数组，要求找出一个最短的，非空的，连续的子序列且累加和至少为 k 。 由于给的数组里面可能存在负数，所以子数组的累加和不会随着数组的长度增加而增加。题目中要求区间和，理所应当需要利用 prefixSum 前缀和，先计算出 prefixSum 前缀和。 简化一下题目的要求，即能否找到 prefixSum[y] - prefixSum[x] ≥ K ，且 y - x 的差值最小。如果固定的 y，那么对于 x，x 越大，y - x 的差值就越小(因为 x 越逼近 y)。所以想求区间 [x, y] 的最短距离，需要保证 y 尽量小，x 尽量大，这样 [x, y] 区间距离最小。那么有以下 2 点“常识”一定成立：  如果 x1 \u0026lt; x2 ，并且 prefixSum[x2] ≤ prefixSum[x1]，说明结果一定不会取 x1。因为如果 prefixSum[x1] ≤ prefixSum[y] - k，那么 prefixSum[x2] ≤ prefixSum[x1] ≤ prefixSum[y] - k，x2 也能满足题意，并且 x2 比 x1 更加接近 y，最优解一定优先考虑 x2。 在确定了 x 以后，以后就不用再考虑 x 了，因为如果 y2 \u0026gt; y1，且 y2 的时候取 x 还是一样的，那么算距离的话，y2 - x 显然大于 y1 - x，这样的话肯定不会是最短的距离。   从上面这两个常识来看，可以用双端队列 deque 来处理 prefixSum。deque 中存储的是递增的 x 下标，为了满足常识一。从双端队列的开头开始遍历，假如区间和之差大于等于 K，就移除队首元素并更新结果 res。队首移除元素，直到不满足 prefixSum[i]-prefixSum[deque[0]] \u0026gt;= K 这一不等式，是为了满足常识二。之后的循环是此题的精髓，从双端队列的末尾开始往前遍历，假如当前区间和 prefixSum[i] 小于等于队列末尾的区间和，则移除队列末尾元素。为什么这样处理呢？因为若数组都是正数，那么长度越长，区间和一定越大，则 prefixSum[i] 一定大于所有双端队列中的区间和，但由于可能存在负数，从而使得长度变长，区间总和反而减少了，之前的区间和之差值都没有大于等于 K(\u0026lt; K)，现在的更不可能大于等于 K，这个结束位置可以直接淘汰，不用进行计算。循环结束后将当前位置加入双端队列即可。遇到新下标在队尾移除若干元素，这一行为，也是为了满足常识一。 由于所有下标都只进队列一次，也最多 pop 出去一次，所以时间复杂度 O(n)，空间复杂度 O(n)。  代码 #  func shortestSubarray(A []int, K int) int { res, prefixSum := len(A)+1, make([]int, len(A)+1) for i := 0; i \u0026lt; len(A); i++ { prefixSum[i+1] = prefixSum[i] + A[i] } // deque 中保存递增的 prefixSum 下标 \tdeque := []int{} for i := range prefixSum { // 下面这个循环希望能找到 [deque[0], i] 区间内累加和 \u0026gt;= K，如果找到了就更新答案 \tfor len(deque) \u0026gt; 0 \u0026amp;\u0026amp; prefixSum[i]-prefixSum[deque[0]] \u0026gt;= K { length := i - deque[0] if res \u0026gt; length { res = length } // 找到第一个 deque[0] 能满足条件以后，就移除它，因为它是最短长度的子序列了 \tdeque = deque[1:] } // 下面这个循环希望能保证 prefixSum[deque[i]] 递增 \tfor len(deque) \u0026gt; 0 \u0026amp;\u0026amp; prefixSum[i] \u0026lt;= prefixSum[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } deque = append(deque, i) } if res \u0026lt;= len(A) { return res } return -1 } "});index.add({'id':386,'href':'/leetcode-java/04_Leetcode/0863.All-Nodes-Distance-K-in-Binary-Tree/','title':"0863. All Nodes Distance K in Binary Tree",'section':"第四章",'content':"863. All Nodes Distance K in Binary Tree #  题目 #  We are given a binary tree (with root node root), a target node, and an integer value K.\nReturn a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order.\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 Output: [7,4,1] Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.  Note:\n The given tree is non-empty. Each node in the tree has unique values 0 \u0026lt;= node.val \u0026lt;= 500. The target node is a node in the tree. 0 \u0026lt;= K \u0026lt;= 1000.  题目大意 #  给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n提示：\n 给定的树是非空的。 树上的每个结点都具有唯一的值 0 \u0026lt;= node.val \u0026lt;= 500 。 目标结点 target 是树上的结点。 0 \u0026lt;= K \u0026lt;= 1000.  解题思路 #   给出一颗树和一个目标节点 target，一个距离 K，要求找到所有距离目标节点 target 的距离是 K 的点。 这一题用 DFS 的方法解题。先找到当前节点距离目标节点的距离，如果在左子树中找到了 target，距离当前节点的距离 \u0026gt; 0，则还需要在它的右子树中查找剩下的距离。如果是在右子树中找到了 target，反之同理。如果当前节点就是目标节点，那么就可以直接记录这个点。否则每次遍历一个点，距离都减一。  代码 #  func distanceK(root *TreeNode, target *TreeNode, K int) []int { visit := []int{} findDistanceK(root, target, K, \u0026amp;visit) return visit } func findDistanceK(root, target *TreeNode, K int, visit *[]int) int { if root == nil { return -1 } if root == target { findChild(root, K, visit) return K - 1 } leftDistance := findDistanceK(root.Left, target, K, visit) if leftDistance == 0 { findChild(root, leftDistance, visit) } if leftDistance \u0026gt; 0 { findChild(root.Right, leftDistance-1, visit) return leftDistance - 1 } rightDistance := findDistanceK(root.Right, target, K, visit) if rightDistance == 0 { findChild(root, rightDistance, visit) } if rightDistance \u0026gt; 0 { findChild(root.Left, rightDistance-1, visit) return rightDistance - 1 } return -1 } func findChild(root *TreeNode, K int, visit *[]int) { if root == nil { return } if K == 0 { *visit = append(*visit, root.Val) } else { findChild(root.Left, K-1, visit) findChild(root.Right, K-1, visit) } } "});index.add({'id':387,'href':'/leetcode-java/04_Leetcode/0864.Shortest-Path-to-Get-All-Keys/','title':"0864. Shortest Path to Get All Keys",'section':"第四章",'content':"864. Shortest Path to Get All Keys #  题目 #  We are given a 2-dimensional grid. \u0026quot;.\u0026quot; is an empty cell, \u0026quot;#\u0026quot; is a wall, \u0026quot;@\u0026quot; is the starting point, (\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026hellip;) are keys, and (\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026hellip;) are locks.\nWe start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions. We cannot walk outside the grid, or walk into a wall. If we walk over a key, we pick it up. We can\u0026rsquo;t walk over a lock unless we have the corresponding key.\nFor some 1 \u0026lt;= K \u0026lt;= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it\u0026rsquo;s impossible, return -1.\nExample 1:\nInput: [\u0026quot;@.a.#\u0026quot;,\u0026quot;###.#\u0026quot;,\u0026quot;b.A.B\u0026quot;] Output: 8  Example 2:\nInput: [\u0026quot;@..aA\u0026quot;,\u0026quot;..B#.\u0026quot;,\u0026quot;....b\u0026quot;] Output: 6  Note:\n 1 \u0026lt;= grid.length \u0026lt;= 30 1 \u0026lt;= grid[0].length \u0026lt;= 30 grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F' The number of keys is in [1, 6]. Each key has a different letter and opens exactly one lock.  题目大意 #  给定一个二维网格 grid。 \u0026ldquo;.\u0026rdquo; 代表一个空房间， \u0026ldquo;#\u0026rdquo; 代表一堵墙， \u0026ldquo;@\u0026rdquo; 是起点，（\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026hellip;）代表钥匙，（\u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026hellip;）代表锁。\n我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。\n假设 K 为钥匙/锁的个数，且满足 1 \u0026lt;= K \u0026lt;= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。\n返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。\n提示：\n 1 \u0026lt;= grid.length \u0026lt;= 30 1 \u0026lt;= grid[0].length \u0026lt;= 30 grid[i][j] 只含有 \u0026lsquo;.\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, \u0026lsquo;@\u0026rsquo;, \u0026lsquo;a\u0026rsquo;-\u0026lsquo;f\u0026rsquo; 以及 \u0026lsquo;A\u0026rsquo;-\u0026lsquo;F\u0026rsquo; 钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。  解题思路 #   给出一个地图，在图中有钥匙和锁，当锁在没有钥匙的时候不能通行，问从起点 @ 开始，到最终获得所有钥匙，最短需要走多少步。 这一题可以用 BFS 来解答。由于钥匙的种类比较多，所以 visited 数组需要 3 个维度，一个是 x 坐标，一个是 y 坐标，最后一个是当前获取钥匙的状态。每把钥匙都有获取了和没有获取两种状态，题目中说最多有 6 把钥匙，那么排列组合最多是 2^6 = 64 种状态。用一个十进制数的二进制位来压缩这些状态，二进制位分别来表示这些钥匙是否已经获取了。既然钥匙的状态可以压缩，其实 x 和 y 的坐标也可以一并压缩到这个数中。BFS 中存的数字是坐标 + 钥匙状态的状态。在 BFS 遍历的过程中，用 visited 数组来过滤遍历过的情况，来保证走的路是最短的。其他的情况无非是判断锁的状态，是否能通过，判断钥匙获取状态。 这一题不知道是否能用 DFS 来解答。我实现了一版，但是在 18 / 35 这组 case 上超时了，具体 case 见测试文件第一个 case。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;strings\u0026#34; ) // 解法一 BFS，利用状态压缩来过滤筛选状态 func shortestPathAllKeys(grid []string) int { if len(grid) == 0 { return 0 } board, visited, startx, starty, res, fullKeys := make([][]byte, len(grid)), make([][][]bool, len(grid)), 0, 0, 0, 0 for i := 0; i \u0026lt; len(grid); i++ { board[i] = make([]byte, len(grid[0])) } for i, g := range grid { board[i] = []byte(g) for _, v := range g { if v == \u0026#39;a\u0026#39; || v == \u0026#39;b\u0026#39; || v == \u0026#39;c\u0026#39; || v == \u0026#39;d\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;f\u0026#39; { fullKeys |= (1 \u0026lt;\u0026lt; uint(v-\u0026#39;a\u0026#39;)) } } if strings.Contains(g, \u0026#34;@\u0026#34;) { startx, starty = i, strings.Index(g, \u0026#34;@\u0026#34;) } } for i := 0; i \u0026lt; len(visited); i++ { visited[i] = make([][]bool, len(board[0])) } for i := 0; i \u0026lt; len(board); i++ { for j := 0; j \u0026lt; len(board[0]); j++ { visited[i][j] = make([]bool, 64) } } queue := []int{} queue = append(queue, (starty\u0026lt;\u0026lt;16)|(startx\u0026lt;\u0026lt;8)) visited[startx][starty][0] = true for len(queue) != 0 { qLen := len(queue) for i := 0; i \u0026lt; qLen; i++ { state := queue[0] queue = queue[1:] starty, startx = state\u0026gt;\u0026gt;16, (state\u0026gt;\u0026gt;8)\u0026amp;0xFF keys := state \u0026amp; 0xFF if keys == fullKeys { return res } for i := 0; i \u0026lt; 4; i++ { newState := keys nx := startx + dir[i][0] ny := starty + dir[i][1] if !isInBoard(board, nx, ny) { continue } if board[nx][ny] == \u0026#39;#\u0026#39; { continue } flag, canThroughLock := keys\u0026amp;(1\u0026lt;\u0026lt;(board[nx][ny]-\u0026#39;A\u0026#39;)), false if flag != 0 { canThroughLock = true } if isLock(board, nx, ny) \u0026amp;\u0026amp; !canThroughLock { continue } if isKey(board, nx, ny) { newState |= (1 \u0026lt;\u0026lt; (board[nx][ny] - \u0026#39;a\u0026#39;)) } if visited[nx][ny][newState] { continue } queue = append(queue, (ny\u0026lt;\u0026lt;16)|(nx\u0026lt;\u0026lt;8)|newState) visited[nx][ny][newState] = true } } res++ } return -1 } // 解法二 DFS，但是超时了，剪枝条件不够强 func shortestPathAllKeys1(grid []string) int { if len(grid) == 0 { return 0 } board, visited, startx, starty, res, fullKeys := make([][]byte, len(grid)), make([][][]bool, len(grid)), 0, 0, math.MaxInt64, 0 for i := 0; i \u0026lt; len(grid); i++ { board[i] = make([]byte, len(grid[0])) } for i, g := range grid { board[i] = []byte(g) for _, v := range g { if v == \u0026#39;a\u0026#39; || v == \u0026#39;b\u0026#39; || v == \u0026#39;c\u0026#39; || v == \u0026#39;d\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;f\u0026#39; { fullKeys |= (1 \u0026lt;\u0026lt; uint(v-\u0026#39;a\u0026#39;)) } } if strings.Contains(g, \u0026#34;@\u0026#34;) { startx, starty = i, strings.Index(g, \u0026#34;@\u0026#34;) } } for i := 0; i \u0026lt; len(visited); i++ { visited[i] = make([][]bool, len(board[0])) } for i := 0; i \u0026lt; len(board); i++ { for j := 0; j \u0026lt; len(board[0]); j++ { visited[i][j] = make([]bool, 64) } } searchKeys(board, \u0026amp;visited, fullKeys, 0, (starty\u0026lt;\u0026lt;16)|(startx\u0026lt;\u0026lt;8), \u0026amp;res, []int{}) if res == math.MaxInt64 { return -1 } return res - 1 } func searchKeys(board [][]byte, visited *[][][]bool, fullKeys, step, state int, res *int, path []int) { y, x := state\u0026gt;\u0026gt;16, (state\u0026gt;\u0026gt;8)\u0026amp;0xFF keys := state \u0026amp; 0xFF if keys == fullKeys { *res = min(*res, step) return } flag, canThroughLock := keys\u0026amp;(1\u0026lt;\u0026lt;(board[x][y]-\u0026#39;A\u0026#39;)), false if flag != 0 { canThroughLock = true } newState := keys //fmt.Printf(\u0026#34;x = %v y = %v fullKeys = %v keys = %v step = %v res = %v path = %v state = %v\\n\u0026#34;, x, y, fullKeys, keys, step, *res, path, state) \tif (board[x][y] != \u0026#39;#\u0026#39; \u0026amp;\u0026amp; !isLock(board, x, y)) || (isLock(board, x, y) \u0026amp;\u0026amp; canThroughLock) { if isKey(board, x, y) { newState |= (1 \u0026lt;\u0026lt; uint(board[x][y]-\u0026#39;a\u0026#39;)) } (*visited)[x][y][newState] = true path = append(path, x) path = append(path, y) for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isInBoard(board, nx, ny) \u0026amp;\u0026amp; !(*visited)[nx][ny][newState] { searchKeys(board, visited, fullKeys, step+1, (ny\u0026lt;\u0026lt;16)|(nx\u0026lt;\u0026lt;8)|newState, res, path) } } (*visited)[x][y][keys] = false path = path[:len(path)-1] path = path[:len(path)-1] } } func isLock(board [][]byte, x, y int) bool { if (board[x][y] == \u0026#39;A\u0026#39;) || (board[x][y] == \u0026#39;B\u0026#39;) || (board[x][y] == \u0026#39;C\u0026#39;) || (board[x][y] == \u0026#39;D\u0026#39;) || (board[x][y] == \u0026#39;E\u0026#39;) || (board[x][y] == \u0026#39;F\u0026#39;) { return true } return false } func isKey(board [][]byte, x, y int) bool { if (board[x][y] == \u0026#39;a\u0026#39;) || (board[x][y] == \u0026#39;b\u0026#39;) || (board[x][y] == \u0026#39;c\u0026#39;) || (board[x][y] == \u0026#39;d\u0026#39;) || (board[x][y] == \u0026#39;e\u0026#39;) || (board[x][y] == \u0026#39;f\u0026#39;) { return true } return false } "});index.add({'id':388,'href':'/leetcode-java/04_Leetcode/0865.Smallest-Subtree-With-All-The-Deepest-Nodes/','title':"0865. Smallest Subtree With All the Deepest Nodes",'section':"第四章",'content':"865. 具有所有最深节点的最小子树 #  Difficulty: 中等\n给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。\n如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。\n一个节点的 子树 是该节点加上它的所有后代的集合。\n返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。\n**注意：**本题与力扣 1123 重复：\n示例 1：\n 输入：root = [3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。 示例 2：\n输入：root = [1] 输出：[1] 解释：根节点是树中最深的节点。 示例 3：\n输入：root = [0,1,3,null,2] 输出：[2] 解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。 提示：\n 树中节点的数量介于 1 和 500 之间。 0 \u0026lt;= Node.val \u0026lt;= 500 每个节点的值都是独一无二的。  题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode subtreeWithAllDeepest(TreeNode root) { return dfs(root).node; } // Return the result of the subtree at this node.  public Result dfs(TreeNode node) { if (node == null) return new Result(null, 0); Result L = dfs(node.left), R = dfs(node.right); if (L.dist \u0026gt; R.dist) return new Result(L.node, L.dist + 1); if (L.dist \u0026lt; R.dist) return new Result(R.node, R.dist + 1); return new Result(node, L.dist + 1); } } /** * The result of a subtree is: * Result.node: the largest depth node that is equal to or * an ancestor of all the deepest nodes of this subtree. * Result.dist: the number of nodes in the path from the root * of this subtree, to the deepest node in this subtree. */ class Result { TreeNode node; int dist; Result(TreeNode n, int d) { node = n; dist = d; } } 复杂度分析 #    时间复杂度： O(N)，其中 N 为树的大小。\n  空间复杂度： O(N)。\n  "});index.add({'id':389,'href':'/leetcode-java/04_Leetcode/0867.Transpose-Matrix/','title':"0867. Transpose Matrix",'section':"第四章",'content':"867. 转置矩阵 #  Difficulty: 简单\n给定一个矩阵 A， 返回 A 的转置矩阵。\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n示例 1：\n输入：[[1,2,3],[4,5,6],[7,8,9]] 输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2：\n输入：[[1,2,3],[4,5,6]] 输出：[[1,4],[2,5],[3,6]] 提示：\n 1 \u0026lt;= A.length \u0026lt;= 1000 1 \u0026lt;= A[0].length \u0026lt;= 1000  题解 #  题解一：直接复制 #  class Solution { public int[][] transpose(int[][] A) { int first = A.length; int second = A[0].length; int[][] result = new int[second][first]; for (int i = 0; i \u0026lt; second; i++) { for (int j = 0; j \u0026lt; first; j++) { result[i][j] = A[j][i]; } } return result; } } 复杂度分析 #    时间复杂度：O(R * C)，其中 R 和 C 是给定矩阵 A 的行数和列数。\n  空间复杂度：O(R * C)。\n  "});index.add({'id':390,'href':'/leetcode-java/04_Leetcode/0872.Leaf-Similar-Trees/','title':"0872. Leaf Similar Trees",'section':"第四章",'content':"872. 叶子相似的树 #  Difficulty: 简单\n请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。\n 举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。\n如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 _叶相似 _的。\n如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。\n示例 1：\n 输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] 输出：true 示例 2：\n输入：root1 = [1], root2 = [1] 输出：true 示例 3：\n输入：root1 = [1], root2 = [2] 输出：false 示例 4：\n输入：root1 = [1,2], root2 = [2,2] 输出：true 示例 5：\n 输入：root1 = [1,2,3], root2 = [1,3,2] 输出：false 提示：\n 给定的两棵树可能会有 1 到 200 个结点。 给定的两棵树上的值介于 0 到 200 之间。  题解 #  题解一：DFS（深度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean leafSimilar(TreeNode root1, TreeNode root2) { StringBuffer buffer1 = new StringBuffer(\u0026#34;\u0026#34;); StringBuffer buffer2 = new StringBuffer(\u0026#34;\u0026#34;); helper(root1, buffer1); helper(root2, buffer2); return buffer1.toString().equals(buffer2.toString()); } private void helper(TreeNode node, StringBuffer buffer) { if (node == null) { return; } if (node.left == null \u0026amp;\u0026amp; node.right == null) { buffer.append(node.val).append(\u0026#34;,\u0026#34;); } helper(node.left, buffer); helper(node.right, buffer); } } 复杂度分析\n  时间复杂度：O(T1 + T2)。\n  空间复杂度：O(T1 + T2)。\n  "});index.add({'id':391,'href':'/leetcode-java/04_Leetcode/0875.Koko-Eating-Bananas/','title':"0875. Koko Eating Bananas",'section':"第四章",'content':"875. Koko Eating Bananas #  题目 #  Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won\u0026rsquo;t eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\nExample 1:\nInput: piles = [3,6,7,11], H = 8 Output: 4  Example 2:\nInput: piles = [30,11,23,4,20], H = 5 Output: 30  Example 3:\nInput: piles = [30,11,23,4,20], H = 6 Output: 23  Note:\n 1 \u0026lt;= piles.length \u0026lt;= 10^4 piles.length \u0026lt;= H \u0026lt;= 10^9 1 \u0026lt;= piles[i] \u0026lt;= 10^9  题目大意 #  珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。\n珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。\n提示：\n 1 \u0026lt;= piles.length \u0026lt;= 10^4 piles.length \u0026lt;= H \u0026lt;= 10^9 1 \u0026lt;= piles[i] \u0026lt;= 10^9  解题思路 #   给出一个数组，数组里面每个元素代表的是每个香蕉🍌串上香蕉的个数。koko 以 k 个香蕉/小时的速度吃这些香蕉。守卫会在 H 小时以后回来。问 k 至少为多少，能在守卫回来之前吃完所有的香蕉。当香蕉的个数小于 k 的时候，这个小时只能吃完这些香蕉，不能再吃其他串上的香蕉了。 这一题可以用二分搜索来解答。在 [0 , max(piles)] 的范围内搜索，二分的过程都是常规思路。判断是否左右边界如果划分的时候需要注意题目中给的限定条件。当香蕉个数小于 k 的时候，那个小时不能再吃其他香蕉了。  代码 #  package leetcode import \u0026#34;math\u0026#34; func minEatingSpeed(piles []int, H int) int { low, high := 1, maxInArr(piles) for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if !isPossible(piles, mid, H) { low = mid + 1 } else { high = mid } } return low } func isPossible(piles []int, h, H int) bool { res := 0 for _, p := range piles { res += int(math.Ceil(float64(p) / float64(h))) } return res \u0026lt;= H } func maxInArr(xs []int) int { res := 0 for _, x := range xs { if res \u0026lt; x { res = x } } return res } "});index.add({'id':392,'href':'/leetcode-java/04_Leetcode/0876.Middle-of-the-Linked-List/','title':"0876. Middle of the Linked List",'section':"第四章",'content':"876. 链表的中间结点 #  Difficulty: 简单\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：\n输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：\n 给定链表的结点数介于 1 和 100 之间。  题解 #  题解一：单指针解法 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode temp = head; int length = 1; while (temp.next != null) { length++; temp = temp.next; } int middle = length / 2; for (int i = 0; i \u0026lt; middle; i++) { head = head.next; } return head; } } 复杂度分析 #    时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  题解二：快慢指针法 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } } 复杂度分析 #    时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  "});index.add({'id':393,'href':'/leetcode-java/04_Leetcode/0878.Nth-Magical-Number/','title':"0878. Nth Magical Number",'section':"第四章",'content':"878. Nth Magical Number #  题目 #  A positive integer is magical if it is divisible by either A or B.\nReturn the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: N = 1, A = 2, B = 3 Output: 2  Example 2:\nInput: N = 4, A = 2, B = 3 Output: 6  Example 3:\nInput: N = 5, A = 2, B = 4 Output: 10  Example 4:\nInput: N = 3, A = 6, B = 4 Output: 8  Note:\n 1 \u0026lt;= N \u0026lt;= 10^9 2 \u0026lt;= A \u0026lt;= 40000 2 \u0026lt;= B \u0026lt;= 40000  题目大意 #  如果正整数可以被 A 或 B 整除，那么它是神奇的。返回第 N 个神奇数字。由于答案可能非常大，返回它模 10^9 + 7 的结果。\n提示：\n 1 \u0026lt;= N \u0026lt;= 10^9 2 \u0026lt;= A \u0026lt;= 40000 2 \u0026lt;= B \u0026lt;= 40000  解题思路 #   给出 3 个数字，a，b，n。要求输出可以整除 a 或者整除 b 的第 n 个数。 这一题是第 1201 题的缩水版，代码和解题思路也基本不变，这一题的二分搜索的区间是 [min(A, B)，N * min(A, B)] = [2, 10 ^ 14]。其他代码和第 1201 题一致，思路见第 1201 题。  代码 #  package leetcode func nthMagicalNumber(N int, A int, B int) int { low, high := int64(0), int64(1*1e14) for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calNthMagicalCount(mid, int64(A), int64(B)) \u0026lt; int64(N) { low = mid + 1 } else { high = mid } } return int(low) % 1000000007 } func calNthMagicalCount(num, a, b int64) int64 { ab := a * b / gcd(a, b) return num/a + num/b - num/ab } "});index.add({'id':394,'href':'/leetcode-java/04_Leetcode/0880.Decoded-String-at-Index/','title':"0880. Decoded String at Index",'section':"第四章",'content':"880. Decoded String at Index #  题目 #  An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:\nIf the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total. Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.\nExample 1:\n Input: S = \u0026quot;leet2code3\u0026quot;, K = 10 Output: \u0026quot;o\u0026quot; Explanation: The decoded string is \u0026quot;leetleetcodeleetleetcodeleetleetcode\u0026quot;. The 10th letter in the string is \u0026quot;o\u0026quot;. Example 2:\n Input: S = \u0026quot;ha22\u0026quot;, K = 5 Output: \u0026quot;h\u0026quot; Explanation: The decoded string is \u0026quot;hahahaha\u0026quot;. The 5th letter is \u0026quot;h\u0026quot;. Example 3:\n Input: S = \u0026quot;a2345678999999999999999\u0026quot;, K = 1 Output: \u0026quot;a\u0026quot; Explanation: The decoded string is \u0026quot;a\u0026quot; repeated 8301530446056247680 times. The 1st letter is \u0026quot;a\u0026quot;. Note:\n 2 \u0026lt;= S.length \u0026lt;= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 \u0026lt;= K \u0026lt;= 10^9 The decoded string is guaranteed to have less than 2^63 letters.  题目大意 #  给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：\n 如果所读的字符是字母，则将该字母写在磁带上。 如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。  现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。\n解题思路 #  按照题意，扫描字符串扫到数字的时候，开始重复字符串，这里可以用递归。注意在重复字符串的时候到第 K 个字符的时候就可以返回了，不要等所有字符都扩展完成，这样会超时。d 有可能超大。\n代码 #  package leetcode func isLetter(char byte) bool { if char \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; char \u0026lt;= \u0026#39;z\u0026#39; { return true } return false } func decodeAtIndex(S string, K int) string { length := 0 for i := 0; i \u0026lt; len(S); i++ { if isLetter(S[i]) { length++ if length == K { return string(S[i]) } } else { if length*int(S[i]-\u0026#39;0\u0026#39;) \u0026gt;= K { if K%length != 0 { return decodeAtIndex(S[:i], K%length) } return decodeAtIndex(S[:i], length) } length *= int(S[i] - \u0026#39;0\u0026#39;) } } return \u0026#34;\u0026#34; } "});index.add({'id':395,'href':'/leetcode-java/04_Leetcode/0881.Boats-to-Save-People/','title':"0881. Boats to Save People",'section':"第四章",'content':"881. Boats to Save People #  题目 #  The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\nExample 1:\n Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2:\n Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3:\n Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:\n 1 \u0026lt;= people.length \u0026lt;= 50000 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 30000  题目大意 #  给出人的重量数组，和一个船最大载重量 limit。一个船最多装 2 个人。要求输出装下所有人，最小需要多少艘船。\n解题思路 #  先对人的重量进行排序，然后用 2 个指针分别指向一前一后，一起计算这两个指针指向的重量之和，如果小于 limit，左指针往右移动，并且右指针往左移动。如果大于等于 limit，右指针往左移动。每次指针移动，需要船的个数都要 ++。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func numRescueBoats(people []int, limit int) int { sort.Ints(people) left, right, res := 0, len(people)-1, 0 for left \u0026lt;= right { if left == right { res++ return res } if people[left]+people[right] \u0026lt;= limit { left++ right-- } else { right-- } res++ } return res } "});index.add({'id':396,'href':'/leetcode-java/04_Leetcode/0884.Uncommon-Words-from-Two-Sentences/','title':"0884. Uncommon Words From Two Sentences",'section':"第四章",'content':"884. Uncommon Words from Two Sentences #  题目 #  We are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.)\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\nReturn a list of all uncommon words.\nYou may return the list in any order.\nExample 1:\nInput: A = \u0026quot;this apple is sweet\u0026quot;, B = \u0026quot;this apple is sour\u0026quot; Output: [\u0026quot;sweet\u0026quot;,\u0026quot;sour\u0026quot;]  Example 2:\nInput: A = \u0026quot;apple apple\u0026quot;, B = \u0026quot;banana\u0026quot; Output: [\u0026quot;banana\u0026quot;]  Note:\n 0 \u0026lt;= A.length \u0026lt;= 200 0 \u0026lt;= B.length \u0026lt;= 200 A and B both contain only spaces and lowercase letters.  题目大意 #  给定两个句子 A 和 B 。（句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）\n如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。返回所有不常用单词的列表。您可以按任何顺序返回列表。\n解题思路 #   找出 2 个句子中不同的单词，将它们俩都打印出来。简单题，先将 2 个句子的单词都拆开放入 map 中进行词频统计，不同的两个单词的词频肯定都为 1，输出它们即可。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func uncommonFromSentences(A string, B string) []string { m, res := map[string]int{}, []string{} for _, s := range []string{A, B} { for _, word := range strings.Split(s, \u0026#34; \u0026#34;) { m[word]++ } } for key := range m { if m[key] == 1 { res = append(res, key) } } return res } "});index.add({'id':397,'href':'/leetcode-java/04_Leetcode/0885.Spiral-Matrix-III/','title':"0885. Spiral Matrix I I I",'section':"第四章",'content':"885. Spiral Matrix III #  题目 #  On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.\nHere, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.\nNow, we walk in a clockwise spiral shape to visit every position in this grid.\nWhenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)\nEventually, we reach all R * C spaces of the grid.\nReturn a list of coordinates representing the positions of the grid in the order they were visited.\nExample 1:\nInput: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]   Example 2:\nInput: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4], [3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1], [0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]   Note:\n 1 \u0026lt;= R \u0026lt;= 100 1 \u0026lt;= C \u0026lt;= 100 0 \u0026lt;= r0 \u0026lt; R 0 \u0026lt;= c0 \u0026lt; C  题目大意 #  在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始。这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。最终，我们到过网格的所有 R * C 个空间。\n要求输出按照访问顺序返回表示网格位置的坐标列表。\n解题思路 #   给出一个二维数组的行 R，列 C，以及这个数组中的起始点 (r0,c0)。从这个起始点开始出发，螺旋的访问数组中各个点，输出途径经过的每个坐标。注意每个螺旋的步长在变长，第一个螺旋是 1 步，第二个螺旋是 1 步，第三个螺旋是 2 步，第四个螺旋是 2 步……即 1，1，2，2，3，3，4，4，5……这样的步长。 这一题是第 59 题的加强版。除了有螺旋以外，还加入了步长的限制。步长其实是有规律的，第 0 次移动的步长是 0/2+1，第 1 次移动的步长是 1/2+1，第 n 次移动的步长是 n/2+1。其他的做法和第 59 题一致。  代码 #  package leetcode func spiralMatrixIII(R int, C int, r0 int, c0 int) [][]int { res, round, spDir := [][]int{}, 0, [][]int{ []int{0, 1}, // 朝右 \t[]int{1, 0}, // 朝下 \t[]int{0, -1}, // 朝左 \t[]int{-1, 0}, // 朝上 \t} res = append(res, []int{r0, c0}) for i := 0; len(res) \u0026lt; R*C; i++ { for j := 0; j \u0026lt; i/2+1; j++ { r0 += spDir[round%4][0] c0 += spDir[round%4][1] if 0 \u0026lt;= r0 \u0026amp;\u0026amp; r0 \u0026lt; R \u0026amp;\u0026amp; 0 \u0026lt;= c0 \u0026amp;\u0026amp; c0 \u0026lt; C { res = append(res, []int{r0, c0}) } } round++ } return res } "});index.add({'id':398,'href':'/leetcode-java/04_Leetcode/0887.Super-Egg-Drop/','title':"0887. Super Egg Drop",'section':"第四章",'content':"887. Super Egg Drop #  题目 #  You are given K eggs, and you have access to a building with N floors from 1 to N.\nEach egg is identical in function, and if an egg breaks, you cannot drop it again.\nYou know that there exists a floor F with 0 \u0026lt;= F \u0026lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 \u0026lt;= X \u0026lt;= N).\nYour goal is to know with certainty what the value of F is.\nWhat is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?\nExample 1:\nInput: K = 1, N = 2 Output: 2 Explanation: Drop the egg from floor 1. If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2. If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.  Example 2:\nInput: K = 2, N = 6 Output: 3  Example 3:\nInput: K = 3, N = 14 Output: 4  Note:\n 1 \u0026lt;= K \u0026lt;= 100 1 \u0026lt;= N \u0026lt;= 10000  题目大意 #  你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 \u0026lt;= F \u0026lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 \u0026lt;= X \u0026lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？\n提示：\n 1 \u0026lt;= K \u0026lt;= 100 1 \u0026lt;= N \u0026lt;= 10000  解题思路 #   给出 K 个鸡蛋，N 层楼，要求确定安全楼层 F 需要最小步数 t。 这一题是微软的经典面试题。拿到题最容易想到的是二分搜索。但是仔细分析以后会发现单纯的二分是不对的。不断的二分确实能找到最终安全的楼层，但是这里没有考虑到 K 个鸡蛋。鸡蛋数的限制会导致二分搜索无法找到最终楼层。题目要求要在保证能找到最终安全楼层的情况下，找到最小步数。所以单纯的二分搜索并不能解答这道题。 这一题如果按照题意正向考虑，动态规划的状态转移方程是 searchTime(K, N) = max( searchTime(K-1, X-1), searchTime(K, N-X) )。其中 X 是丢鸡蛋的楼层。随着 X 从 [1,N]，都能计算出一个 searchTime 的值，在所有这 N 个值之中，取最小值就是本题的答案了。这个解法可以 AC 这道题。不过这个解法不细展开了。时间复杂度 O(k*N^2)。   换个角度来看这个问题，定义 dp[k][m] 代表 K 个鸡蛋，M 次移动能检查的最大楼层。考虑某一步 t 应该在哪一层丢鸡蛋呢？一个正确的选择是在 dp[k-1][t-1] + 1 层丢鸡蛋，结果分两种情况：  如果鸡蛋碎了，我们首先排除了该层以上的所有楼层（不管这个楼有多高），而对于剩下的 dp[k-1][t-1] 层楼，我们一定能用 k-1 个鸡蛋在 t-1 步内求解。因此这种情况下，我们总共可以求解无限高的楼层。可见，这是一种非常好的情况，但并不总是发生。 如果鸡蛋没碎，我们首先排除了该层以下的 dp[k-1][t-1] 层楼，此时我们还有 k 个蛋和 t-1 步，那么我们去该层以上的楼层继续测得 dp[k][t-1] 层楼。因此这种情况下，我们总共可以求解 dp[k-1][t-1] + 1 + dp[k][t-1] 层楼。   在所有 m 步中只要有一次出现了第一种情况，那么我们就可以求解无限高的楼层。但题目要求我们能保证一定能找到安全楼层，所以每次丢鸡蛋的情况应该按照最差情况来，即每次都是第二种情况。于是得到转状态转移方程: dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1 。这个方程可以压缩到一维，因为每个新的状态只和上一行和左一列有关。那么每一行从右往左更新，即 dp[i] += 1 + dp[i-1]。时间复杂度 O(K * log N)，空间复杂度 O(N)。 可能会有人有疑问，如果最初选择不在 dp[k-1][t-1] + 1 层丢鸡蛋会怎么样呢？选择在更低的层或者更高的层丢鸡蛋会怎样呢？  如果在更低的楼层丢鸡蛋也能保证找到安全楼层。那么得到的结果一定不是最小步数。因为这次丢鸡蛋没有充分的展现鸡蛋和移动次数的潜力，最终求解一定会有鸡蛋和步数剩余，即不是能探测的最大楼层了。 如果在更高的楼层丢鸡蛋，假设是第 dp[k-1][t-1] + 2 层丢鸡蛋，如果这次鸡蛋碎了，剩下 k-1 个鸡蛋和 t-1 步只能保证验证 dp[k-1][t-1] 的楼层，这里还剩第 dp[k-1][t-1]+ 1 的楼层，不能保证最终一定能找到安全楼层了。   用反证法就能得出每一步都应该在第 dp[k-1][t-1] + 1 层丢鸡蛋。 这道题还可以用二分搜索来解答。回到上面分析的状态转移方程：dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1 。用数学方法来解析这个递推关系。令 f(t,k) 为 t 和 k 的函数，题目所要求能测到最大楼层是 N 的最小步数，即要求出 f(t,k) ≥ N 时候的最小 t。由状态转移方程可以知道：f(t,k) = f(t-1,k) + f(t-1,k-1) + 1，当 k = 1 的时候，对应一个鸡蛋的情况，f(t,1) = t，当 t = 1 的时候，对应一步的情况，f(1,k) = 1。有状态转移方程得：   令 g(t,k) = f(t,k) - f(t,k-1)，可以得到：   可以知道 g(t,k) 是一个杨辉三角，即二项式系数：   利用裂项相消的方法：   于是可以得到：   其中：   于是针对每一项的二项式常数，都可以由前一项乘以一个分数得到下一项。   利用二分搜索，不断的二分 t，直到逼近找到 f(t,k) ≥ N 时候最小的 t。时间复杂度 O(K * log N)，空间复杂度 O(1)。  代码 #  package leetcode // 解法一 二分搜索 func superEggDrop(K int, N int) int { low, high := 1, N for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if counterF(K, N, mid) \u0026gt;= N { high = mid } else { low = mid + 1 } } return low } // 计算二项式和，特殊的第一项 C(t,0) = 1 func counterF(k, n, mid int) int { res, sum := 1, 0 for i := 1; i \u0026lt;= k \u0026amp;\u0026amp; sum \u0026lt; n; i++ { res *= mid - i + 1 res /= i sum += res } return sum } // 解法二 动态规划 DP func superEggDrop1(K int, N int) int { dp, step := make([]int, K+1), 0 for ; dp[K] \u0026lt; N; step++ { for i := K; i \u0026gt; 0; i-- { dp[i] = (1 + dp[i] + dp[i-1]) } } return step } "});index.add({'id':399,'href':'/leetcode-java/04_Leetcode/0888.Fair-Candy-Swap/','title':"0888. Fair Candy Swap",'section':"第四章",'content':"888. Fair Candy Swap #  题目 #  Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.\nSince they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.)\nReturn an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.\nIf there are multiple answers, you may return any one of them. It is guaranteed an answer exists.\nExample 1:\nInput: A = [1,1], B = [2,2] Output: [1,2] Example 2:\nInput: A = [1,2], B = [2,3] Output: [1,2] Example 3:\nInput: A = [2], B = [1,3] Output: [2,3] Example 4:\nInput: A = [1,2,5], B = [2,4] Output: [5,4] Note:\n 1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= B.length \u0026lt;= 10000 1 \u0026lt;= A[i] \u0026lt;= 100000 1 \u0026lt;= B[i] \u0026lt;= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.  题目大意 #  爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。如果有多个答案，你可以返回其中任何一个。保证答案存在。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= B.length \u0026lt;= 10000 1 \u0026lt;= A[i] \u0026lt;= 100000 1 \u0026lt;= B[i] \u0026lt;= 100000 保证爱丽丝与鲍勃的糖果总量不同。 答案肯定存在。  解题思路 #   两人交换糖果，使得两人糖果相等。要求输出一个数组，里面分别包含两人必须交换的糖果大小。 首先这一题肯定了一定有解，其次只允许交换一次。有了这两个前提，使本题变成简单题。先计算出为了使得交换以后两个相同的糖果数，A 需要增加或者减少的糖果数 diff。然后遍历 B ，看 A 中是否存在一个元素，能使得 B 做了对应交换 diff 以后，两人糖果相等。(此题前提保证了一定能找到)。最后输出 A 中的这个元素和遍历到 B 的这个元素，即是两人要交换的糖果数。  代码 #  package leetcode func fairCandySwap(A []int, B []int) []int { hDiff, aMap := diff(A, B)/2, make(map[int]int, len(A)) for _, a := range A { aMap[a] = a } for _, b := range B { if a, ok := aMap[hDiff+b]; ok { return []int{a, b} } } return nil } func diff(A []int, B []int) int { diff, maxLen := 0, max(len(A), len(B)) for i := 0; i \u0026lt; maxLen; i++ { if i \u0026lt; len(A) { diff += A[i] } if i \u0026lt; len(B) { diff -= B[i] } } return diff } func max(a, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':400,'href':'/leetcode-java/04_Leetcode/0891.Sum-of-Subsequence-Widths/','title':"0891. Sum of Subsequence Widths",'section':"第四章",'content':"891. Sum of Subsequence Widths #  题目 #  Given an array of integers A, consider all non-empty subsequences of A.\nFor any sequence S, let the width of S be the difference between the maximum and minimum element of S.\nReturn the sum of the widths of all subsequences of A.\nAs the answer may be very large, return the answer modulo 10^9 + 7.\nExample 1:\n Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Note:\n 1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= 20000  题目大意 #  给定一个整数数组 A ，考虑 A 的所有非空子序列。对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。返回 A 的所有子序列的宽度之和。由于答案可能非常大，请返回答案模 10^9+7。\n解题思路 #    理解题意以后，可以发现，数组内元素的顺序并不影响最终求得的所有子序列的宽度之和。\n [2,1,3]:[1],[2],[3],[2,1],[2,3],[1,3],[2,1,3] [1,2,3]:[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]  针对每个 A[i] 而言，A[i] 对最终结果的贡献是在子序列的左右两边的时候才有贡献，当 A[i] 位于区间中间的时候，不影响最终结果。先对 A[i] 进行排序，排序以后，有 i 个数 \u0026lt;= A[i]，有 n - i - 1 个数 \u0026gt;= A[i]。所以 A[i] 会在 2^i 个子序列的右边界出现，2^(n-i-1) 个左边界出现。那么 A[i] 对最终结果的贡献是 A[i] * 2^i - A[i] * 2^(n-i-1) 。举个例子，[1,4,5,7]，A[2] = 5，那么 5 作为右边界的子序列有 2^2 = 4 个，即 [5],[1,5],[4,5],[1,4,5]，5 作为左边界的子序列有 2^(4-2-1) = 2 个，即 [5],[5,7]。A[2] = 5 对最终结果的影响是 5 * 2^2 - 5 * 2^(4-2-1) = 10 。\n  题目要求所有子序列的宽度之和，也就是求每个区间最大值减去最小值的总和。那么 Ans = SUM{ A[i]*2^i - A[n-i-1] * 2^(n-i-1) }，其中 0 \u0026lt;= i \u0026lt; n。需要注意的是 2^i 可能非常大，所以在计算中就需要去 mod 了，而不是最后计算完了再 mod。注意取模的结合律：(a * b) % c = (a % c) * (b % c) % c。\n  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func sumSubseqWidths(A []int) int { sort.Ints(A) res, mod, n, p := 0, 1000000007, len(A), 1 for i := 0; i \u0026lt; n; i++ { res = (res + (A[i]-A[n-1-i])*p) % mod p = (p \u0026lt;\u0026lt; 1) % mod } return res } "});index.add({'id':401,'href':'/leetcode-java/04_Leetcode/0892.Surface-Area-of-3D-Shapes/','title':"0892. Surface Area of 3 D Shapes",'section':"第四章",'content':"892. Surface Area of 3D Shapes #  题目 #  On a N * N grid, we place some 1 * 1 * 1 cubes.\nEach value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).\nReturn the total surface area of the resulting shapes.\nExample 1:\nInput: [[2]] Output: 10 Example 2:\nInput: [[1,2],[3,4]] Output: 34 Example 3:\nInput: [[1,0],[0,2]] Output: 16 Example 4:\nInput: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5:\nInput: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note:\n 1 \u0026lt;= N \u0026lt;= 50 0 \u0026lt;= grid[i][j] \u0026lt;= 50  题目大意 #  在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。请你返回最终形体的表面积。\n解题思路 #   给定一个网格数组，数组里面装的是立方体叠放在所在的单元格，求最终这些叠放的立方体的表面积。 简单题。按照题目意思，找到叠放时，重叠的面，然后用总表面积减去这些重叠的面积即为最终答案。  代码 #  package leetcode func surfaceArea(grid [][]int) int { area := 0 for i := 0; i \u0026lt; len(grid); i++ { for j := 0; j \u0026lt; len(grid[0]); j++ { if grid[i][j] == 0 { continue } area += grid[i][j]*4 + 2 // up \tif i \u0026gt; 0 { m := min(grid[i][j], grid[i-1][j]) area -= m } // down \tif i \u0026lt; len(grid)-1 { m := min(grid[i][j], grid[i+1][j]) area -= m } // left \tif j \u0026gt; 0 { m := min(grid[i][j], grid[i][j-1]) area -= m } // right \tif j \u0026lt; len(grid[i])-1 { m := min(grid[i][j], grid[i][j+1]) area -= m } } } return area } func min(a, b int) int { if a \u0026gt; b { return b } return a } "});index.add({'id':402,'href':'/leetcode-java/04_Leetcode/0895.Maximum-Frequency-Stack/','title':"0895. Maximum Frequency Stack",'section':"第四章",'content':"895. Maximum Frequency Stack #  题目 #  Implement FreqStack, a class which simulates the operation of a stack-like data structure.\nFreqStack has two functions:\npush(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.\nIf there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.\nExample 1:\n Input: [\u0026quot;FreqStack\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;pop\u0026quot;,\u0026quot;pop\u0026quot;,\u0026quot;pop\u0026quot;,\u0026quot;pop\u0026quot;], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then: pop() -\u0026gt; returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. pop() -\u0026gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. pop() -\u0026gt; returns 5. The stack becomes [5,7,4]. pop() -\u0026gt; returns 4. The stack becomes [5,7]. Note:\n Calls to FreqStack.push(int x) will be such that 0 \u0026lt;= x \u0026lt;= 10^9. It is guaranteed that FreqStack.pop() won\u0026rsquo;t be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.  题目大意 #  实现 FreqStack，模拟类似栈的数据结构的操作的一个类。\nFreqStack 有两个函数：\n push(int x)，将整数 x 推入栈中。 pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。  解题思路 #  FreqStack 里面保存频次的 map 和相同频次 group 的 map。push 的时候动态的维护 x 的频次，并更新到对应频次的 group 中。pop 的时候对应减少频次字典里面的频次，并更新到对应频次的 group 中。\n代码 #  package leetcode type FreqStack struct { freq map[int]int group map[int][]int maxfreq int } func Constructor895() FreqStack { hash := make(map[int]int) maxHash := make(map[int][]int) return FreqStack{freq: hash, group: maxHash} } func (this *FreqStack) Push(x int) { if _, ok := this.freq[x]; ok { this.freq[x]++ } else { this.freq[x] = 1 } f := this.freq[x] if f \u0026gt; this.maxfreq { this.maxfreq = f } this.group[f] = append(this.group[f], x) } func (this *FreqStack) Pop() int { tmp := this.group[this.maxfreq] x := tmp[len(tmp)-1] this.group[this.maxfreq] = this.group[this.maxfreq][:len(this.group[this.maxfreq])-1] this.freq[x]-- if len(this.group[this.maxfreq]) == 0 { this.maxfreq-- } return x } /** * Your FreqStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); */ "});index.add({'id':403,'href':'/leetcode-java/04_Leetcode/0896.Monotonic-Array/','title':"0896. Monotonic Array",'section':"第四章",'content':"896. Monotonic Array #  题目 #  An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array A is monotone increasing if for all i \u0026lt;= j, A[i] \u0026lt;= A[j]. An array A is monotone decreasing if for all i \u0026lt;= j, A[i] \u0026gt;= A[j].\nReturn true if and only if the given array A is monotonic.\nExample 1:\nInput: [1,2,2,3] Output: true Example 2:\nInput: [6,5,4,4] Output: true Example 3:\nInput: [1,3,2] Output: false Example 4:\nInput: [1,2,4,5] Output: true Example 5:\nInput: [1,1,1] Output: true Note:\n 1 \u0026lt;= A.length \u0026lt;= 50000 -100000 \u0026lt;= A[i] \u0026lt;= 100000  题目大意 #  如果数组是单调递增或单调递减的，那么它是单调的。如果对于所有 i \u0026lt;= j，A[i] \u0026lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i \u0026lt;= j，A[i]\u0026gt; = A[j]，那么数组 A 是单调递减的。当给定的数组 A 是单调数组时返回 true，否则返回 false。\n解题思路 #   判断给定的数组是不是单调(单调递增或者单调递减)的。 简单题，按照题意循环判断即可。  代码 #  package leetcode func isMonotonic(A []int) bool { if len(A) \u0026lt;= 1 { return true } if A[0] \u0026lt; A[1] { return inc(A[1:]) } if A[0] \u0026gt; A[1] { return dec(A[1:]) } return inc(A[1:]) || dec(A[1:]) } func inc(A []int) bool { for i := 0; i \u0026lt; len(A)-1; i++ { if A[i] \u0026gt; A[i+1] { return false } } return true } func dec(A []int) bool { for i := 0; i \u0026lt; len(A)-1; i++ { if A[i] \u0026lt; A[i+1] { return false } } return true } "});index.add({'id':404,'href':'/leetcode-java/04_Leetcode/0897.Increasing-Order-Search-Tree/','title':"0897. Increasing Order Search Tree",'section':"第四章",'content':"897. 递增顺序查找树 #  Difficulty: 简单\n给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。\n示例 ：\n输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 提示：\n 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。  题解 #  解法一：中序遍历 + 构造新的树 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode increasingBST(TreeNode root) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); inOrder(root, list); TreeNode node = new TreeNode(0); TreeNode cur = node; for (int v : list) { cur.right = new TreeNode(v); cur = cur.right; } return node.right; } private void inOrder(TreeNode node, List\u0026lt;Integer\u0026gt; list) { if (node == null) { return; } inOrder(node.left, list); list.add(node.val); inOrder(node.right, list); } } 复杂度分析 #    时间复杂度：O(N)，其中 N 是树上的节点个数。\n  空间复杂度：O(N)。\n  解法二：中序遍历 + 更改树的连接方式 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { TreeNode cur; public TreeNode increasingBST(TreeNode root) { TreeNode ans = new TreeNode(0); cur = ans; inorder(root); return ans.right; } public void inorder(TreeNode node) { if (node == null) return; inorder(node.left); node.left = null; cur.right = node; cur = node; inorder(node.right); } } 复杂度分析 #    时间复杂度：O(N)，其中 N 是树上的节点个数。\n  空间复杂度：O(H)，其中 H 是树的高度。\n  "});index.add({'id':405,'href':'/leetcode-java/04_Leetcode/0898.Bitwise-ORs-of-Subarrays/','title':"0898. Bitwise O Rs of Subarrays",'section':"第四章",'content':"898. Bitwise ORs of Subarrays #  题目 #  We have an array A of non-negative integers.\nFor every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i \u0026lt;= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].\nReturn the number of possible results. (Results that occur more than once are only counted once in the final answer.)\nExample 1:\nInput: [0] Output: 1 Explanation: There is only one possible result: 0.  Example 2:\nInput: [1,1,2] Output: 3 Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.  Example 3:\nInput: [1,2,4] Output: 6 Explanation: The possible results are 1, 2, 3, 4, 6, and 7.  Note:\n 1 \u0026lt;= A.length \u0026lt;= 50000 0 \u0026lt;= A[i] \u0026lt;= 10^9  题目大意 #  我们有一个非负整数数组 A。对于每个（连续的）子数组 B = [A[i], A[i+1], \u0026hellip;, A[j]] （ i \u0026lt;= j），我们对 B 中的每个元素进行按位或操作，获得结果 A[i] | A[i+1] | \u0026hellip; | A[j]。返回可能结果的数量。（多次出现的结果在最终答案中仅计算一次。）\n解题思路 #   给出一个数组，要求求出这个数组所有的子数组中，每个集合内所有数字取 | 运算以后，不同结果的种类数。 这道题可以这样考虑，第一步，先考虑所有的子数组如何得到，以 [001, 011, 100, 110, 101] 为例，所有的子数组集合如下：  [001] [001 011] [011] [001 011 100] [011 100] [100] [001 011 100 110] [011 100 110] [100 110] [110] [001 011 100 110 101] [011 100 110 101] [100 110 101] [110 101] [101] 可以发现，从左往右遍历原数组，每次新来的一个元素，依次加入到之前已经生成过的集合中，再以自己为单独集合。这样就可以生成原数组的所有子集。\n 第二步，将每一行的子集内的所有元素都进行 | 运算，得到：  001 011 011 111 111 100 111 111 110 110 111 111 111 111 101  第三步，去重：  001 011 111 100 111 110 111 101 由于二进制位不超过 32 位，所以这里每一行最多不会超过 32 个数。所以最终时间复杂度不会超过 O(32 N)，即 O(K * N)。最后将这每一行的数字都放入最终的 map 中去重即可。\n代码 #  package leetcode // 解法一 array 优化版 func subarrayBitwiseORs(A []int) int { res, cur, isInMap := []int{}, []int{}, make(map[int]bool) cur = append(cur, 0) for _, v := range A { var cur2 []int for _, vv := range cur { tmp := v | vv if !inSlice(cur2, tmp) { cur2 = append(cur2, tmp) } } if !inSlice(cur2, v) { cur2 = append(cur2, v) } cur = cur2 for _, vv := range cur { if _, ok := isInMap[vv]; !ok { isInMap[vv] = true res = append(res, vv) } } } return len(res) } func inSlice(A []int, T int) bool { for _, v := range A { if v == T { return true } } return false } // 解法二 map 版 func subarrayBitwiseORs1(A []int) int { res, t := map[int]bool{}, map[int]bool{} for _, num := range A { r := map[int]bool{} r[num] = true for n := range t { r[(num | n)] = true } t = r for n := range t { res[n] = true } } return len(res) } "});index.add({'id':406,'href':'/leetcode-java/04_Leetcode/0901.Online-Stock-Span/','title':"0901. Online Stock Span",'section':"第四章",'content':"901. Online Stock Span #  题目 #  Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock\u0026rsquo;s price for the current day.\nThe span of the stock\u0026rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today\u0026rsquo;s price.\nFor example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].\nExample 1:\n Input: [\u0026quot;StockSpanner\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. Note:\n Calls to StockSpanner.next(int price) will have 1 \u0026lt;= price \u0026lt;= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.  题目大意 #  编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n解题思路 #  这一题就是单调栈的题目。维护一个单调递增的下标。\n总结 #  单调栈类似的题\nNext Greater Element I Next Greater Element II Daily Temperatures Sum of Subarray Minimums Largest Rectangle in Histogram  代码 #  package leetcode import \u0026#34;fmt\u0026#34; // node pair type Node struct { Val int res int } // slice type StockSpanner struct { Item []Node } func Constructor901() StockSpanner { stockSpanner := StockSpanner{make([]Node, 0)} return stockSpanner } // need refactor later func (this *StockSpanner) Next(price int) int { res := 1 if len(this.Item) == 0 { this.Item = append(this.Item, Node{price, res}) return res } for len(this.Item) \u0026gt; 0 \u0026amp;\u0026amp; this.Item[len(this.Item)-1].Val \u0026lt;= price { res = res + this.Item[len(this.Item)-1].res this.Item = this.Item[:len(this.Item)-1] } this.Item = append(this.Item, Node{price, res}) fmt.Printf(\u0026#34;this.Item = %v\\n\u0026#34;, this.Item) return res } /** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ "});index.add({'id':407,'href':'/leetcode-java/04_Leetcode/0904.Fruit-Into-Baskets/','title':"0904. Fruit Into Baskets",'section':"第四章",'content':"904. Fruit Into Baskets #  题目 #  In a row of trees, the i-th tree produces fruit with type tree[i].\nYou start at any tree of your choice, then repeatedly perform the following steps:\n Add one piece of fruit from this tree to your baskets. If you cannot, stop. Move to the next tree to the right of the current tree. If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.\nYou have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.\nWhat is the total amount of fruit you can collect with this procedure?\nExample 1:\nInput: [1,2,1] Output: 3 Explanation: We can collect [1,2,1]. Example 2:\n Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1]. Example 3:\n Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2]. Example 4:\n Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits. Note:\n 1 \u0026lt;= tree.length \u0026lt;= 40000 0 \u0026lt;= tree[i] \u0026lt; tree.length  题目大意 #  这道题考察的是滑动窗口的问题。\n给出一个数组，数组里面的数字代表每个果树上水果的种类，1 代表一号水果，不同数字代表的水果不同。现在有 2 个篮子，每个篮子只能装一个种类的水果，这就意味着只能选 2 个不同的数字。摘水果只能从左往右摘，直到右边没有水果可以摘就停下。问可以连续摘水果的最长区间段的长度。\n解题思路 #  简化一下题意，给出一段数字，要求找出包含 2 个不同数字的最大区间段长度。这个区间段内只能包含这 2 个不同数字，可以重复，但是不能包含其他数字。\n用典型的滑动窗口的处理方法处理即可。\n代码 #  package leetcode func totalFruit(tree []int) int { if len(tree) == 0 { return 0 } left, right, counter, res, freq := 0, 0, 1, 1, map[int]int{} freq[tree[0]]++ for left \u0026lt; len(tree) { if right+1 \u0026lt; len(tree) \u0026amp;\u0026amp; ((counter \u0026gt; 0 \u0026amp;\u0026amp; tree[right+1] != tree[left]) || (tree[right+1] == tree[left] || freq[tree[right+1]] \u0026gt; 0)) { if counter \u0026gt; 0 \u0026amp;\u0026amp; tree[right+1] != tree[left] { counter-- } right++ freq[tree[right]]++ } else { if counter == 0 || (counter \u0026gt; 0 \u0026amp;\u0026amp; right == len(tree)-1) { res = max(res, right-left+1) } freq[tree[left]]-- if freq[tree[left]] == 0 { counter++ } left++ } } return res } "});index.add({'id':408,'href':'/leetcode-java/04_Leetcode/0907.Sum-of-Subarray-Minimums/','title':"0907. Sum of Subarray Minimums",'section':"第四章",'content':"907. Sum of Subarray Minimums #  题目 #  Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.\nSince the answer may be large, return the answer modulo 10^9 + 7.\nExample 1:\n Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. Note:\n 1 \u0026lt;= A.length \u0026lt;= 30000 1 \u0026lt;= A[i] \u0026lt;= 30000  题目大意 #  给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。\n由于答案可能很大，因此返回答案模 10^9 + 7。\n解题思路 #    首先想到的是暴力解法，用两层循环，分别枚举每个连续的子区间，区间内用一个元素记录区间内最小值。每当区间起点发生变化的时候，最终结果都加上上次遍历区间找出的最小值。当整个数组都扫完一遍以后，最终结果模上 10^9+7。\n  上面暴力解法时间复杂度特别大，因为某个区间的最小值可能是很多区间的最小值，但是我们暴力枚举所有区间，导致要遍历的区间特别多。优化点就在如何减少遍历的区间。第二种思路是用 2 个单调栈。想得到思路是 res = sum(A[i] * f(i))，其中 f(i) 是子区间的数，A[i] 是这个子区间内的最小值。为了得到 f(i) 我们需要找到 left[i] 和 right[i]，left[i] 是 A[i] 左边严格大于 A[i](\u0026gt; 关系)的区间长度。right[i] 是 A[i] 右边非严格大于(\u0026gt;= 关系)的区间长度。left[i] + 1 等于以 A[i] 结尾的子数组数目，A[i] 是唯一的最小值；right[i] + 1 等于以 A[i] 开始的子数组数目，A[i] 是第一个最小值。于是有 f(i) = (left[i] + 1) * (right[i] + 1)。例如对于 [3,1,4,2,5,3,3,1] 中的“2”，我们找到的串就为[4,2,5,3,3]，2 左边有 1 个数比 2 大且相邻，2 右边有 3 个数比 2 大且相邻，所以 2 作为最小值的串有 2 * 4 = 8 种。用排列组合的思维也能分析出来，2 的左边可以拿 0，1，…… m 个，总共 (m + 1) 种，同理右边可以拿 0，1，…… n 个，总共 (n + 1) 种，所以总共 (m + 1)(n + 1)种。只要计算出了 f(i)，这个题目就好办了。以 [3,1,2,4] 为例，left[i] + 1 = [1,2,1,1]，right[i] + 1 = [1,3,2,1]，对应 i 位的乘积是 f[i] = [1 * 1，2 * 3，1 * 2，1 * 1] = [1，6，2，1]，最终要求的最小值的总和 res = 3 * 1 + 1 * 6 + 2 * 2 + 4 * 1 = 17。\n  看到这种 mod1e9+7 的题目，首先要想到的就是dp。最终的优化解即是利用 DP + 单调栈。单调栈维护数组中的值逐渐递增的对应下标序列。定义 dp[i + 1] 代表以 A[i] 结尾的子区间内最小值的总和。状态转移方程是 dp[i + 1] = dp[prev + 1] + (i - prev) * A[i]，其中 prev 是比 A[i] 小的前一个数，由于我们维护了一个单调栈，所以 prev 就是栈顶元素。(i - prev) * A[i] 代表在还没有出现 prev 之前，这些区间内都是 A[i] 最小，那么这些区间有 i - prev 个，所以最小值总和应该是 (i - prev) * A[i]。再加上 dp[prev + 1] 就是 dp[i + 1] 的最小值总和了。以 [3, 1, 2, 4, 3] 为例，当 i = 4, 所有以 A[4] 为结尾的子区间有:\n [3] [4, 3] [2, 4, 3] [1, 2, 4, 3] [3, 1, 2, 4, 3]  在这种情况下, stack.peek() = 2, A[2] = 2。前两个子区间 [3] and [4, 3], 最小值的总和 = (i - stack.peek()) * A[i] = 6。后 3 个子区间是 [2, 4, 3], [1, 2, 4, 3] 和 [3, 1, 2, 4, 3], 它们都包含 2，2 是比 3 小的前一个数，所以 dp[i + 1] = dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = dp[2 + 1]。即需要求 i = 2 的时候 dp[i + 1] 的值。继续递推，比 2 小的前一个值是 1，A[1] = 1。dp[3] = dp[1 + 1] + (2 - 1) * A[2]= dp[2] + 2。dp[2] = dp[1 + 1]，当 i = 1 的时候，prev = -1，即没有人比 A[1] 更小了，所以 dp[2] = dp[1 + 1] = dp[-1 + 1] + (1 - (-1)) * A[1] = 0 + 2 * 1 = 2。迭代回去，dp[3] = dp[2] + 2 = 2 + 2 = 4。dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = 4。所以 dp[i + 1] = 4 + 6 = 10。\n  与这一题相似的解题思路的题目有第 828 题，第 891 题。\n  代码 #  package leetcode // 解法一 最快的解是 DP + 单调栈 func sumSubarrayMins(A []int) int { stack, dp, res, mod := []int{}, make([]int, len(A)+1), 0, 1000000007 stack = append(stack, -1) for i := 0; i \u0026lt; len(A); i++ { for stack[len(stack)-1] != -1 \u0026amp;\u0026amp; A[i] \u0026lt;= A[stack[len(stack)-1]] { stack = stack[:len(stack)-1] } dp[i+1] = (dp[stack[len(stack)-1]+1] + (i-stack[len(stack)-1])*A[i]) % mod stack = append(stack, i) res += dp[i+1] res %= mod } return res } type pair struct { val int count int } // 解法二 用两个单调栈 func sumSubarrayMins1(A []int) int { res, n, mod := 0, len(A), 1000000007 lefts, rights, leftStack, rightStack := make([]int, n), make([]int, n), []*pair{}, []*pair{} for i := 0; i \u0026lt; n; i++ { count := 1 for len(leftStack) != 0 \u0026amp;\u0026amp; leftStack[len(leftStack)-1].val \u0026gt; A[i] { count += leftStack[len(leftStack)-1].count leftStack = leftStack[:len(leftStack)-1] } leftStack = append(leftStack, \u0026amp;pair{val: A[i], count: count}) lefts[i] = count } for i := n - 1; i \u0026gt;= 0; i-- { count := 1 for len(rightStack) != 0 \u0026amp;\u0026amp; rightStack[len(rightStack)-1].val \u0026gt;= A[i] { count += rightStack[len(rightStack)-1].count rightStack = rightStack[:len(rightStack)-1] } rightStack = append(rightStack, \u0026amp;pair{val: A[i], count: count}) rights[i] = count } for i := 0; i \u0026lt; n; i++ { res = (res + A[i]*lefts[i]*rights[i]) % mod } return res } // 解法三 暴力解法，中间很多重复判断子数组的情况 func sumSubarrayMins2(A []int) int { res, mod := 0, 1000000007 for i := 0; i \u0026lt; len(A); i++ { stack := []int{} stack = append(stack, A[i]) for j := i; j \u0026lt; len(A); j++ { if stack[len(stack)-1] \u0026gt;= A[j] { stack = stack[:len(stack)-1] stack = append(stack, A[j]) } res += stack[len(stack)-1] } } return res % mod } "});index.add({'id':409,'href':'/leetcode-java/04_Leetcode/0911.Online-Election/','title':"0911. Online Election",'section':"第四章",'content':"911. Online Election #  题目 #  In an election, the i-th vote was cast for persons[i] at time times[i].\nNow, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.\nVotes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nExample 1:\nInput: [\u0026quot;TopVotedCandidate\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;q\u0026quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation: At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.  Note:\n 1 \u0026lt;= persons.length = times.length \u0026lt;= 5000 0 \u0026lt;= persons[i] \u0026lt;= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t \u0026gt;= times[0].  题目大意 #  在选举中，第 i 张票是在时间为 times[i] 时投给 persons[i] 的。\n现在，我们想要实现下面的查询函数： TopVotedCandidate.q(int t) 将返回在 t 时刻主导选举的候选人的编号。\n在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。\n提示：\n 1 \u0026lt;= persons.length = times.length \u0026lt;= 5000 0 \u0026lt;= persons[i] \u0026lt;= persons.length times 是严格递增的数组，所有元素都在 [0, 10^9] 范围中。 每个测试用例最多调用 10000 次 TopVotedCandidate.q。 TopVotedCandidate.q(int t) 被调用时总是满足 t \u0026gt;= times[0]。  解题思路 #   给出一个 2 个数组，分别代表第 i 人在第 t 时刻获得的票数。需要实现一个查询功能的函数，查询在任意 t 时刻，输出谁的选票领先。 persons[] 数组里面装的是获得选票人的编号，times[] 数组里面对应的是每个选票的时刻。times[] 数组默认是有序的，从小到大排列。先计算出每个时刻哪个人选票领先，放在一个数组中，实现查询函数的时候，只需要先对 times[] 数组二分搜索，找到比查询时间 t 小的最大时刻 i，再在选票领先的数组里面输出对应时刻领先的人的编号即可。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) // TopVotedCandidate define type TopVotedCandidate struct { persons []int times []int } // Constructor911 define func Constructor911(persons []int, times []int) TopVotedCandidate { leaders, votes := make([]int, len(persons)), make([]int, len(persons)) leader := persons[0] for i := 0; i \u0026lt; len(persons); i++ { p := persons[i] votes[p]++ if votes[p] \u0026gt;= votes[leader] { leader = p } leaders[i] = leader } return TopVotedCandidate{persons: leaders, times: times} } // Q define func (tvc *TopVotedCandidate) Q(t int) int { i := sort.Search(len(tvc.times), func(p int) bool { return tvc.times[p] \u0026gt; t }) return tvc.persons[i-1] } /** * Your TopVotedCandidate object will be instantiated and called as such: * obj := Constructor(persons, times); * param_1 := obj.Q(t); */ "});index.add({'id':410,'href':'/leetcode-java/04_Leetcode/0914.X-of-a-Kind-in-a-Deck-of-Cards/','title':"0914. X of a Kind in a Deck of Cards",'section':"第四章",'content':"914. X of a Kind in a Deck of Cards #  题目 #  In a deck of cards, each card has an integer written on it.\nReturn true if and only if you can choose X \u0026gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:\n Each group has exactly X cards. All the cards in each group have the same integer.  Example 1:\nInput: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2:\nInput: deck = [1,1,1,2,2,2,3,3] Output: false´ Explanation: No possible partition. Example 3:\nInput: deck = [1] Output: false Explanation: No possible partition. Example 4:\nInput: deck = [1,1] Output: true Explanation: Possible partition [1,1]. Example 5:\nInput: deck = [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]. Constraints:\n 1 \u0026lt;= deck.length \u0026lt;= 10^4 0 \u0026lt;= deck[i] \u0026lt; 10^4  题目大意 #  给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。  仅当你可选的 X \u0026gt;= 2 时返回 true。\n解题思路 #   给定一副牌，要求选出数字 X，使得每组都有 X 张牌，每组牌的数字都相同。当 X ≥ 2 的时候，输出 true。 通过分析题目，我们可以知道，只有当 X 为所有 count 的约数，即所有 count 的最大公约数的约数时，才存在可能的分组。因此我们只要求出所有 count 的最大公约数 g，判断 g 是否大于等于 2 即可，如果大于等于 2，则满足条件，否则不满足。 时间复杂度：O(NlogC)，其中 N 是卡牌的个数，C 是数组 deck 中数的范围，在本题中 C 的值为 10000。求两个数最大公约数的复杂度是 O(logC)，需要求最多 N - 1 次。空间复杂度：O(N + C) 或 O(N)。  代码 #  package leetcode func hasGroupsSizeX(deck []int) bool { if len(deck) \u0026lt; 2 { return false } m, g := map[int]int{}, -1 for _, d := range deck { m[d]++ } for _, v := range m { if g == -1 { g = v } else { g = gcd(g, v) } } return g \u0026gt;= 2 } func gcd(a, b int) int { if a == 0 { return b } return gcd(b%a, a) } "});index.add({'id':411,'href':'/leetcode-java/04_Leetcode/0918.Maximum-Sum-Circular-Subarray/','title':"0918. Maximum Sum Circular Subarray",'section':"第四章",'content':"918. Maximum Sum Circular Subarray #  题目 #  Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.\nHere, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 \u0026lt;= i \u0026lt; A.length, and C[i+A.length] = C[i] when i \u0026gt;= 0.)\nAlso, a subarray may only include each element of the fixed buffer A at most once. (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i \u0026lt;= k1, k2 \u0026lt;= j with k1 % A.length = k2 % A.length.)\nExample 1:\nInput: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3  Example 2:\nInput: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10  Example 3:\nInput: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4  Example 4:\nInput: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5:\nInput: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1  Note:\n -30000 \u0026lt;= A[i] \u0026lt;= 30000 1 \u0026lt;= A.length \u0026lt;= 30000  题目大意 #  给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 \u0026lt;= i \u0026lt; A.length 时 C[i] = A[i]，而当 i \u0026gt;= 0 时 C[i+A.length] = C[i]）\n此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], \u0026hellip;, C[j]，不存在 i \u0026lt;= k1, k2 \u0026lt;= j 其中 k1 % A.length = k2 % A.length）\n提示：\n -30000 \u0026lt;= A[i] \u0026lt;= 30000 1 \u0026lt;= A.length \u0026lt;= 30000  解题思路 #   给出一个环形数组，要求出这个环形数组中的连续子数组的最大和。 拿到这题最先想到的思路是把这个数组再拼接一个，在这两个数组中查找连续子数组的最大和。这种做法是错误的，例如在 [5,-3,5] 这个数组中会得出 7 的结果，但是实际结果是 10 。那么这题怎么做呢？仔细分析可以得到，环形数组的最大连续子段和有两种情况，第一种情况是这个连续子段就出现在数组中， 不存在循环衔接的情况。针对这种情况就比较简单，用 kadane 算法(也是动态规划的思想)，O(n) 的时间复杂度就可以求出结果。第二种情况是这个连续的子段出现在跨数组的情况，即会出现首尾相连的情况。要想找到这样一个连续子段，可以反向考虑。想找到跨段的连续子段，那么这个数组剩下的这一段就是不跨段的连续子段。想要跨段的子段和最大，那么剩下的这段连续子段和最小。如果能找到这个数组的每个元素取相反数组成的数组中的最大连续子段和，那么反过来就能找到原数组的连续子段和最小。举个例子：[1，2，-3，-4，5] ，取它的每个元素的相反数 [-1，-2，3，4，-5]，构造的数组中最大连续子段和是 3 + 4 = 7，由于取了相反数，所以可以得到原数组中最小连续子段和是 -7 。所以跨段的最大连续子段和就是剩下的那段 [1,2,5]。 还有一些边界的情况，例如，[1，2，-2，-3，5，5，-4，6] 和 [1，2，-2，-3，5，5，-4，8]，所以还需要比较一下情况一和情况二的值，它们两者最大值才是最终环形数组的连续子数组的最大和。  代码 #  package leetcode import \u0026#34;math\u0026#34; func maxSubarraySumCircular(A []int) int { n, sum := len(A), 0 for _, v := range A { sum += v } kad := kadane(A) for i := 0; i \u0026lt; n; i++ { A[i] = -A[i] } negativeMax := kadane(A) if sum+negativeMax \u0026lt;= 0 { return kad } return max(kad, sum+negativeMax) } func kadane(a []int) int { n, MaxEndingHere, maxSoFar := len(a), a[0], math.MinInt32 for i := 1; i \u0026lt; n; i++ { MaxEndingHere = max(a[i], MaxEndingHere+a[i]) maxSoFar = max(MaxEndingHere, maxSoFar) } return maxSoFar } "});index.add({'id':412,'href':'/leetcode-java/04_Leetcode/0920.Number-of-Music-Playlists/','title':"0920. Number of Music Playlists",'section':"第四章",'content':"920. Number of Music Playlists #  题目 #  Your music player contains N different songs and she wants to listen to L ****(not necessarily different) songs during your trip. You create a playlist so that:\n Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists. As the answer can be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].  Example 2:\nInput: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]  Example 3:\nInput: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]  Note:\n 0 \u0026lt;= K \u0026lt; N \u0026lt;= L \u0026lt;= 100  题目大意 #  你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：\n 每首歌至少播放一次。 一首歌只有在其他 K 首歌播放完之后才能再次播放。  返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。\n提示：\n 0 \u0026lt;= K \u0026lt; N \u0026lt;= L \u0026lt;= 100  解题思路 #   简化抽象一下题意，给 N 个数，要求从这 N 个数里面组成一个长度为 L 的序列，并且相同元素的间隔不能小于 K 个数。问总共有多少组组成方法。 一拿到题，会觉得这一题是三维 DP，因为存在 3 个变量，但是实际考虑一下，可以降一维。我们先不考虑 K 的限制，只考虑 N 和 L。定义 dp[i][j] 代表播放列表里面有 i 首歌，其中包含 j 首不同的歌曲，那么题目要求的最终解存在 dp[L][N] 中。考虑 dp[i][j] 的递归公式，音乐列表当前需要组成 i 首歌，有 2 种方式可以得到，由 i - 1 首歌的列表中添加一首列表中不存在的新歌曲，或者由 i - 1 首歌的列表中添加一首列表中已经存在的歌曲。即，dp[i][j] 可以由 dp[i - 1][j - 1] 得到，也可以由 dp[i - 1][j] 得到。如果是第一种情况，添加一首新歌，那么新歌有 N - ( j - 1 ) 首，如果是第二种情况，添加一首已经存在的歌，歌有 j 首，所以状态转移方程是 dp[i][j] = dp[i - 1][j - 1] * ( N - ( j - 1 ) ) + dp[i - 1][j] * j 。但是这个方程是在不考虑 K 的限制条件下得到的，距离满足题意还差一步。接下来需要考虑加入 K 这个限制条件以后，状态转移方程该如何推导。 如果是添加一首新歌，是不受 K 限制的，所以 dp[i - 1][j - 1] * ( N - ( j - 1 ) ) 这里不需要变化。如果是添加一首存在的歌曲，这个时候就会受到 K 的限制了。如果当前播放列表里面的歌曲有 j 首，并且 j \u0026gt; K，那么选择歌曲只能从 j - K 里面选，因为不能选择 j - 1 到 j - k 的这些歌，选择了就不满足重复的歌之间间隔不能小于 K 的限制条件了。那 j ≤ K 呢？这个时候一首歌都不能选，因为歌曲数都没有超过 K，当然不能再选择重复的歌曲。(选择了就再次不满足重复的歌之间间隔不能小于 K 的限制条件了)。经过上述分析，可以得到最终的状态转移方程：    上面的式子可以合并简化成下面这个式子：dp[i][j] = dp[i - 1][j - 1]*(N - (j - 1)) + dp[i-1][j]*max(j-K, 0)，递归初始值 dp[0][0] = 1。  代码 #  package leetcode func numMusicPlaylists(N int, L int, K int) int { dp, mod := make([][]int, L+1), 1000000007 for i := 0; i \u0026lt; L+1; i++ { dp[i] = make([]int, N+1) } dp[0][0] = 1 for i := 1; i \u0026lt;= L; i++ { for j := 1; j \u0026lt;= N; j++ { dp[i][j] = (dp[i-1][j-1] * (N - (j - 1))) % mod if j \u0026gt; K { dp[i][j] = (dp[i][j] + (dp[i-1][j]*(j-K))%mod) % mod } } } return dp[L][N] } "});index.add({'id':413,'href':'/leetcode-java/04_Leetcode/0921.Minimum-Add-to-Make-Parentheses-Valid/','title':"0921. Minimum Add to Make Parentheses Valid",'section':"第四章",'content':"921. Minimum Add to Make Parentheses Valid #  题目 #  Given a string S of \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo; parentheses, we add the minimum number of parentheses ( \u0026lsquo;(\u0026rsquo; or \u0026lsquo;)\u0026rsquo;, and in any positions ) so that the resulting parentheses string is valid.\nFormally, a parentheses string is valid if and only if:\n It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.  Example 1:\n Input: \u0026quot;())\u0026quot; Output: 1 Example 2:\n Input: \u0026quot;(((\u0026quot; Output: 3 Example 3:\n Input: \u0026quot;()\u0026quot; Output: 0 Example 4:\n Input: \u0026quot;()))((\u0026quot; Output: 4 Note:\n S.length \u0026lt;= 1000 S only consists of \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo; characters.  题目大意 #  给一个括号的字符串，如果能在这个括号字符串中的任意位置添加括号，问能使得这串字符串都能完美匹配的最少添加数是多少。\n解题思路 #  这题也是栈的题目，利用栈进行括号匹配。最后栈里剩下几个括号，就是最少需要添加的数目。\n代码 #  package leetcode func minAddToMakeValid(S string) int { if len(S) == 0 { return 0 } stack := make([]rune, 0) for _, v := range S { if v == \u0026#39;(\u0026#39; { stack = append(stack, v) } else if (v == \u0026#39;)\u0026#39;) \u0026amp;\u0026amp; len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39; { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } return len(stack) } "});index.add({'id':414,'href':'/leetcode-java/04_Leetcode/0922.Sort-Array-By-Parity-II/','title':"0922. Sort Array by Parity I I",'section':"第四章",'content':"922. Sort Array By Parity II #  题目 #  Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.\nSort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.\nYou may return any answer array that satisfies this condition.\nExample 1:\n Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Note:\n 2 \u0026lt;= A.length \u0026lt;= 20000 A.length % 2 == 0 0 \u0026lt;= A[i] \u0026lt;= 1000  题目大意 #  要求数组中奇数下标位置上放奇数，偶数下标位置上放偶数。\n解题思路 #  这题比较简单，用两个下标控制奇数，偶数放置在哪个下标即可。奇数奇数之间，偶数偶数之间的顺序可以是无序的。\n代码 #  package leetcode func sortArrayByParityII(A []int) []int { if len(A) == 0 || len(A)%2 != 0 { return []int{} } res := make([]int, len(A)) oddIndex := 1 evenIndex := 0 for i := 0; i \u0026lt; len(A); i++ { if A[i]%2 == 0 { res[evenIndex] = A[i] evenIndex += 2 } else { res[oddIndex] = A[i] oddIndex += 2 } } return res } "});index.add({'id':415,'href':'/leetcode-java/04_Leetcode/0923.3Sum-With-Multiplicity/','title':"0923.3 Sum With Multiplicity",'section':"第四章",'content':"923. 3Sum With Multiplicity #  题目 #  Given an integer array A, and an integer target, return the number of tuples i, j, k such that i \u0026lt; j \u0026lt; k and A[i] + A[j] + A[k] == target.\nAs the answer can be very large, return it modulo 10^9 + 7.\nExample 1:\n Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times. Example 2:\n Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation: A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways. Note:\n 3 \u0026lt;= A.length \u0026lt;= 3000 0 \u0026lt;= A[i] \u0026lt;= 100 0 \u0026lt;= target \u0026lt;= 300  题目大意 #  这道题是第 15 题的升级版。给出一个数组，要求找到 3 个数相加的和等于 target 的解组合的个数，并且要求 i \u0026lt; j \u0026lt; k。解的组合个数不需要去重，相同数值不同下标算不同解(这里也是和第 15 题的区别)\n解题思路 #  这一题大体解法和第 15 题一样的，只不过算所有解组合的时候需要一点排列组合的知识，如果取 3 个一样的数，需要计算 C n 3，去 2 个相同的数字的时候，计算 C n 2，取一个数字就正常计算。最后所有解的个数都加起来就可以了。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func threeSumMulti(A []int, target int) int { mod := 1000000007 counter := map[int]int{} for _, value := range A { counter[value]++ } uniqNums := []int{} for key := range counter { uniqNums = append(uniqNums, key) } sort.Ints(uniqNums) res := 0 for i := 0; i \u0026lt; len(uniqNums); i++ { ni := counter[uniqNums[i]] if (uniqNums[i]*3 == target) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt;= 3 { res += ni * (ni - 1) * (ni - 2) / 6 } for j := i + 1; j \u0026lt; len(uniqNums); j++ { nj := counter[uniqNums[j]] if (uniqNums[i]*2+uniqNums[j] == target) \u0026amp;\u0026amp; counter[uniqNums[i]] \u0026gt; 1 { res += ni * (ni - 1) / 2 * nj } if (uniqNums[j]*2+uniqNums[i] == target) \u0026amp;\u0026amp; counter[uniqNums[j]] \u0026gt; 1 { res += nj * (nj - 1) / 2 * ni } c := target - uniqNums[i] - uniqNums[j] if c \u0026gt; uniqNums[j] \u0026amp;\u0026amp; counter[c] \u0026gt; 0 { res += ni * nj * counter[c] } } } return res % mod } "});index.add({'id':416,'href':'/leetcode-java/04_Leetcode/0924.Minimize-Malware-Spread/','title':"0924. Minimize Malware Spread",'section':"第四章",'content':"924. Minimize Malware Spread #  题目 #  In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will remove one node from the initial list. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0  Example 2:\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0  Example 3:\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1  Note:\n 1 \u0026lt; graph.length = graph[0].length \u0026lt;= 300 0 \u0026lt;= graph[i][j] == graph[j][i] \u0026lt;= 1 graph[i][i] = 1 1 \u0026lt;= initial.length \u0026lt; graph.length 0 \u0026lt;= initial[i] \u0026lt; graph.length  题目大意 #  在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。\n提示：\n 1 \u0026lt; graph.length = graph[0].length \u0026lt;= 300 0 \u0026lt;= graph[i][j] == graph[j][i] \u0026lt;= 1 graph[i][i] = 1 1 \u0026lt;= initial.length \u0026lt; graph.length 0 \u0026lt;= initial[i] \u0026lt; graph.length  解题思路 #   给出一个节点之间的关系图，如果两个节点是连通的，那么病毒软件就会感染到连通的所有节点。现在如果想移除一个病毒节点，能最大减少感染，请问移除哪个节点？如果多个节点都能减少感染量，优先移除序号偏小的那个节点。 这一题一看就是考察的并查集。利用节点的连通关系，把题目中给的所有节点都 union() 起来，然后依次统计每个集合内有多少个点。最后扫描一次 initial 数组，选出这个数组中节点小的并且所在集合节点多，这个节点就是最终答案。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func minMalwareSpread(graph [][]int, initial []int) int { if len(initial) == 0 { return 0 } uf, minIndex, count, countMap := template.UnionFind{}, 0, math.MinInt64, map[int]int{} uf.Init(len(graph)) for i := range graph { for j := range graph[i] { if i == j { break } if graph[i][j] == 1 { uf.Union(i, j) } } } for i := 0; i \u0026lt; len(graph); i++ { countMap[uf.Find(i)]++ } for _, v := range initial { tmp := countMap[uf.Find(v)] if count == tmp \u0026amp;\u0026amp; minIndex \u0026gt; v { minIndex = v } if count \u0026lt; tmp { minIndex = v count = tmp } } return minIndex } "});index.add({'id':417,'href':'/leetcode-java/04_Leetcode/0925.Long-Pressed-Name/','title':"0925. Long Pressed Name",'section':"第四章",'content':"925. Long Pressed Name #  题目 #  Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\nExample 1:\n Input: name = \u0026quot;alex\u0026quot;, typed = \u0026quot;aaleex\u0026quot; Output: true Explanation: 'a' and 'e' in 'alex' were long pressed. Example 2:\n Input: name = \u0026quot;saeed\u0026quot;, typed = \u0026quot;ssaaedd\u0026quot; Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output. Example 3:\n Input: name = \u0026quot;leelee\u0026quot;, typed = \u0026quot;lleeelee\u0026quot; Output: true Example 4:\n Input: name = \u0026quot;laiden\u0026quot;, typed = \u0026quot;laiden\u0026quot; Output: true Explanation: It's not necessary to long press any character. Note:\n name.length \u0026lt;= 1000 typed.length \u0026lt;= 1000 The characters of name and typed are lowercase letters.  题目大意 #  给定 2 个字符串，后者的字符串中包含前者的字符串。比如在打字的过程中，某个字符会多按了几下。判断后者字符串是不是比前者字符串存在这样的“长按”键盘的情况。\n解题思路 #   这一题也可以借助滑动窗口的思想。2 个字符串一起比较，如果遇到有相同的字符串，窗口继续往后滑动。直到遇到了第一个不同的字符，如果遇到两个字符串不相等的情况，可以直接返回 false。具体实现见代码。 这一题的测试用例修改过一次，需要注意我这里写的第二组测试用例，当 name 结束以后，如果 typed 还有多余的不同的字符，这种情况要输出 false 的。具体见 test 文件里面的第二组，第三组，第四组测试用例。  代码 #  package leetcode func isLongPressedName(name string, typed string) bool { if len(name) == 0 \u0026amp;\u0026amp; len(typed) == 0 { return true } if (len(name) == 0 \u0026amp;\u0026amp; len(typed) != 0) || (len(name) != 0 \u0026amp;\u0026amp; len(typed) == 0) { return false } i, j := 0, 0 for i \u0026lt; len(name) \u0026amp;\u0026amp; j \u0026lt; len(typed) { if name[i] != typed[j] { return false } for i \u0026lt; len(name) \u0026amp;\u0026amp; j \u0026lt; len(typed) \u0026amp;\u0026amp; name[i] == typed[j] { i++ j++ } for j \u0026lt; len(typed) \u0026amp;\u0026amp; typed[j] == typed[j-1] { j++ } } return i == len(name) \u0026amp;\u0026amp; j == len(typed) } "});index.add({'id':418,'href':'/leetcode-java/04_Leetcode/0927.Three-Equal-Parts/','title':"0927. Three Equal Parts",'section':"第四章",'content':"927. Three Equal Parts #  题目 #  Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i+1 \u0026lt; j, such that:\n A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\nExample 1:\nInput: [1,0,1,0,1] Output: [0,3]  Example 2:\nInput: [1,1,0,1,1] Output: [-1,-1]  Note:\n 3 \u0026lt;= A.length \u0026lt;= 30000 A[i] == 0 or A[i] == 1  题目大意 #  给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。如果可以做到，请返回任何 [i, j]，其中 i+1 \u0026lt; j，这样一来：\n A[0], A[1], \u0026hellip;, A[i] 组成第一部分； A[i+1], A[i+2], \u0026hellip;, A[j-1] 作为第二部分； A[j], A[j+1], \u0026hellip;, A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。  如果无法做到，就返回 [-1, -1]。\n注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。\n提示：\n 3 \u0026lt;= A.length \u0026lt;= 30000 A[i] == 0 或 A[i] == 1  解题思路 #   给出一个数组，数组里面只包含 0 和 1，要求找到 2 个分割点，使得分成的 3 个子数组的二进制是完全一样的。 这一题的解题思路不难，按照题意模拟即可。先统计 1 的个数 total，然后除以 3 就是每段 1 出现的个数。有一些特殊情况需要额外判断一下，例如没有 1 的情况，那么只能首尾分割。1 个个数不是 3 的倍数，也无法分割成满足题意。然后找到第一个 1 的下标，然后根据 total/3 找到 mid，第一个分割点。再往后移动，找到第二个分割点。找到这 3 个点以后，同步的移动这 3 个点，移动中判断这 3 个下标对应的数值是否相等，如果都相等，并且最后一个点能移动到末尾，就算找到了满足题意的解了。  代码 #  package leetcode func threeEqualParts(A []int) []int { n, ones, i, count := len(A), 0, 0, 0 for _, a := range A { ones += a } if ones == 0 { return []int{0, n - 1} } if ones%3 != 0 { return []int{-1, -1} } k := ones / 3 for i \u0026lt; n { if A[i] == 1 { break } i++ } start, j := i, i for j \u0026lt; n { count += A[j] if count == k+1 { break } j++ } mid := j j, count = 0, 0 for j \u0026lt; n { count += A[j] if count == 2*k+1 { break } j++ } end := j for end \u0026lt; n \u0026amp;\u0026amp; A[start] == A[mid] \u0026amp;\u0026amp; A[mid] == A[end] { start++ mid++ end++ } if end == n { return []int{start - 1, mid} } return []int{-1, -1} } "});index.add({'id':419,'href':'/leetcode-java/04_Leetcode/0928.Minimize-Malware-Spread-II/','title':"0928. Minimize Malware Spread I I",'section':"第四章",'content':"928. Minimize Malware Spread II #  题目 #  (This problem is the same as Minimize Malware Spread, with the differences bolded.)\nIn a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will remove one node from the initial list, completely removing it and any connections from this node to any other node. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0  Example 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1  Example 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1  Note:\n 1 \u0026lt; graph.length = graph[0].length \u0026lt;= 300 0 \u0026lt;= graph[i][j] == graph[j][i] \u0026lt;= 1 graph[i][i] = 1 1 \u0026lt;= initial.length \u0026lt; graph.length 0 \u0026lt;= initial[i] \u0026lt; graph.length  题目大意 #  (这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。\n提示：\n 1 \u0026lt; graph.length = graph[0].length \u0026lt;= 300 0 \u0026lt;= graph[i][j] == graph[j][i] \u0026lt;= 1 graph[i][i] = 1 1 \u0026lt;= initial.length \u0026lt; graph.length 0 \u0026lt;= initial[i] \u0026lt; graph.length  解题思路 #   这一题是第 924 题的加强版。给出一个节点之间的关系图，如果两个节点是连通的，那么病毒软件就会感染到连通的所有节点。现在如果想完全彻底移除一个病毒节点，能最大减少感染，请问移除哪个节点？如果多个节点都能减少感染量，优先移除序号偏小的那个节点。这一题的输入输出要求和第 924 题是完全一样的，区别在于第 924 题实际上是要求把一个病毒节点变成非病毒节点，而这道题是完全删除一个病毒节点以及它连接的所有边。 这一题考察的是并查集。当然用 DFS 也可以解答这一题。并查集的做法如下，首先先将所有的病毒节点去掉，然后将所有连通块合并成一个节点。因为一个连通集合中的节点，要么全部被感染，要么全部不被感染，所以可以把每个集合整体考虑。然后统计所有集合直接相邻的病毒节点的个数。对于一个集合来说：  如果直接相邻的病毒节点的个数为 0，则一定不会被感染，忽略这种情况； 如果直接相邻的病毒节点的个数为 1，则将该病毒节点删除后，整个连通块就可以避免被感染，这种情况是我们寻找的答案； 如果直接相邻的病毒节点的个数大于等于2，则不管删除哪个病毒节点，该连通块都仍会被感染，忽略这种情况；   所以只需在所有第二种连通块（直接相邻的病毒节点的个数为 1 的连通块）中，找出节点个数最多的连通块，与它相邻的病毒节点就是我们要删除的节点；如果有多个连通块节点个数相同，再找出与之对应的编号最小的病毒节点即可。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func minMalwareSpread2(graph [][]int, initial []int) int { if len(initial) == 0 { return 0 } uf, minIndex, count, countMap, malwareMap, infectMap := template.UnionFind{}, initial[0], math.MinInt64, map[int]int{}, map[int]int{}, map[int]map[int]int{} for _, v := range initial { malwareMap[v]++ } uf.Init(len(graph)) for i := range graph { for j := range graph[i] { if i == j { break } if graph[i][j] == 1 \u0026amp;\u0026amp; malwareMap[i] == 0 \u0026amp;\u0026amp; malwareMap[j] == 0 { uf.Union(i, j) } } } for i := 0; i \u0026lt; len(graph); i++ { countMap[uf.Find(i)]++ } // 记录每个集合和直接相邻病毒节点的个数 \tfor _, i := range initial { for j := 0; j \u0026lt; len(graph); j++ { if malwareMap[j] == 0 \u0026amp;\u0026amp; graph[i][j] == 1 { p := uf.Find(j) if _, ok := infectMap[p]; ok { infectMap[p][i] = i } else { tmp := map[int]int{} tmp[i] = i infectMap[p] = tmp } } } } // 选出病毒节点中序号最小的 \tfor _, v := range initial { minIndex = min(minIndex, v) } for i, v := range infectMap { // 找出只和一个病毒节点相连通的 \tif len(v) == 1 { tmp := countMap[uf.Find(i)] keys := []int{} for k := range v { keys = append(keys, k) } if count == tmp \u0026amp;\u0026amp; minIndex \u0026gt; keys[0] { minIndex = keys[0] } if count \u0026lt; tmp { minIndex = keys[0] count = tmp } } } return minIndex } "});index.add({'id':420,'href':'/leetcode-java/04_Leetcode/0930.Binary-Subarrays-With-Sum/','title':"0930. Binary Subarrays With Sum",'section':"第四章",'content':"930. Binary Subarrays With Sum #  题目 #  In an array A of 0s and 1s, how many non-empty subarrays have sum S?\nExample 1:\n Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Note:\n A.length \u0026lt;= 30000 0 \u0026lt;= S \u0026lt;= A.length A[i] is either 0 or 1.  题目大意 #  给定一个数组，数组里面的元素只有 0 和 1 两种。问这个数组有多少个和为 S 的子数组。\n解题思路 #  这道题也是滑动窗口的题目。不断的加入右边的值，直到总和等于 S。[i,j] 区间内的和可以等于 [0,j] 的和减去 [0,i-1] 的和。在 freq 中不断的记下能使得和为 sum 的组合方法数，例如 freq[1] = 2 ，代表和为 1 有两种组合方法，(可能是 1 和 1，0 或者 0，1，这道题只管组合总数，没要求输出具体的组合对)。这道题的做法就是不断的累加，如果遇到比 S 多的情况，多出来的值就在 freq 中查表，看多出来的值可能是由几种情况构成的。一旦和与 S 相等以后，之后比 S 多出来的情况会越来越多(因为在不断累积，总和只会越来越大)，不断的查 freq 表就可以了。\n代码 #  package leetcode import \u0026#34;fmt\u0026#34; func numSubarraysWithSum(A []int, S int) int { freq, sum, res := make([]int, len(A)+1), 0, 0 freq[0] = 1 for _, v := range A { t := sum + v - S if t \u0026gt;= 0 { // 总和有多余的，需要减去 t，除去的方法有 freq[t] 种 \tres += freq[t] } sum += v freq[sum]++ fmt.Printf(\u0026#34;freq = %v sum = %v res = %v t = %v\\n\u0026#34;, freq, sum, res, t) } return res } "});index.add({'id':421,'href':'/leetcode-java/04_Leetcode/0933.Number-of-Recent-Calls/','title':"0933. Number of Recent Calls",'section':"第四章",'content':"933. Number of Recent Calls #  题目 #  Write a class RecentCounter to count recent requests.\nIt has only one method: ping(int t), where t represents some time in milliseconds.\nReturn the number of pings that have been made from 3000 milliseconds ago until now.\nAny ping with time in [t - 3000, t] will count, including the current ping.\nIt is guaranteed that every call to ping uses a strictly larger value of t than before.\nExample 1:\nInput: inputs = [\u0026quot;RecentCounter\u0026quot;,\u0026quot;ping\u0026quot;,\u0026quot;ping\u0026quot;,\u0026quot;ping\u0026quot;,\u0026quot;ping\u0026quot;], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3] Note:\n Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 \u0026lt;= t \u0026lt;= 10^9.  题目大意 #  写一个 RecentCounter 类来计算最近的请求。它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。返回从 3000 毫秒前到现在的 ping 数。任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。保证每次对 ping 的调用都使用比之前更大的 t 值。 提示：\n 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 \u0026lt;= t \u0026lt;= 10^9。  解题思路 #   要求设计一个类，可以用 ping(t) 的方法，计算 [t-3000, t] 区间内的 ping 数。t 是毫秒。 这一题比较简单，ping() 方法用二分搜索即可。  代码 #  type RecentCounter struct { list []int } func Constructor933() RecentCounter { return RecentCounter{ list: []int{}, } } func (this *RecentCounter) Ping(t int) int { this.list = append(this.list, t) index := sort.Search(len(this.list), func(i int) bool { return this.list[i] \u0026gt;= t-3000 }) if index \u0026lt; 0 { index = -index - 1 } return len(this.list) - index } /** * Your RecentCounter object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Ping(t); */ "});index.add({'id':422,'href':'/leetcode-java/04_Leetcode/0942.DI-String-Match/','title':"0942. D I String Match",'section':"第四章",'content':"942. DI String Match #  题目 #  Given a string S that only contains \u0026ldquo;I\u0026rdquo; (increase) or \u0026ldquo;D\u0026rdquo; (decrease), let N = S.length.\nReturn any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:\n If S[i] == \u0026quot;I\u0026quot;, then A[i] \u0026lt; A[i+1] If S[i] == \u0026quot;D\u0026quot;, then A[i] \u0026gt; A[i+1]  Example 1:\nInput: \u0026quot;IDID\u0026quot; Output: [0,4,1,3,2]  Example 2:\nInput: \u0026quot;III\u0026quot; Output: [0,1,2,3]  Example 3:\nInput: \u0026quot;DDI\u0026quot; Output: [3,2,0,1]  Note:\n 1 \u0026lt;= S.length \u0026lt;= 10000 S only contains characters \u0026quot;I\u0026quot; or \u0026quot;D\u0026quot;.  题目大意 #  给定只含 \u0026ldquo;I\u0026rdquo;（增大）或 \u0026ldquo;D\u0026rdquo;（减小）的字符串 S ，令 N = S.length。返回 [0, 1, \u0026hellip;, N] 的任意排列 A 使得对于所有 i = 0, \u0026hellip;, N-1，都有：\n 如果 S[i] == \u0026ldquo;I\u0026rdquo;，那么 A[i] \u0026lt; A[i+1] 如果 S[i] == \u0026ldquo;D\u0026rdquo;，那么 A[i] \u0026gt; A[i+1]  解题思路 #   给出一个字符串，字符串中只有字符 \u0026quot;I\u0026quot; 和字符 \u0026quot;D\u0026quot;。字符 \u0026quot;I\u0026quot; 代表 A[i] \u0026lt; A[i+1]，字符 \u0026quot;D\u0026quot; 代表 A[i] \u0026gt; A[i+1] ，要求找到满足条件的任意组合。 这一题也是水题，取出字符串长度即是最大数的数值，然后按照题意一次排出最终数组即可。  代码 #  package leetcode func diStringMatch(S string) []int { result, maxNum, minNum, index := make([]int, len(S)+1), len(S), 0, 0 for _, ch := range S { if ch == \u0026#39;I\u0026#39; { result[index] = minNum minNum++ } else { result[index] = maxNum maxNum-- } index++ } result[index] = minNum return result } "});index.add({'id':423,'href':'/leetcode-java/04_Leetcode/0946.Validate-Stack-Sequences/','title':"0946. Validate Stack Sequences",'section':"第四章",'content':"946. Validate Stack Sequences #  题目 #  Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\nExample 1:\n Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -\u0026gt; 4, push(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1 Example 2:\n Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Note:\n 0 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 0 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 pushed is a permutation of popped. pushed and popped have distinct values.  题目大意 #  给 2 个数组，一个数组里面代表的是 push 的顺序，另一个数组里面代表的是 pop 的顺序。问按照这样的顺序操作以后，最终能否把栈清空？\n解题思路 #  这一题也是靠栈操作的题目，按照 push 数组的顺序先把压栈，然后再依次在 pop 里面找栈顶元素，找到了就 pop，直到遍历完 pop 数组，最终如果遍历完了 pop 数组，就代表清空了整个栈了。\n代码 #  package leetcode import \u0026#34;fmt\u0026#34; func validateStackSequences(pushed []int, popped []int) bool { stack, j, N := []int{}, 0, len(pushed) for _, x := range pushed { stack = append(stack, x) fmt.Printf(\u0026#34;stack = %v j = %v\\n\u0026#34;, stack, j) for len(stack) != 0 \u0026amp;\u0026amp; j \u0026lt; N \u0026amp;\u0026amp; stack[len(stack)-1] == popped[j] { stack = stack[0 : len(stack)-1] j++ } fmt.Printf(\u0026#34;*****stack = %v j = %v\\n\u0026#34;, stack, j) } return j == N } "});index.add({'id':424,'href':'/leetcode-java/04_Leetcode/0947.Most-Stones-Removed-with-Same-Row-or-Column/','title':"0947. Most Stones Removed With Same Row or Column",'section':"第四章",'content':"947. Most Stones Removed with Same Row or Column #  题目 #  On a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most one stone.\nNow, a move consists of removing a stone that shares a column or row with another stone on the grid.\nWhat is the largest possible number of moves we can make?\nExample 1:\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5  Example 2:\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3  Example 3:\nInput: stones = [[0,0]] Output: 0  Note:\n 1 \u0026lt;= stones.length \u0026lt;= 1000 0 \u0026lt;= stones[i][j] \u0026lt; 10000  题目大意 #  在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。我们最多能执行多少次 move 操作？\n提示：\n 1 \u0026lt;= stones.length \u0026lt;= 1000 0 \u0026lt;= stones[i][j] \u0026lt; 10000  解题思路 #   给出一个数组，数组中的元素是一系列的坐标点。现在可以移除一些坐标点，移除必须满足：移除的这个点，在相同的行或者列上有一个点。问最终可以移除多少个点。移除到最后必然有些点独占一行，那么这些点都不能被移除。 这一题的解题思路是并查集。把所有共行或者共列的点都 union() 起来。不同集合之间是不能相互移除的。反证法：如果能移除，代表存在共行或者共列的情况，那么肯定是同一个集合了，这样就不满足不同集合了。最终剩下的点就是集合的个数，每个集合只会留下一个点。所以移除的点就是点的总数减去集合的个数 len(stones) - uf.totalCount()。 如果暴力合并集合，时间复杂度也非常差，可以由优化的地方。再遍历所有点的过程中，可以把遍历过的行和列存起来。这里可以用 map 来记录，key 为行号，value 为上一次遍历过的点的序号。同样，列也可以用 map 存起来，key 为列号，value 为上一次遍历过的点的序号。经过这样的优化以后，时间复杂度会提高不少。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func removeStones(stones [][]int) int { if len(stones) \u0026lt;= 1 { return 0 } uf, rowMap, colMap := template.UnionFind{}, map[int]int{}, map[int]int{} uf.Init(len(stones)) for i := 0; i \u0026lt; len(stones); i++ { if _, ok := rowMap[stones[i][0]]; ok { uf.Union(rowMap[stones[i][0]], i) } else { rowMap[stones[i][0]] = i } if _, ok := colMap[stones[i][1]]; ok { uf.Union(colMap[stones[i][1]], i) } else { colMap[stones[i][1]] = i } } return len(stones) - uf.TotalCount() } "});index.add({'id':425,'href':'/leetcode-java/04_Leetcode/0949.Largest-Time-for-Given-Digits/','title':"0949. Largest Time for Given Digits",'section':"第四章",'content':"949. Largest Time for Given Digits #  题目 #  Given an array of 4 digits, return the largest 24 hour time that can be made.\nThe smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight.\nReturn the answer as a string of length 5. If no valid time can be made, return an empty string.\nExample 1:\nInput: [1,2,3,4] Output: \u0026quot;23:41\u0026quot; Example 2:\nInput: [5,5,5,5] Output: \u0026quot;\u0026quot; Note:\n A.length == 4 0 \u0026lt;= A[i] \u0026lt;= 9  题目大意 #  给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。\n解题思路 #   给出 4 个数字，要求返回一个字符串，代表由这 4 个数字能组成的最大 24 小时制的时间。 简单题，这一题直接暴力枚举就可以了。依次检查给出的 4 个数字每个排列组合是否是时间合法的。例如检查 10 * A[i] + A[j] 是不是小于 24， 10 * A[k] + A[l] 是不是小于 60。如果合法且比目前存在的最大时间更大，就更新这个最大时间。  代码 #  package leetcode import \u0026#34;fmt\u0026#34; func largestTimeFromDigits(A []int) string { flag, res := false, 0 for i := 0; i \u0026lt; 4; i++ { for j := 0; j \u0026lt; 4; j++ { if i == j { continue } for k := 0; k \u0026lt; 4; k++ { if i == k || j == k { continue } l := 6 - i - j - k hour := A[i]*10 + A[j] min := A[k]*10 + A[l] if hour \u0026lt; 24 \u0026amp;\u0026amp; min \u0026lt; 60 { if hour*60+min \u0026gt;= res { res = hour*60 + min flag = true } } } } } if flag { return fmt.Sprintf(\u0026#34;%02d:%02d\u0026#34;, res/60, res%60) } else { return \u0026#34;\u0026#34; } } "});index.add({'id':426,'href':'/leetcode-java/04_Leetcode/0952.Largest-Component-Size-by-Common-Factor/','title':"0952. Largest Component Size by Common Factor",'section':"第四章",'content':"952. Largest Component Size by Common Factor #  题目 #  Given a non-empty array of unique positive integers A, consider the following graph:\n There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i]and A[j] share a common factor greater than 1.  Return the size of the largest connected component in the graph.\nExample 1:\nInput: [4,6,15,35] Output: 4   Example 2:\nInput: [20,50,9,63] Output: 2   Example 3:\nInput: [2,3,6,7,4,12,21,39] Output: 8   Note:\n 1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= 100000  题目大意 #  给定一个由不同正整数的组成的非空数组 A，考虑下面的图：\n有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记； 只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。 返回图中最大连通组件的大小。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= 100000  解题思路 #   给出一个数组，数组中的元素如果每两个元素有公约数，那么这两个元素可以算有关系。所有有关系的数可以放在一个集合里，问这个数组里面有关系的元素组成的集合里面最多有多少个元素。 这一题读完题直觉就是用并查集来解题。首先可以用暴力的解法尝试。用 2 层循环，两两比较有没有公约数，如果有公约数就 union() 到一起。提交以后出现 TLE，其实看一下数据规模就知道会超时，1 \u0026lt;= A.length \u0026lt;= 20000。注意到 1 \u0026lt;= A[i] \u0026lt;= 100000，开根号以后最后才 316.66666，这个规模的数不大。所以把每个数小于根号自己的因子都找出来，例如 6 = 2 * 3，15 = 3 * 5，那么把 6 和 2，6 和 3 都 union()，15 和 3，15 和 5 都 union()，最终遍历所有的集合，找到最多元素的集合，输出它包含的元素值。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) // 解法一 并查集 UnionFind func largestComponentSize(A []int) int { maxElement, uf, countMap, res := 0, template.UnionFind{}, map[int]int{}, 1 for _, v := range A { maxElement = max(maxElement, v) } uf.Init(maxElement + 1) for _, v := range A { for k := 2; k*k \u0026lt;= v; k++ { if v%k == 0 { uf.Union(v, k) uf.Union(v, v/k) } } } for _, v := range A { countMap[uf.Find(v)]++ res = max(res, countMap[uf.Find(v)]) } return res } // 解法二 UnionFindCount func largestComponentSize1(A []int) int { uf, factorMap := template.UnionFindCount{}, map[int]int{} uf.Init(len(A)) for i, v := range A { for k := 2; k*k \u0026lt;= v; k++ { if v%k == 0 { if _, ok := factorMap[k]; !ok { factorMap[k] = i } else { uf.Union(i, factorMap[k]) } if _, ok := factorMap[v/k]; !ok { factorMap[v/k] = i } else { uf.Union(i, factorMap[v/k]) } } } if _, ok := factorMap[v]; !ok { factorMap[v] = i } else { uf.Union(i, factorMap[v]) } } return uf.MaxUnionCount() } "});index.add({'id':427,'href':'/leetcode-java/04_Leetcode/0953.Verifying-an-Alien-Dictionary/','title':"0953. Verifying an Alien Dictionary",'section':"第四章",'content':"953. Verifying an Alien Dictionary #  题目 #  In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The orderof the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.\nExample 1:\nInput: words = [\u0026quot;hello\u0026quot;,\u0026quot;leetcode\u0026quot;], order = \u0026quot;hlabcdefgijkmnopqrstuvwxyz\u0026quot; Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.  Example 2:\nInput: words = [\u0026quot;word\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;row\u0026quot;], order = \u0026quot;worldabcefghijkmnpqstuvxyz\u0026quot; Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u0026gt; words[1], hence the sequence is unsorted.  Example 3:\nInput: words = [\u0026quot;apple\u0026quot;,\u0026quot;app\u0026quot;], order = \u0026quot;abcdefghijklmnopqrstuvwxyz\u0026quot; Output: false Explanation: The first three characters \u0026quot;app\u0026quot; match, and the second string is shorter (in size.) According to lexicographical rules \u0026quot;apple\u0026quot; \u0026gt; \u0026quot;app\u0026quot;, because 'l' \u0026gt; '∅', where '∅' is defined as the blank character which is less than any other character (More info).  Note:\n 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 20 order.length == 26 All characters in words[i] and order are english lowercase letters.  题目大意 #  某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。\n解题思路 #   这一题是简单题。给出一个字符串数组，判断把字符串数组里面字符串是否是按照 order 的排序排列的。order 是给出个一个字符串排序。这道题的解法是把 26 个字母的顺序先存在 map 中，然后依次遍历判断字符串数组里面字符串的大小。  代码 #  package leetcode func isAlienSorted(words []string, order string) bool { if len(words) \u0026lt; 2 { return true } hash := make(map[byte]int) for i := 0; i \u0026lt; len(order); i++ { hash[order[i]] = i } for i := 0; i \u0026lt; len(words)-1; i++ { pointer, word, wordplus := 0, words[i], words[i+1] for pointer \u0026lt; len(word) \u0026amp;\u0026amp; pointer \u0026lt; len(wordplus) { if hash[word[pointer]] \u0026gt; hash[wordplus[pointer]] { return false } if hash[word[pointer]] \u0026lt; hash[wordplus[pointer]] { break } else { pointer = pointer + 1 } } if pointer \u0026lt; len(word) \u0026amp;\u0026amp; pointer \u0026gt;= len(wordplus) { return false } } return true } "});index.add({'id':428,'href':'/leetcode-java/04_Leetcode/0959.Regions-Cut-By-Slashes/','title':"0959. Regions Cut by Slashes",'section':"第四章",'content':"959. Regions Cut By Slashes #  题目 #  In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \\, or blank space. These characters divide the square into contiguous regions.\n(Note that backslash characters are escaped, so a \\ is represented as \u0026quot;\\\\\u0026quot;.)\nReturn the number of regions.\nExample 1:\nInput: [ \u0026quot; /\u0026quot;, \u0026quot;/ \u0026quot; ] Output: 2 Explanation: The 2x2 grid is as follows:   Example 2:\nInput: [ \u0026quot; /\u0026quot;, \u0026quot; \u0026quot; ] Output: 1 Explanation: The 2x2 grid is as follows:   Example 3:\nInput: [ \u0026quot;\\\\/\u0026quot;, \u0026quot;/\\\\\u0026quot; ] Output: 4 Explanation: (Recall that because \\ characters are escaped, \u0026quot;\\\\/\u0026quot; refers to \\/, and \u0026quot;/\\\\\u0026quot; refers to /\\.) The 2x2 grid is as follows:   Example 4:\nInput: [ \u0026quot;/\\\\\u0026quot;, \u0026quot;\\\\/\u0026quot; ] Output: 5 Explanation: (Recall that because \\ characters are escaped, \u0026quot;/\\\\\u0026quot; refers to /\\, and \u0026quot;\\\\/\u0026quot; refers to \\/.) The 2x2 grid is as follows:   Example 5:\nInput: [ \u0026quot;//\u0026quot;, \u0026quot;/ \u0026quot; ] Output: 3 Explanation: The 2x2 grid is as follows:   Note:\n 1 \u0026lt;= grid.length == grid[0].length \u0026lt;= 30 grid[i][j] is either '/', '\\', or ' '.  题目大意 #  在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。(请注意，反斜杠字符是转义的，因此 \\ 用 \u0026ldquo;\\\u0026rdquo; 表示)返回区域的数目。\n提示：\n 1 \u0026lt;= grid.length == grid[0].length \u0026lt;= 30 grid[i][j] 是 \u0026lsquo;/'、''、或 ' \u0026lsquo;。  解题思路 #   给出一个字符串，代表的是 N x N 正方形中切分的情况，有 2 种切分的情况 '\\' 和 '/' ，即从左上往右下切和从右上往左下切。问按照给出的切分方法，能把 N x N 正方形切成几部分？ 这一题解题思路是并查集。先将每个 1*1 的正方形切分成下图的样子。分成 4 小块。然后按照题目给的切分图来合并各个小块。    遇到 '\\\\'，就把第 0 块和第 1 块 union() 起来，第 2 块和第 3 块 union() 起来；遇到 '/'，就把第 0 块和第 3 块 union() 起来，第 2 块和第 1 块 union() 起来；遇到 ' '，就把第 0 块和第 1 块 union() 起来，第 2 块和第 1 块 union() 起来，第 2 块和第 3 块 union() 起来，即 4 块都 union() 起来；最后还需要记得上一行和下一行还需要 union()，即本行的第 2 块和下一行的第 0 块 union() 起来；左边一列和右边一列也需要 union()。即本列的第 1 块和右边一列的第 3 块 union() 起来。最后计算出集合总个数就是最终答案了。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func regionsBySlashes(grid []string) int { size := len(grid) uf := template.UnionFind{} uf.Init(4 * size * size) for i := 0; i \u0026lt; size; i++ { for j := 0; j \u0026lt; size; j++ { switch grid[i][j] { case \u0026#39;\\\\\u0026#39;: uf.Union(getFaceIdx(size, i, j, 0), getFaceIdx(size, i, j, 1)) uf.Union(getFaceIdx(size, i, j, 2), getFaceIdx(size, i, j, 3)) case \u0026#39;/\u0026#39;: uf.Union(getFaceIdx(size, i, j, 0), getFaceIdx(size, i, j, 3)) uf.Union(getFaceIdx(size, i, j, 2), getFaceIdx(size, i, j, 1)) case \u0026#39; \u0026#39;: uf.Union(getFaceIdx(size, i, j, 0), getFaceIdx(size, i, j, 1)) uf.Union(getFaceIdx(size, i, j, 2), getFaceIdx(size, i, j, 1)) uf.Union(getFaceIdx(size, i, j, 2), getFaceIdx(size, i, j, 3)) } if i \u0026lt; size-1 { uf.Union(getFaceIdx(size, i, j, 2), getFaceIdx(size, i+1, j, 0)) } if j \u0026lt; size-1 { uf.Union(getFaceIdx(size, i, j, 1), getFaceIdx(size, i, j+1, 3)) } } } count := 0 for i := 0; i \u0026lt; 4*size*size; i++ { if uf.Find(i) == i { count++ } } return count } func getFaceIdx(size, i, j, k int) int { return 4*(i*size+j) + k } "});index.add({'id':429,'href':'/leetcode-java/04_Leetcode/0961.N-Repeated-Element-in-Size-2N-Array/','title':"0961. N Repeated Element in Size 2 N Array",'section':"第四章",'content':"961. N-Repeated Element in Size 2N Array #  题目 #  In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\nExample 1:\nInput: [1,2,3,3] Output: 3  Example 2:\nInput: [2,1,2,5,3,2] Output: 2  Example 3:\nInput: [5,1,5,2,5,3,5,4] Output: 5  Note:\n 4 \u0026lt;= A.length \u0026lt;= 10000 0 \u0026lt;= A[i] \u0026lt; 10000 A.length is even  题目大意 #  在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。返回重复了 N 次的那个元素。\n解题思路 #   简单题。数组中有 2N 个数，有 N + 1 个数是不重复的，这之中有一个数重复了 N 次，请找出这个数。解法非常简单，把所有数都存入 map 中，如果遇到存在的 key 就返回这个数。  代码 #  package leetcode func repeatedNTimes(A []int) int { kv := make(map[int]struct{}) for _, val := range A { if _, ok := kv[val]; ok { return val } kv[val] = struct{}{} } return 0 } "});index.add({'id':430,'href':'/leetcode-java/04_Leetcode/0968.Binary-Tree-Cameras/','title':"0968. Binary Tree Cameras",'section':"第四章",'content':"968. Binary Tree Cameras #  题目 #  Given a binary tree, we install cameras on the nodes of the tree.\nEach camera at a node can monitor its parent, itself, and its immediate children.\nCalculate the minimum number of cameras needed to monitor all nodes of the tree.\nExample 1:\n Input: [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown.  Example 2:\n Input: [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.  Note:\n The number of nodes in the given tree will be in the range [1, 1000]. Every node has value 0.  题目大意 #  给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。\n提示：\n 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。  解题思路 #   给出一棵树，要求在这个树上面放摄像头，一个摄像头最多可以监视 4 个节点，2 个孩子，本身节点，还有父亲节点。问最少放多少个摄像头可以覆盖树上的所有节点。 这一题可以用贪心思想来解题。先将节点分为 3 类，第一类，叶子节点，第二类，包含叶子节点的节点，第三类，其中一个叶子节点上放了摄像头的。按照这个想法，将树的每个节点染色，如下图。    所有包含叶子节点的节点，可以放一个摄像头，这个可以覆盖至少 3 个节点，如果还有父节点的话，可以覆盖 4 个节点。所以贪心的策略是从最下层的叶子节点开始往上“染色”，先把最下面的一层 1 染色。标 1 的节点都是要放一个摄像头的。如果叶子节点中包含 1 的节点，那么再将这个节点染成 2 。如下图的黄色节点。黄色节点代表的是不用放摄像头的节点，因为它被叶子节点的摄像头覆盖了。出现了 2 的节点以后，再往上的节点又再次恢复成叶子节点 0 。如此类推，直到推到根节点。    最后根节点还需要注意多种情况，根节点可能是叶子节点 0，那么最终答案还需要 + 1，因为需要在根节点上放一个摄像头，不然根节点覆盖不到了。根节点也有可能是 1 或者 2，这两种情况都不需要增加摄像头了，以为都覆盖到了。按照上述的方法，递归即可得到答案。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type status int const ( isLeaf status = iota parentofLeaf isMonitoredWithoutCamera ) func minCameraCover(root *TreeNode) int { res := 0 if minCameraCoverDFS(root, \u0026amp;res) == isLeaf { res++ } return res } func minCameraCoverDFS(root *TreeNode, res *int) status { if root == nil { return 2 } left, right := minCameraCoverDFS(root.Left, res), minCameraCoverDFS(root.Right, res) if left == isLeaf || right == isLeaf { *res++ return parentofLeaf } else if left == parentofLeaf || right == parentofLeaf { return isMonitoredWithoutCamera } else { return isLeaf } } "});index.add({'id':431,'href':'/leetcode-java/04_Leetcode/0969.Pancake-Sorting/','title':"0969. Pancake Sorting",'section':"第四章",'content':"969. Pancake Sorting #  题目 #  Given an array A, we can perform a pancake flip: We choose some positive integer k \u0026lt;= A.length, then reverse the order of the first k elements of A. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.\nReturn the k-values corresponding to a sequence of pancake flips that sort A. Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.\nExample 1:\n Input: [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: A = [3, 2, 4, 1] After 1st flip (k=4): A = [1, 4, 2, 3] After 2nd flip (k=2): A = [4, 1, 2, 3] After 3rd flip (k=4): A = [3, 2, 1, 4] After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted. Example 2:\n Input: [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. Note:\n 1 \u0026lt;= A.length \u0026lt;= 100 A[i] is a permutation of [1, 2, \u0026hellip;, A.length]  题目大意 #  给定一个数组，要求输出“煎饼排序”的步骤，使得最终数组是从小到大有序的。“煎饼排序”，每次排序都反转前 n 个数，n 小于数组的长度。\n解题思路 #  这道题的思路是，每次找到当前数组中无序段中最大的值，（初始的时候，整个数组相当于都是无序段），将最大值的下标 i 进行“煎饼排序”，前 i 个元素都反转一遍。这样最大值就到了第一个位置了。然后紧接着再进行一次数组总长度 n 的“煎饼排序”，目的是使最大值到数组最后一位，这样它的位置就归位了。那么数组的无序段为 n-1 。然后用这个方法不断的循环，直至数组中每个元素都到了排序后最终的位置下标上了。最终数组就有序了。\n这道题有一个特殊点在于，数组里面的元素都是自然整数，那么最终数组排序完成以后，数组的长度就是最大值。所以找最大值也不需要遍历一次数组了，直接取出长度就是最大值。\n代码 #  package leetcode func pancakeSort(A []int) []int { if len(A) == 0 { return []int{} } right := len(A) var ( ans []int ) for right \u0026gt; 0 { idx := find(A, right) if idx != right-1 { reverse969(A, 0, idx) reverse969(A, 0, right-1) ans = append(ans, idx+1, right) } right-- } return ans } func reverse969(nums []int, l, r int) { for l \u0026lt; r { nums[l], nums[r] = nums[r], nums[l] l++ r-- } } func find(nums []int, t int) int { for i, num := range nums { if num == t { return i } } return -1 } "});index.add({'id':432,'href':'/leetcode-java/04_Leetcode/0970.Powerful-Integers/','title':"0970. Powerful Integers",'section':"第四章",'content':"970. Powerful Integers #  题目 #  Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i \u0026gt;= 0 and j \u0026gt;= 0.\nReturn a list of all powerful integers that have value less than or equal to bound.\nYou may return the answer in any order. In your answer, each value should occur at most once.\nExample 1:\nInput: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation: 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2  Example 2:\nInput: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14]  Note:\n 1 \u0026lt;= x \u0026lt;= 100 1 \u0026lt;= y \u0026lt;= 100 0 \u0026lt;= bound \u0026lt;= 10^6  题目大意 #  给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i \u0026gt;= 0 且 j \u0026gt;= 0，那么我们认为该整数是一个强整数。返回值小于或等于 bound 的所有强整数组成的列表。你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。\n解题思路 #   简答题，题目要求找出满足 x^i + y^j ≤ bound 条件的所有解。题目要求输出中不能重复，所以用 map 来去重。剩下的就是 n^2 暴力循环枚举所有解。  代码 #  package leetcode import \u0026#34;math\u0026#34; func powerfulIntegers(x int, y int, bound int) []int { if x == 1 \u0026amp;\u0026amp; y == 1 { if bound \u0026lt; 2 { return []int{} } return []int{2} } if x \u0026gt; y { x, y = y, x } visit, result := make(map[int]bool), make([]int, 0) for i := 0; ; i++ { found := false for j := 0; pow(x, i)+pow(y, j) \u0026lt;= bound; j++ { v := pow(x, i) + pow(y, j) if !visit[v] { found = true visit[v] = true result = append(result, v) } } if !found { break } } return result } func pow(x, i int) int { return int(math.Pow(float64(x), float64(i))) } "});index.add({'id':433,'href':'/leetcode-java/04_Leetcode/0973.K-Closest-Points-to-Origin/','title':"0973. K Closest Points to Origin",'section':"第四章",'content':"973. K Closest Points to Origin #  题目 #  We have a list of points on the plane. Find the K closest points to the origin (0, 0).\n(Here, the distance between two points on a plane is the Euclidean distance.)\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)\nExample 1:\n Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u0026lt; sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. Example 2:\n Input: points = [[3,3],[5,-1],[-2,4]], K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note:\n 1 \u0026lt;= K \u0026lt;= points.length \u0026lt;= 10000 -10000 \u0026lt; points[i][0] \u0026lt; 10000 -10000 \u0026lt; points[i][1] \u0026lt; 10000  题目大意 #  找出 K 个距离坐标原点最近的坐标点。\n解题思路 #  这题也是排序题，先将所有点距离坐标原点的距离都算出来，然后从小到大排序。取前 K 个即可。\n代码 #  package leetcode import \u0026#34;sort\u0026#34; // KClosest define func KClosest(points [][]int, K int) [][]int { sort.Slice(points, func(i, j int) bool { return points[i][0]*points[i][0]+points[i][1]*points[i][1] \u0026lt; points[j][0]*points[j][0]+points[j][1]*points[j][1] }) ans := make([][]int, K) for i := 0; i \u0026lt; K; i++ { ans[i] = points[i] } return ans } "});index.add({'id':434,'href':'/leetcode-java/04_Leetcode/0976.Largest-Perimeter-Triangle/','title':"0976. Largest Perimeter Triangle",'section':"第四章",'content':"976. Largest Perimeter Triangle #  题目 #  Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\nIf it is impossible to form any triangle of non-zero area, return 0.\nExample 1:\n Input: [2,1,2] Output: 5 Example 2:\n Input: [1,2,1] Output: 0 Example 3:\n Input: [3,2,3,4] Output: 10 Example 4:\n Input: [3,6,2,3] Output: 8 Note:\n 3 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= A[i] \u0026lt;= 10^6  题目大意 #  找到可以组成三角形三条边的长度，要求输出三条边之和最长的，即三角形周长最长。\n解题思路 #  这道题也是排序题，先讲所有的长度进行排序，从大边开始往前找，找到第一个任意两边之和大于第三边(满足能构成三角形的条件)的下标，然后输出这 3 条边之和即可，如果没有找到输出 0 。\n代码 #  package leetcode func largestPerimeter(A []int) int { if len(A) \u0026lt; 3 { return 0 } quickSort164(A, 0, len(A)-1) for i := len(A) - 1; i \u0026gt;= 2; i-- { if (A[i]+A[i-1] \u0026gt; A[i-2]) \u0026amp;\u0026amp; (A[i]+A[i-2] \u0026gt; A[i-1]) \u0026amp;\u0026amp; (A[i-2]+A[i-1] \u0026gt; A[i]) { return A[i] + A[i-1] + A[i-2] } } return 0 } "});index.add({'id':435,'href':'/leetcode-java/04_Leetcode/0977.Squares-of-a-Sorted-Array/','title':"0977. Squares of a Sorted Array",'section':"第四章",'content':"977. Squares of a Sorted Array #  题目 #  Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.\nExample 1:\n Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2:\n Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note:\n 1 \u0026lt;= A.length \u0026lt;= 10000 -10000 \u0026lt;= A[i] \u0026lt;= 10000 A is sorted in non-decreasing order.  题目大意 #  给一个已经有序的数组，返回的数组也必须是有序的，且数组中的每个元素是由原数组中每个数字的平方得到的。\n解题思路 #  这一题由于原数组是有序的，所以要尽量利用这一特点来减少时间复杂度。\n最终返回的数组，最后一位，是最大值，这个值应该是由原数组最大值，或者最小值得来的，所以可以从数组的最后一位开始排列最终数组。用 2 个指针分别指向原数组的首尾，分别计算平方值，然后比较两者大小，大的放在最终数组的后面。然后大的一个指针移动。直至两个指针相撞，最终数组就排列完成了。\n代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 func sortedSquares(A []int) []int { ans := make([]int, len(A)) for i, k, j := 0, len(A)-1, len(ans)-1; i \u0026lt;= j; k-- { if A[i]*A[i] \u0026gt; A[j]*A[j] { ans[k] = A[i] * A[i] i++ } else { ans[k] = A[j] * A[j] j-- } } return ans } // 解法二 func sortedSquares1(A []int) []int { for i, value := range A { A[i] = value * value } sort.Ints(A) return A } "});index.add({'id':436,'href':'/leetcode-java/04_Leetcode/0978.Longest-Turbulent-Subarray/','title':"0978. Longest Turbulent Subarray",'section':"第四章",'content':"978. Longest Turbulent Subarray #  题目 #  A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:\n For i \u0026lt;= k \u0026lt; j, A[k] \u0026gt; A[k+1] when k is odd, and A[k] \u0026lt; A[k+1] when k is even; OR, for i \u0026lt;= k \u0026lt; j, A[k] \u0026gt; A[k+1] when k is even, and A[k] \u0026lt; A[k+1] when k is odd.  That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nReturn the length of a maximum size turbulent subarray of A.\nExample 1:\nInput: [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: (A[1] \u0026gt; A[2] \u0026lt; A[3] \u0026gt; A[4] \u0026lt; A[5])  Example 2:\nInput: [4,8,12,16] Output: 2  Example 3:\nInput: [100] Output: 1  Note:\n 1 \u0026lt;= A.length \u0026lt;= 40000 0 \u0026lt;= A[i] \u0026lt;= 10^9  题目大意 #  当 A 的子数组 A[i], A[i+1], \u0026hellip;, A[j] 满足下列条件时，我们称其为湍流子数组：\n若 i \u0026lt;= k \u0026lt; j，当 k 为奇数时， A[k] \u0026gt; A[k+1]，且当 k 为偶数时，A[k] \u0026lt; A[k+1]； 或 若 i \u0026lt;= k \u0026lt; j，当 k 为偶数时，A[k] \u0026gt; A[k+1] ，且当 k 为奇数时， A[k] \u0026lt; A[k+1]。 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。\n返回 A 的最大湍流子数组的长度。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 40000 0 \u0026lt;= A[i] \u0026lt;= 10^9  解题思路 #   给出一个数组，要求找出“摆动数组”的最大长度。所谓“摆动数组”的意思是，元素一大一小间隔的。 这一题可以用滑动窗口来解答。用一个变量记住下次出现的元素需要大于还是需要小于前一个元素。也可以用模拟的方法，用两个变量分别记录上升和下降数字的长度。一旦元素相等了，上升和下降数字长度都置为 1，其他时候按照上升和下降的关系增加队列长度即可，最后输出动态维护的最长长度。  代码 #  package leetcode // 解法一 模拟法 func maxTurbulenceSize(A []int) int { inc, dec := 1, 1 maxLen := min(1, len(A)) for i := 1; i \u0026lt; len(A); i++ { if A[i-1] \u0026lt; A[i] { inc = dec + 1 dec = 1 } else if A[i-1] \u0026gt; A[i] { dec = inc + 1 inc = 1 } else { inc = 1 dec = 1 } maxLen = max(maxLen, max(inc, dec)) } return maxLen } // 解法二 滑动窗口 func maxTurbulenceSize1(A []int) int { if len(A) == 1 { return 1 } // flag \u0026gt; 0 代表下一个数要大于前一个数，flag \u0026lt; 0 代表下一个数要小于前一个数 \tres, left, right, flag, lastNum := 0, 0, 0, A[1]-A[0], A[0] for left \u0026lt; len(A) { if right \u0026lt; len(A)-1 \u0026amp;\u0026amp; ((A[right+1] \u0026gt; lastNum \u0026amp;\u0026amp; flag \u0026gt; 0) || (A[right+1] \u0026lt; lastNum \u0026amp;\u0026amp; flag \u0026lt; 0) || (right == left)) { right++ flag = lastNum - A[right] lastNum = A[right] } else { if flag != 0 { res = max(res, right-left+1) } left++ } } return max(res, 1) } "});index.add({'id':437,'href':'/leetcode-java/04_Leetcode/0979.Distribute-Coins-in-Binary-Tree/','title':"0979. Distribute Coins in Binary Tree",'section':"第四章",'content':"979. Distribute Coins in Binary Tree #  题目 #  Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.)\nReturn the number of moves required to make every node have exactly one coin.\nExample 1:\n Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.  Example 2:\n Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.  Example 3:\n Input: [1,0,2] Output: 2  Example 4:\n Input: [1,0,0,null,3] Output: 4  Note:\n 1\u0026lt;= N \u0026lt;= 100 0 \u0026lt;= node.val \u0026lt;= N  题目大意 #  给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。返回使每个结点上只有一枚硬币所需的移动次数。\n提示：\n 1\u0026lt;= N \u0026lt;= 100 0 \u0026lt;= node.val \u0026lt;= N  解题思路 #   给出一棵树，有 N 个节点。有 N 个硬币分散在这 N 个节点中，问经过多少次移动以后，所有节点都有一枚硬币。 这一题乍一看比较难分析，仔细一想，可以用贪心和分治的思想来解决。一个树的最小单元是一个根节点和两个孩子。在这种情况下，3 个节点谁的硬币多就可以分给没有硬币的那个节点，这种移动方法也能保证移动步数最少。不难证明，硬币由相邻的节点移动过来的步数是最少的。那么一棵树从最下一层开始往上推，逐步从下往上把硬币移动上去，直到最后根节点也都拥有硬币。多余 1 枚的节点记为 n -1，没有硬币的节点记为 -1 。例如，下图中左下角的 3 个节点，有 4 枚硬币的节点可以送出 3 枚硬币，叶子节点有 0 枚硬币的节点需要接收 1 枚硬币。根节点有 0 枚硬币，左孩子给了 3 枚，右孩子需要 1 枚，自己本身还要留一枚，所以最终还能剩 1 枚。    所以每个节点移动的步数应该是 left + right + root.Val - 1。最后递归求解即可。  代码 #  package leetcode /** * Definition for a binary tree root. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func distributeCoins(root *TreeNode) int { res := 0 distributeCoinsDFS(root, \u0026amp;res) return res } func distributeCoinsDFS(root *TreeNode, res *int) int { if root == nil { return 0 } left, right := distributeCoinsDFS(root.Left, res), distributeCoinsDFS(root.Right, res) *res += abs(left) + abs(right) return left + right + root.Val - 1 } "});index.add({'id':438,'href':'/leetcode-java/04_Leetcode/0980.Unique-Paths-III/','title':"0980. Unique Paths I I I",'section':"第四章",'content':"980. Unique Paths III #  题目 #  On a 2-dimensional grid, there are 4 types of squares:\n 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over.  Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\nExample 1:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)  Example 2:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)  Example 3:\nInput: [[0,1],[2,0]] Output: 0 Explanation: There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid.  Note:\n 1 \u0026lt;= grid.length * grid[0].length \u0026lt;= 20  题目大意 #  在二维网格 grid 上，有 4 种类型的方格：\n 1 表示起始方格。且只有一个起始方格。 2 表示结束方格，且只有一个结束方格。 0 表示我们可以走过的空方格。 -1 表示我们无法跨越的障碍。  返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。\n解题思路 #   这一题也可以按照第 79 题的思路来做。题目要求输出地图中从起点到终点的路径条数。注意路径要求必须走满所有空白的格子。 唯一需要注意的一点是，空白的格子并不是最后走的总步数，总步数 = 空白格子数 + 1，因为要走到终点，走到终点也算一步。  代码 #  package leetcode var dir = [][]int{ {-1, 0}, {0, 1}, {1, 0}, {0, -1}, } func uniquePathsIII(grid [][]int) int { visited := make([][]bool, len(grid)) for i := 0; i \u0026lt; len(visited); i++ { visited[i] = make([]bool, len(grid[0])) } res, empty, startx, starty, endx, endy, path := 0, 0, 0, 0, 0, 0, []int{} for i, v := range grid { for j, vv := range v { switch vv { case 0: empty++ case 1: startx, starty = i, j case 2: endx, endy = i, j } } } findUniquePathIII(grid, visited, path, empty+1, startx, starty, endx, endy, \u0026amp;res) // 可走的步数要加一，因为终点格子也算一步，不然永远走不到终点！ \treturn res } func isInPath(board [][]int, x, y int) bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(board) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(board[0]) } func findUniquePathIII(board [][]int, visited [][]bool, path []int, empty, startx, starty, endx, endy int, res *int) { if startx == endx \u0026amp;\u0026amp; starty == endy { if empty == 0 { *res++ } return } if board[startx][starty] \u0026gt;= 0 { visited[startx][starty] = true empty-- path = append(path, startx) path = append(path, starty) for i := 0; i \u0026lt; 4; i++ { nx := startx + dir[i][0] ny := starty + dir[i][1] if isInPath(board, nx, ny) \u0026amp;\u0026amp; !visited[nx][ny] { findUniquePathIII(board, visited, path, empty, nx, ny, endx, endy, res) } } visited[startx][starty] = false //empty++ 这里虽然可以还原这个变量值，但是赋值没有意义，干脆不写了 \tpath = path[:len(path)-2] } return } "});index.add({'id':439,'href':'/leetcode-java/04_Leetcode/0981.Time-Based-Key-Value-Store/','title':"0981. Time Based Key Value Store",'section':"第四章",'content':"981. Time Based Key-Value Store #  题目 #  Create a timebased key-value store class TimeMap, that supports two operations.\n1. set(string key, string value, int timestamp)\n Stores the key and value, along with the given timestamp.  2. get(string key, int timestamp)\n Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).  Example 1:\nInput: inputs = [\u0026quot;TimeMap\u0026quot;,\u0026quot;set\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;set\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;], inputs = [[],[\u0026quot;foo\u0026quot;,\u0026quot;bar\u0026quot;,1],[\u0026quot;foo\u0026quot;,1],[\u0026quot;foo\u0026quot;,3],[\u0026quot;foo\u0026quot;,\u0026quot;bar2\u0026quot;,4],[\u0026quot;foo\u0026quot;,4],[\u0026quot;foo\u0026quot;,5]] Output: [null,null,\u0026quot;bar\u0026quot;,\u0026quot;bar\u0026quot;,null,\u0026quot;bar2\u0026quot;,\u0026quot;bar2\u0026quot;] Explanation: TimeMap kv; kv.set(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;, 1); // store the key \u0026quot;foo\u0026quot; and value \u0026quot;bar\u0026quot; along with timestamp = 1 kv.get(\u0026quot;foo\u0026quot;, 1); // output \u0026quot;bar\u0026quot; kv.get(\u0026quot;foo\u0026quot;, 3); // output \u0026quot;bar\u0026quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie \u0026quot;bar\u0026quot; kv.set(\u0026quot;foo\u0026quot;, \u0026quot;bar2\u0026quot;, 4); kv.get(\u0026quot;foo\u0026quot;, 4); // output \u0026quot;bar2\u0026quot; kv.get(\u0026quot;foo\u0026quot;, 5); //output \u0026quot;bar2\u0026quot;  Example 2:\nInput: inputs = [\u0026quot;TimeMap\u0026quot;,\u0026quot;set\u0026quot;,\u0026quot;set\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;,\u0026quot;get\u0026quot;], inputs = [[],[\u0026quot;love\u0026quot;,\u0026quot;high\u0026quot;,10],[\u0026quot;love\u0026quot;,\u0026quot;low\u0026quot;,20],[\u0026quot;love\u0026quot;,5],[\u0026quot;love\u0026quot;,10],[\u0026quot;love\u0026quot;,15],[\u0026quot;love\u0026quot;,20],[\u0026quot;love\u0026quot;,25]] Output: [null,null,null,\u0026quot;\u0026quot;,\u0026quot;high\u0026quot;,\u0026quot;high\u0026quot;,\u0026quot;low\u0026quot;,\u0026quot;low\u0026quot;]  Note:\n All key/value strings are lowercase. All key/value strings have length in the range [1, 100] The timestamps for all TimeMap.set operations are strictly increasing. 1 \u0026lt;= timestamp \u0026lt;= 10^7 TimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case.  题目大意 #  创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：\n set(string key, string value, int timestamp)   存储键 key、值 value，以及给定的时间戳 timestamp。  get(string key, int timestamp)   返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev \u0026lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（\u0026quot;\u0026quot;）。  提示：\n 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 \u0026lt;= timestamp \u0026lt;= 10^7 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。  解题思路 #   要求设计一个基于时间戳的 kv 存储。set() 操作里面会会包含一个时间戳。get() 操作的时候查找时间戳小于等于 timestamp 的 key 对应的 value，如果有多个解，输出满足条件的最大时间戳对应的 value 值。 这一题可以用二分搜索来解答，用 map 存储 kv 数据，key 对应的就是 key，value 对应一个结构体，里面包含 value 和 timestamp。执行 get() 操作的时候，先取出 key 对应的结构体数组，然后在这个数组里面根据 timestamp 进行二分搜索。由于题意是要找小于等于 timestamp 的最大 timestamp ，这会有很多满足条件的解，变换一下，先找 \u0026gt; timestamp 的最小解，然后下标减一即是满足题意的最大解。 另外题目中提到“TimeMap.set 操作中的 timestamp 是严格递增的”。所以在 map 中存储 value 结构体的时候，不需要排序了，天然有序。  代码 #  package leetcode import \u0026#34;sort\u0026#34; type data struct { time int value string } // TimeMap is a timebased key-value store // TimeMap define type TimeMap map[string][]data // Constructor981 define func Constructor981() TimeMap { return make(map[string][]data, 1024) } // Set define func (t TimeMap) Set(key string, value string, timestamp int) { if _, ok := t[key]; !ok { t[key] = make([]data, 1, 1024) } t[key] = append(t[key], data{ time: timestamp, value: value, }) } // Get define func (t TimeMap) Get(key string, timestamp int) string { d := t[key] i := sort.Search(len(d), func(i int) bool { return timestamp \u0026lt; d[i].time }) i-- return t[key][i].value } /** * Your TimeMap object will be instantiated and called as such: * obj := Constructor(); * obj.Set(key,value,timestamp); * param_2 := obj.Get(key,timestamp); */ "});index.add({'id':440,'href':'/leetcode-java/04_Leetcode/0984.String-Without-AAA-or-BBB/','title':"0984. String Without a a a or B B B",'section':"第四章",'content':"984. String Without AAA or BBB #  题目 #  Given two integers A and B, return any string S such that:\n S has length A + B and contains exactly A 'a' letters, and exactly B 'b'letters; The substring 'aaa' does not occur in S; The substring 'bbb' does not occur in S.  Example 1:\nInput: A = 1, B = 2 Output: \u0026quot;abb\u0026quot; Explanation: \u0026quot;abb\u0026quot;, \u0026quot;bab\u0026quot; and \u0026quot;bba\u0026quot; are all correct answers.  Example 2:\nInput: A = 4, B = 1 Output: \u0026quot;aabaa\u0026quot;  Note:\n 0 \u0026lt;= A \u0026lt;= 100 0 \u0026lt;= B \u0026lt;= 100 It is guaranteed such an S exists for the given A and B.  题目大意 #  给定两个整数 A 和 B，返回任意字符串 S，要求满足：\n S 的长度为 A + B，且正好包含 A 个 \u0026lsquo;a\u0026rsquo; 字母与 B 个 \u0026lsquo;b\u0026rsquo; 字母； 子串 \u0026lsquo;aaa\u0026rsquo; 没有出现在 S 中； 子串 \u0026lsquo;bbb\u0026rsquo; 没有出现在 S 中。  提示：\n 0 \u0026lt;= A \u0026lt;= 100 0 \u0026lt;= B \u0026lt;= 100 对于给定的 A 和 B，保证存在满足要求的 S。  解题思路 #   给出 A 和 B 的个数，要求组合出字符串，不能出现 3 个连续的 A 和 3 个连续的 B。这题由于只可能有 4 种情况，暴力枚举就可以了。假设 B 的个数比 A 多(如果 A 多，就交换一下 A 和 B)，最终可能的情况只可能是这 4 种情况中的一种： ba，bbabb，bbabbabb，bbabbabbabbabababa。  代码 #  package leetcode func strWithout3a3b(A int, B int) string { ans, a, b := \u0026#34;\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; if B \u0026lt; A { A, B = B, A a, b = b, a } Dif := B - A if A == 1 \u0026amp;\u0026amp; B == 1 { // ba \tans = b + a } else if A == 1 \u0026amp;\u0026amp; B \u0026lt; 5 { // bbabb \tfor i := 0; i \u0026lt; B-2; i++ { ans = ans + b } ans = b + b + a + ans } else if (B-A)/A \u0026gt;= 1 { //bbabbabb \tfor i := 0; i \u0026lt; A; i++ { ans = ans + b + b + a B = B - 2 } for i := 0; i \u0026lt; B; i++ { ans = ans + b } } else { //bbabbabbabbabababa \tfor i := 0; i \u0026lt; Dif; i++ { ans = ans + b + b + a B -= 2 A-- } for i := 0; i \u0026lt; B; i++ { ans = ans + b + a } } return ans } "});index.add({'id':441,'href':'/leetcode-java/04_Leetcode/0985.Sum-of-Even-Numbers-After-Queries/','title':"0985. Sum of Even Numbers After Queries",'section':"第四章",'content':"985. Sum of Even Numbers After Queries #  题目 #  We have an array A of integers, and an array queries of queries.\nFor the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index]. Then, the answer to the i-th query is the sum of the even values of A.\n(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)\nReturn the answer to all queries. Your answer array should have answer[i] as the answer to the i-th query.\nExample 1:\nInput: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation: At the beginning, the array is [1,2,3,4]. After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6. After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2. After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. Note:\n 1 \u0026lt;= A.length \u0026lt;= 10000 -10000 \u0026lt;= A[i] \u0026lt;= 10000 1 \u0026lt;= queries.length \u0026lt;= 10000 -10000 \u0026lt;= queries[i][0] \u0026lt;= 10000 0 \u0026lt;= queries[i][1] \u0026lt; A.length  题目大意 #  给出一个整数数组 A 和一个查询数组 queries。\n对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。\n解题思路 #   给出一个数组 A 和 query 数组。要求每次 query 操作都改变数组 A 中的元素值，并计算此次操作结束数组 A 中偶数值之和。 简单题，先计算 A 中所有偶数之和。再每次 query 操作的时候，动态维护这个偶数之和即可。  代码 #  package leetcode func sumEvenAfterQueries(A []int, queries [][]int) []int { cur, res := 0, []int{} for _, v := range A { if v%2 == 0 { cur += v } } for _, q := range queries { if A[q[1]]%2 == 0 { cur -= A[q[1]] } A[q[1]] += q[0] if A[q[1]]%2 == 0 { cur += A[q[1]] } res = append(res, cur) } return res } "});index.add({'id':442,'href':'/leetcode-java/04_Leetcode/0986.Interval-List-Intersections/','title':"0986. Interval List Intersections",'section':"第四章",'content':"986. Interval List Intersections #  题目 #  Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\n(Formally, a closed interval [a, b] (with a \u0026lt;= b) denotes the set of real numbers x with a \u0026lt;= x \u0026lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)\nExample 1:\n Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. Note:\n 0 \u0026lt;= A.length \u0026lt; 1000 0 \u0026lt;= B.length \u0026lt; 1000 0 \u0026lt;= A[i].start, A[i].end, B[i].start, B[i].end \u0026lt; 10^9  Note: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n题目大意 #  这道题考察的是滑动窗口的问题。\n给出 2 个数组 A 和数组 B。要求求出这 2 个数组的交集数组。题意见图。\n解题思路 #  交集的左边界应该为，start := max(A[i].Start, B[j].Start)，右边界为，end := min(A[i].End, B[j].End)，如果 start \u0026lt;= end，那么这个就是一个满足条件的交集，放入最终数组中。如果 A[i].End \u0026lt;= B[j].End，代表 B 数组范围比 A 数组大，A 的游标右移。如果 A[i].End \u0026gt; B[j].End，代表 A 数组范围比 B 数组大，B 的游标右移。\n代码 #  package leetcode /** * Definition for an interval. * type Interval struct { *\tStart int *\tEnd int * } */ func intervalIntersection(A []Interval, B []Interval) []Interval { res := []Interval{} for i, j := 0, 0; i \u0026lt; len(A) \u0026amp;\u0026amp; j \u0026lt; len(B); { start := max(A[i].Start, B[j].Start) end := min(A[i].End, B[j].End) if start \u0026lt;= end { res = append(res, Interval{Start: start, End: end}) } if A[i].End \u0026lt;= B[j].End { i++ } else { j++ } } return res } "});index.add({'id':443,'href':'/leetcode-java/04_Leetcode/0990.Satisfiability-of-Equality-Equations/','title':"0990. Satisfiability of Equality Equations",'section':"第四章",'content':"990. Satisfiability of Equality Equations #  题目 #  Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: \u0026quot;a==b\u0026quot; or \u0026quot;a!=b\u0026quot;. Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.\nExample 1:\nInput: [\u0026quot;a==b\u0026quot;,\u0026quot;b!=a\u0026quot;] Output: false Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations.  Example 2:\nInput: [\u0026quot;b==a\u0026quot;,\u0026quot;a==b\u0026quot;] Output: true Explanation: We could assign a = 1 and b = 1 to satisfy both equations.  Example 3:\nInput: [\u0026quot;a==b\u0026quot;,\u0026quot;b==c\u0026quot;,\u0026quot;a==c\u0026quot;] Output: true  Example 4:\nInput: [\u0026quot;a==b\u0026quot;,\u0026quot;b!=c\u0026quot;,\u0026quot;c==a\u0026quot;] Output: false  Example 5:\nInput: [\u0026quot;c==c\u0026quot;,\u0026quot;b==d\u0026quot;,\u0026quot;x!=z\u0026quot;] Output: true  Note:\n 1 \u0026lt;= equations.length \u0026lt;= 500 equations[i].length == 4 equations[i][0] and equations[i][3] are lowercase letters equations[i][1] is either '=' or '!' equations[i][2] is '='  题目大意 #  给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\u0026ldquo;a==b\u0026rdquo; 或 \u0026ldquo;a!=b\u0026rdquo;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 提示：\n 1 \u0026lt;= equations.length \u0026lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 \u0026lsquo;='，要么是 \u0026lsquo;!\u0026rsquo; equations[i][2] 是 \u0026lsquo;=\u0026rsquo;  解题思路 #   给出一个字符串数组，数组里面给出的是一些字母的关系，只有 '==' 和 '! =' 两种关系。问给出的这些关系中是否存在悖论？ 这一题是简单的并查集的问题。先将所有 '==' 关系的字母 union() 起来，然后再一一查看 '! =' 关系中是否有 '==' 关系的组合，如果有，就返回 false，如果遍历完都没有找到，则返回 true。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func equationsPossible(equations []string) bool { if len(equations) == 0 { return false } uf := template.UnionFind{} uf.Init(26) for _, equ := range equations { if equ[1] == \u0026#39;=\u0026#39; \u0026amp;\u0026amp; equ[2] == \u0026#39;=\u0026#39; { uf.Union(int(equ[0]-\u0026#39;a\u0026#39;), int(equ[3]-\u0026#39;a\u0026#39;)) } } for _, equ := range equations { if equ[1] == \u0026#39;!\u0026#39; \u0026amp;\u0026amp; equ[2] == \u0026#39;=\u0026#39; { if uf.Find(int(equ[0]-\u0026#39;a\u0026#39;)) == uf.Find(int(equ[3]-\u0026#39;a\u0026#39;)) { return false } } } return true } "});index.add({'id':444,'href':'/leetcode-java/04_Leetcode/0992.Subarrays-with-K-Different-Integers/','title':"0992. Subarrays With K Different Integers",'section':"第四章",'content':"992. Subarrays with K Different Integers #  题目 #  Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\n(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\nReturn the number of good subarrays of A.\nExample 1:\n Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Example 2:\n Input: A = [1,2,1,3,4], K = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Note:\n 1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= A.length 1 \u0026lt;= K \u0026lt;= A.length  题目大意 #  这道题考察的是滑动窗口的问题。\n给出一个数组 和 K，K 代表窗口能能包含的不同数字的个数。K = 2 代表窗口内只能有 2 个不同的数字。求数组中满足条件 K 的窗口个数。\n解题思路 #  如果只是单纯的滑动窗口去做，会错过一些解。比如在例子 1 中，滑动窗口可以得到 [1,2], [1,2,1], [1,2,1,2], [2,1,2], [1,2], [2,3], 会少 [2,1] 这个解，原因是右边窗口滑动到最右边了，左边窗口在缩小的过程中，右边窗口不会再跟着动了。有同学可能会说，每次左边窗口移动的时候，右边窗口都再次从左边窗口的位置开始重新滑动。这样做确实可以，但是这样做完会发现超时。因为中间包含大量的重复计算。\n这道题就需要第 3 个指针。原有滑动窗口的 2 个指针，右窗口保留这个窗口里面最长的子数组，正好有 K 个元素，左窗口右移的逻辑不变。再多用一个指针用来标识正好有 K - 1 个元素的位置。那么正好有 K 个不同元素的解就等于 ans = atMostK(A, K) - atMostK(A, K - 1)。最多有 K 个元素减去最多有 K - 1 个元素得到的窗口中正好有 K 个元素的解。\n以例子 1 为例，先求最多有 K 个元素的窗口个数。\n[1] [1,2], [2] [1,2,1], [2,1], [1] [1,2,1,2], [2,1,2], [1,2], [2] [2,3], [3] 每当窗口滑动到把 K 消耗为 0 的时候，res = right - left + 1 。为什么要这么计算，right - left + 1 代表的含义是，终点为 right，至多为 K 个元素的窗口有多少个。[left,right], [left + 1,right], [left + 2,right] …… [right,right]。这样算出来的解是包含这道题最终求得的解的，还多出了一部分解。多出来的部分减掉即可，即减掉最多为 K - 1 个元素的解。\n最多为 K - 1 个元素的解如下：\n[1] [2] [1] [2] [3] 两者相减以后得到的结果就是最终结果：\n[1,2] [1,2,1], [2,1] [1,2,1,2], [2,1,2], [1,2] [2,3] 代码 #  package leetcode func subarraysWithKDistinct(A []int, K int) int { return subarraysWithKDistinctSlideWindow(A, K) - subarraysWithKDistinctSlideWindow(A, K-1) } func subarraysWithKDistinctSlideWindow(A []int, K int) int { left, right, counter, res, freq := 0, 0, K, 0, map[int]int{} for right = 0; right \u0026lt; len(A); right++ { if freq[A[right]] == 0 { counter-- } freq[A[right]]++ for counter \u0026lt; 0 { freq[A[left]]-- if freq[A[left]] == 0 { counter++ } left++ } res += right - left + 1 } return res } "});index.add({'id':445,'href':'/leetcode-java/04_Leetcode/0993.Cousins-in-Binary-Tree/','title':"0993. Cousins in Binary Tree",'section':"第四章",'content':"993. 二叉树的堂兄弟节点 #  Difficulty: 简单\n在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n如果二叉树的两个节点深度相同，但父节点不同，则它们是一对_堂兄弟节点_。\n我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。\n示例 1：\n\n输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2：\n\n输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3：\n \n输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示：\n 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。  题解 #  题解一：DFS（广度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { Map\u0026lt;Integer, Integer\u0026gt; depthMap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, TreeNode\u0026gt; parentMap = new HashMap\u0026lt;\u0026gt;(); public boolean isCousins(TreeNode root, int x, int y) { helper(root, null); return (depthMap.get(x) == depthMap.get(y)) \u0026amp;\u0026amp; (parentMap.get(x) != parentMap.get(y)); } private void helper(TreeNode node, TreeNode parent) { if (node == null) { return; } depthMap.put(node.val, parent == null ? 0 : depthMap.get(parent.val) + 1); parentMap.put(node.val, parent); helper(node.left, node); helper(node.right, node); } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(N)。\n  "});index.add({'id':446,'href':'/leetcode-java/04_Leetcode/0995.Minimum-Number-of-K-Consecutive-Bit-Flips/','title':"0995. Minimum Number of K Consecutive Bit Flips",'section':"第四章",'content':"995. Minimum Number of K Consecutive Bit Flips #  题目 #  In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\nExample 1:\nInput: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2].  Example 2:\nInput: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].  Example 3:\nInput: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]  Note:\n 1 \u0026lt;= A.length \u0026lt;= 30000 1 \u0026lt;= K \u0026lt;= A.length  题目大意 #  在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 30000 1 \u0026lt;= K \u0026lt;= A.length  解题思路 #    给出一个数组，数组里面的元素只有 0 和 1。给一个长度为 K 的窗口，在这个窗口内的所有元素都会 0-1 翻转。问最后需要翻转几次，使得整个数组都为 1 。如果不能翻转使得最后数组元素都为 1，则输出 -1。\n  拿到这一题首先想到的是贪心算法。例如第 765 题，这类题的描述都是这样的：在一个数组中或者环形数组中通过交换位置，或者翻转变换，达到最终结果，要求找到最少步数。贪心能保证是最小步数(证明略)。按照贪心的思想，这一题也这样做，从数组 0 下标开始往后扫，依次翻转每个 K 大小的窗口内元素。\n  由于窗口大小限制了，所以这题滑动窗口只需要一个边界坐标，用左边界就可以判断了。每一个 A[i] 是否需要翻转，是由于 [ i-k+1，i ]、[ i-k+2，i+1 ]、[ i-k+3，i+2 ]……[ i-1，i+k ] 这一系列的窗口翻转累积影响的。那如何之前这些窗口累积到 A[i] 上翻转的次数呢？可以动态的维护一个翻转次数，当 i 摆脱了上一次翻转窗口 K 的时候，翻转次数就 -1 。举个例子：\n A = [0 0 0 1 0 1 1 0] K = 3 A = [2 0 0 1 0 1 1 0] i = 0 flippedTime = 1 A = [2 0 0 1 0 1 1 0] i = 1 flippedTime = 1 A = [2 0 0 1 0 1 1 0] i = 2 flippedTime = 1 A = [2 0 0 1 0 1 1 0] i = 3 flippedTime = 0 A = [2 0 0 1 2 1 1 0] i = 4 flippedTime = 1 A = [2 0 0 1 2 2 1 0] i = 5 flippedTime = 2 A = [2 0 0 1 2 2 1 0] i = 6 flippedTime = 2 A = [2 0 0 1 2 2 1 0] i = 7 flippedTime = 1  当判断 A[i] 是否需要翻转的时候，只需要留意每个宽度为 K 窗口的左边界。会影响到 A[i] 的窗口的左边界分别是 i-k+1、i-k+2、i-k+3、…… i-1，只需要分别看这些窗口有没有翻转就行。这里可以用特殊标记来记录这些窗口的左边界是否被翻转了。如果翻转过，则把窗口左边界的那个数字标记为 2 (为什么要标记为 2 呢？其实设置成什么都可以，只要不是 0 和 1 ，和原有的数字区分开就行)。当 i≥k 的时候，代表 i 已经脱离了 i-k 的这个窗口，因为能影响 A[i] 的窗口是从 i-k+1 开始的，如果 A[i-k] == 2 代表 i-k 窗口已经翻转过了，现在既然脱离了它的窗口影响，那么就要把累积的 flippedTime - 1 。这样就维护了累积 flippedTime 和滑动窗口中累积影响的关系。\n  接下来还需要处理的是 flippedTime 与当前 A[i] 是否翻转的问题。如果 flippedTime 是偶数次，原来的 0 还是 0，就需要再次翻转，如果 flippedTime 是奇数次，原来的 0 变成了 1 就不需要翻转了。总结成一条结论就是 A[i] 与 flippedTime 同奇偶性的时候就要翻转。当 i + K 比 len(A) 大的时候，代表剩下的这些元素肯定不能在一个窗口里面翻转，则输出 -1 。\n  代码 #  package leetcode func minKBitFlips(A []int, K int) int { flippedTime, count := 0, 0 for i := 0; i \u0026lt; len(A); i++ { if i \u0026gt;= K \u0026amp;\u0026amp; A[i-K] == 2 { flippedTime-- } // 下面这个判断包含了两种情况： \t// 如果 flippedTime 是奇数，且 A[i] == 1 就需要翻转 \t// 如果 flippedTime 是偶数，且 A[i] == 0 就需要翻转 \tif flippedTime%2 == A[i] { if i+K \u0026gt; len(A) { return -1 } A[i] = 2 flippedTime++ count++ } } return count } "});index.add({'id':447,'href':'/leetcode-java/04_Leetcode/0996.Number-of-Squareful-Arrays/','title':"0996. Number of Squareful Arrays",'section':"第四章",'content':"996. Number of Squareful Arrays #  题目 #  Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.\nReturn the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].\nExample 1:\nInput: [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations.  Example 2:\nInput: [2,2,2] Output: 1  Note:\n 1 \u0026lt;= A.length \u0026lt;= 12 0 \u0026lt;= A[i] \u0026lt;= 1e9  题目大意 #  给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。\n返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。\n解题思路 #   这一题是第 47 题的加强版。第 47 题要求求出一个数组的所有不重复的排列。这一题要求求出一个数组的所有不重复，且相邻两个数字之和都为完全平方数的排列。 思路和第 47 题完全一致，只不过增加判断相邻两个数字之和为完全平方数的判断，注意在 DFS 的过程中，需要剪枝，否则时间复杂度很高，会超时。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) func numSquarefulPerms(A []int) int { if len(A) == 0 { return 0 } used, p, res := make([]bool, len(A)), []int{}, [][]int{} sort.Ints(A) // 这里是去重的关键逻辑 \tgeneratePermutation996(A, 0, p, \u0026amp;res, \u0026amp;used) return len(res) } func generatePermutation996(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { checkSquareful := true for i := 0; i \u0026lt; len(p)-1; i++ { if !checkSquare(p[i] + p[i+1]) { checkSquareful = false break } } if checkSquareful { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) } return } for i := 0; i \u0026lt; len(nums); i++ { if !(*used)[i] { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !(*used)[i-1] { // 这里是去重的关键逻辑 \tcontinue } if len(p) \u0026gt; 0 \u0026amp;\u0026amp; !checkSquare(nums[i]+p[len(p)-1]) { // 关键的剪枝条件 \tcontinue } (*used)[i] = true p = append(p, nums[i]) generatePermutation996(nums, index+1, p, res, used) p = p[:len(p)-1] (*used)[i] = false } } return } func checkSquare(num int) bool { tmp := math.Sqrt(float64(num)) if int(tmp)*int(tmp) == num { return true } return false } "});index.add({'id':448,'href':'/leetcode-java/04_Leetcode/0997.Squares-Of-A-Sorted-Array/','title':"0997. Squares of a Sorted Array",'section':"第四章",'content':"977. 有序数组的平方 #  Difficulty: 简单\n给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n示例 1：\n输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：\n输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示：\n 1 \u0026lt;= A.length \u0026lt;= 10000 -10000 \u0026lt;= A[i] \u0026lt;= 10000 A 已按非递减顺序排序。  题解 #  题解一：直接排序 #  class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; for (int i = 0; i \u0026lt; nums.length; i++) { result[i] = nums[i] * nums[i]; } Arrays.sort(result); return result; } } 复杂度分析 #    时间复杂度：O(nlogn)，其中 n 是数组 A 的长度。\n  空间复杂度：O(logn)。\n  解法二：双指针解法 #  class Solution { public int[] sortedSquares(int[] A) { int n = A.length; int negative = -1; for (int i = 0; i \u0026lt; n; ++i) { if (A[i] \u0026lt; 0) { negative = i; } else { break; } } int[] ans = new int[n]; int index = 0, i = negative, j = negative + 1; while (i \u0026gt;= 0 || j \u0026lt; n) { if (i \u0026lt; 0) { ans[index] = A[j] * A[j]; ++j; } else if (j == n) { ans[index] = A[i] * A[i]; --i; } else if (A[i] * A[i] \u0026lt; A[j] * A[j]) { ans[index] = A[i] * A[i]; --i; } else { ans[index] = A[j] * A[j]; ++j; } ++index; } return ans; } } 复杂度分析 #    时间复杂度：O(n)，其中 n 是数组 A 的长度。\n  空间复杂度：O(1)。\n  题解三：双指针解法 #  class Solution { public int[] sortedSquares(int[] A) { int[] result = new int[A.length]; for (int i = 0, j = A.length - 1, pos = A.length - 1; i \u0026lt;= j; pos--) { if (A[i] * A[i] \u0026gt; A[j] * A[j]) { result[pos] = A[i] * A[i]; i++; } else { result[pos] = A[j] * A[j]; j--; } } return result; } } 复杂度分析 #    时间复杂度：O(n)，其中 n 是数组 A 的长度。\n  空间复杂度：O(1)。\n  "});index.add({'id':449,'href':'/leetcode-java/04_Leetcode/0998.Maximum-Binary-Tree-II/','title':"0998. Maximum Binary Tree I I",'section':"第四章",'content':"998. 最大二叉树 II #  Difficulty: 中等\n最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。\n给出最大树的根节点 root。\n就像那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：\n 如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]]) root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) 返回 root  请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).\n假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。\n返回 Construct(B)。\n示例 1：\n \n输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2] 解释：A = [1,4,2,3], B = [1,4,2,3,5] 示例 2：\n\n输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3] 解释：A = [2,1,5,4], B = [2,1,5,4,3] 示例 3：\n\n输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3] 解释：A = [2,1,5,3], B = [2,1,5,3,4] 提示：\n 1 \u0026lt;= B.length \u0026lt;= 100  题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode insertIntoMaxTree(TreeNode root, int val) { if(root == null || root.val \u0026lt; val) { TreeNode tmp = new TreeNode(val); tmp.left = root; return tmp; } TreeNode right = insertIntoMaxTree(root.right,val); root.right = right; return root; } } "});index.add({'id':450,'href':'/leetcode-java/04_Leetcode/0999.Available-Captures-for-Rook/','title':"0999. Available Captures for Rook",'section':"第四章",'content':"999. Available Captures for Rook #  题目 #  On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters \u0026lsquo;R\u0026rsquo;, \u0026lsquo;.\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, and \u0026lsquo;p\u0026rsquo; respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.\nThe rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies. Also, rooks cannot move into the same square as other friendly bishops.\nReturn the number of pawns the rook can capture in one move.\nExample 1:\n Input: [[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]] Output: 3 Explanation: In this example the rook is able to capture all the pawns. Example 2:\n Input: [[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]] Output: 0 Explanation: Bishops are blocking the rook to capture any pawn. Example 3:\n Input: [[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]] Output: 3 Explanation: The rook can capture the pawns at positions b5, d6 and f5. Note:\n board.length == board[i].length == 8 board[i][j] is either 'R', '.', 'B', or 'p' There is exactly one cell with board[i][j] == 'R'  题目大意 #  在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 \u0026lsquo;R\u0026rsquo; 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 \u0026lsquo;.'，\u0026lsquo;B\u0026rsquo; 和 \u0026lsquo;p\u0026rsquo; 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：\n 棋手选择主动停下来。 棋子因到达棋盘的边缘而停下。 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。  你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。\n解题思路 #   按照国际象棋的规则移动车，要求输出只移动一次，有多少个卒在车的捕获范围之内 简单题，按照国际象棋车的移动规则， 4 个方向分别枚举即可。  代码 #  package leetcode func numRookCaptures(board [][]byte) int { num := 0 for i := 0; i \u0026lt; len(board); i++ { for j := 0; j \u0026lt; len(board[i]); j++ { if board[i][j] == \u0026#39;R\u0026#39; { num += caputure(board, i-1, j, -1, 0) // Up \tnum += caputure(board, i+1, j, 1, 0) // Down \tnum += caputure(board, i, j-1, 0, -1) // Left \tnum += caputure(board, i, j+1, 0, 1) // Right \t} } } return num } func caputure(board [][]byte, x, y int, bx, by int) int { for x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(board) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(board[x]) \u0026amp;\u0026amp; board[x][y] != \u0026#39;B\u0026#39; { if board[x][y] == \u0026#39;p\u0026#39; { return 1 } x += bx y += by } return 0 } "});index.add({'id':451,'href':'/leetcode-java/04_Leetcode/1002.Find-Common-Characters/','title':"1002. Find Common Characters",'section':"第四章",'content':"1002. Find Common Characters #  题目 #  Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.\nYou may return the answer in any order.\nExample 1:\nInput: [\u0026quot;bella\u0026quot;,\u0026quot;label\u0026quot;,\u0026quot;roller\u0026quot;] Output: [\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;]  Example 2:\nInput: [\u0026quot;cool\u0026quot;,\u0026quot;lock\u0026quot;,\u0026quot;cook\u0026quot;] Output: [\u0026quot;c\u0026quot;,\u0026quot;o\u0026quot;]  Note:\n 1 \u0026lt;= A.length \u0026lt;= 100 1 \u0026lt;= A[i].length \u0026lt;= 100 A[i][j] is a lowercase letter  题目大意 #  给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。你可以按任意顺序返回答案。\n解题思路 #   简单题。给出一个字符串数组 A，要求找出这个数组中每个字符串都包含字符，如果字符出现多次，在最终结果中也需要出现多次。这一题可以用 map 来统计每个字符串的频次，但是如果用数组统计会更快。题目中说了只有小写字母，那么用 2 个 26 位长度的数组就可以统计出来了。遍历字符串数组的过程中，不过的缩小每个字符在每个字符串中出现的频次(因为需要找所有字符串公共的字符，公共的频次肯定就是最小的频次)，得到了最终公共字符的频次数组以后，按顺序输出就可以了。  代码 #  package leetcode import \u0026#34;math\u0026#34; func commonChars(A []string) []string { cnt := [26]int{} for i := range cnt { cnt[i] = math.MaxUint16 } cntInWord := [26]int{} for _, word := range A { for _, char := range []byte(word) { // compiler trick - here we will not allocate new memory \tcntInWord[char-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; 26; i++ { // 缩小频次，使得统计的公共频次更加准确 \tif cntInWord[i] \u0026lt; cnt[i] { cnt[i] = cntInWord[i] } } // 重置状态 \tfor i := range cntInWord { cntInWord[i] = 0 } } result := make([]string, 0) for i := 0; i \u0026lt; 26; i++ { for j := 0; j \u0026lt; cnt[i]; j++ { result = append(result, string(i+\u0026#39;a\u0026#39;)) } } return result } "});index.add({'id':452,'href':'/leetcode-java/04_Leetcode/1003.Check-If-Word-Is-Valid-After-Substitutions/','title':"1003. Check if Word Is Valid After Substitutions",'section':"第四章",'content':"1003. Check If Word Is Valid After Substitutions #  题目 #  We are given that the string \u0026ldquo;abc\u0026rdquo; is valid.\nFrom any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + \u0026ldquo;abc\u0026rdquo; + Y is also valid.\nIf for example S = \u0026ldquo;abc\u0026rdquo;, then examples of valid strings are: \u0026ldquo;abc\u0026rdquo;, \u0026ldquo;aabcbc\u0026rdquo;, \u0026ldquo;abcabc\u0026rdquo;, \u0026ldquo;abcabcababcc\u0026rdquo;. Examples of invalid strings are: \u0026ldquo;abccba\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;cababc\u0026rdquo;, \u0026ldquo;bac\u0026rdquo;.\nReturn true if and only if the given string S is valid.\nExample 1:\n Input: \u0026quot;aabcbc\u0026quot; Output: true Explanation: We start with the valid string \u0026quot;abc\u0026quot;. Then we can insert another \u0026quot;abc\u0026quot; between \u0026quot;a\u0026quot; and \u0026quot;bc\u0026quot;, resulting in \u0026quot;a\u0026quot; + \u0026quot;abc\u0026quot; + \u0026quot;bc\u0026quot; which is \u0026quot;aabcbc\u0026quot;. Example 2:\n Input: \u0026quot;abcabcababcc\u0026quot; Output: true Explanation: \u0026quot;abcabcabc\u0026quot; is valid after consecutive insertings of \u0026quot;abc\u0026quot;. Then we can insert \u0026quot;abc\u0026quot; before the last letter, resulting in \u0026quot;abcabcab\u0026quot; + \u0026quot;abc\u0026quot; + \u0026quot;c\u0026quot; which is \u0026quot;abcabcababcc\u0026quot;. Example 3:\n Input: \u0026quot;abccba\u0026quot; Output: false Example 4:\n Input: \u0026quot;cababc\u0026quot; Output: false Note:\n 1 \u0026lt;= S.length \u0026lt;= 20000 S[i] is \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, or \u0026lsquo;c\u0026rsquo;  题目大意 #  假设 abc 是有效的字符串，对于任何 字符串 V，如果用 abc 把字符串 V 切成 2 半，X 和 Y，组成 X + abc + Y 的字符串，X + abc + Y 的这个字符串依旧是有效的。X 和 Y 可以是空字符串。\n例如，\u0026ldquo;abc\u0026rdquo;( \u0026quot;\u0026quot; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;\u0026quot;), \u0026ldquo;aabcbc\u0026rdquo;( \u0026ldquo;a\u0026rdquo; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;bc\u0026rdquo;), \u0026ldquo;abcabc\u0026rdquo;( \u0026quot;\u0026rdquo; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;abc\u0026rdquo;), \u0026ldquo;abcabcababcc\u0026rdquo;( \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;ababcc\u0026rdquo;，其中 \u0026ldquo;ababcc\u0026rdquo; 也是有效的，\u0026ldquo;ab\u0026rdquo; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;c\u0026rdquo;) 都是有效的字符串。\n\u0026ldquo;abccba\u0026rdquo;( \u0026quot;\u0026quot; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;cba\u0026rdquo;，\u0026ldquo;cba\u0026rdquo; 不是有效的字符串), \u0026ldquo;ab\u0026rdquo;(\u0026ldquo;ab\u0026rdquo; 也不是有效字符串), \u0026ldquo;cababc\u0026rdquo;(\u0026ldquo;c\u0026rdquo; + \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;bc\u0026rdquo;，\u0026ldquo;c\u0026rdquo;，\u0026ldquo;bc\u0026rdquo; 都不是有效字符串), \u0026ldquo;bac\u0026rdquo; (\u0026ldquo;bac\u0026rdquo; 也不是有效字符串)这些都不是有效的字符串。\n任意给一个字符串 S ，要求判断它是否有效，如果有效则输出 true。\n解题思路 #  这一题可以类似括号匹配问题，因为 \u0026ldquo;abc\u0026rdquo; 这样的组合就代表是有效的，类似于括号匹配，遇到 \u0026ldquo;a\u0026rdquo; 就入栈，当遇到 \u0026ldquo;b\u0026rdquo; 字符的时候判断栈顶是不是 \u0026ldquo;a\u0026rdquo;，当遇到 \u0026ldquo;c\u0026rdquo; 字符的时候需要判断栈顶是不是 \u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo;。最后如果栈都清空了，就输出 true。\n代码 #  package leetcode func isValid1003(S string) bool { if len(S) \u0026lt; 3 { return false } stack := []byte{} for i := 0; i \u0026lt; len(S); i++ { if S[i] == \u0026#39;a\u0026#39; { stack = append(stack, S[i]) } else if S[i] == \u0026#39;b\u0026#39; { if len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;a\u0026#39; { stack = append(stack, S[i]) } else { return false } } else { if len(stack) \u0026gt; 1 \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-2] == \u0026#39;a\u0026#39; { stack = stack[:len(stack)-2] } else { return false } } } return len(stack) == 0 } "});index.add({'id':453,'href':'/leetcode-java/04_Leetcode/1004.Max-Consecutive-Ones-III/','title':"1004. Max Consecutive Ones I I I",'section':"第四章",'content':"1004. Max Consecutive Ones III #  题目 #  Given an array A of 0s and 1s, we may change up to K values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s.\nExample 1:\n Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2:\n Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 Output: 10 Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Note:\n 1 \u0026lt;= A.length \u0026lt;= 20000 0 \u0026lt;= K \u0026lt;= A.length A[i] is 0 or 1  题目大意 #  这道题考察的是滑动窗口的问题。\n给出一个数组，数组中元素只包含 0 和 1 。再给一个 K，代表能将 0 变成 1 的次数。要求出经过变换以后，1 连续的最长长度。\n解题思路 #  按照滑动窗口的思路处理即可，不断的更新和维护最大长度。\n代码 #  package leetcode func longestOnes(A []int, K int) int { res, left, right := 0, 0, 0 for left \u0026lt; len(A) { if right \u0026lt; len(A) \u0026amp;\u0026amp; ((A[right] == 0 \u0026amp;\u0026amp; K \u0026gt; 0) || A[right] == 1) { if A[right] == 0 { K-- } right++ } else { if K == 0 || (right == len(A) \u0026amp;\u0026amp; K \u0026gt; 0) { res = max(res, right-left) } if A[left] == 0 { K++ } left++ } } return res } "});index.add({'id':454,'href':'/leetcode-java/04_Leetcode/1005.Maximize-Sum-Of-Array-After-K-Negations/','title':"1005. Maximize Sum of Array After K Negations",'section':"第四章",'content':"1005. Maximize Sum Of Array After K Negations #  题目 #  Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total. (We may choose the same index i multiple times.)\nReturn the largest possible sum of the array after modifying it in this way.\nExample 1:\n Input: A = [4,2,3], K = 1 Output: 5 Explanation: Choose indices (1,) and A becomes [4,-2,3]. Example 2:\n Input: A = [3,-1,0,2], K = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2]. Example 3:\n Input: A = [2,-3,-1,5,-4], K = 2 Output: 13 Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4]. Note:\n 1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= K \u0026lt;= 10000 -100 \u0026lt;= A[i] \u0026lt;= 100  题目大意 #  将数组中的元素变成它的相反数，这种操作执行 K 次之后，求出数组中所有元素的总和最大。\n解题思路 #  这一题可以用最小堆来做，构建最小堆，每次将最小的元素变成它的相反数。然后最小堆调整，再将新的最小元素变成它的相反数。执行 K 次以后求数组中所有的值之和就是最大值。\n这道题也可以用排序来实现。排序一次，从最小值开始往后扫，依次将最小值变为相反数。这里需要注意一点，负数都改变成正数以后，接着不是再改变这些变成正数的负数，而是接着改变顺序的正数。因为这些正数是比较小的正数。负数越小，变成正数以后值越大。正数越小，变成负数以后对总和影响最小。具体实现见代码。\n代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func largestSumAfterKNegations(A []int, K int) int { sort.Ints(A) minIdx := 0 for i := 0; i \u0026lt; K; i++ { A[minIdx] = -A[minIdx] if A[minIdx+1] \u0026lt; A[minIdx] { minIdx++ } } sum := 0 for _, a := range A { sum += a } return sum } "});index.add({'id':455,'href':'/leetcode-java/04_Leetcode/1011.Capacity-To-Ship-Packages-Within-D-Days/','title':"1011. Capacity to Ship Packages Within D Days",'section':"第四章",'content':"1011. Capacity To Ship Packages Within D Days #  题目 #  A conveyor belt has packages that must be shipped from one port to another within D days.\nThe i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\nExample 1:\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.  Example 2:\nInput: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4  Example 3:\nInput: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation: 1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1  Note:\n 1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 50000 1 \u0026lt;= weights[i] \u0026lt;= 500  题目大意 #  传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。\n提示：\n 1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 50000 1 \u0026lt;= weights[i] \u0026lt;= 500  解题思路 #   给出一个数组和天数 D，要求正好在 D 天把数组中的货物都运完。求传输带上能承受的最小货物重量是多少。 这一题和第 410 题完全一样，只不过换了一个题面。代码完全不变。思路解析见第 410 题。  代码 #  package leetcode func shipWithinDays(weights []int, D int) int { maxNum, sum := 0, 0 for _, num := range weights { sum += num if num \u0026gt; maxNum { maxNum = num } } if D == 1 { return sum } low, high := maxNum, sum for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calSum(mid, D, weights) { high = mid } else { low = mid + 1 } } return low } "});index.add({'id':456,'href':'/leetcode-java/04_Leetcode/1017.Convert-to-Base-2/','title':"1017. Convert to Base 2",'section':"第四章",'content':"1017. Convert to Base -2 #  题目 #  Given a number N, return a string consisting of \u0026quot;0\u0026quot;s and \u0026quot;1\u0026quot;s that represents its value in base -2 (negative two).\nThe returned string must have no leading zeroes, unless the string is \u0026quot;0\u0026quot;.\nExample 1:\nInput: 2 Output: \u0026quot;110\u0026quot; Explantion: (-2) ^ 2 + (-2) ^ 1 = 2  Example 2:\nInput: 3 Output: \u0026quot;111\u0026quot; Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3  Example 3:\nInput: 4 Output: \u0026quot;100\u0026quot; Explantion: (-2) ^ 2 = 4  Note:\n 0 \u0026lt;= N \u0026lt;= 10^9  题目大意 #  给出数字 N，返回由若干 \u0026ldquo;0\u0026rdquo; 和 \u0026ldquo;1\u0026quot;组成的字符串，该字符串为 N 的负二进制（base -2）表示。除非字符串就是 \u0026ldquo;0\u0026rdquo;，否则返回的字符串中不能含有前导零。\n提示：\n 0 \u0026lt;= N \u0026lt;= 10^9  解题思路 #   给出一个十进制的数，要求转换成 -2 进制的数 这一题仿造十进制转二进制的思路，短除法即可。  代码 #  package leetcode import \u0026#34;strconv\u0026#34; func baseNeg2(N int) string { if N == 0 { return \u0026#34;0\u0026#34; } res := \u0026#34;\u0026#34; for N != 0 { remainder := N % (-2) N = N / (-2) if remainder \u0026lt; 0 { remainder += 2 N++ } res = strconv.Itoa(remainder) + res } return res } "});index.add({'id':457,'href':'/leetcode-java/04_Leetcode/1019.Next-Greater-Node-In-Linked-List/','title':"1019. Next Greater Node in Linked List",'section':"第四章",'content':"1019. Next Greater Node In Linked List #  题目 #  We are given a linked list with head as the first node. Let\u0026rsquo;s number the nodes in the list: node_1, node_2, node_3, \u0026hellip; etc.\nEach node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j \u0026gt; i, node_j.val \u0026gt; node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0.\nReturn an array of integers answer, where answer[i] = next_larger(node_{i+1}).\nNote that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5.\nExample 1:\n Input: [2,1,5] Output: [5,5,0] Example 2:\n Input: [2,7,4,3,5] Output: [7,0,5,5,0] Example 3:\n Input: [1,7,5,1,9,2,5,1] Output: [7,9,9,9,0,5,0,0] Note:\n 1 \u0026lt;= node.val \u0026lt;= 10^9 for each node in the linked list. The given list has length in the range [0, 10000].  题目大意 #  给出一个链表，要求找出每个结点后面比该结点值大的第一个结点，如果找不到这个结点，则输出 0 。\n解题思路 #  这一题和第 739 题、第 496 题、第 503 题类似。也有 2 种解题方法。先把链表中的数字存到数组中，整道题的思路就和第 739 题完全一致了。普通做法就是 2 层循环。优化的做法就是用单调栈，维护一个单调递减的栈即可。\n代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 单调栈 func nextLargerNodes(head *ListNode) []int { res, indexes, nums := make([]int, 0), make([]int, 0), make([]int, 0) p := head for p != nil { nums = append(nums, p.Val) p = p.Next } for i := 0; i \u0026lt; len(nums); i++ { res = append(res, 0) } for i := 0; i \u0026lt; len(nums); i++ { num := nums[i] for len(indexes) \u0026gt; 0 \u0026amp;\u0026amp; nums[indexes[len(indexes)-1]] \u0026lt; num { index := indexes[len(indexes)-1] res[index] = num indexes = indexes[:len(indexes)-1] } indexes = append(indexes, i) } return res } "});index.add({'id':458,'href':'/leetcode-java/04_Leetcode/1020.Number-of-Enclaves/','title':"1020. Number of Enclaves",'section':"第四章",'content':"1020. Number of Enclaves #  题目 #  Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)\nA move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.\nReturn the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.\nExample 1:\nInput: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary. Example 2:\nInput: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. Note:\n 1 \u0026lt;= A.length \u0026lt;= 500 1 \u0026lt;= A[i].length \u0026lt;= 500 0 \u0026lt;= A[i][j] \u0026lt;= 1 All rows have the same size.  题目大意 #  给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。\n提示：\n 1 \u0026lt;= A.length \u0026lt;= 500 1 \u0026lt;= A[i].length \u0026lt;= 500 0 \u0026lt;= A[i][j] \u0026lt;= 1 所有行的大小都相同  解题思路 #   给出一个地图，要求输出不和边界连通的 1 的个数。 这一题可以用 DFS 也可以用并查集解答。DFS 的思路是深搜的过程中把和边界连通的点都覆盖成 0，最后遍历一遍地图，输出 1 的个数即可。并查集的思路就比较直接了，把能和边界连通的放在一个集合中，剩下的就是不能和边界连通的都在另外一个集合中，输出这个集合里面元素的个数即可。 这一题和第 200 题，第 1254 题，第 695 题类似。可以放在一起练习。  代码 #  func numEnclaves(A [][]int) int { m, n := len(A), len(A[0]) for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if i == 0 || i == m-1 || j == 0 || j == n-1 { if A[i][j] == 1 { dfsNumEnclaves(A, i, j) } } } } count := 0 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if A[i][j] == 1 { count++ } } } return count } func dfsNumEnclaves(A [][]int, x, y int) { if !isInGrid(A, x, y) || A[x][y] == 0 { return } A[x][y] = 0 for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] dfsNumEnclaves(A, nx, ny) } } "});index.add({'id':459,'href':'/leetcode-java/04_Leetcode/1021.Remove-Outermost-Parentheses/','title':"1021. Remove Outermost Parentheses",'section':"第四章",'content':"1021. Remove Outermost Parentheses #  题目 #  A valid parentheses string is either empty (\u0026quot;\u0026quot;), \u0026ldquo;(\u0026rdquo; + A + \u0026ldquo;)\u0026rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \u0026ldquo;\u0026rdquo;, \u0026ldquo;()\u0026rdquo;, \u0026ldquo;(())()\u0026rdquo;, and \u0026ldquo;(()(()))\u0026rdquo; are all valid parentheses strings.\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + \u0026hellip; + P_k, where P_i are primitive valid parentheses strings.\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\nExample 1:\n Input: \u0026quot;(()())(())\u0026quot; Output: \u0026quot;()()()\u0026quot; Explanation: The input string is \u0026quot;(()())(())\u0026quot;, with primitive decomposition \u0026quot;(()())\u0026quot; + \u0026quot;(())\u0026quot;. After removing outer parentheses of each part, this is \u0026quot;()()\u0026quot; + \u0026quot;()\u0026quot; = \u0026quot;()()()\u0026quot;. Example 2:\n Input: \u0026quot;(()())(())(()(()))\u0026quot; Output: \u0026quot;()()()()(())\u0026quot; Explanation: The input string is \u0026quot;(()())(())(()(()))\u0026quot;, with primitive decomposition \u0026quot;(()())\u0026quot; + \u0026quot;(())\u0026quot; + \u0026quot;(()(()))\u0026quot;. After removing outer parentheses of each part, this is \u0026quot;()()\u0026quot; + \u0026quot;()\u0026quot; + \u0026quot;()(())\u0026quot; = \u0026quot;()()()()(())\u0026quot;. Example 3:\n Input: \u0026quot;()()\u0026quot; Output: \u0026quot;\u0026quot; Explanation: The input string is \u0026quot;()()\u0026quot;, with primitive decomposition \u0026quot;()\u0026quot; + \u0026quot;()\u0026quot;. After removing outer parentheses of each part, this is \u0026quot;\u0026quot; + \u0026quot;\u0026quot; = \u0026quot;\u0026quot;. Note:\n S.length \u0026lt;= 10000 S[i] is \u0026ldquo;(\u0026rdquo; or \u0026ldquo;)\u0026rdquo; S is a valid parentheses string  题目大意 #  题目要求去掉最外层的括号。\n解题思路 #  用栈模拟即可。\n代码 #  package leetcode // 解法一 func removeOuterParentheses(S string) string { now, current, ans := 0, \u0026#34;\u0026#34;, \u0026#34;\u0026#34; for _, char := range S { if string(char) == \u0026#34;(\u0026#34; { now++ } else if string(char) == \u0026#34;)\u0026#34; { now-- } current += string(char) if now == 0 { ans += current[1 : len(current)-1] current = \u0026#34;\u0026#34; } } return ans } // 解法二 func removeOuterParentheses1(S string) string { stack, res, counter := []byte{}, \u0026#34;\u0026#34;, 0 for i := 0; i \u0026lt; len(S); i++ { if counter == 0 \u0026amp;\u0026amp; len(stack) == 1 \u0026amp;\u0026amp; S[i] == \u0026#39;)\u0026#39; { stack = stack[1:] continue } if len(stack) == 0 \u0026amp;\u0026amp; S[i] == \u0026#39;(\u0026#39; { stack = append(stack, S[i]) continue } if len(stack) \u0026gt; 0 { switch S[i] { case \u0026#39;(\u0026#39;: { counter++ res += \u0026#34;(\u0026#34; } case \u0026#39;)\u0026#39;: { counter-- res += \u0026#34;)\u0026#34; } } } } return res } "});index.add({'id':460,'href':'/leetcode-java/04_Leetcode/1022.Sum-Of-Root-To-Leaf-Binary-Numbers/','title':"1022. Sum of Root to Leaf Binary Numbers",'section':"第四章",'content':"1022. 从根到叶的二进制数之和 #  Difficulty: 简单\n给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -\u0026gt; 1 -\u0026gt; 1 -\u0026gt; 0 -\u0026gt; 1，那么它表示二进制数 01101，也就是 13 。\n对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n返回这些数字之和。题目数据保证答案是一个 32 位 整数。\n示例 1：\n 输入：root = [1,0,1,0,1,0,1] 输出：22 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 示例 2：\n输入：root = [0] 输出：0 示例 3：\n输入：root = [1] 输出：1 示例 4：\n输入：root = [1,1] 输出：3 提示：\n 树中的结点数介于 1 和 1000 之间。 Node.val 为 0 或 1 。  题解 #  题解一：DFS（深度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int result = 0; public int sumRootToLeaf(TreeNode root) { if (root == null) { return 0; } helper(root, 0); return result; } private void helper(TreeNode node, int lastResult) { if (node == null) { return; } int temp = (lastResult \u0026lt;\u0026lt; 1) + node.val; if (node.left == null \u0026amp;\u0026amp; node.right == null) { result += temp; return; } if (node.left != null) { helper(node.left, temp); } if (node.right != null) { helper(node.right, temp); } } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(1)。\n  "});index.add({'id':461,'href':'/leetcode-java/04_Leetcode/1025.Divisor-Game/','title':"1025. Divisor Game",'section':"第四章",'content':"1025. Divisor Game #  题目 #  Alice and Bob take turns playing a game, with Alice starting first.\nInitially, there is a number N on the chalkboard. On each player\u0026rsquo;s turn, that player makes a move consisting of:\n Choosing any x with 0 \u0026lt; x \u0026lt; N and N % x == 0. Replacing the number N on the chalkboard with N - x.  Also, if a player cannot make a move, they lose the game.\nReturn True if and only if Alice wins the game, assuming both players play optimally.\nExample 1:\nInput: 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves.  Example 2:\nInput: 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.  Note:\n 1 \u0026lt;= N \u0026lt;= 1000  题目大意 #  爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n 选出任一 x，满足 0 \u0026lt; x \u0026lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。  如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。\n解题思路 #   两人相互玩一个游戏，游戏初始有一个数 N，开始游戏的时候，任一方选择一个数 x，满足 0 \u0026lt; x \u0026lt; N 并且 N % x == 0 的条件，然后 N-x 为下一轮开始的数。此轮结束，该另外一个人继续选择数字，两人相互轮流选择。直到某一方再也没法选择数字的时候，输掉游戏。问如果你先手开始游戏，给出 N 的时候，能否直到这局你是否会必胜或者必输？ 这一题当 N = 1 的时候，那一轮的人必输。因为没法找到一个数字能满足 0 \u0026lt; x \u0026lt; N 并且 N % x == 0 的条件了。必胜策略就是把对方逼至 N = 1 的情况。题目中假设了对手也是一个很有头脑的人。初始如果 N 为偶数，我就选择 x = 1，对手拿到的数字就是奇数。只要最终能让对手拿到奇数，他就会输。初始如果 N 为奇数，N = 1 的时候直接输了，N 为其他奇数的时候，我们也只能选择一个奇数 x，(因为 N % x == 0 ，N 为奇数，x 一定不会是偶数，因为偶数就能被 2 整除了)，对手由于是一个很有头脑的人，当我们选完 N - x 是偶数的时候，他就选择 1，那么轮到我们拿到的数字又是奇数。对手只要一直保证我们拿到奇数，最终肯定会逼着我们拿到 1，最终他就会获得胜利。所以经过分析可得，初始数字如果是偶数，有必胜策略，如果初始数字是奇数，有必输的策略。  代码 #  package leetcode func divisorGame(N int) bool { return N%2 == 0 } "});index.add({'id':462,'href':'/leetcode-java/04_Leetcode/1026.Maximum-Difference-Between-Node-and-Ancestor/','title':"1026. Maximum Difference Between Node and Ancestor",'section':"第四章",'content':"1026. Maximum Difference Between Node and Ancestor #  题目 #  Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.\n(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)\nExample 1:\n Input: [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation: We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7. Note:\n The number of nodes in the tree is between 2 and 5000. Each node will have value between 0 and 100000.  题目大意 #  给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n提示：\n 树中的节点数在 2 到 5000 之间。 每个节点的值介于 0 到 100000 之间。  解题思路 #   给出一颗树，要求找出祖先和孩子的最大差值。 DPS 深搜即可。每个节点和其所有孩子的最大值来自于 3 个值，节点本身，递归遍历左子树的最大值，递归遍历右子树的最大值；每个节点和其所有孩子的最小值来自于 3 个值，节点本身，递归遍历左子树的最小值，递归遍历右子树的最小值。依次求出自身节点和其所有孩子节点的最大差值，深搜的过程中动态维护最大差值即可。  代码 #  func maxAncestorDiff(root *TreeNode) int { res := 0 dfsAncestorDiff(root, \u0026amp;res) return res } func dfsAncestorDiff(root *TreeNode, res *int) (int, int) { if root == nil { return -1, -1 } leftMax, leftMin := dfsAncestorDiff(root.Left, res) if leftMax == -1 \u0026amp;\u0026amp; leftMin == -1 { leftMax = root.Val leftMin = root.Val } rightMax, rightMin := dfsAncestorDiff(root.Right, res) if rightMax == -1 \u0026amp;\u0026amp; rightMin == -1 { rightMax = root.Val rightMin = root.Val } *res = max(*res, max(abs(root.Val-min(leftMin, rightMin)), abs(root.Val-max(leftMax, rightMax)))) return max(leftMax, max(rightMax, root.Val)), min(leftMin, min(rightMin, root.Val)) } "});index.add({'id':463,'href':'/leetcode-java/04_Leetcode/1028.Recover-a-Tree-From-Preorder-Traversal/','title':"1028. Recover a Tree From Preorder Traversal",'section':"第四章",'content':"1028. Recover a Tree From Preorder Traversal #  题目 #  We run a preorder depth first search on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. (If the depth of a node is D, the depth of its immediate child is D+1. The depth of the root node is 0.)\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output S of this traversal, recover the tree and return its root.\nExample 1:\n Input: \u0026quot;1-2--3--4-5--6--7\u0026quot; Output: [1,2,5,3,4,6,7]  Example 2:\n Input: \u0026quot;1-2--3---4-5--6---7\u0026quot; Output: [1,2,5,3,null,6,null,4,null,7]  Example 3:\n Input: \u0026quot;1-401--349---90--88\u0026quot; Output: [1,401,null,349,88,90]  Note:\n The number of nodes in the original tree is between 1 and 1000. Each node will have a value between 1 and 10^9.  题目大意 #  我们从二叉树的根节点 root 开始进行深度优先搜索。\n在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出 S，还原树并返回其根节点 root。\n提示：\n 原始树中的节点数介于 1 和 1000 之间。 每个节点的值介于 1 和 10 ^ 9 之间。  解题思路 #   给出一个字符串，字符串是一个树的先根遍历的结果，其中破折号的个数代表层数。请根据这个字符串生成对应的树。 这一题解题思路比较明确，用 DFS 就可以解题。边深搜字符串，边根据破折号的个数判断当前节点是否属于本层。如果不属于本层，回溯到之前的根节点，添加叶子节点以后再继续深搜。需要注意的是每次深搜时，扫描字符串的 index 需要一直保留，回溯也需要用到这个 index。  代码 #  package leetcode import ( \u0026#34;strconv\u0026#34; ) /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func recoverFromPreorder(S string) *TreeNode { if len(S) == 0 { return \u0026amp;TreeNode{} } root, index, level := \u0026amp;TreeNode{}, 0, 0 cur := root dfsBuildPreorderTree(S, \u0026amp;index, \u0026amp;level, cur) return root.Right } func dfsBuildPreorderTree(S string, index, level *int, cur *TreeNode) (newIndex *int) { if *index == len(S) { return index } if *index == 0 \u0026amp;\u0026amp; *level == 0 { i := 0 for i = *index; i \u0026lt; len(S); i++ { if !isDigital(S[i]) { break } } num, _ := strconv.Atoi(S[*index:i]) tmp := \u0026amp;TreeNode{Val: num, Left: nil, Right: nil} cur.Right = tmp nLevel := *level + 1 index = dfsBuildPreorderTree(S, \u0026amp;i, \u0026amp;nLevel, tmp) index = dfsBuildPreorderTree(S, index, \u0026amp;nLevel, tmp) } i := 0 for i = *index; i \u0026lt; len(S); i++ { if isDigital(S[i]) { break } } if *level == i-*index { j := 0 for j = i; j \u0026lt; len(S); j++ { if !isDigital(S[j]) { break } } num, _ := strconv.Atoi(S[i:j]) tmp := \u0026amp;TreeNode{Val: num, Left: nil, Right: nil} if cur.Left == nil { cur.Left = tmp nLevel := *level + 1 index = dfsBuildPreorderTree(S, \u0026amp;j, \u0026amp;nLevel, tmp) index = dfsBuildPreorderTree(S, index, level, cur) } else if cur.Right == nil { cur.Right = tmp nLevel := *level + 1 index = dfsBuildPreorderTree(S, \u0026amp;j, \u0026amp;nLevel, tmp) index = dfsBuildPreorderTree(S, index, level, cur) } } return index } "});index.add({'id':464,'href':'/leetcode-java/04_Leetcode/1030.Matrix-Cells-in-Distance-Order/','title':"1030. Matrix Cells in Distance Order",'section':"第四章",'content':"1030. Matrix Cells in Distance Order #  题目 #  We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 \u0026lt;= r \u0026lt; R and 0 \u0026lt;= c \u0026lt; C.\nAdditionally, we are given a cell in that matrix with coordinates (r0, c0).\nReturn the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|. (You may return the answer in any order that satisfies this condition.)\nExample 1:\nInput: R = 1, C = 2, r0 = 0, c0 = 0 Output: [[0,0],[0,1]] Explanation: The distances from (r0, c0) to other cells are: [0,1]  Example 2:\nInput: R = 2, C = 2, r0 = 0, c0 = 1 Output: [[0,1],[0,0],[1,1],[1,0]] Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2] The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.  Example 3:\nInput: R = 2, C = 3, r0 = 1, c0 = 2 Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3] There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].  Note:\n 1 \u0026lt;= R \u0026lt;= 100 1 \u0026lt;= C \u0026lt;= 100 0 \u0026lt;= r0 \u0026lt; R 0 \u0026lt;= c0 \u0026lt; C  题目大意 #  给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 \u0026lt;= r \u0026lt; R 且 0 \u0026lt;= c \u0026lt; C。另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。\n返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）\n解题思路 #   按照题意计算矩阵内给定点到其他每个点的距离即可  代码 #  package leetcode func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int { longRow, longCol, result := max(abs(r0-0), abs(R-r0)), max(abs(c0-0), abs(C-c0)), make([][]int, 0) maxDistance := longRow + longCol bucket := make([][][]int, maxDistance+1) for i := 0; i \u0026lt;= maxDistance; i++ { bucket[i] = make([][]int, 0) } for r := 0; r \u0026lt; R; r++ { for c := 0; c \u0026lt; C; c++ { distance := abs(r-r0) + abs(c-c0) tmp := []int{r, c} bucket[distance] = append(bucket[distance], tmp) } } for i := 0; i \u0026lt;= maxDistance; i++ { for _, buk := range bucket[i] { result = append(result, buk) } } return result } "});index.add({'id':465,'href':'/leetcode-java/04_Leetcode/1037.Valid-Boomerang/','title':"1037. Valid Boomerang",'section':"第四章",'content':"1037. Valid Boomerang #  题目 #  A boomerang is a set of 3 points that are all distinct and not in a straight line.\nGiven a list of three points in the plane, return whether these points are a boomerang.\nExample 1:\nInput: [[1,1],[2,3],[3,2]] Output: true Example 2:\nInput: [[1,1],[2,2],[3,3]] Output: false Note:\n points.length == 3 points[i].length == 2 0 \u0026lt;= points[i][j] \u0026lt;= 100  题目大意 #  回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。\n解题思路 #   判断给出的 3 组点能否满足回旋镖。 简单题。判断 3 个点组成的 2 条直线的斜率是否相等。由于斜率的计算是除法，还可能遇到分母为 0 的情况，那么可以转换成乘法，交叉相乘再判断是否相等，就可以省去判断分母为 0 的情况了，代码也简洁成一行了。  代码 #  package leetcode func isBoomerang(points [][]int) bool { return (points[0][0]-points[1][0])*(points[0][1]-points[2][1]) != (points[0][0]-points[2][0])*(points[0][1]-points[1][1]) } "});index.add({'id':466,'href':'/leetcode-java/04_Leetcode/1040.Moving-Stones-Until-Consecutive-II/','title':"1040. Moving Stones Until Consecutive I I",'section':"第四章",'content':"1040. Moving Stones Until Consecutive II #  题目 #  On an infinite number line, the position of the i-th stone is given by stones[i]. Call a stone an endpoint stone if it has the smallest or largest position.\nEach turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\nWhen the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]\nExample 1:\nInput: [7,4,9] Output: [1,2] Explanation: We can move 4 -\u0026gt; 8 for one move to finish the game. Or, we can move 9 -\u0026gt; 5, 4 -\u0026gt; 6 for two moves to finish the game.  Example 2:\nInput: [6,5,4,3,10] Output: [2,3] We can move 3 -\u0026gt; 8 then 10 -\u0026gt; 7 to finish the game. Or, we can move 3 -\u0026gt; 7, 4 -\u0026gt; 8, 5 -\u0026gt; 9 to finish the game. Notice we cannot move 10 -\u0026gt; 2 to finish the game, because that would be an illegal move.  Example 3:\nInput: [100,101,104,102,103] Output: [0,0]  Note:\n 3 \u0026lt;= stones.length \u0026lt;= 10^4 1 \u0026lt;= stones[i] \u0026lt;= 10^9 stones[i] have distinct values.  题目大意 #  在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作端点石子。每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。\n要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。\n提示：\n 3 \u0026lt;= stones.length \u0026lt;= 10^4 1 \u0026lt;= stones[i] \u0026lt;= 10^9 stones[i] 的值各不相同。  解题思路 #    给出一个数组，数组里面代表的是石头的坐标。要求移动石头，最终使得这些石头的坐标是一个连续的自然数列。但是规定，当一个石头是端点的时候，是不能移动的，例如 [1,2,5]，5 是端点，不能把 5 移到 3 或者 0 的位置，因为移动之后，这个石头仍然是端点。最终输出将所有石头排成连续的自然数列所需的最小步数和最大步数。\n  这道题的关键就是如何保证端点石头不能再次移动到端点的限制。例如，[5,6,8,9,20]，20 是端点，但是 20 就可以移动到 7 的位置，最终形成 [5,6,7,8,9] 的连续序列。但是 [5,6,7,8,20]，这种情况 20 就不能移动到 9 了，只能让 8 移动到 9，20 再移动到 8 的位置，最终还是形成了 [5,6,7,8,9]，但是步数需要 2 步。经过上述分析，可以得到，端点石头只能往中间空挡的位置移动，如果中间没有空挡，那么需要借助一个石头先制造一个空挡，然后端点石头再插入到中间，这样最少是需要 2 步。\n  再来考虑极值的情况。先看最大步数，最大步数肯定慢慢移动，一次移动一格，并且移动的格数最多。这里有两个极端情况，把数组里面的数全部都移动到最左端点，把数组里面的数全部都移动到最右端点。每次只移动一格。例如，全部都移到最右端点：\n [3,4,5,6,10] // 初始状态，连续的情况 [4,5,6,7,10] // 第一步，把 3 挪到右边第一个可以插入的位置，即 7 [5,6,7,8,10] // 第二步，把 4 挪到右边第一个可以插入的位置，即 8 [6,7,8,9,10] // 第三步，把 5 挪到右边第一个可以插入的位置，即 9 [1,3,5,7,10] // 初始状态，不连续的情况 [3,4,5,7,10] // 第一步，把 1 挪到右边第一个可以插入的位置，即 4 [4,5,6,7,10] // 第二步，把 3 挪到右边第一个可以插入的位置，即 6 [5,6,7,8,10] // 第三步，把 4 挪到右边第一个可以插入的位置，即 8 [6,7,8,9,10] // 第四步，把 5 挪到右边第一个可以插入的位置，即 9  挪动的过程类似翻滚，最左边的石头挪到右边第一个可以放下的地方。然后不断的往右翻滚。把数组中的数全部都移动到最左边也同理。对比这两种情况的最大值，即是移动的最大步数。\n  再看最小步数。这里就涉及到了滑动窗口了。由于最终是要形成连续的自然数列，所以滑动窗口的大小已经固定成 n 了，从数组的 0 下标可以往右滑动窗口，这个窗口中能包含的数字越多，代表窗口外的数字越少，那么把这些数字放进窗口内的步数也最小。于是可以求得最小步数。这里有一个比较坑的地方就是题目中的那个“端点不能移动以后还是端点”的限制。针对这种情况，需要额外的判断。如果当前窗口内有 n-1 个元素了，即只有一个端点在窗口外，并且窗口右边界的值减去左边界的值也等于 n-1，代表这个窗口内已经都是连续数字了。这种情况端点想融合到这个连续数列中，最少需要 2 步(上文已经分析过了)。\n  注意一些边界情况。如果窗口从左往右滑动，窗口右边界滑到最右边了，但是窗口右边界的数字减去左边界的数字还是小于窗口大小 n，代表已经滑到头了，可以直接 break 出去。为什么滑到头了呢？由于数组经过从小到大排序以后，数字越往右边越大，当前数字是小值，已经满足了 stones[right]-stones[left] \u0026lt; n，左边界继续往右移动只会使得 stones[left] 更大，就更加小于 n 了。而我们需要寻找的是 stones[right]-stones[left] \u0026gt;= n 的边界点，肯定再也找不到了。\n  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) func numMovesStonesII(stones []int) []int { if len(stones) == 0 { return []int{0, 0} } sort.Ints(stones) n := len(stones) maxStep, minStep, left, right := max(stones[n-1]-stones[1]-n+2, stones[n-2]-stones[0]-n+2), math.MaxInt64, 0, 0 for left \u0026lt; n { if right+1 \u0026lt; n \u0026amp;\u0026amp; stones[right]-stones[left] \u0026lt; n { right++ } else { if stones[right]-stones[left] \u0026gt;= n { right-- } if right-left+1 == n-1 \u0026amp;\u0026amp; stones[right]-stones[left]+1 == n-1 { minStep = min(minStep, 2) } else { minStep = min(minStep, n-(right-left+1)) } if right == n-1 \u0026amp;\u0026amp; stones[right]-stones[left] \u0026lt; n { break } left++ } } return []int{minStep, maxStep} } "});index.add({'id':467,'href':'/leetcode-java/04_Leetcode/1047.Remove-All-Adjacent-Duplicates-In-String/','title':"1047. Remove All Adjacent Duplicates in String",'section':"第四章",'content':"1047. Remove All Adjacent Duplicates In String #  题目 #  Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.\nWe repeatedly make duplicate removals on S until we no longer can.\nReturn the final string after all such duplicate removals have been made. It is guaranteed the answer is unique.\nExample 1:\n Input: \u0026quot;abbaca\u0026quot; Output: \u0026quot;ca\u0026quot; Explanation: For example, in \u0026quot;abbaca\u0026quot; we could remove \u0026quot;bb\u0026quot; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \u0026quot;aaca\u0026quot;, of which only \u0026quot;aa\u0026quot; is possible, so the final string is \u0026quot;ca\u0026quot;. Note:\n 1 \u0026lt;= S.length \u0026lt;= 20000 S consists only of English lowercase letters.  题目大意 #  给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n解题思路 #  用栈模拟，类似“对对碰”，一旦新来的字符和栈顶的字符一样的话，就弹出栈顶字符，直至扫完整个字符串。栈中剩下的字符串就是最终要输出的结果。\n代码 #  package leetcode func removeDuplicates1047(S string) string { stack := []rune{} for _, s := range S { if len(stack) == 0 || len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] != s { stack = append(stack, s) } else { stack = stack[:len(stack)-1] } } return string(stack) } "});index.add({'id':468,'href':'/leetcode-java/04_Leetcode/1049.Last-Stone-Weight-II/','title':"1049. Last Stone Weight I I",'section':"第四章",'content':"1049. Last Stone Weight II #  题目 #  We have a collection of rocks, each rock has a positive integer weight.\nEach turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x \u0026lt;= y. The result of this smash is:\n If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight yhas new weight y-x.  At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)\nExample 1:\nInput: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.  Note:\n 1 \u0026lt;= stones.length \u0026lt;= 30 1 \u0026lt;= stones[i] \u0026lt;= 100  题目大意 #  有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。\n提示：\n 1 \u0026lt;= stones.length \u0026lt;= 30 1 \u0026lt;= stones[i] \u0026lt;= 1000  解题思路 #   给出一个数组，数组里面的元素代表的是石头的重量。现在要求两个石头对碰，如果重量相同，两个石头都消失，如果一个重一个轻，剩下的石头是两者的差值。问经过这样的多次碰撞以后，能剩下的石头的重量最轻是多少？ 由于两两石头要发生碰撞，所以可以将整个数组可以分为两部分，如果这两部分的石头重量总和相差不大，那么经过若干次碰撞以后，剩下的石头重量一定是最小的。现在就需要找到这样两堆总重量差不多的两堆石头。这个问题就可以转化为 01 背包问题。从数组中找到 sum/2 重量的石头集合，如果一半能尽量达到 sum/2，那么另外一半和 sum/2 的差是最小的，最好的情况就是两堆石头的重量都是 sum/2，那么两两石头对碰以后最后都能消失。01 背包的经典模板可以参考第 416 题。  代码 #  package leetcode func lastStoneWeightII(stones []int) int { sum := 0 for _, v := range stones { sum += v } n, C, dp := len(stones), sum/2, make([]int, sum/2+1) for i := 0; i \u0026lt;= C; i++ { if stones[0] \u0026lt;= i { dp[i] = stones[0] } else { dp[i] = 0 } } for i := 1; i \u0026lt; n; i++ { for j := C; j \u0026gt;= stones[i]; j-- { dp[j] = max(dp[j], dp[j-stones[i]]+stones[i]) } } return sum - 2*dp[C] } "});index.add({'id':469,'href':'/leetcode-java/04_Leetcode/1051.Height-Checker/','title':"1051. Height Checker",'section':"第四章",'content':"1051. Height Checker #  题目 #  Students are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.\nExample 1:\nInput: heights = [1,1,4,2,1,3] Output: 3 Explanation: Current array : [1,1,4,2,1,3] Target array : [1,1,1,2,3,4] On index 2 (0-based) we have 4 vs 1 so we have to move this student. On index 4 (0-based) we have 1 vs 3 so we have to move this student. On index 5 (0-based) we have 3 vs 4 so we have to move this student. Example 2:\nInput: heights = [5,1,2,3,4] Output: 5 Example 3:\nInput: heights = [1,2,3,4,5] Output: 0 Constraints:\n 1 \u0026lt;= heights.length \u0026lt;= 100 1 \u0026lt;= heights[i] \u0026lt;= 100  题目大意 #  学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。\n解题思路 #   给定一个高度数组，要求输出把这个数组按照非递减高度排列所需移动的最少次数。 简单题，最少次数意味着每次移动，一步到位，一步就移动到它所在的最终位置。那么用一个辅助排好序的数组，一一比对计数即可。  代码 #  package leetcode func heightChecker(heights []int) int { result, checker := 0, []int{} checker = append(checker, heights...) sort.Ints(checker) for i := 0; i \u0026lt; len(heights); i++ { if heights[i] != checker[i] { result++ } } return result } "});index.add({'id':470,'href':'/leetcode-java/04_Leetcode/1052.Grumpy-Bookstore-Owner/','title':"1052. Grumpy Bookstore Owner",'section':"第四章",'content':"1052. Grumpy Bookstore Owner #  题目 #  Today, the bookstore owner has a store open for customers.lengthminutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.\nExample 1:\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.  Note:\n 1 \u0026lt;= X \u0026lt;= customers.length == grumpy.length \u0026lt;= 20000 0 \u0026lt;= customers[i] \u0026lt;= 1000 0 \u0026lt;= grumpy[i] \u0026lt;= 1  题目大意 #  今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。请你返回这一天营业下来，最多有多少客户能够感到满意的数量。\n提示：\n 1 \u0026lt;= X \u0026lt;= customers.length == grumpy.length \u0026lt;= 20000 0 \u0026lt;= customers[i] \u0026lt;= 1000 0 \u0026lt;= grumpy[i] \u0026lt;= 1  解题思路 #   给出一个顾客入店时间表和书店老板发脾气的时间表。两个数组的时间是一一对应的，即相同下标对应的相同的时间。书店老板可以控制自己在 X 分钟内不发火，但是只能控制一次。问有多少顾客能在书店老板不发火的时候在书店里看书。抽象一下，给出一个价值数组和一个装着 0 和 1 的数组，当价值数组的下标对应另外一个数组相同下标的值是 0 的时候，那么这个价值可以累加，当对应是 1 的时候，就不能加上这个价值。现在可以让装着 0 和 1 的数组中连续 X 个数都变成 0，问最终价值最大是多少？ 这道题是典型的滑动窗口的题目。最暴力的解法是滑动窗口右边界，当与左边界的距离等于 X 的时候，计算此刻对应的数组的总价值。当整个宽度为 X 的窗口滑过整个数组以后，输出维护的最大值即可。这个方法耗时比较长。因为每次计算数组总价值的时候都要遍历整个数组。这里是可以优化的地方。 每次计算数组总价值的时候，其实目的是为了找到宽度为 X 的窗口对应里面为 1 的数累加和最大，因为如果把这个窗口里面的 1 都变成 0 以后，那么对最终价值的影响也最大。所以用一个变量 customer0 专门记录脾气数组中为 0 的对应的价值，累加起来。因为不管怎么改变，为 0 的永远为 0，唯一变化的是 1 变成 0 。用 customer1 专门记录脾气数组中为 1 的对应的价值。在窗口滑动过程中找到 customer1 的最大值。最终要求的最大值就是 customer0 + maxCustomer1。  代码 #  package leetcode // 解法一 滑动窗口优化版 func maxSatisfied(customers []int, grumpy []int, X int) int { customer0, customer1, maxCustomer1, left, right := 0, 0, 0, 0, 0 for ; right \u0026lt; len(customers); right++ { if grumpy[right] == 0 { customer0 += customers[right] } else { customer1 += customers[right] for right-left+1 \u0026gt; X { if grumpy[left] == 1 { customer1 -= customers[left] } left++ } if customer1 \u0026gt; maxCustomer1 { maxCustomer1 = customer1 } } } return maxCustomer1 + customer0 } // 解法二 滑动窗口暴力版 func maxSatisfied1(customers []int, grumpy []int, X int) int { left, right, res := 0, -1, 0 for left \u0026lt; len(customers) { if right+1 \u0026lt; len(customers) \u0026amp;\u0026amp; right-left \u0026lt; X-1 { right++ } else { if right-left+1 == X { res = max(res, sumSatisfied(customers, grumpy, left, right)) } left++ } } return res } func sumSatisfied(customers []int, grumpy []int, start, end int) int { sum := 0 for i := 0; i \u0026lt; len(customers); i++ { if i \u0026lt; start || i \u0026gt; end { if grumpy[i] == 0 { sum += customers[i] } } else { sum += customers[i] } } return sum } "});index.add({'id':471,'href':'/leetcode-java/04_Leetcode/1054.Distant-Barcodes/','title':"1054. Distant Barcodes",'section':"第四章",'content':"1054. Distant Barcodes #  题目 #  In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].\nRearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\nExample 1:\nInput: [1,1,1,2,2,2] Output: [2,1,2,1,2,1]  Example 2:\nInput: [1,1,1,1,2,2,3,3] Output: [1,3,1,3,2,1,2,1]  Note:\n 1 \u0026lt;= barcodes.length \u0026lt;= 10000 1 \u0026lt;= barcodes[i] \u0026lt;= 10000  题目大意 #  在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。\n解题思路 #   这一题和第 767 题原理是完全一样的。第 767 题是 Google 的面试题。 解题思路比较简单，先按照每个数字的频次从高到低进行排序，注意会有频次相同的数字。排序以后，分别从第 0 号位和中间的位置开始往后取数，取完以后即为最终解。  代码 #  package leetcode import \u0026#34;sort\u0026#34; func rearrangeBarcodes(barcodes []int) []int { bfs := barcodesFrequencySort(barcodes) if len(bfs) == 0 { return []int{} } res := []int{} j := (len(bfs)-1)/2 + 1 for i := 0; i \u0026lt;= (len(bfs)-1)/2; i++ { res = append(res, bfs[i]) if j \u0026lt; len(bfs) { res = append(res, bfs[j]) } j++ } return res } func barcodesFrequencySort(s []int) []int { if len(s) == 0 { return []int{} } sMap := map[int]int{} // 统计每个数字出现的频次 \tcMap := map[int][]int{} // 按照频次作为 key 排序 \tfor _, b := range s { sMap[b]++ } for key, value := range sMap { cMap[value] = append(cMap[value], key) } var keys []int for k := range cMap { keys = append(keys, k) } sort.Sort(sort.Reverse(sort.IntSlice(keys))) res := make([]int, 0) for _, k := range keys { for i := 0; i \u0026lt; len(cMap[k]); i++ { for j := 0; j \u0026lt; k; j++ { res = append(res, cMap[k][i]) } } } return res } "});index.add({'id':472,'href':'/leetcode-java/04_Leetcode/1073.Adding-Two-Negabinary-Numbers/','title':"1073. Adding Two Negabinary Numbers",'section':"第四章",'content':"1073. Adding Two Negabinary Numbers #  题目 #  Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format: as an array of 0s and 1s, from most significant bit to least significant bit. For example, arr = [1,1,0,1]represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3. A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.\nExample 1:\nInput: arr1 = [1,1,1,1,1], arr2 = [1,0,1] Output: [1,0,0,0,0] Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.  Note:\n 1 \u0026lt;= arr1.length \u0026lt;= 1000 1 \u0026lt;= arr2.length \u0026lt;= 1000 arr1 and arr2 have no leading zeros arr1[i] is 0 or 1 arr2[i] is 0 or 1  题目大意 #  给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 的数字也同样不含前导零：以 arr 为例，这意味着要么 arr == [0]，要么 arr[0] == 1。\n返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。\n提示：\n 1 \u0026lt;= arr1.length \u0026lt;= 1000 1 \u0026lt;= arr2.length \u0026lt;= 1000 arr1 和 arr2 都不含前导零 arr1[i] 为 0 或 1 arr2[i] 为 0 或 1  解题思路 #   给出两个 -2 进制的数，要求计算出这两个数的和，最终表示形式还是 -2 进制。 这一题最先想到的思路是先把两个 -2 进制的数转成 10 进制以后做加法，然后把结果表示成 -2 进制。这个思路可行，但是在提交以后会发现数据溢出 int64 了。在第 257 / 267 组测试数据会出现 WA。测试数据见 test 文件。另外换成 big.Add 也不是很方便。所以考虑换一个思路。 这道题实际上就是求两个 -2 进制数的加法，为什么还要先转到 10 进制再换回 -2 进制呢？为何不直接进行 -2 进制的加法。所以开始尝试直接进行加法运算。加法是从低位到高位依次累加，遇到进位要从低往高位进位。所以从两个数组的末尾往前扫，模拟低位相加的过程。关键的是进位问题。进位分 3 种情况，依次来讨论：   进位到高位 k ，高位 k 上的两个数数字分别是 0 和 0 。这种情况最终 k 位为 1 。  证明：由于进位是由 k - 1 位进过来的，所以 k - 1 位是 2 个 1 。现在 k 位是 2 个 0， 所以加起来的和是 2 * (-2)^(k - 1)。 当 k 为奇数的时候，2 * (-2)^(k - 1) = (-1)^(k - 1)* 2 * 2^(k - 1) = 2^k 当 k 为偶数的时候，2 * (-2)^(k - 1) = (-1)^(k - 1)* 2 * 2^(k - 1) = -2^k 综合起来就是 (-2)^k，所以最终 k 位上有一个 1 进位到高位 k ，高位 k 上的两个数数字分别是 0 和 1 。这种情况最终 k 位为 0 。  证明：由于进位是由 k - 1 位进过来的，所以 k - 1 位是 2 个 1。现在 k 位是 1 个 0 和 1 个 1, 所以加起来的和是 (-2)^k + 2 * (-2)^(k - 1)。 当 k 为奇数的时候，(-2)^k + 2 * (-2)^(k - 1) = -2^k + 2^k = 0 当 k 为偶数的时候，(-2)^k + 2 * (-2)^(k - 1) = 2^k - 2^k = 0 综合起来就是 0，所以最终 k 位上有一个 0 进位到高位 k ，高位 k 上的两个数数字分别是 1 和 1 。这种情况最终 k 位为 1 。  证明：由于进位是由 k - 1 位进过来的，所以 k - 1 位是 2 个 1 。现在 k 位是 2 个 1， 所以加起来的和是 2 * (-2)^k + 2 * (-2)^(k - 1)。 当 k 为奇数的时候，2 * (-2)^k + 2 * (-2)^(k - 1) = -2^(k + 1) + 2^k = 2^k*(1 - 2) = -2^k 当 k 为偶数的时候，2 * (-2)^k + 2 * (-2)^(k - 1) = 2^(k + 1) - 2^k = 2^k*(2 - 1) = 2^k 综合起来就是 (-2)^k，所以最终 k 位上有一个 1  所以综上所属，-2 进制的进位和 2 进制的进位原理是完全一致的，只不过 -2 进制的进位是 -1，而 2 进制的进位是 1 。由于进位可能在 -2 进制上出现前导 0 ，所以最终结果需要再去除前导 0 。  代码 #  package leetcode // 解法一 模拟进位 func addNegabinary(arr1 []int, arr2 []int) []int { carry, ans := 0, []int{} for i, j := len(arr1)-1, len(arr2)-1; i \u0026gt;= 0 || j \u0026gt;= 0 || carry != 0; { if i \u0026gt;= 0 { carry += arr1[i] i-- } if j \u0026gt;= 0 { carry += arr2[j] j-- } ans = append([]int{carry \u0026amp; 1}, ans...) carry = -(carry \u0026gt;\u0026gt; 1) } for idx, num := range ans { // 去掉前导 0 \tif num != 0 { return ans[idx:] } } return []int{0} } // 解法二 标准的模拟，但是这个方法不能 AC，因为测试数据超过了 64 位，普通数据类型无法存储 func addNegabinary1(arr1 []int, arr2 []int) []int { return intToNegabinary(negabinaryToInt(arr1) + negabinaryToInt(arr2)) } func negabinaryToInt(arr []int) int { if len(arr) == 0 { return 0 } res := 0 for i := 0; i \u0026lt; len(arr)-1; i++ { if res == 0 { res += (-2) * arr[i] } else { res = res * (-2) res += (-2) * arr[i] } } return res + 1*arr[len(arr)-1] } func intToNegabinary(num int) []int { if num == 0 { return []int{0} } res := []int{} for num != 0 { remainder := num % (-2) num = num / (-2) if remainder \u0026lt; 0 { remainder += 2 num++ } res = append([]int{remainder}, res...) } return res } "});index.add({'id':473,'href':'/leetcode-java/04_Leetcode/1074.Number-of-Submatrices-That-Sum-to-Target/','title':"1074. Number of Submatrices That Sum to Target",'section':"第四章",'content':"1074. Number of Submatrices That Sum to Target #  题目 #  Given a matrix, and a target, return the number of non-empty submatrices that sum to target.\nA submatrix x1, y1, x2, y2 is the set of all cells matrix[y] with x1 \u0026lt;= x \u0026lt;= x2 and y1 \u0026lt;= y \u0026lt;= y2.\nTwo submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.\nExample 1:\nInput: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0.  Example 2:\nInput: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.  Note:\n 1 \u0026lt;= matrix.length \u0026lt;= 300 1 \u0026lt;= matrix[0].length \u0026lt;= 300 -1000 \u0026lt;= matrix[i] \u0026lt;= 1000 -10^8 \u0026lt;= target \u0026lt;= 10^8  题目大意 #  给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。\n子矩阵 x1, y1, x2, y2 是满足 x1 \u0026lt;= x \u0026lt;= x2 且 y1 \u0026lt;= y \u0026lt;= y2 的所有单元 matrix[x][y] 的集合。\n如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。\n提示：\n 1 \u0026lt;= matrix.length \u0026lt;= 300 1 \u0026lt;= matrix[0].length \u0026lt;= 300 -1000 \u0026lt;= matrix[i] \u0026lt;= 1000 -10^8 \u0026lt;= target \u0026lt;= 10^8  解题思路 #    给出一个矩阵，要求在这个矩阵中找出子矩阵的和等于 target 的矩阵个数。\n  这一题读完题感觉是滑动窗口的二维版本。如果把它拍扁，在一维数组中，求连续的子数组和为 target，这样就很好做。如果这题不降维，纯暴力解是 O(n^6)。如何优化降低时间复杂度呢？\n  联想到第 1 题 Two Sum 问题，可以把 2 个数求和的问题优化到 O(n)。这里也用类似的思想，用一个 map 来保存行方向上曾经出现过的累加和，相减就可以得到本行的和。这里可能读者会有疑惑，为什么不能每一行都单独保存呢？为什么一定要用累加和相减的方式来获取每一行的和呢？因为这一题要求子矩阵所有解，如果只单独保存每一行的和，只能求得小的子矩阵，子矩阵和子矩阵组成的大矩阵的情况会漏掉(当然再循环一遍，把子矩阵累加起来也可以，但是这样就多了一层循环了)，例如子矩阵是 1*4 的，但是 2 个这样的子矩阵摞在一起形成 2 * 4 也能满足条件，如果不用累加和的办法，只单独存每一行的和，最终还要有组合的步骤。经过这样的优化，可以从 O(n^6) 优化到 O(n^4)，能 AC 这道题，但是时间复杂度太高了。如何优化？\n  首先，子矩阵需要上下左右 4 个边界，4 个变量控制循环就需要 O(n^4)，行和列的区间累加还需要 O(n^2)。行和列的区间累加可以通过 preSum 来解决。例如 sum[i,j] = sum[j] - sum[i - 1]，其中 sum[k] 中存的是从 0 到 K 的累加和： 那么一个区间内的累加和可以由这个区间的右边界减去区间左边界左边的那个累加和得到(由于是闭区间，所需要取左边界左边的和)。经过这样的处理，列方向的维度就被我们拍扁了。\n  再来看看行方向的和，现在每一列的和都可以通过区间相减的方法得到。那么这道题就变成了第 1 题 Two Sum 的问题了。Two Sum 问题只需要 O(n) 的时间复杂度求解，这一题由于是二维的，所以两个列的边界还需要循环，所以最终优化下来的时间复杂度是 O(n^3)。计算 presum 可以直接用原数组，所以空间复杂度只有一个 O(n) 的字典。\n  类似思路的题目有第 560 题，第 304 题。\n  代码 #  package leetcode func numSubmatrixSumTarget(matrix [][]int, target int) int { m, n, res := len(matrix), len(matrix[0]), 0 for row := range matrix { for col := 1; col \u0026lt; len(matrix[row]); col++ { matrix[row][col] += matrix[row][col-1] } } for i := 0; i \u0026lt; n; i++ { for j := i; j \u0026lt; n; j++ { counterMap, sum := make(map[int]int, m), 0 counterMap[0] = 1 // 题目保证一定有解，所以这里初始化是 1 \tfor row := 0; row \u0026lt; m; row++ { if i \u0026gt; 0 { sum += matrix[row][j] - matrix[row][i-1] } else { sum += matrix[row][j] } res += counterMap[sum-target] counterMap[sum]++ } } } return res } // 暴力解法 O(n^4) func numSubmatrixSumTarget1(matrix [][]int, target int) int { m, n, res, sum := len(matrix), len(matrix[0]), 0, 0 for i := 0; i \u0026lt; n; i++ { for j := i; j \u0026lt; n; j++ { counterMap := map[int]int{} counterMap[0] = 1 // 题目保证一定有解，所以这里初始化是 1 \tsum = 0 for row := 0; row \u0026lt; m; row++ { for k := i; k \u0026lt;= j; k++ { sum += matrix[row][k] } res += counterMap[sum-target] counterMap[sum]++ } } } return res } // 暴力解法超时！ O(n^6) func numSubmatrixSumTarget2(matrix [][]int, target int) int { res := 0 for startx := 0; startx \u0026lt; len(matrix); startx++ { for starty := 0; starty \u0026lt; len(matrix[startx]); starty++ { for endx := startx; endx \u0026lt; len(matrix); endx++ { for endy := starty; endy \u0026lt; len(matrix[startx]); endy++ { if sumSubmatrix(matrix, startx, starty, endx, endy) == target { //fmt.Printf(\u0026#34;startx = %v, starty = %v, endx = %v, endy = %v\\n\u0026#34;, startx, starty, endx, endy) \tres++ } } } } } return res } func sumSubmatrix(matrix [][]int, startx, starty, endx, endy int) int { sum := 0 for i := startx; i \u0026lt;= endx; i++ { for j := starty; j \u0026lt;= endy; j++ { sum += matrix[i][j] } } return sum } "});index.add({'id':474,'href':'/leetcode-java/04_Leetcode/1078.Occurrences-After-Bigram/','title':"1078. Occurrences After Bigram",'section':"第四章",'content':"1078. Occurrences After Bigram #  题目 #  Given words first and second, consider occurrences in some text of the form \u0026ldquo;first second third\u0026rdquo;, where second comes immediately after first, and thirdcomes immediately after second.\nFor each such occurrence, add \u0026ldquo;third\u0026rdquo; to the answer, and return the answer.\nExample 1:\nInput: text = \u0026quot;alice is a good girl she is a good student\u0026quot;, first = \u0026quot;a\u0026quot;, second = \u0026quot;good\u0026quot; Output: [\u0026quot;girl\u0026quot;,\u0026quot;student\u0026quot;]  Example 2:\nInput: text = \u0026quot;we will we will rock you\u0026quot;, first = \u0026quot;we\u0026quot;, second = \u0026quot;will\u0026quot; Output: [\u0026quot;we\u0026quot;,\u0026quot;rock\u0026quot;]  Note:\n 1 \u0026lt;= text.length \u0026lt;= 1000 text consists of space separated words, where each word consists of lowercase English letters. 1 \u0026lt;= first.length, second.length \u0026lt;= 10 first and second consist of lowercase English letters.  题目大意 #  给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 \u0026ldquo;first second third\u0026rdquo; 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。对于每种这样的情况，将第三个词 \u0026ldquo;third\u0026rdquo; 添加到答案中，并返回答案。\n解题思路 #   简单题。给出一个 text，要求找出紧接在 first 和 second 后面的那个字符串，有多个就输出多个。解法很简单，先分解出 words 每个字符串，然后依次遍历进行字符串匹配。匹配到 first 和 second 以后，输出之后的那个字符串。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func findOcurrences(text string, first string, second string) []string { var res []string words := strings.Split(text, \u0026#34; \u0026#34;) if len(words) \u0026lt; 3 { return []string{} } for i := 2; i \u0026lt; len(words); i++ { if words[i-2] == first \u0026amp;\u0026amp; words[i-1] == second { res = append(res, words[i]) } } return res } "});index.add({'id':475,'href':'/leetcode-java/04_Leetcode/1079.Letter-Tile-Possibilities/','title':"1079. Letter Tile Possibilities",'section':"第四章",'content':"1079. Letter Tile Possibilities #  题目 #  You have a set of tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make.\nExample 1:\nInput: \u0026quot;AAB\u0026quot; Output: 8 Explanation: The possible sequences are \u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;AB\u0026quot;, \u0026quot;BA\u0026quot;, \u0026quot;AAB\u0026quot;, \u0026quot;ABA\u0026quot;, \u0026quot;BAA\u0026quot;.  Example 2:\nInput: \u0026quot;AAABBC\u0026quot; Output: 188  Note:\n 1 \u0026lt;= tiles.length \u0026lt;= 7 tiles consists of uppercase English letters.  题目大意 #  你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。提示：\n 1 \u0026lt;= tiles.length \u0026lt;= 7 tiles 由大写英文字母组成  解题思路 #   题目要求输出所有非空字母序列的数目。这一题是排列和组合的结合题目。组合是可以选择一个字母，二个字母，…… n 个字母。每个组合内是排列问题。比如选择 2 个字母，字母之间相互排序不同是影响最终结果的，不同的排列顺序是不同的解。 这道题目由于不需要输出所有解，所以解法可以优化，例如我们在递归计算解的时候，不需要真的遍历原字符串，只需要累加一些字母的频次就可以。当然如果要输出所有解，就需要真实遍历原字符串了(见解法二)。简单的做法是每次递归按照频次累加。因为每次增加一个字母一定是 26 个大写字母中的一个。这里需要注意的是，增加的只能是 26 个字母里面还能取出“机会”的字母，例如递归到到第 3 轮了，A 用完了，这个时候只能取频次还不为 0 的字母拼上去。   代码 #  package leetcode // 解法一 DFS func numTilePossibilities(tiles string) int { m := make(map[byte]int) for i := range tiles { m[tiles[i]]++ } arr := make([]int, 0) for _, v := range m { arr = append(arr, v) } return numTileDFS(arr) } func numTileDFS(arr []int) (r int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 { continue } r++ arr[i]-- r += numTileDFS(arr) arr[i]++ } return } // 解法二 DFS 暴力解法 func numTilePossibilities1(tiles string) int { res, tmp, tMap, used := 0, []byte{}, make(map[string]string, 0), make([]bool, len(tiles)) findTile([]byte(tiles), tmp, \u0026amp;used, 0, \u0026amp;res, tMap) return res } func findTile(tiles, tmp []byte, used *[]bool, index int, res *int, tMap map[string]string) { flag := true for _, v := range *used { if v == false { flag = false break } } if flag { return } for i := 0; i \u0026lt; len(tiles); i++ { if (*used)[i] == true { continue } tmp = append(tmp, tiles[i]) (*used)[i] = true if _, ok := tMap[string(tmp)]; !ok { //fmt.Printf(\u0026#34;i = %v tiles = %v 找到了结果 = %v\\n\u0026#34;, i, string(tiles), string(tmp)) \t*res++ } tMap[string(tmp)] = string(tmp) findTile([]byte(tiles), tmp, used, i+1, res, tMap) tmp = tmp[:len(tmp)-1] (*used)[i] = false } } "});index.add({'id':476,'href':'/leetcode-java/04_Leetcode/1089.Duplicate-Zeros/','title':"1089. Duplicate Zeros",'section':"第四章",'content':"1089. Duplicate Zeros #  题目 #  Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written.\nDo the above modifications to the input array in place, do not return anything from your function.\nExample 1:\nInput: [1,0,2,3,0,4,5,0] Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2:\nInput: [1,2,3] Output: null Explanation: After calling your function, the input array is modified to: [1,2,3] Note:\n 1 \u0026lt;= arr.length \u0026lt;= 10000 0 \u0026lt;= arr[i] \u0026lt;= 9  题目大意 #  给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。注意：请不要在超过该数组长度的位置写入元素。要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。\n解题思路 #   给一个固定长度的数组，把数组元素为 0 的元素都往后复制一遍，后面的元素往后移，超出数组长度的部分删除。 简单题，按照题意，用 append 和 slice 操作即可。  代码 #  package leetcode func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1]...) i++ } } } "});index.add({'id':477,'href':'/leetcode-java/04_Leetcode/1093.Statistics-from-a-Large-Sample/','title':"1093. Statistics From a Large Sample",'section':"第四章",'content':"1093. Statistics from a Large Sample #  题目 #  We sampled integers between 0 and 255, and stored the results in an array count: count[k] is the number of integers we sampled equal to k.\nReturn the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers. The mode is guaranteed to be unique.\n(Recall that the median of a sample is:\n The middle element, if the elements of the sample were sorted and the number of elements is odd; The average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)  Example 1:\nInput: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,3.00000,2.37500,2.50000,3.00000]  Example 2:\nInput: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,4.00000,2.18182,2.00000,1.00000]  Constraints:\n count.length == 256 1 \u0026lt;= sum(count) \u0026lt;= 10^9 The mode of the sample that count represents is unique. Answers within 10^-5 of the true value will be accepted as correct.  题目大意 #  我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。\n我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。我们先来回顾一下中位数的知识：\n 如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素； 如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。  解题思路 #    这个问题的关键需要理解题目的意思，什么是采样？count[k] 就是整数 k 的采样个数。\n  题目要求返回样本的最小值、最大值、平均值、中位数和众数。最大值和最小值就很好处理，只需要遍历 count 判断最小的非 0 的 index 就是最小值，最大的非 0 的 index 就是最大值。平均值也非常好处理，对于所有非 0 的 count，我们通过累加 count[k] * index 得到所有数的和，然后除上所有非 0 的 count 的和。   众数也非常容易，只需统计 count 值最大时的 index 即可。\n  中位数的处理相对麻烦一些，因为需要分非 0 的 count 之和是奇数还是偶数两种情况。先假设非 0 的 count 和为 cnt，那么如果 cnt 是奇数的话，只需要找到 cnt/2 的位置即可，通过不断累加 count 的值，直到累加和超过 ≥ cnt/2。如果 cnt 是偶数的话，需要找到 cnt/2 + 1 和 cnt/2 的位置，找法和奇数情况相同，不过需要找两次(可以放到一个循环中做两次判断)。\n  代码 #  package leetcode func sampleStats(count []int) []float64 { res := make([]float64, 5) res[0] = 255 sum := 0 for _, val := range count { sum += val } left, right := sum/2, sum/2 if (sum % 2) == 0 { right++ } pre, mode := 0, 0 for i, val := range count { if val \u0026gt; 0 { if i \u0026lt; int(res[0]) { res[0] = float64(i) } res[1] = float64(i) } res[2] += float64(i*val) / float64(sum) if pre \u0026lt; left \u0026amp;\u0026amp; pre+val \u0026gt;= left { res[3] += float64(i) / 2.0 } if pre \u0026lt; right \u0026amp;\u0026amp; pre+val \u0026gt;= right { res[3] += float64(i) / 2.0 } pre += val if val \u0026gt; mode { mode = val res[4] = float64(i) } } return res } "});index.add({'id':478,'href':'/leetcode-java/04_Leetcode/1105.Filling-Bookcase-Shelves/','title':"1105. Filling Bookcase Shelves",'section':"第四章",'content':"1105. Filling Bookcase Shelves #  题目 #  We have a sequence of books: the i-th book has thickness books[i][0]and height books[i][1].\nWe want to place these books in order onto bookcase shelves that have total width shelf_width.\nWe choose some of the books to place on this shelf (such that the sum of their thickness is \u0026lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\nNote again that at each step of the above process, the order of the books we place is the same order as the given sequence of books. For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\nReturn the minimum possible height that the total bookshelf can be after placing shelves in this manner.\nExample 1:\n Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 Output: 6 Explanation: The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6. Notice that book number 2 does not have to be on the first shelf.  Constraints:\n 1 \u0026lt;= books.length \u0026lt;= 1000 1 \u0026lt;= books[i][0] \u0026lt;= shelf_width \u0026lt;= 1000 1 \u0026lt;= books[i][1] \u0026lt;= 1000  题目大意 #  附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。按顺序将这些书摆放到总宽度为 shelf_width 的书架上。\n先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。\n需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。以这种方式布置书架，返回书架整体可能的最小高度。\n解题思路 #   给出一个数组，数组里面每个元素代表的是一个本书的宽度和高度。要求按照书籍的顺序，把书摆到宽度为 shelf_width 的书架上。问最终放下所有书籍以后，书架的最小高度。 这一题的解题思路是动态规划。dp[i] 代表放置前 i 本书所需要的书架最小高度。初始值 dp[0] = 0，其他为最大值 1000*1000。遍历每一本书，把当前这本书作为书架最后一层的最后一本书，将这本书之前的书向后调整，看看是否可以减少之前的书架高度。状态转移方程为 dp[i] = min(dp[i] , dp[j - 1] + h)，其中 j 表示最后一层所能容下书籍的索引，h 表示最后一层最大高度。j 调整完一遍以后就能找出书架最小高度值了。时间复杂度 O(n^2)。  代码 #  package leetcode func minHeightShelves(books [][]int, shelfWidth int) int { dp := make([]int, len(books)+1) dp[0] = 0 for i := 1; i \u0026lt;= len(books); i++ { width, height := books[i-1][0], books[i-1][1] dp[i] = dp[i-1] + height for j := i - 1; j \u0026gt; 0 \u0026amp;\u0026amp; width+books[j-1][0] \u0026lt;= shelfWidth; j-- { height = max(height, books[j-1][1]) width += books[j-1][0] dp[i] = min(dp[i], dp[j-1]+height) } } return dp[len(books)] } "});index.add({'id':479,'href':'/leetcode-java/04_Leetcode/1108.Defanging-an-IP-Address/','title':"1108. Defanging an I P Address",'section':"第四章",'content':"1108. Defanging an IP Address #  题目 #  Given a valid (IPv4) IP address, return a defanged version of that IP address.\nA defanged IP address replaces every period \u0026quot;.\u0026quot; with \u0026quot;[.]\u0026quot;.\nExample 1:\nInput: address = \u0026quot;1.1.1.1\u0026quot; Output: \u0026quot;1[.]1[.]1[.]1\u0026quot;  Example 2:\nInput: address = \u0026quot;255.100.50.0\u0026quot; Output: \u0026quot;255[.]100[.]50[.]0\u0026quot;  Constraints:\n The given address is a valid IPv4 address.  题目大意 #  给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 \u0026ldquo;[.]\u0026rdquo; 代替了每个 \u0026ldquo;.\u0026quot;。\n提示：\n 给出的 address 是一个有效的 IPv4 地址  解题思路 #   给出一个 IP 地址，要求把点替换成 [.]。 简单题，按照题意替换即可。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func defangIPaddr(address string) string { return strings.Replace(address, \u0026#34;.\u0026#34;, \u0026#34;[.]\u0026#34;, -1) } "});index.add({'id':480,'href':'/leetcode-java/04_Leetcode/1110.Delete-Nodes-And-Return-Forest/','title':"1110. Delete Nodes and Return Forest",'section':"第四章",'content':"1110. Delete Nodes And Return Forest #  题目 #  Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\nExample 1:\n Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Constraints:\n The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length \u0026lt;= 1000 to_delete contains distinct values between 1 and 1000.  题目大意 #  给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。\n提示：\n 树中的节点数最大为 1000。 每个节点都有一个介于 1 到 1000 之间的值，且各不相同。 to_delete.length \u0026lt;= 1000 to_delete 包含一些从 1 到 1000、各不相同的值。  解题思路 #   给出一棵树，再给出一个数组，要求删除数组中相同元素值的节点。输出最终删除以后的森林。 简单题。边遍历树，边删除数组中的元素。这里可以先把数组里面的元素放入 map 中，加速查找。遇到相同的元素就删除节点。这里需要特殊判断的是当前删除的节点是否是根节点，如果是根节点需要根据条件置空它的左节点或者右节点。  代码 #  func delNodes(root *TreeNode, toDelete []int) []*TreeNode { if root == nil { return nil } res, deleteMap := []*TreeNode{}, map[int]bool{} for _, v := range toDelete { deleteMap[v] = true } dfsDelNodes(root, deleteMap, true, \u0026amp;res) return res } func dfsDelNodes(root *TreeNode, toDel map[int]bool, isRoot bool, res *[]*TreeNode) bool { if root == nil { return false } if isRoot \u0026amp;\u0026amp; !toDel[root.Val] { *res = append(*res, root) } isRoot = false if toDel[root.Val] { isRoot = true } if dfsDelNodes(root.Left, toDel, isRoot, res) { root.Left = nil } if dfsDelNodes(root.Right, toDel, isRoot, res) { root.Right = nil } return isRoot } "});index.add({'id':481,'href':'/leetcode-java/04_Leetcode/1111.Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings/','title':"1111. Maximum Nesting Depth of Two Valid Parentheses Strings",'section':"第四章",'content':"1111. Maximum Nesting Depth of Two Valid Parentheses Strings #  题目 #  A string is a valid parentheses string (denoted VPS) if and only if it consists of \u0026quot;(\u0026quot; and \u0026quot;)\u0026quot; characters only, and:\n It is the empty string, or It can be written as AB (A concatenated with B), where A and B are VPS\u0026rsquo;s, or It can be written as (A), where A is a VPS.  We can similarly define the nesting depth depth(S) of any VPS S as follows:\n depth(\u0026quot;\u0026quot;) = 0 depth(A + B) = max(depth(A), depth(B)), where A and B are VPS\u0026rsquo;s depth(\u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot;) = 1 + depth(A), where A is a VPS.  For example, \u0026quot;\u0026quot;, \u0026quot;()()\u0026quot;, and \u0026quot;()(()())\u0026quot; are VPS\u0026rsquo;s (with nesting depths 0, 1, and 2), and \u0026quot;)(\u0026quot; and \u0026quot;(()\u0026quot; are not VPS\u0026rsquo;s.\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS\u0026rsquo;s (and A.length + B.length = seq.length).\nNow choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.\nReturn an answer array (of length seq.length) that encodes such a choice of A and B: answer[i] = 0 if seq[i] is part of A, else answer[i] = 1. Note that even though multiple answers may exist, you may return any of them.\nExample 1:\nInput: seq = \u0026quot;(()())\u0026quot; Output: [0,1,1,1,1,0]  Example 2:\nInput: seq = \u0026quot;()(())()\u0026quot; Output: [0,0,0,1,1,0,1,1]  Constraints:\n 1 \u0026lt;= seq.size \u0026lt;= 10000  题目大意 #  有效括号字符串 仅由 \u0026ldquo;(\u0026rdquo; 和 \u0026ldquo;)\u0026rdquo; 构成，并符合下述几个条件之一：\n 空字符串 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串 嵌套，可以记作 (A)，其中 A 是有效括号字符串  类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：\n s 为空时，depth(\u0026quot;\u0026quot;) = 0 s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串 s 为嵌套情况，depth(\u0026quot;(\u0026quot; + A + \u0026ldquo;)\u0026quot;) = 1 + depth(A)，其中 A 是有效括号字符串  例如：\u0026quot;\u0026quot;，\u0026quot;()()\u0026quot;，和 \u0026ldquo;()(()())\u0026rdquo; 都是有效括号字符串，嵌套深度分别为 0，1，2，而 \u0026ldquo;)(\u0026rdquo; 和 \u0026ldquo;(()\u0026rdquo; 都不是有效括号字符串。\n 给你一个有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。\n现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。\n返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。\n解题思路 #   给出一个括号字符串。选出 A 部分和 B 部分，使得 max(depth(A), depth(B)) 值最小。在最终的数组中输出 0 和 1，0 标识是 A 部分，1 标识是 B 部分。 这一题想要 max(depth(A), depth(B)) 值最小，可以使用贪心思想。如果 A 部分和 B 部分都尽快括号匹配，不深层次嵌套，那么总的层次就会变小。只要让嵌套的括号中属于 A 的和属于 B 的间隔排列即可。例如：“(((())))”，上面的字符串的嵌套深度是 4，按照上述的贪心思想，则标记为 0101 1010。 这一题也可以用二分的思想来解答。把深度平分给 A 部分和 B 部分。  第一次遍历，先计算最大深度 第二次遍历，把深度小于等于最大深度一半的括号标记为 0(给 A 部分)，否则标记为 1(给 B 部分)    代码 #  package leetcode // 解法一 二分思想 func maxDepthAfterSplit(seq string) []int { stack, maxDepth, res := 0, 0, []int{} for _, v := range seq { if v == \u0026#39;(\u0026#39; { stack++ maxDepth = max(stack, maxDepth) } else { stack-- } } stack = 0 for i := 0; i \u0026lt; len(seq); i++ { if seq[i] == \u0026#39;(\u0026#39; { stack++ if stack \u0026lt;= maxDepth/2 { res = append(res, 0) } else { res = append(res, 1) } } else { if stack \u0026lt;= maxDepth/2 { res = append(res, 0) } else { res = append(res, 1) } stack-- } } return res } // 解法二 模拟 func maxDepthAfterSplit1(seq string) []int { stack, top, res := make([]int, len(seq)), -1, make([]int, len(seq)) for i, r := range seq { if r == \u0026#39;)\u0026#39; { res[i] = res[stack[top]] top-- continue } top++ stack[top] = i res[i] = top % 2 } return res } "});index.add({'id':482,'href':'/leetcode-java/04_Leetcode/1122.Relative-Sort-Array/','title':"1122. Relative Sort Array",'section':"第四章",'content':"1122. Relative Sort Array #  题目 #  Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that don\u0026rsquo;t appear in arr2 should be placed at the end of arr1 in ascending order.\nExample 1:\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19]  Constraints:\n arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 Each arr2[i] is distinct. Each arr2[i] is in arr1.  题目大意 #  给你两个数组，arr1 和 arr2，\n arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中  对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。\n提示：\n arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中  解题思路 #   给出 2 个数组 A 和 B，A 中包含 B 中的所有元素。要求 A 按照 B 的元素顺序排序，B 中没有的元素再接着排在后面，从小到大排序。 这一题有多种解法。一种暴力的解法就是依照题意，先把 A 中的元素都统计频次放在 map 中，然后 按照 B 的顺序输出，接着再把剩下的元素排序接在后面。还有一种桶排序的思想，由于题目限定了 A 的大小是 1000，这个数量级很小，所以可以用 1001 个桶装所有的数，把数都放在桶里，这样默认就已经排好序了。接下来的做法和前面暴力解法差不多，按照频次输出。B 中以外的元素就按照桶的顺序依次输出即可。  代码 #  package leetcode import \u0026#34;sort\u0026#34; // 解法一 桶排序，时间复杂度 O(n^2) func relativeSortArray(A, B []int) []int { count := [1001]int{} for _, a := range A { count[a]++ } res := make([]int, 0, len(A)) for _, b := range B { for count[b] \u0026gt; 0 { res = append(res, b) count[b]-- } } for i := 0; i \u0026lt; 1001; i++ { for count[i] \u0026gt; 0 { res = append(res, i) count[i]-- } } return res } // 解法二 模拟，时间复杂度 O(n^2) func relativeSortArray1(arr1 []int, arr2 []int) []int { leftover, m, res := []int{}, make(map[int]int), []int{} for _, v := range arr1 { m[v]++ } for _, s := range arr2 { count := m[s] for i := 0; i \u0026lt; count; i++ { res = append(res, s) } m[s] = 0 } for v, count := range m { for i := 0; i \u0026lt; count; i++ { leftover = append(leftover, v) } } sort.Ints(leftover) res = append(res, leftover...) return res } "});index.add({'id':483,'href':'/leetcode-java/04_Leetcode/1123.Lowest-Common-Ancestor-of-Deepest-Leaves/','title':"1123. Lowest Common Ancestor of Deepest Leaves",'section':"第四章",'content':"1123. Lowest Common Ancestor of Deepest Leaves #  题目 #  Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\n The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1. The lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.  Example 1:\nInput: root = [1,2,3] Output: [1,2,3] Explanation: The deepest leaves are the nodes with values 2 and 3. The lowest common ancestor of these leaves is the node with value 1. The answer returned is a TreeNode object (not an array) with serialization \u0026quot;[1,2,3]\u0026quot;.  Example 2:\nInput: root = [1,2,3,4] Output: [4]  Example 3:\nInput: root = [1,2,3,4,5] Output: [2,4,5]  Constraints:\n The given tree will have between 1 and 1000 nodes. Each node of the tree will have a distinct value between 1 and 1000.  题目大意 #  给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。\n回想一下：\n 叶节点 是二叉树中没有子节点的节点 树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1 如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。   提示：\n 给你的树中将有 1 到 1000 个节点。 树中每个节点的值都在 1 到 1000 之间。  解题思路 #   给出一颗树，找出最深的叶子节点的最近公共祖先 LCA。 这一题思路比较直接。先遍历找到最深的叶子节点，如果左右子树的最深的叶子节点深度相同，那么当前节点就是它们的最近公共祖先。如果左右子树的最深的深度不等，那么需要继续递归往下找符合题意的 LCA。如果最深的叶子节点没有兄弟，那么公共父节点就是叶子本身，否则返回它的 LCA。 有几个特殊的测试用例，见测试文件。特殊的点就是最深的叶子节点没有兄弟节点的情况。  代码 #  package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lcaDeepestLeaves(root *TreeNode) *TreeNode { if root == nil { return nil } lca, maxLevel := \u0026amp;TreeNode{}, 0 lcaDeepestLeavesDFS(\u0026amp;lca, \u0026amp;maxLevel, 0, root) return lca } func lcaDeepestLeavesDFS(lca **TreeNode, maxLevel *int, depth int, root *TreeNode) int { *maxLevel = max(*maxLevel, depth) if root == nil { return depth } depthLeft := lcaDeepestLeavesDFS(lca, maxLevel, depth+1, root.Left) depthRight := lcaDeepestLeavesDFS(lca, maxLevel, depth+1, root.Right) if depthLeft == *maxLevel \u0026amp;\u0026amp; depthRight == *maxLevel { *lca = root } return max(depthLeft, depthRight) } "});index.add({'id':484,'href':'/leetcode-java/04_Leetcode/1128.Number-of-Equivalent-Domino-Pairs/','title':"1128. Number of Equivalent Domino Pairs",'section':"第四章",'content':"1128. Number of Equivalent Domino Pairs #  题目 #  Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 \u0026lt;= i \u0026lt; j \u0026lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].\nExample 1:\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1  Constraints:\n 1 \u0026lt;= dominoes.length \u0026lt;= 40000 1 \u0026lt;= dominoes[i][j] \u0026lt;= 9  题目大意 #  给你一个由一些多米诺骨牌组成的列表 dominoes。如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。\n在 0 \u0026lt;= i \u0026lt; j \u0026lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。\n提示：\n 1 \u0026lt;= dominoes.length \u0026lt;= 40000 1 \u0026lt;= dominoes[i][j] \u0026lt;= 9  解题思路 #   给出一组多米诺骨牌，求出这组牌中相同牌的个数。牌相同的定义是：牌的 2 个数字相同(正序或者逆序相同都算相同) 简单题。由于牌是 2 个数，所以将牌的 2 个数 hash 成一个 2 位数，比较大小即可，正序和逆序都 hash 成 2 位数，然后在桶中比较是否已经存在，如果不存在，跳过，如果存在，计数。  代码 #  package leetcode func numEquivDominoPairs(dominoes [][]int) int { if dominoes == nil || len(dominoes) == 0 { return 0 } result, buckets := 0, [100]int{} for _, dominoe := range dominoes { key, rotatedKey := dominoe[0]*10+dominoe[1], dominoe[1]*10+dominoe[0] if dominoe[0] != dominoe[1] { if buckets[rotatedKey] \u0026gt; 0 { result += buckets[rotatedKey] } } if buckets[key] \u0026gt; 0 { result += buckets[key] buckets[key]++ } else { buckets[key]++ } } return result } "});index.add({'id':485,'href':'/leetcode-java/04_Leetcode/1137.N-th-Tribonacci-Number/','title':"1137. N Th Tribonacci Number",'section':"第四章",'content':"1137. N-th Tribonacci Number #  题目 #  The Tribonacci sequence Tn is defined as follows:\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u0026gt;= 0.\nGiven n, return the value of Tn.\nExample 1:\nInput: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4  Example 2:\nInput: n = 25 Output: 1389537  Constraints:\n 0 \u0026lt;= n \u0026lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u0026lt;= 2^31 - 1.  题目大意 #  泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n \u0026gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n提示：\n 0 \u0026lt;= n \u0026lt;= 37 答案保证是一个 32 位整数，即 answer \u0026lt;= 2^31 - 1。  解题思路 #   求泰波那契数列中的第 n 个数。 简单题，按照题意定义计算即可。  代码 #  package leetcode func tribonacci(n int) int { if n \u0026lt; 2 { return n } trib, prev, prev2 := 1, 1, 0 for n \u0026gt; 2 { trib, prev, prev2 = trib+prev+prev2, trib, prev n-- } return trib } "});index.add({'id':486,'href':'/leetcode-java/04_Leetcode/1145.Binary-Tree-Coloring-Game/','title':"1145. Binary Tree Coloring Game",'section':"第四章",'content':"1145. Binary Tree Coloring Game #  题目 #  Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.\nInitially, the first player names a value x with 1 \u0026lt;= x \u0026lt;= n, and the second player names a value y with 1 \u0026lt;= y \u0026lt;= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue.\nThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\nYou are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.\nExample 1:\n Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2. Constraints:\n root is the root of a binary tree with n nodes and distinct node values from 1 to n. n is odd. 1 \u0026lt;= x \u0026lt;= n \u0026lt;= 100  题目大意 #  有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，\n 「一号」玩家从 [1, n] 中取一个值 x（1 \u0026lt;= x \u0026lt;= n）； 「二号」玩家也从 [1, n] 中取一个值 y（1 \u0026lt;= y \u0026lt;= n）且 y != x。 「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。  之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。\n提示：\n 二叉树的根节点为 root，树上由 n 个节点，节点上的值从 1 到 n 各不相同。 n 为奇数。 1 \u0026lt;= x \u0026lt;= n \u0026lt;= 100  解题思路 #   2 个人参加二叉树着色游戏。二叉树节点数为奇数。1 号玩家和 2 号玩家分别在二叉树上选项一个点着色。每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。当有人不能选点着色的时候，他的那个回合会被跳过。双方都没法继续着色的时候游戏结束。着色多的人获胜。问二号玩家是否存在必胜策略？    如图所示，当一号玩家选择了一个红色的结点，可能会将二叉树切割为 3 个部分（连通分量），如果选择的是根结点，则可能是 2 个部分或 1 个部分，如果选择叶结点，则是 1 个部分。不过无论哪种情况都无关紧要，我们都可以当成 3 个部分来对待，例如一号玩家选择了一个叶结点，我们也可以把叶结点的左右两个空指针看成大小为 0 的两个部分。 那么二号玩家怎样选择蓝色结点才是最优呢？答案是：选择离红色结点最近，且所属连通分量规模最大的那个点。也就是示例图中的 1 号结点。如果我们选择了 1 号结点为蓝色结点，那么可以染成红色的点就只剩下 6 号点和 7 号点了，而蓝色可以把根结点和其左子树全部占据。 如何确定蓝色是否有必胜策略，就可以转换为，被红色点切割的三个连通分量中，是否存在一个连通分量，大小大于所有结点数目的一半。统计三个连通分量大小的过程，可以用深度优先搜索（DFS）来实现。当遍历到某一结点，其结点值等于选定的红色结点时，我们统计这个结点的左子树 red_left 和右子树 red_right 的大小，那么我们就已经找到两个连通分量的大小了，最后一个父结点连通分量的大小，可以用结点总数减去这两个连通分量大小，再减去红色所占结点，即 parent = n - red_left - red_right - 1。  代码 #  func btreeGameWinningMove(root *TreeNode, n int, x int) bool { var left, right int dfsBtreeGameWinningMove(root, \u0026amp;left, \u0026amp;right, x) up := n - left - right - 1 n /= 2 return left \u0026gt; n || right \u0026gt; n || up \u0026gt; n } func dfsBtreeGameWinningMove(node *TreeNode, left, right *int, x int) int { if node == nil { return 0 } l, r := dfsBtreeGameWinningMove(node.Left, left, right, x), dfsBtreeGameWinningMove(node.Right, left, right, x) if node.Val == x { *left, *right = l, r } return l + r + 1 } "});index.add({'id':487,'href':'/leetcode-java/04_Leetcode/1154.Day-of-the-Year/','title':"1154. Day of the Year",'section':"第四章",'content':"1154. Day of the Year #  题目 #  Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.\nExample 1:\nInput: date = \u0026quot;2019-01-09\u0026quot; Output: 9 Explanation: Given date is the 9th day of the year in 2019.  Example 2:\nInput: date = \u0026quot;2019-02-10\u0026quot; Output: 41  Example 3:\nInput: date = \u0026quot;2003-03-01\u0026quot; Output: 60  Example 4:\nInput: date = \u0026quot;2004-03-01\u0026quot; Output: 61  Constraints:\n date.length == 10 date[4] == date[7] == '-', and all other date[i]\u0026rsquo;s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.  题目大意 #  实现一个 MajorityChecker 的类，它应该具有下述几个 API：\n MajorityChecker(int[] arr) 会用给定的数组 arr 来构造一个 MajorityChecker 的实例。 int query(int left, int right, int threshold) 有这么几个参数：  0 \u0026lt;= left \u0026lt;= right \u0026lt; arr.length 表示数组 arr 的子数组的长度。 2 * threshold \u0026gt; right - left + 1，也就是说阈值 threshold 始终比子序列长度的一半还要大。    每次查询 query(\u0026hellip;) 会返回在 arr[left], arr[left+1], \u0026hellip;, arr[right] 中至少出现阈值次数 threshold 的元素，如果不存在这样的元素，就返回 -1。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 20000 1 \u0026lt;= arr[i] \u0026lt;= 20000 对于每次查询，0 \u0026lt;= left \u0026lt;= right \u0026lt; len(arr) 对于每次查询，2 * threshold \u0026gt; right - left + 1 查询次数最多为 10000  解题思路 #   给出一个时间字符串，求出这一天是这一年当中的第几天。 简单题。依照题意处理即可。  代码 #  package leetcode import \u0026#34;time\u0026#34; func dayOfYear(date string) int { first := date[:4] + \u0026#34;-01-01\u0026#34; firstDay, _ := time.Parse(\u0026#34;2006-01-02\u0026#34;, first) dateDay, _ := time.Parse(\u0026#34;2006-01-02\u0026#34;, date) duration := dateDay.Sub(firstDay) return int(duration.Hours())/24 + 1 } "});index.add({'id':488,'href':'/leetcode-java/04_Leetcode/1157.Online-Majority-Element-In-Subarray/','title':"1157. Online Majority Element in Subarray",'section':"第四章",'content':"1157. Online Majority Element In Subarray #  题目 #  Implementing the class MajorityChecker, which has the following API:\n MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr; int query(int left, int right, int threshold) has arguments such that:  0 \u0026lt;= left \u0026lt;= right \u0026lt; arr.length representing a subarray of arr; 2 * threshold \u0026gt; right - left + 1, ie. the threshold is always a strict majority of the length of the subarray    Each query(...) returns the element in arr[left], arr[left+1], ..., arr[right] that occurs at least threshold times, or -1 if no such element exists.\nExample:\nMajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // returns 1 majorityChecker.query(0,3,3); // returns -1 majorityChecker.query(2,3,2); // returns 2  Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 20000 1 \u0026lt;= arr[i] \u0026lt;= 20000 For each query, 0 \u0026lt;= left \u0026lt;= right \u0026lt; len(arr) For each query, 2 * threshold \u0026gt; right - left + 1 The number of queries is at most 10000  题目大意 #  实现一个 MajorityChecker 的类，它应该具有下述几个 API：\n MajorityChecker(int[] arr) 会用给定的数组 arr 来构造一个 MajorityChecker 的实例。 int query(int left, int right, int threshold) 有这么几个参数： 0 \u0026lt;= left \u0026lt;= right \u0026lt; arr.length 表示数组 arr 的子数组的长度。 2 * threshold \u0026gt; right - left + 1，也就是说阈值 threshold 始终比子序列长度的一半还要大。  每次查询 query(\u0026hellip;) 会返回在 arr[left], arr[left+1], \u0026hellip;, arr[right] 中至少出现阈值次数 threshold 的元素，如果不存在这样的元素，就返回 -1。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 20000 1 \u0026lt;= arr[i] \u0026lt;= 20000 对于每次查询，0 \u0026lt;= left \u0026lt;= right \u0026lt; len(arr) 对于每次查询，2 * threshold \u0026gt; right - left + 1 查询次数最多为 10000  解题思路 #    设计一个数据结构，能在任意的一个区间内，查找是否存在众数，众数的定义是：该数字出现的次数大于区间的一半。如果存在众数，一定唯一。如果在给定的区间内找不到众数，则输出 -1 。\n  这一题有一个很显眼的“暗示”，2 * threshold \u0026gt; right - left + 1，这个条件就是摩尔投票算法的前提条件。摩尔投票的思想可以见第 169 题。这一题又要在区间内查询，所以选用线段树这个数据结构来实现。经过分析，可以确定此题的解题思路，摩尔投票 + 线段树。\n  摩尔投票的思想是用两个变量，candidate 和 count，用来记录待被投票投出去的元素，和候选人累积没被投出去的轮数。如果候选人累积没有被投出去的轮数越多，那么最终成为众数的可能越大。从左往右扫描整个数组，先去第一个元素为 candidate，如果遇到相同的元素就累加轮数，如果遇到不同的元素，就把 candidate 和不同的元素一起投出去。当轮数变成 0 了，再选下一个元素作为 candidate。从左扫到右，就能找到众数了。那怎么和线段树结合起来呢？\n  线段树是把一个大的区间拆分成很多个小区间，那么考虑这样一个问题。每个小区间内使用摩尔投票，最终把所有小区间合并起来再用一次摩尔投票，得到的结果和对整个区间使用一次摩尔投票的结果是一样的么？答案是一样的。可以这样想，众数总会在一个区间内被选出来，那么其他区间的摩尔投票都是起“中和”作用的，即两两元素一起出局。这个问题想通以后，说明摩尔投票具有可加的性质。既然满足可加，就可以和线段树结合，因为线段树每个线段就是加起来，最终合并成大区间的。\n  举个例子，arr = [1,1,2,2,1,1]，先构造线段树，如下左图。\n 现在每个线段树的节点不是只存一个 int 数字了，而是存 candidate 和 count。每个节点的 candidate 和 count 分别代表的是该区间内摩尔投票的结果。初始化的时候，先把每个叶子都填满，candidate 是自己，count = 1 。即右图绿色节点。然后在 pushUp 的时候，进行摩尔投票：\n mc.merge = func(i, j segmentItem) segmentItem { if i.candidate == j.candidate { return segmentItem{candidate: i.candidate, count: i.count + j.count} } if i.count \u0026gt; j.count { return segmentItem{candidate: i.candidate, count: i.count - j.count} } return segmentItem{candidate: j.candidate, count: j.count - i.count} }  直到根节点的 candidate 和 count 都填满。注意，这里的 count 并不是元素出现的总次数，而是摩尔投票中坚持没有被投出去的轮数。当线段树构建完成以后，就可以开始查询任意区间内的众数了，candidate 即为众数。接下来还要确定众数是否满足 threshold 的条件。\n  用一个字典记录每个元素在数组中出现位置的下标，例如上述这个例子，用 map 记录下标：count = map[1:[0 1 4 5] 2:[2 3]]。由于下标在记录过程中是递增的，所以满足二分查找的条件。利用这个字典就可以查出在任意区间内，指定元素出现的次数。例如这里要查找 1 在 [0,5] 区间内出现的个数，那么利用 2 次二分查找，分别找到 lowerBound 和 upperBound，在 [lowerBound，upperBound) 区间内，都是元素 1 ，那么区间长度即是该元素重复出现的次数，和 threshold 比较，如果 ≥ threshold 说明找到了答案，否则没有找到就输出 -1 。\n  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) type segmentItem struct { candidate int count int } // MajorityChecker define type MajorityChecker struct { segmentTree []segmentItem data []int merge func(i, j segmentItem) segmentItem count map[int][]int } // Constructor1157 define func Constructor1157(arr []int) MajorityChecker { data, tree, mc, count := make([]int, len(arr)), make([]segmentItem, 4*len(arr)), MajorityChecker{}, make(map[int][]int) // 这个 merge 函数就是摩尔投票算法 \tmc.merge = func(i, j segmentItem) segmentItem { if i.candidate == j.candidate { return segmentItem{candidate: i.candidate, count: i.count + j.count} } if i.count \u0026gt; j.count { return segmentItem{candidate: i.candidate, count: i.count - j.count} } return segmentItem{candidate: j.candidate, count: j.count - i.count} } for i := 0; i \u0026lt; len(arr); i++ { data[i] = arr[i] } for i := 0; i \u0026lt; len(arr); i++ { if _, ok := count[arr[i]]; !ok { count[arr[i]] = []int{} } count[arr[i]] = append(count[arr[i]], i) } mc.data, mc.segmentTree, mc.count = data, tree, count if len(arr) \u0026gt; 0 { mc.buildSegmentTree(0, 0, len(arr)-1) } return mc } func (mc *MajorityChecker) buildSegmentTree(treeIndex, left, right int) { if left == right { mc.segmentTree[treeIndex] = segmentItem{candidate: mc.data[left], count: 1} return } leftTreeIndex, rightTreeIndex := mc.leftChild(treeIndex), mc.rightChild(treeIndex) midTreeIndex := left + (right-left)\u0026gt;\u0026gt;1 mc.buildSegmentTree(leftTreeIndex, left, midTreeIndex) mc.buildSegmentTree(rightTreeIndex, midTreeIndex+1, right) mc.segmentTree[treeIndex] = mc.merge(mc.segmentTree[leftTreeIndex], mc.segmentTree[rightTreeIndex]) } func (mc *MajorityChecker) leftChild(index int) int { return 2*index + 1 } func (mc *MajorityChecker) rightChild(index int) int { return 2*index + 2 } // Query define func (mc *MajorityChecker) query(left, right int) segmentItem { if len(mc.data) \u0026gt; 0 { return mc.queryInTree(0, 0, len(mc.data)-1, left, right) } return segmentItem{candidate: -1, count: -1} } func (mc *MajorityChecker) queryInTree(treeIndex, left, right, queryLeft, queryRight int) segmentItem { midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, mc.leftChild(treeIndex), mc.rightChild(treeIndex) if queryLeft \u0026lt;= left \u0026amp;\u0026amp; queryRight \u0026gt;= right { // segment completely inside range \treturn mc.segmentTree[treeIndex] } if queryLeft \u0026gt; midTreeIndex { return mc.queryInTree(rightTreeIndex, midTreeIndex+1, right, queryLeft, queryRight) } else if queryRight \u0026lt;= midTreeIndex { return mc.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, queryRight) } // merge query results \treturn mc.merge(mc.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, midTreeIndex), mc.queryInTree(rightTreeIndex, midTreeIndex+1, right, midTreeIndex+1, queryRight)) } // Query define func (mc *MajorityChecker) Query(left int, right int, threshold int) int { res := mc.query(left, right) if _, ok := mc.count[res.candidate]; !ok { return -1 } start := sort.Search(len(mc.count[res.candidate]), func(i int) bool { return left \u0026lt;= mc.count[res.candidate][i] }) end := sort.Search(len(mc.count[res.candidate]), func(i int) bool { return right \u0026lt; mc.count[res.candidate][i] }) - 1 if (end - start + 1) \u0026gt;= threshold { return res.candidate } return -1 } /** * Your MajorityChecker object will be instantiated and called as such: * obj := Constructor(arr); * param_1 := obj.Query(left,right,threshold); */ "});index.add({'id':489,'href':'/leetcode-java/04_Leetcode/1160.Find-Words-That-Can-Be-Formed-by-Characters/','title':"1160. Find Words That Can Be Formed by Characters",'section':"第四章",'content':"1160. Find Words That Can Be Formed by Characters #  题目 #  You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.\nExample 1:\nInput: words = [\u0026quot;cat\u0026quot;,\u0026quot;bt\u0026quot;,\u0026quot;hat\u0026quot;,\u0026quot;tree\u0026quot;], chars = \u0026quot;atach\u0026quot; Output: 6 Explanation: The strings that can be formed are \u0026quot;cat\u0026quot; and \u0026quot;hat\u0026quot; so the answer is 3 + 3 = 6.  Example 2:\nInput: words = [\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;leetcode\u0026quot;], chars = \u0026quot;welldonehoneyr\u0026quot; Output: 10 Explanation: The strings that can be formed are \u0026quot;hello\u0026quot; and \u0026quot;world\u0026quot; so the answer is 5 + 5 = 10.  Note:\n 1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100 All strings contain lowercase English letters only.  题目大意 #  给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。注意：每次拼写时，chars 中的每个字母都只能用一次。返回词汇表 words 中你掌握的所有单词的 长度之和。\n提示：\n 1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100 所有字符串中都仅包含小写英文字母  解题思路 #   给出一个字符串数组 words 和一个字符串 chars，要求输出 chars 中能构成 words 字符串的字符数总数。 简单题。先分别统计 words 和 chars 里面字符的频次。然后针对 words 中每个 word 判断能够能由 chars 构成，如果能构成，最终结果加上这个 word 的长度。  代码 #  package leetcode func countCharacters(words []string, chars string) int { count, res := make([]int, 26), 0 for i := 0; i \u0026lt; len(chars); i++ { count[chars[i]-\u0026#39;a\u0026#39;]++ } for _, w := range words { if canBeFormed(w, count) { res += len(w) } } return res } func canBeFormed(w string, c []int) bool { count := make([]int, 26) for i := 0; i \u0026lt; len(w); i++ { count[w[i]-\u0026#39;a\u0026#39;]++ if count[w[i]-\u0026#39;a\u0026#39;] \u0026gt; c[w[i]-\u0026#39;a\u0026#39;] { return false } } return true } "});index.add({'id':490,'href':'/leetcode-java/04_Leetcode/1170.Compare-Strings-by-Frequency-of-the-Smallest-Character/','title':"1170. Compare Strings by Frequency of the Smallest Character",'section':"第四章",'content':"1170. Compare Strings by Frequency of the Smallest Character #  题目 #  Let\u0026rsquo;s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = \u0026quot;dcce\u0026quot; then f(s) = 2 because the smallest character is \u0026quot;c\u0026quot; and its frequency is 2.\nNow, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) \u0026lt; f(W), where W is a word in words.\nExample 1:\nInput: queries = [\u0026quot;cbd\u0026quot;], words = [\u0026quot;zaaaz\u0026quot;] Output: [1] Explanation: On the first query we have f(\u0026quot;cbd\u0026quot;) = 1, f(\u0026quot;zaaaz\u0026quot;) = 3 so f(\u0026quot;cbd\u0026quot;) \u0026lt; f(\u0026quot;zaaaz\u0026quot;).  Example 2:\nInput: queries = [\u0026quot;bbb\u0026quot;,\u0026quot;cc\u0026quot;], words = [\u0026quot;a\u0026quot;,\u0026quot;aa\u0026quot;,\u0026quot;aaa\u0026quot;,\u0026quot;aaaa\u0026quot;] Output: [1,2] Explanation: On the first query only f(\u0026quot;bbb\u0026quot;) \u0026lt; f(\u0026quot;aaaa\u0026quot;). On the second query both f(\u0026quot;aaa\u0026quot;) and f(\u0026quot;aaaa\u0026quot;) are both \u0026gt; f(\u0026quot;cc\u0026quot;).  Constraints:\n 1 \u0026lt;= queries.length \u0026lt;= 2000 1 \u0026lt;= words.length \u0026lt;= 2000 1 \u0026lt;= queries[i].length, words[i].length \u0026lt;= 10 queries[i][j], words[i][j] are English lowercase letters.  题目大意 #  我们来定义一个函数 f(s)，其中传入参数 s 是一个非空字符串；该函数的功能是统计 s 中（按字典序比较）最小字母的出现频次。\n例如，若 s = \u0026ldquo;dcce\u0026rdquo;，那么 f(s) = 2，因为最小的字母是 \u0026ldquo;c\u0026rdquo;，它出现了 2 次。\n现在，给你两个字符串数组待查表 queries 和词汇表 words，请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是满足 f(queries[i]) \u0026lt; f(W) 的词的数目，W 是词汇表 words 中的词。\n提示：\n 1 \u0026lt;= queries.length \u0026lt;= 2000 1 \u0026lt;= words.length \u0026lt;= 2000 1 \u0026lt;= queries[i].length, words[i].length \u0026lt;= 10 queries[i][j], words[i][j] 都是小写英文字母  解题思路 #   给出 2 个数组，queries 和 words，针对每一个 queries[i] 统计在 words[j] 中满足 f(queries[i]) \u0026lt; f(words[j]) 条件的 words[j] 的个数。f(string) 的定义是 string 中字典序最小的字母的频次。 先依照题意，构造出 f() 函数，算出每个 words[j] 的 f() 值，然后排序。再依次计算 queries[i] 的 f() 值。针对每个 f() 值，在 words[j] 的 f() 值中二分搜索，查找比它大的值的下标 k，n-k 即是比 queries[i] 的 f() 值大的元素个数。依次输出到结果数组中即可。  代码 #  package leetcode import \u0026#34;sort\u0026#34; func numSmallerByFrequency(queries []string, words []string) []int { ws, res := make([]int, len(words)), make([]int, len(queries)) for i, w := range words { ws[i] = countFunc(w) } sort.Ints(ws) for i, q := range queries { fq := countFunc(q) res[i] = len(words) - sort.Search(len(words), func(i int) bool { return fq \u0026lt; ws[i] }) } return res } func countFunc(s string) int { count, i := [26]int{}, 0 for _, b := range s { count[b-\u0026#39;a\u0026#39;]++ } for count[i] == 0 { i++ } return count[i] } "});index.add({'id':491,'href':'/leetcode-java/04_Leetcode/1171.Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/','title':"1171. Remove Zero Sum Consecutive Nodes From Linked List",'section':"第四章",'content':"1171. Remove Zero Sum Consecutive Nodes from Linked List #  题目 #  Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.\nAfter doing so, return the head of the final linked list. You may return any such answer.\n(Note that in the examples below, all sequences are serializations of ListNode objects.)\nExample 1:\nInput: head = [1,2,-3,3,1] Output: [3,1] **Note**: The answer [1,2,1] would also be accepted.  Example 2:\nInput: head = [1,2,3,-3,4] Output: [1,2,4]  Example 3:\nInput: head = [1,2,3,-3,-2] Output: [1]  Constraints:\n The given linked list will contain between 1 and 1000 nodes. Each node in the linked list has -1000 \u0026lt;= node.val \u0026lt;= 1000.  题目大意 #  给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。你可以返回任何满足题目要求的答案。\n（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）\n提示：\n 给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 \u0026lt;= node.val \u0026lt;= 1000.  解题思路 #   给出一个链表，要求把链表中和为 0 的结点都移除。 由于链表的特性，不能随机访问。所以从链表的头开始往后扫，把累加和存到字典中。当再次出现相同的累加和的时候，代表这中间的一段和是 0，于是要删除这一段。删除这一段的过程中，也要删除这一段在字典中存过的累加和。有一个特殊情况需要处理，即整个链表的总和是 0，那么最终结果是空链表。针对这个特殊情况，字典中先预存入 0 值。  代码 #  package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 func removeZeroSumSublists(head *ListNode) *ListNode { // 计算累加和，和作为 key 存在 map 中，value 存那个节点的指针。如果字典中出现了重复的和，代表出现了和为 0 的段。 \tsum, sumMap, cur := 0, make(map[int]*ListNode), head // 字典中增加 0 这个特殊值，是为了防止最终链表全部消除完 \tsumMap[0] = nil for cur != nil { sum = sum + cur.Val if ptr, ok := sumMap[sum]; ok { // 在字典中找到了重复的和，代表 [ptr, tmp] 中间的是和为 0 的段，要删除的就是这一段。 \t// 同时删除 map 中中间这一段的和 \tif ptr != nil { iter := ptr.Next tmpSum := sum + iter.Val for tmpSum != sum { // 删除中间为 0 的那一段，tmpSum 不断的累加删除 map 中的和 \tdelete(sumMap, tmpSum) iter = iter.Next tmpSum = tmpSum + iter.Val } ptr.Next = cur.Next } else { head = cur.Next sumMap = make(map[int]*ListNode) sumMap[0] = nil } } else { sumMap[sum] = cur } cur = cur.Next } return head } // 解法二 暴力解法 func removeZeroSumSublists1(head *ListNode) *ListNode { if head == nil { return nil } h, prefixSumMap, sum, counter, lastNode := head, map[int]int{}, 0, 0, \u0026amp;ListNode{Val: 1010} for h != nil { for h != nil { sum += h.Val counter++ if v, ok := prefixSumMap[sum]; ok { lastNode, counter = h, v break } if sum == 0 { head = h.Next break } prefixSumMap[sum] = counter h = h.Next } if lastNode.Val != 1010 { h = head for counter \u0026gt; 1 { counter-- h = h.Next } h.Next = lastNode.Next } if h == nil { break } else { h, prefixSumMap, sum, counter, lastNode = head, map[int]int{}, 0, 0, \u0026amp;ListNode{Val: 1010} } } return head } "});index.add({'id':492,'href':'/leetcode-java/04_Leetcode/1175.Prime-Arrangements/','title':"1175. Prime Arrangements",'section':"第四章",'content':"1175. Prime Arrangements #  题目 #  Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\nExample 1:\nInput: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.  Example 2:\nInput: n = 100 Output: 682289015  Constraints:\n 1 \u0026lt;= n \u0026lt;= 100  题目大意 #  请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。\n提示：\n 1 \u0026lt;= n \u0026lt;= 100  解题思路 #   给出一个数 n，要求在 1-n 这 n 个数中，素数在素数索引下标位置上的全排列个数。 由于这一题的 n 小于 100，所以可以用打表法。先把小于 100 个素数都打表打出来。然后对小于 n 的素数进行全排列，即 n！，然后再对剩下来的非素数进行全排列，即 (n-c)！。两个的乘积即为最终答案。  代码 #  package leetcode import \u0026#34;sort\u0026#34; var primes = []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} func numPrimeArrangements(n int) int { primeCount := sort.Search(25, func(i int) bool { return primes[i] \u0026gt; n }) return factorial(primeCount) * factorial(n-primeCount) % 1000000007 } func factorial(n int) int { if n == 1 || n == 0 { return 1 } return n * factorial(n-1) % 1000000007 } "});index.add({'id':493,'href':'/leetcode-java/04_Leetcode/1184.Distance-Between-Bus-Stops/','title':"1184. Distance Between Bus Stops",'section':"第四章",'content':"1184. Distance Between Bus Stops #  题目 #  A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.\nThe bus goes along both directions i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given start and destination stops.\nExample 1:\n Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.  Example 2:\n Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.  Example 3:\n Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.  Constraints:\n 1 \u0026lt;= n \u0026lt;= 10^4 distance.length == n 0 \u0026lt;= start, destination \u0026lt; n 0 \u0026lt;= distance[i] \u0026lt;= 10^4  题目大意 #  环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。环线上的公交车都可以按顺时针和逆时针的方向行驶。返回乘客从出发点 start 到目的地 destination 之间的最短距离。\n提示：\n 1 \u0026lt;= n \u0026lt;= 10^4 distance.length == n 0 \u0026lt;= start, destination \u0026lt; n 0 \u0026lt;= distance[i] \u0026lt;= 10^4  解题思路 #   给出一个数组，代表的是公交车站每站直接的距离。距离是按照数组下标的顺序给出的，公交车可以按照顺时针行驶，也可以按照逆时针行驶。问行驶的最短距离是多少。 按照题意，分别算出顺时针和逆时针的行驶距离，比较两者距离，取出小值就是结果。  代码 #  package leetcode func distanceBetweenBusStops(distance []int, start int, destination int) int { clockwiseDis, counterclockwiseDis, n := 0, 0, len(distance) for i := start; i != destination; i = (i + 1) % n { clockwiseDis += distance[i] } for i := destination; i != start; i = (i + 1) % n { counterclockwiseDis += distance[i] } if clockwiseDis \u0026lt; counterclockwiseDis { return clockwiseDis } return counterclockwiseDis } "});index.add({'id':494,'href':'/leetcode-java/04_Leetcode/1185.Day-of-the-Week/','title':"1185. Day of the Week",'section':"第四章",'content':"1185. Day of the Week #  题目 #  Given a date, return the corresponding day of the week for that date.\nThe input is given as three integers representing the day, month and year respectively.\nReturn the answer as one of the following values {\u0026quot;Sunday\u0026quot;, \u0026quot;Monday\u0026quot;, \u0026quot;Tuesday\u0026quot;, \u0026quot;Wednesday\u0026quot;, \u0026quot;Thursday\u0026quot;, \u0026quot;Friday\u0026quot;, \u0026quot;Saturday\u0026quot;}.\nExample 1:\nInput: day = 31, month = 8, year = 2019 Output: \u0026quot;Saturday\u0026quot;  Example 2:\nInput: day = 18, month = 7, year = 1999 Output: \u0026quot;Sunday\u0026quot;  Example 3:\nInput: day = 15, month = 8, year = 1993 Output: \u0026quot;Sunday\u0026quot;  Constraints:\n The given dates are valid dates between the years 1971 and 2100.  题目大意 #  给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。输入为三个整数：day、month 和 year，分别表示日、月、年。\n您返回的结果必须是这几个值中的一个 {\u0026ldquo;Sunday\u0026rdquo;, \u0026ldquo;Monday\u0026rdquo;, \u0026ldquo;Tuesday\u0026rdquo;, \u0026ldquo;Wednesday\u0026rdquo;, \u0026ldquo;Thursday\u0026rdquo;, \u0026ldquo;Friday\u0026rdquo;, \u0026ldquo;Saturday\u0026rdquo;}。\n提示：\n 给出的日期一定是在 1971 到 2100 年之间的有效日期。  解题思路 #   给出一个日期，要求算出这一天是星期几。 简单题，按照常识计算即可。  代码 #  package leetcode import \u0026#34;time\u0026#34; func dayOfTheWeek(day int, month int, year int) string { return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.Local).Weekday().String() } "});index.add({'id':495,'href':'/leetcode-java/04_Leetcode/1189.Maximum-Number-of-Balloons/','title':"1189. Maximum Number of Balloons",'section':"第四章",'content':"1189. Maximum Number of Balloons #  题目 #  Given a string text, you want to use the characters of text to form as many instances of the word \u0026ldquo;balloon\u0026rdquo; as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\nExample 1:\n Input: text = \u0026quot;nlaebolko\u0026quot; Output: 1  Example 2:\n Input: text = \u0026quot;loonbalxballpoon\u0026quot; Output: 2  Example 3:\nInput: text = \u0026quot;leetcode\u0026quot; Output: 0  Constraints:\n 1 \u0026lt;= text.length \u0026lt;= 10^4 text consists of lower case English letters only.  题目大意 #  给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 \u0026ldquo;balloon\u0026rdquo;（气球）。字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \u0026ldquo;balloon\u0026rdquo;。\n提示：\n 1 \u0026lt;= text.length \u0026lt;= 10^4 text 全部由小写英文字母组成  解题思路 #   给出一个字符串，问这个字符串里面的数组能组成多少个 balloon 这个单词。 简单题，先统计 26 个字母每个字母的频次，然后取出 balloon 这 5 个字母出现频次最小的值就是结果。  代码 #  package leetcode func maxNumberOfBalloons(text string) int { fre := make([]int, 26) for _, t := range text { fre[t-\u0026#39;a\u0026#39;]++ } // 字符 b 的频次是数组下标 1 对应的元素值 \t// 字符 a 的频次是数组下标 0 对应的元素值 \t// 字符 l 的频次是数组下标 11 对应的元素值，这里有 2 个 l，所以元素值需要除以 2 \t// 字符 o 的频次是数组下标 14 对应的元素值，这里有 2 个 o，所以元素值需要除以 2 \t// 字符 n 的频次是数组下标 13 对应的元素值 \treturn min(fre[1], min(fre[0], min(fre[11]/2, min(fre[14]/2, fre[13])))) } "});index.add({'id':496,'href':'/leetcode-java/04_Leetcode/1200.Minimum-Absolute-Difference/','title':"1200. Minimum Absolute Difference",'section':"第四章",'content':"1200. Minimum Absolute Difference #  题目 #  Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows\n a, b are from arr a \u0026lt; b b - a equals to the minimum absolute difference of any two elements in arr  Example 1:\nInput: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.  Example 2:\nInput: arr = [1,3,6,10,15] Output: [[1,3]]  Example 3:\nInput: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]]  Constraints:\n 2 \u0026lt;= arr.length \u0026lt;= 10^5 -10^6 \u0026lt;= arr[i] \u0026lt;= 10^6  题目大意 #  给出一个数组，要求找出所有满足条件的数值对 [a,b]：a\u0026lt;b 并且 b-a 的差值是数组中所有两个元素差值的最小值。\n解题思路 #   给出一个数组，要求找出所有满足条件的数值对 [a,b]：a\u0026lt;b 并且 b-a 的差值是数组中所有两个元素差值的最小值。 简单题，按照题意先排序，然后依次求出两个相邻元素的差值，求出最小的差值。最后遍历一遍数组，把所有等于最小差值的数值对都输出。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; \u0026#34;sort\u0026#34; ) func minimumAbsDifference(arr []int) [][]int { minDiff, res := math.MaxInt32, [][]int{} sort.Ints(arr) for i := 1; i \u0026lt; len(arr); i++ { if arr[i]-arr[i-1] \u0026lt; minDiff { minDiff = arr[i] - arr[i-1] } if minDiff == 1 { break } } for i := 1; i \u0026lt; len(arr); i++ { if arr[i]-arr[i-1] == minDiff { res = append(res, []int{arr[i-1], arr[i]}) } } return res } "});index.add({'id':497,'href':'/leetcode-java/04_Leetcode/1201.Ugly-Number-III/','title':"1201. Ugly Number I I I",'section':"第四章",'content':"1201. Ugly Number III #  题目 #  Write a program to find the n-th ugly number.\nUgly numbers are positive integers which are divisible by a or b or c.\nExample 1:\nInput: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.  Example 2:\nInput: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.  Example 3:\nInput: n = 5, a = 2, b = 11, c = 13 Output: 10 Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.  Example 4:\nInput: n = 1000000000, a = 2, b = 217983653, c = 336916467 Output: 1999999984  Constraints:\n 1 \u0026lt;= n, a, b, c \u0026lt;= 10^9 1 \u0026lt;= a * b * c \u0026lt;= 10^18 It\u0026rsquo;s guaranteed that the result will be in range [1, 2 * 10^9]  题目大意 #  请你帮忙设计一个程序，用来找出第 n 个丑数。丑数是可以被 a 或 b 或 c 整除的 正整数。\n提示：\n 1 \u0026lt;= n, a, b, c \u0026lt;= 10^9 1 \u0026lt;= a * b * c \u0026lt;= 10^18 本题结果在 [1, 2 * 10^9] 的范围内  解题思路 #   给出 4 个数字，a，b，c，n。要求输出可以整除 a 或者整除 b 或者整除 c 的第 n 个数。 这一题限定了解的范围， [1, 2 * 10^9]，所以直接二分搜索来求解。逐步二分逼近 low 值，直到找到能满足条件的 low 的最小值，即为最终答案。 这一题的关键在如何判断一个数是第几个数。一个数能整除 a，能整除 b，能整除 c，那么它应该是第 num/a + num/b + num/c - num/ab - num/bc - num/ac + num/abc 个数。这个就是韦恩图。需要注意的是，求 ab、bc、ac、abc 的时候需要再除以各自的最大公约数 gcd()。  代码 #  package leetcode func nthUglyNumber(n int, a int, b int, c int) int { low, high := int64(0), int64(2*1e9) for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calNthCount(mid, int64(a), int64(b), int64(c)) \u0026lt; int64(n) { low = mid + 1 } else { high = mid } } return int(low) } func calNthCount(num, a, b, c int64) int64 { ab, bc, ac := a*b/gcd(a, b), b*c/gcd(b, c), a*c/gcd(a, c) abc := a * bc / gcd(a, bc) return num/a + num/b + num/c - num/ab - num/bc - num/ac + num/abc } func gcd(a, b int64) int64 { for b != 0 { a, b = b, a%b } return a } "});index.add({'id':498,'href':'/leetcode-java/04_Leetcode/1202.Smallest-String-With-Swaps/','title':"1202. Smallest String With Swaps",'section':"第四章",'content':"1202. Smallest String With Swaps #  题目 #  You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.\nYou can swap the characters at any pair of indices in the given pairs any number of times.\nReturn the lexicographically smallest string that s can be changed to after using the swaps.\nExample 1:\nInput: s = \u0026quot;dcab\u0026quot;, pairs = [[0,3],[1,2]] Output: \u0026quot;bacd\u0026quot; Explaination: Swap s[0] and s[3], s = \u0026quot;bcad\u0026quot; Swap s[1] and s[2], s = \u0026quot;bacd\u0026quot;  Example 2:\nInput: s = \u0026quot;dcab\u0026quot;, pairs = [[0,3],[1,2],[0,2]] Output: \u0026quot;abcd\u0026quot; Explaination: Swap s[0] and s[3], s = \u0026quot;bcad\u0026quot; Swap s[0] and s[2], s = \u0026quot;acbd\u0026quot; Swap s[1] and s[2], s = \u0026quot;abcd\u0026quot;  Example 3:\nInput: s = \u0026quot;cba\u0026quot;, pairs = [[0,1],[1,2]] Output: \u0026quot;abc\u0026quot; Explaination: Swap s[0] and s[1], s = \u0026quot;bca\u0026quot; Swap s[1] and s[2], s = \u0026quot;bac\u0026quot; Swap s[0] and s[1], s = \u0026quot;abc\u0026quot;  Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 10^5 0 \u0026lt;= pairs.length \u0026lt;= 10^5 0 \u0026lt;= pairs[i][0], pairs[i][1] \u0026lt; s.length s only contains lower case English letters.  题目大意 #  给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。你可以 任意多次交换 在 pairs 中任意一对索引处的字符。返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。\n提示：\n 1 \u0026lt;= s.length \u0026lt;= 10^5 0 \u0026lt;= pairs.length \u0026lt;= 10^5 0 \u0026lt;= pairs[i][0], pairs[i][1] \u0026lt; s.length s 中只含有小写英文字母  解题思路 #   给出一个字符串和一个字符串里可交换的下标。要求交换以后字典序最小的字符串。 这一题可以用并查集来解题，先把可交换下标都 Union() 起来，每个集合内，按照字典序从小到大排列。最后扫描原有字符串，从左到右依次找到各自对应的集合里面最小的字符进行替换，每次替换完以后，删除集合中该字符(防止下次重复替换)。最终得到的字符就是最小字典序的字符。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; ) func smallestStringWithSwaps(s string, pairs [][]int) string { uf, res, sMap := template.UnionFind{}, []byte(s), map[int][]byte{} uf.Init(len(s)) for _, pair := range pairs { uf.Union(pair[0], pair[1]) } for i := 0; i \u0026lt; len(s); i++ { r := uf.Find(i) sMap[r] = append(sMap[r], s[i]) } for _, v := range sMap { sort.Slice(v, func(i, j int) bool { return v[i] \u0026lt; v[j] }) } for i := 0; i \u0026lt; len(s); i++ { r := uf.Find(i) bytes := sMap[r] res[i] = bytes[0] sMap[r] = bytes[1:len(bytes)] } return string(res) } "});index.add({'id':499,'href':'/leetcode-java/04_Leetcode/1207.Unique-Number-of-Occurrences/','title':"1207. Unique Number of Occurrences",'section':"第四章",'content':"1207. Unique Number of Occurrences #  题目 #  Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.\nExample 1:\nInput: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.  Example 2:\nInput: arr = [1,2] Output: false  Example 3:\nInput: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true  Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 1000 -1000 \u0026lt;= arr[i] \u0026lt;= 1000  题目大意 #  给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 1000 -1000 \u0026lt;= arr[i] \u0026lt;= 1000  解题思路 #   给出一个数组，先统计每个数字出现的频次，判断在这个数组中是否存在相同的频次。 简单题，先统计数组中每个数字的频次，然后用一个 map 判断频次是否重复。  代码 #  package leetcode func uniqueOccurrences(arr []int) bool { freq, m := map[int]int{}, map[int]bool{} for _, v := range arr { freq[v]++ } for _, v := range freq { if _, ok := m[v]; !ok { m[v] = true } else { return false } } return true } "});index.add({'id':500,'href':'/leetcode-java/04_Leetcode/1208.Get-Equal-Substrings-Within-Budget/','title':"1208. Get Equal Substrings Within Budget",'section':"第四章",'content':"1208. Get Equal Substrings Within Budget #  题目 #  You are given two strings s and t of the same length. You want to change s to t. Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.\nYou are also given an integer maxCost.\nReturn the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.\nIf there is no substring from s that can be changed to its corresponding substring from t, return 0.\nExample 1:\nInput: s = \u0026quot;abcd\u0026quot;, t = \u0026quot;bcdf\u0026quot;, maxCost = 3 Output: 3 Explanation: \u0026quot;abc\u0026quot; of s can change to \u0026quot;bcd\u0026quot;. That costs 3, so the maximum length is 3.  Example 2:\nInput: s = \u0026quot;abcd\u0026quot;, t = \u0026quot;cdef\u0026quot;, maxCost = 3 Output: 1 Explanation: Each character in s costs 2 to change to charactor in t, so the maximum length is 1.  Example 3:\nInput: s = \u0026quot;abcd\u0026quot;, t = \u0026quot;acde\u0026quot;, maxCost = 0 Output: 1 Explanation: You can't make any change, so the maximum length is 1.  Constraints:\n 1 \u0026lt;= s.length, t.length \u0026lt;= 10^5 0 \u0026lt;= maxCost \u0026lt;= 10^6 s and t only contain lower case English letters.  题目大意 #  给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。\n用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。\n提示：\n 1 \u0026lt;= s.length, t.length \u0026lt;= 10^5 0 \u0026lt;= maxCost \u0026lt;= 10^6 s 和 t 都只含小写英文字母。  解题思路 #   给出 2 个字符串 s 和 t 和一个“预算”，要求把“预算”尽可能的花完，s 中最多连续有几个字母能变成 t 中的字母。“预算”的定义是：|s[i] - t[i]| 。 这一题是滑动窗口的题目，滑动窗口右边界每移动一格，就减少一定的预算，直到预算不能减少，再移动滑动窗口的左边界，这个时候注意要把预算还原回去。当整个窗口把字符 s 或 t 都滑动完了的时候，取出滑动过程中窗口的最大值即为结果。  代码 #  package leetcode func equalSubstring(s string, t string, maxCost int) int { left, right, res := 0, -1, 0 for left \u0026lt; len(s) { if right+1 \u0026lt; len(s) \u0026amp;\u0026amp; maxCost-abs(int(s[right+1]-\u0026#39;a\u0026#39;)-int(t[right+1]-\u0026#39;a\u0026#39;)) \u0026gt;= 0 { right++ maxCost -= abs(int(s[right]-\u0026#39;a\u0026#39;) - int(t[right]-\u0026#39;a\u0026#39;)) } else { res = max(res, right-left+1) maxCost += abs(int(s[left]-\u0026#39;a\u0026#39;) - int(t[left]-\u0026#39;a\u0026#39;)) left++ } } return res } "});index.add({'id':501,'href':'/leetcode-java/04_Leetcode/1217.Play-with-Chips/','title':"1217. Play With Chips",'section':"第四章",'content':"1217. Play with Chips #  题目 #  There are some chips, and the i-th chip is at position chips[i].\nYou can perform any of the two following types of moves any number of times (possibly zero) on any chip:\n Move the i-th chip by 2 units to the left or to the right with a cost of 0. Move the i-th chip by 1 unit to the left or to the right with a cost of 1.  There can be two or more chips at the same position initially.\nReturn the minimum cost needed to move all the chips to the same position (any position).\nExample 1:\nInput: chips = [1,2,3] Output: 1 Explanation: Second chip will be moved to positon 3 with cost 1. First chip will be moved to position 3 with cost 0. Total cost is 1.  Example 2:\nInput: chips = [2,2,2,3,3] Output: 2 Explanation: Both fourth and fifth chip will be moved to position two with cost 1. Total minimum cost will be 2.  Constraints:\n 1 \u0026lt;= chips.length \u0026lt;= 100 1 \u0026lt;= chips[i] \u0026lt;= 10^9  题目大意 #  数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：\n 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。  最开始的时候，同一位置上也可能放着两个或者更多的筹码。返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。\n提示：\n 1 \u0026lt;= chips.length \u0026lt;= 100 1 \u0026lt;= chips[i] \u0026lt;= 10^9  解题思路 #   给出一个数组，数组的下标代表的是数轴上的坐标点，数组的元素代表的是砝码大小。砝码移动规则，左右移动 2 格，没有代价，左右移动 1 个，代价是 1 。问最终把砝码都移动到一个格子上，最小代价是多少。 先解读砝码移动规则：偶数位置的到偶数位置的没有代价，奇数到奇数位置的没有代价。利用这个规则，我们可以把所有的砝码无代价的摞在一个奇数的位置上和一个偶数的位置上。这样我们只用关心这两个位置了。并且这两个位置可以连续在一起。最后一步即将相邻的这两摞砝码合并到一起。由于左右移动一个代价是 1，所以最小代价的操作是移动最少砝码的那一边。奇数位置上砝码少就移动奇数位置上的，偶数位置上砝码少就移动偶数位置上的。所以这道题解法变的异常简单，遍历一次数组，找到其中有多少个奇数和偶数位置的砝码，取其中比较少的，就是最终答案。  代码 #  package leetcode func minCostToMoveChips(chips []int) int { odd, even := 0, 0 for _, c := range chips { if c%2 == 0 { even++ } else { odd++ } } return min(odd, even) } "});index.add({'id':502,'href':'/leetcode-java/04_Leetcode/1221.Split-a-String-in-Balanced-Strings/','title':"1221. Split a String in Balanced Strings",'section':"第四章",'content':"1221. Split a String in Balanced Strings #  题目 #  Balanced strings are those who have equal quantity of \u0026lsquo;L\u0026rsquo; and \u0026lsquo;R\u0026rsquo; characters.\nGiven a balanced string s split it in the maximum amount of balanced strings.\nReturn the maximum amount of splitted balanced strings.\nExample 1:\nInput: s = \u0026quot;RLRRLLRLRL\u0026quot; Output: 4 Explanation: s can be split into \u0026quot;RL\u0026quot;, \u0026quot;RRLL\u0026quot;, \u0026quot;RL\u0026quot;, \u0026quot;RL\u0026quot;, each substring contains same number of 'L' and 'R'.  Example 2:\nInput: s = \u0026quot;RLLLLRRRLR\u0026quot; Output: 3 Explanation: s can be split into \u0026quot;RL\u0026quot;, \u0026quot;LLLRRR\u0026quot;, \u0026quot;LR\u0026quot;, each substring contains same number of 'L' and 'R'.  Example 3:\nInput: s = \u0026quot;LLLLRRRR\u0026quot; Output: 1 Explanation: s can be split into \u0026quot;LLLLRRRR\u0026quot;.  Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 1000 s[i] = 'L' or 'R'  题目大意 #  在一个「平衡字符串」中，\u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 字符的数量是相同的。给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的最大数量。\n提示：\n 1 \u0026lt;= s.length \u0026lt;= 1000 s[i] = \u0026lsquo;L\u0026rsquo; 或 \u0026lsquo;R\u0026rsquo;  解题思路 #   给出一个字符串，要求把这个字符串切成一些子串，这些子串中 R 和 L 的字符数是相等的。问能切成多少个满足条件的子串。 这道题是简单题，按照题意模拟即可。从左往右扫，遇到 R 就加一，遇到 L 就减一，当计数是 0 的时候就是平衡的时候，就切割。  代码 #  package leetcode func balancedStringSplit(s string) int { count, res := 0, 0 for _, r := range s { if r == \u0026#39;R\u0026#39; { count++ } else { count-- } if count == 0 { res++ } } return res } "});index.add({'id':503,'href':'/leetcode-java/04_Leetcode/1232.Check-If-It-Is-a-Straight-Line/','title':"1232. Check if It Is a Straight Line",'section':"第四章",'content':"1232. Check If It Is a Straight Line #  题目 #  You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.\nExample 1:\n Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true  Example 2:\n Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false  Constraints:\n 2 \u0026lt;= coordinates.length \u0026lt;= 1000 coordinates[i].length == 2 -10^4 \u0026lt;= coordinates[i][0], coordinates[i][1] \u0026lt;= 10^4 coordinates contains no duplicate point.  题目大意 #  在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。\n提示：\n 2 \u0026lt;= coordinates.length \u0026lt;= 1000 coordinates[i].length == 2 -10^4 \u0026lt;= coordinates[i][0], coordinates[i][1] \u0026lt;= 10^4 coordinates 中不含重复的点  解题思路 #   给出一组坐标点，要求判断这些点是否在同一直线上。 按照几何原理，依次计算这些点的斜率是否相等即可。斜率需要做除法，这里采用一个技巧是换成乘法。例如 a/b = c/d 换成乘法是 a*d = c*d 。  代码 #  package leetcode func checkStraightLine(coordinates [][]int) bool { dx0 := coordinates[1][0] - coordinates[0][0] dy0 := coordinates[1][1] - coordinates[0][1] for i := 1; i \u0026lt; len(coordinates)-1; i++ { dx := coordinates[i+1][0] - coordinates[i][0] dy := coordinates[i+1][1] - coordinates[i][1] if dy*dx0 != dy0*dx { // check cross product \treturn false } } return true } "});index.add({'id':504,'href':'/leetcode-java/04_Leetcode/1234.Replace-the-Substring-for-Balanced-String/','title':"1234. Replace the Substring for Balanced String",'section':"第四章",'content':"1234. Replace the Substring for Balanced String #  题目 #  You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.\nA string is said to be balanced **if each of its characters appears n/4 times where n is the length of the string.\nReturn the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.\nReturn 0 if the string is already balanced.\nExample 1:\nInput: s = \u0026quot;QWER\u0026quot; Output: 0 Explanation: s is already balanced.  Example 2:\nInput: s = \u0026quot;QQWE\u0026quot; Output: 1 Explanation: We need to replace a 'Q' to 'R', so that \u0026quot;RQWE\u0026quot; (or \u0026quot;QRWE\u0026quot;) is balanced.  Example 3:\nInput: s = \u0026quot;QQQW\u0026quot; Output: 2 Explanation: We can replace the first \u0026quot;QQ\u0026quot; to \u0026quot;ER\u0026quot;.  Example 4:\nInput: s = \u0026quot;QQQQ\u0026quot; Output: 3 Explanation: We can replace the last 3 'Q' to make s = \u0026quot;QWER\u0026quot;.  Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 10^5 s.length is a multiple of 4 s contains only 'Q', 'W', 'E' and 'R'.  题目大意 #  有一个只含有 \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;R\u0026rsquo; 四种字符，且长度为 n 的字符串。假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。请返回待替换子串的最小可能长度。如果原字符串自身就是一个平衡字符串，则返回 0。\n提示：\n 1 \u0026lt;= s.length \u0026lt;= 10^5 s.length 是 4 的倍数 s 中只含有 \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;R\u0026rsquo; 四种字符  解题思路 #   给出一个字符串，要求输出把这个字符串变成“平衡字符串”的最小替换字符串的长度(替换只能替换一串，不能单个字母替换)。“平衡字符串”的定义是：字符串中，‘Q’，‘W’，‘E’，‘R’，出现的次数当且仅当只有 len(s)/4 次。 这一题是滑动窗口的题目。先统计 4 个字母的频次并计算出 k = len(s)/4 。滑动窗口向右滑动一次，对应右窗口的那个字母频次减 1，直到滑到所有字母的频次都 ≤ k 的地方停止。此时，窗口外的字母的频次都 ≤ k 了。这是只要变换窗口内字符串即可。但是这个窗口内还可能包含本来频次就小于 k 的字母，如果能把它们剔除掉，窗口可以进一步的减少。所以继续移动左边界，试探移动完左边界以后，是否所有字母频次都 ≤ k。在所有窗口移动过程中取出最小值，即为最终答案。 举个例子：\u0026quot;WQWRQQQW\u0026quot;。w 有 3 个，Q 有 4 个，R 有 1 个，E 有 0 个。最后平衡状态是每个字母 2 个，那么我们需要拿出 1 个 W 和 2 个 Q 替换掉。即要找到一个最短的字符串包含 1 个 W 和 2 个 Q。滑动窗口正好可以解决这个问题。向右滑到 \u0026quot;WQWRQ\u0026quot; 停止，这时窗口外的所有字母频次都 ≤ k 了。这个窗口包含了多余的 1 个 W，和 1 个 R。W 可以踢除掉，那么要替换的字符串是 \u0026quot;QWRQ\u0026quot;。R 不能踢除了(因为要找包含 1 个 W 和 2 个 Q 的字符串) 。窗口不断的滑动，直到结束。这个例子中最小的字符串其实位于末尾，\u0026quot;QQW\u0026quot;。  代码 #  package leetcode func balancedString(s string) int { count, k := make([]int, 128), len(s)/4 for _, v := range s { count[int(v)]++ } left, right, res := 0, -1, len(s) for left \u0026lt; len(s) { if count[\u0026#39;Q\u0026#39;] \u0026gt; k || count[\u0026#39;W\u0026#39;] \u0026gt; k || count[\u0026#39;E\u0026#39;] \u0026gt; k || count[\u0026#39;R\u0026#39;] \u0026gt; k { if right+1 \u0026lt; len(s) { right++ count[s[right]]-- } else { break } } else { res = min(res, right-left+1) count[s[left]]++ left++ } } return res } "});index.add({'id':505,'href':'/leetcode-java/04_Leetcode/1235.Maximum-Profit-in-Job-Scheduling/','title':"1235. Maximum Profit in Job Scheduling",'section':"第四章",'content':"1235. Maximum Profit in Job Scheduling #  题目 #  We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\nExample 1:\n Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.  Example 2:\n Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60.  Example 3:\n Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] Output: 6  Constraints:\n 1 \u0026lt;= startTime.length == endTime.length == profit.length \u0026lt;= 5 * 10^4 1 \u0026lt;= startTime[i] \u0026lt; endTime[i] \u0026lt;= 10^9 1 \u0026lt;= profit[i] \u0026lt;= 10^4  题目大意 #  你打算利用空闲时间来做兼职工作赚些零花钱。这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。注意，时间上出现重叠的 2 份工作不能同时进行。如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。\n提示：\n 1 \u0026lt;= startTime.length == endTime.length == profit.length \u0026lt;= 5 * 10^4 1 \u0026lt;= startTime[i] \u0026lt; endTime[i] \u0026lt;= 10^9 1 \u0026lt;= profit[i] \u0026lt;= 10^4  解题思路 #   给出一组任务，任务有开始时间，结束时间，和任务收益。一个任务开始还没有结束，中间就不能再安排其他任务。问如何安排任务，能使得最后收益最大？ 一般任务的题目，区间的题目，都会考虑是否能排序。这一题可以先按照任务的结束时间从小到大排序，如果结束时间相同，则按照收益从小到大排序。dp[i] 代表前 i 份工作能获得的最大收益。初始值，dp[0] = job[1].profit 。对于任意一个任务 i ，看能否找到满足 jobs[j].enTime \u0026lt;= jobs[j].startTime \u0026amp;\u0026amp; j \u0026lt; i 条件的 j，即查找 upper_bound 。由于 jobs 被我们排序了，所以这里可以使用二分搜索来查找。如果能找到满足条件的任务 j，那么状态转移方程是：dp[i] = max(dp[i-1], jobs[i].profit)。如果能找到满足条件的任务 j，那么状态转移方程是：dp[i] = max(dp[i-1], dp[low]+jobs[i].profit)。最终求得的解在 dp[len(startTime)-1] 中。  代码 #  package leetcode import \u0026#34;sort\u0026#34; type job struct { startTime int endTime int profit int } func jobScheduling(startTime []int, endTime []int, profit []int) int { jobs, dp := []job{}, make([]int, len(startTime)) for i := 0; i \u0026lt; len(startTime); i++ { jobs = append(jobs, job{startTime: startTime[i], endTime: endTime[i], profit: profit[i]}) } sort.Sort(sortJobs(jobs)) dp[0] = jobs[0].profit for i := 1; i \u0026lt; len(jobs); i++ { low, high := 0, i-1 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if jobs[mid+1].endTime \u0026lt;= jobs[i].startTime { low = mid + 1 } else { high = mid } } if jobs[low].endTime \u0026lt;= jobs[i].startTime { dp[i] = max(dp[i-1], dp[low]+jobs[i].profit) } else { dp[i] = max(dp[i-1], jobs[i].profit) } } return dp[len(startTime)-1] } type sortJobs []job func (s sortJobs) Len() int { return len(s) } func (s sortJobs) Less(i, j int) bool { if s[i].endTime == s[j].endTime { return s[i].profit \u0026lt; s[j].profit } return s[i].endTime \u0026lt; s[j].endTime } func (s sortJobs) Swap(i, j int) { s[i], s[j] = s[j], s[i] } "});index.add({'id':506,'href':'/leetcode-java/04_Leetcode/1252.Cells-with-Odd-Values-in-a-Matrix/','title':"1252. Cells With Odd Values in a Matrix",'section':"第四章",'content':"1252. Cells with Odd Values in a Matrix #  题目 #  Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\nExample 1:\n Input: n = 2, m = 3, indices = [[0,1],[1,1]] Output: 6 Explanation: Initial matrix = [[0,0,0],[0,0,0]]. After applying first increment it becomes [[1,2,1],[0,1,0]]. The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.  Example 2:\n Input: n = 2, m = 2, indices = [[1,1],[0,0]] Output: 0 Explanation: Final matrix = [[2,2],[2,2]]. There is no odd number in the final matrix.  Constraints:\n 1 \u0026lt;= n \u0026lt;= 50 1 \u0026lt;= m \u0026lt;= 50 1 \u0026lt;= indices.length \u0026lt;= 100 0 \u0026lt;= indices[i][0] \u0026lt; n 0 \u0026lt;= indices[i][1] \u0026lt; m  题目大意 #  给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。\n提示：\n 1 \u0026lt;= n \u0026lt;= 50 1 \u0026lt;= m \u0026lt;= 50 1 \u0026lt;= indices.length \u0026lt;= 100 0 \u0026lt;= indices[i][0] \u0026lt; n 0 \u0026lt;= indices[i][1] \u0026lt; m  解题思路 #   给出一个 n * m 的矩阵，和一个数组，数组里面包含一些行列坐标，并在指定坐标上 + 1，问最后 n * m 的矩阵中奇数的总数。 暴力方法按照题意模拟即可。  代码 #  package leetcode // 解法一 暴力法 func oddCells(n int, m int, indices [][]int) int { matrix, res := make([][]int, n), 0 for i := range matrix { matrix[i] = make([]int, m) } for _, indice := range indices { for i := 0; i \u0026lt; m; i++ { matrix[indice[0]][i]++ } for j := 0; j \u0026lt; n; j++ { matrix[j][indice[1]]++ } } for _, m := range matrix { for _, v := range m { if v\u0026amp;1 == 1 { res++ } } } return res } // 解法二 暴力法 func oddCells1(n int, m int, indices [][]int) int { rows, cols, count := make([]int, n), make([]int, m), 0 for _, pair := range indices { rows[pair[0]]++ cols[pair[1]]++ } for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; m; j++ { if (rows[i]+cols[j])%2 == 1 { count++ } } } return count } "});index.add({'id':507,'href':'/leetcode-java/04_Leetcode/1254.Number-of-Closed-Islands/','title':"1254. Number of Closed Islands",'section':"第四章",'content':"1254. Number of Closed Islands #  题目 #  Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.\nReturn the number of closed islands.\nExample 1:\n Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s).  Example 2:\n Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1  Example 3:\nInput: grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]] Output: 2  Constraints:\n 1 \u0026lt;= grid.length, grid[0].length \u0026lt;= 100 0 \u0026lt;= grid[i][j] \u0026lt;=1  题目大意 #  有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。请返回封闭岛屿的数目。\n提示：\n 1 \u0026lt;= grid.length, grid[0].length \u0026lt;= 100 0 \u0026lt;= grid[i][j] \u0026lt;=1  解题思路 #   给出一个地图，1 代表海水，0 代表陆地。要求找出四周都是海水的陆地的总个数。 这一题和第 200 题解题思路完全一致。只不过这一题要求必须四周都是海水，第 200 题的陆地可以是靠着地图边缘的。在此题中，靠着地图边缘的陆地不能最终计数到结果中。  代码 #  package leetcode func closedIsland(grid [][]int) int { m := len(grid) if m == 0 { return 0 } n := len(grid[0]) if n == 0 { return 0 } res, visited := 0, make([][]bool, m) for i := 0; i \u0026lt; m; i++ { visited[i] = make([]bool, n) } for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { isEdge := false if grid[i][j] == 0 \u0026amp;\u0026amp; !visited[i][j] { checkIslands(grid, \u0026amp;visited, i, j, \u0026amp;isEdge) if !isEdge { res++ } } } } return res } func checkIslands(grid [][]int, visited *[][]bool, x, y int, isEdge *bool) { if (x == 0 || x == len(grid)-1 || y == 0 || y == len(grid[0])-1) \u0026amp;\u0026amp; grid[x][y] == 0 { *isEdge = true } (*visited)[x][y] = true for i := 0; i \u0026lt; 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if isIntInBoard(grid, nx, ny) \u0026amp;\u0026amp; !(*visited)[nx][ny] \u0026amp;\u0026amp; grid[nx][ny] == 0 { checkIslands(grid, visited, nx, ny, isEdge) } } *isEdge = *isEdge || false } func isIntInBoard(board [][]int, x, y int) bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; len(board) \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; len(board[0]) } "});index.add({'id':508,'href':'/leetcode-java/04_Leetcode/1260.Shift-2D-Grid/','title':"1260. Shift 2 D Grid",'section':"第四章",'content':"1260. Shift 2D Grid #  题目 #  Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.\nIn one shift operation:\n Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0].  Return the 2D grid after applying shift operation k times.\nExample 1:\n Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2:\n Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3:\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] Constraints:\n m == grid.length n == grid[i].length 1 \u0026lt;= m \u0026lt;= 50 1 \u0026lt;= n \u0026lt;= 50 -1000 \u0026lt;= grid[i][j] \u0026lt;= 1000 0 \u0026lt;= k \u0026lt;= 100  题目大意 #  给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。每次「迁移」操作将会引发下述活动：\n 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。  请你返回 k 次迁移操作后最终得到的 二维网格。\n解题思路 #   给一个矩阵和一个移动步数 k，要求把矩阵每个元素往后移动 k 步，最后的元素移动头部，循环移动，最后输出移动结束的矩阵。 简单题，按照题意循环移动即可，注意判断边界情况。  代码 #  package leetcode func shiftGrid(grid [][]int, k int) [][]int { x, y := len(grid[0]), len(grid) newGrid := make([][]int, y) for i := 0; i \u0026lt; y; i++ { newGrid[i] = make([]int, x) } for i := 0; i \u0026lt; y; i++ { for j := 0; j \u0026lt; x; j++ { ny := (k / x) + i if (j + (k % x)) \u0026gt;= x { ny++ } newGrid[ny%y][(j+(k%x))%x] = grid[i][j] } } return newGrid } "});index.add({'id':509,'href':'/leetcode-java/04_Leetcode/1266.Minimum-Time-Visiting-All-Points/','title':"1266. Minimum Time Visiting All Points",'section':"第四章",'content':"1266. Minimum Time Visiting All Points #  题目 #  On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.  Example 1:\n Input: points = [[1,1],[3,4],[-1,0]] Output: 7 Explanation: One optimal path is [1,1] -\u0026gt; [2,2] -\u0026gt; [3,3] -\u0026gt; [3,4] -\u0026gt; [2,3] -\u0026gt; [1,2] -\u0026gt; [0,1] -\u0026gt; [-1,0] Time from [1,1] to [3,4] = 3 seconds Time from [3,4] to [-1,0] = 4 seconds Total time = 7 seconds  Example 2:\nInput: points = [[3,2],[-2,2]] Output: 5  Constraints:\n points.length == n 1 \u0026lt;= n \u0026lt;= 100 points[i].length == 2 -1000 \u0026lt;= points[i][0], points[i][1] \u0026lt;= 1000  题目大意 #  平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。你可以按照下面的规则在平面上移动：\n 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。  提示：\n points.length == n 1 \u0026lt;= n \u0026lt;= 100 points[i].length == 2 -1000 \u0026lt;= points[i][0], points[i][1] \u0026lt;= 1000  解题思路 #   在直角坐标系上给出一个数组，数组里面的点是飞机飞行经过的点。飞机飞行只能沿着水平方向、垂直方向、45°方向飞行。问飞机经过所有点的最短时间。 简单的数学问题。依次遍历数组，分别计算 x 轴和 y 轴上的差值，取最大值即是这两点之间飞行的最短时间。最后累加每次计算的最大值就是最短时间。  代码 #  package leetcode func minTimeToVisitAllPoints(points [][]int) int { res := 0 for i := 1; i \u0026lt; len(points); i++ { res += max(abs(points[i][0]-points[i-1][0]), abs(points[i][1]-points[i-1][1])) } return res } "});index.add({'id':510,'href':'/leetcode-java/04_Leetcode/1275.Find-Winner-on-a-Tic-Tac-Toe-Game/','title':"1275. Find Winner on a Tic Tac Toe Game",'section':"第四章",'content':"1275. Find Winner on a Tic Tac Toe Game #  题目 #  Tic-tac-toe is played by two players A and B on a 3 x 3 grid.\nHere are the rules of Tic-Tac-Toe:\n Players take turns placing characters into empty squares (\u0026quot; \u0026ldquo;). The first player A always places \u0026ldquo;X\u0026rdquo; characters, while the second player B always places \u0026ldquo;O\u0026rdquo; characters. \u0026ldquo;X\u0026rdquo; and \u0026ldquo;O\u0026rdquo; characters are always placed into empty squares, never on filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Given an array moves where each element is another array of size 2 corresponding to the row and column of the grid where they mark their respective character in the order in which A and B play.\nReturn the winner of the game if it exists (A or B), in case the game ends in a draw return \u0026ldquo;Draw\u0026rdquo;, if there are still movements to play return \u0026ldquo;Pending\u0026rdquo;.\nYou can assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid is initially empty and A will play first.\nExample 1:\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] Output: \u0026quot;A\u0026quot; Explanation: \u0026quot;A\u0026quot; wins, he always plays first. \u0026quot;X \u0026quot; \u0026quot;X \u0026quot; \u0026quot;X \u0026quot; \u0026quot;X \u0026quot; \u0026quot;X \u0026quot; \u0026quot; \u0026quot; -\u0026gt; \u0026quot; \u0026quot; -\u0026gt; \u0026quot; X \u0026quot; -\u0026gt; \u0026quot; X \u0026quot; -\u0026gt; \u0026quot; X \u0026quot; \u0026quot; \u0026quot; \u0026quot;O \u0026quot; \u0026quot;O \u0026quot; \u0026quot;OO \u0026quot; \u0026quot;OOX\u0026quot; Example 2:\nInput: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] Output: \u0026quot;B\u0026quot; Explanation: \u0026quot;B\u0026quot; wins. \u0026quot;X \u0026quot; \u0026quot;X \u0026quot; \u0026quot;XX \u0026quot; \u0026quot;XXO\u0026quot; \u0026quot;XXO\u0026quot; \u0026quot;XXO\u0026quot; \u0026quot; \u0026quot; -\u0026gt; \u0026quot; O \u0026quot; -\u0026gt; \u0026quot; O \u0026quot; -\u0026gt; \u0026quot; O \u0026quot; -\u0026gt; \u0026quot;XO \u0026quot; -\u0026gt; \u0026quot;XO \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot; \u0026quot;O \u0026quot; Example 3:\nInput: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] Output: \u0026quot;Draw\u0026quot; Explanation: The game ends in a draw since there are no moves to make. \u0026quot;XXO\u0026quot; \u0026quot;OOX\u0026quot; \u0026quot;XOX\u0026quot; Example 4:\nInput: moves = [[0,0],[1,1]] Output: \u0026quot;Pending\u0026quot; Explanation: The game has not finished yet. \u0026quot;X \u0026quot; \u0026quot; O \u0026quot; \u0026quot; \u0026quot; Constraints:\n 1 \u0026lt;= moves.length \u0026lt;= 9 moves[i].length == 2 0 \u0026lt;= moves[i][j] \u0026lt;= 2 There are no repeated elements on moves. moves follow the rules of tic tac toe.  题目大意 #  A 和 B 在一个 3 x 3 的网格上玩井字棋。井字棋游戏的规则如下：\n 玩家轮流将棋子放在空方格 (\u0026rdquo; \u0026ldquo;) 上。 第一个玩家 A 总是用 \u0026ldquo;X\u0026rdquo; 作为棋子，而第二个玩家 B 总是用 \u0026ldquo;O\u0026rdquo; 作为棋子。 \u0026ldquo;X\u0026rdquo; 和 \u0026ldquo;O\u0026rdquo; 只能放在空方格中，而不能放在已经被占用的方格上。 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。 如果所有方块都放满棋子（不为空），游戏也会结束。 游戏结束后，棋子无法再进行任何移动。  给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 \u0026ldquo;Draw\u0026rdquo;；如果仍会有行动（游戏未结束），则返回 \u0026ldquo;Pending\u0026rdquo;。你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。\n提示：\n 1 \u0026lt;= moves.length \u0026lt;= 9 moves[i].length == 2 0 \u0026lt;= moves[i][j] \u0026lt;= 2 moves 里没有重复的元素。 moves 遵循井字棋的规则。  解题思路 #   两人玩 3*3 井字棋，A 先走，B 再走。谁能获胜就输出谁，如果平局输出 “Draw”，如果游戏还未结束，输出 “Pending”。游戏规则：谁能先占满行、列或者对角线任意一条线，谁就赢。 简单题。题目给定 move 数组最多 3 步，而要赢得比赛，必须走满 3 步，所以可以先模拟，按照给的步数数组把 A 和 B 的步数都放在棋盘上。然后依次判断行、列，对角线的三种情况。如果都判完了，剩下的情况就是平局和死局的情况。  代码 #  package leetcode func tictactoe(moves [][]int) string { board := [3][3]byte{} for i := 0; i \u0026lt; len(moves); i++ { if i%2 == 0 { board[moves[i][0]][moves[i][1]] = \u0026#39;X\u0026#39; } else { board[moves[i][0]][moves[i][1]] = \u0026#39;O\u0026#39; } } for i := 0; i \u0026lt; 3; i++ { if board[i][0] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[i][1] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[i][2] == \u0026#39;X\u0026#39; { return \u0026#34;A\u0026#34; } if board[i][0] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[i][1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[i][2] == \u0026#39;O\u0026#39; { return \u0026#34;B\u0026#34; } if board[0][i] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[1][i] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[2][i] == \u0026#39;X\u0026#39; { return \u0026#34;A\u0026#34; } if board[0][i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[1][i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[2][i] == \u0026#39;O\u0026#39; { return \u0026#34;B\u0026#34; } } if board[0][0] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[1][1] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[2][2] == \u0026#39;X\u0026#39; { return \u0026#34;A\u0026#34; } if board[0][0] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[1][1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[2][2] == \u0026#39;O\u0026#39; { return \u0026#34;B\u0026#34; } if board[0][2] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[1][1] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; board[2][0] == \u0026#39;X\u0026#39; { return \u0026#34;A\u0026#34; } if board[0][2] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[1][1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; board[2][0] == \u0026#39;O\u0026#39; { return \u0026#34;B\u0026#34; } if len(moves) \u0026lt; 9 { return \u0026#34;Pending\u0026#34; } return \u0026#34;Draw\u0026#34; } "});index.add({'id':511,'href':'/leetcode-java/04_Leetcode/1281.Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/','title':"1281. Subtract the Product and Sum of Digits of an Integer",'section':"第四章",'content':"1281. Subtract the Product and Sum of Digits of an Integer #  题目 #  Given an integer number n, return the difference between the product of its digits and the sum of its digits.\nExample 1:\nInput: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 Example 2:\nInput: n = 4421 Output: 21 Explanation: Product of digits = 4 * 4 * 2 * 1 = 32 Sum of digits = 4 + 4 + 2 + 1 = 11 Result = 32 - 11 = 21 Constraints:\n 1 \u0026lt;= n \u0026lt;= 10^5  题目大意 #  给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。\n提示：\n 1 \u0026lt;= n \u0026lt;= 10^5  解题思路 #   给出一个数，计算这个数每位数字乘积减去每位数字累加的差值。 简单题，按照题意输入输出即可。  代码 #  func subtractProductAndSum(n int) int { sum, product := 0, 1 for ; n \u0026gt; 0; n /= 10 { sum += n % 10 product *= n % 10 } return product - sum } "});index.add({'id':512,'href':'/leetcode-java/04_Leetcode/1283.Find-the-Smallest-Divisor-Given-a-Threshold/','title':"1283. Find the Smallest Divisor Given a Threshold",'section':"第四章",'content':"1283. Find the Smallest Divisor Given a Threshold #  题目 #  Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\nIt is guaranteed that there will be an answer.\nExample 1:\nInput: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). Example 2:\nInput: nums = [2,3,5,7,11], threshold = 11 Output: 3 Example 3:\nInput: nums = [19], threshold = 5 Output: 4 Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 5 * 10^4 1 \u0026lt;= nums[i] \u0026lt;= 10^6 nums.length \u0026lt;= threshold \u0026lt;= 10^6  题目大意 #  给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。题目保证一定有解。\n提示：\n 1 \u0026lt;= nums.length \u0026lt;= 5 * 10^4 1 \u0026lt;= nums[i] \u0026lt;= 10^6 nums.length \u0026lt;= threshold \u0026lt;= 10^6  解题思路 #   给出一个数组和一个阈值，要求找到一个除数，使得数组里面每个数和这个除数的商之和不超过这个阈值。求除数的最小值。 这一题是典型的二分搜索的题目。根据题意，在 [1, 1000000] 区间内搜索除数，针对每次 mid，计算一次商的累加和。如果和比 threshold 小，说明除数太大，所以缩小右区间；如果和比 threshold 大，说明除数太小，所以缩小左区间。最终找到的 low 值就是最求的最小除数。  代码 #  func smallestDivisor(nums []int, threshold int) int { low, high := 1, 1000000 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calDivisor(nums, mid, threshold) { high = mid } else { low = mid + 1 } } return low } func calDivisor(nums []int, mid, threshold int) bool { sum := 0 for i := range nums { if nums[i]%mid != 0 { sum += nums[i]/mid + 1 } else { sum += nums[i] / mid } } if sum \u0026lt;= threshold { return true } return false } "});index.add({'id':513,'href':'/leetcode-java/04_Leetcode/1287.Element-Appearing-More-Than-25-In-Sorted-Array/','title':"1287. Element Appearing More Than 25 in Sorted Array",'section':"第四章",'content':"1287. Element Appearing More Than 25% In Sorted Array #  题目 #  Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time.\nReturn that integer.\nExample 1:\nInput: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 0 \u0026lt;= arr[i] \u0026lt;= 10^5  题目大意 #  给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 0 \u0026lt;= arr[i] \u0026lt;= 10^5  解题思路 #   给出一个非递减的有序数组，要求输出出现次数超过数组元素总数 25% 的元素。 简单题，由于已经非递减有序了，所以只需要判断 arr[i] == arr[i+n/4] 是否相等即可。  代码 #  func findSpecialInteger(arr []int) int { n := len(arr) for i := 0; i \u0026lt; n-n/4; i++ { if arr[i] == arr[i+n/4] { return arr[i] } } return -1 } "});index.add({'id':514,'href':'/leetcode-java/04_Leetcode/1290.Convert-Binary-Number-in-a-Linked-List-to-Integer/','title':"1290. Convert Binary Number in a Linked List to Integer",'section':"第四章",'content':"1290. Convert Binary Number in a Linked List to Integer #  题目 #  Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\nReturn the decimal value of the number in the linked list.\nExample 1:\n Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Example 2:\nInput: head = [0] Output: 0 Example 3:\nInput: head = [1] Output: 1 Example 4:\nInput: head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] Output: 18880 Example 5:\nInput: head = [0,0] Output: 0 Constraints:\n The Linked List is not empty. Number of nodes will not exceed 30. Each node\u0026rsquo;s value is either 0 or 1.  题目大意 #  给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的 十进制值 。\n提示：\n 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。  解题思路 #   给出一个链表，链表从头到尾表示的数是一个整数的二进制形式，要求输出这个整数的十进制。 简单题，从头到尾遍历一次链表，边遍历边累加二进制位。  代码 #  func getDecimalValue(head *ListNode) int { sum := 0 for head != nil { sum = sum*2 + head.Val head = head.Next } return sum } "});index.add({'id':515,'href':'/leetcode-java/04_Leetcode/1295.Find-Numbers-with-Even-Number-of-Digits/','title':"1295. Find Numbers With Even Number of Digits",'section':"第四章",'content':"1295. Find Numbers with Even Number of Digits #  题目 #  Given an array nums of integers, return how many of them contain an even number of digits.\nExample 1:\nInput: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits. Example 2:\nInput: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 500 1 \u0026lt;= nums[i] \u0026lt;= 10^5  题目大意 #  给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。\n提示：\n 1 \u0026lt;= nums.length \u0026lt;= 500 1 \u0026lt;= nums[i] \u0026lt;= 10^5  解题思路 #   给你一个整数数组，要求输出位数为偶数的数字的个数。 简单题，把每个数字转换为字符串判断长度是否是偶数即可。  代码 #  func findNumbers(nums []int) int { res := 0 for _, n := range nums { res += 1 - len(strconv.Itoa(n))%2 } return res } "});index.add({'id':516,'href':'/leetcode-java/04_Leetcode/1299.Replace-Elements-with-Greatest-Element-on-Right-Side/','title':"1299. Replace Elements With Greatest Element on Right Side",'section':"第四章",'content':"1299. Replace Elements with Greatest Element on Right Side #  题目 #  Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.\nAfter doing so, return the array.\nExample 1:\nInput: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 1 \u0026lt;= arr[i] \u0026lt;= 10^5  题目大意 #  给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。完成所有替换操作后，请你返回这个数组。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 1 \u0026lt;= arr[i] \u0026lt;= 10^5  解题思路 #   给出一个数组，要求把所有元素都替换成自己右边最大的元素，最后一位补上 -1 。最后输出变化以后的数组。 简单题，按照题意操作即可。  代码 #  func replaceElements(arr []int) []int { j, temp := -1, 0 for i := len(arr) - 1; i \u0026gt;= 0; i-- { temp = arr[i] arr[i] = j j = max(j, temp) } return arr } "});index.add({'id':517,'href':'/leetcode-java/04_Leetcode/1300.Sum-of-Mutated-Array-Closest-to-Target/','title':"1300. Sum of Mutated Array Closest to Target",'section':"第四章",'content':"1300. Sum of Mutated Array Closest to Target #  题目 #  Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\nIn case of a tie, return the minimum such integer.\nNotice that the answer is not neccesarilly a number from arr.\nExample 1:\nInput: arr = [4,9,3], target = 10 Output: 3 Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer. Example 2:\nInput: arr = [2,3,5], target = 10 Output: 5 Example 3:\nInput: arr = [60864,25176,27249,21296,20204], target = 56803 Output: 11361 Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 1 \u0026lt;= arr[i], target \u0026lt;= 10^5  题目大意 #  给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。请注意，答案不一定是 arr 中的数字。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 10^4 1 \u0026lt;= arr[i], target \u0026lt;= 10^5  解题思路 #   给出一个数组 arr 和 target。能否找到一个 value 值，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target。如果有多种方法，输出 value 值最小的。 这一题可以用二分搜索来求解。最后输出的唯一解有 2 个限制条件，一个是变化后的数组和最接近 target 。另一个是输出的 value 是所有可能方法中最小值。二分搜索最终的 value 值。mid 就是尝试的 value 值，每选择一次 mid，就算一次总和，和 target 比较。由于数组里面每个数和 mid 差距各不相同，所以每次调整 mid 有可能出现 mid 选小了以后，距离 target 反而更大了；mid 选大了以后，距离 target 反而更小了。这里的解决办法是，把 value 上下方可能的值都拿出来比较一下。  代码 #  func findBestValue(arr []int, target int) int { low, high := 0, 100000 for low \u0026lt; high { mid := low + (high-low)\u0026gt;\u0026gt;1 if calculateSum(arr, mid) \u0026lt; target { low = mid + 1 } else { high = mid } } if high == 100000 { res := 0 for _, num := range arr { if res \u0026lt; num { res = num } } return res } // 比较阈值线分别定在 left - 1 和 left 的时候与 target 的接近程度 \tsum1, sum2 := calculateSum(arr, low-1), calculateSum(arr, low) if target-sum1 \u0026lt;= sum2-target { return low - 1 } return low } func calculateSum(arr []int, mid int) int { sum := 0 for _, num := range arr { sum += min(num, mid) } return sum } func min(a int, b int) int { if a \u0026gt; b { return b } return a } "});index.add({'id':518,'href':'/leetcode-java/04_Leetcode/1302.Deepest-Leaves-Sum/','title':"1302. Deepest Leaves Sum",'section':"第四章",'content':"1302. Deepest Leaves Sum #  题目 #  Given a binary tree, return the sum of values of its deepest leaves.\nExample 1:\n Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Constraints:\n The number of nodes in the tree is between 1 and 10^4. The value of nodes is between 1 and 100.  题目大意 #  给你一棵二叉树，请你返回层数最深的叶子节点的和。\n提示：\n 树中节点数目在 1 到 10^4 之间。 每个节点的值在 1 到 100 之间。  解题思路 #   给你一棵二叉树，请你返回层数最深的叶子节点的和。 这一题不难，DFS 遍历把最底层的叶子节点和都加起来即可。  代码 #  func deepestLeavesSum(root *TreeNode) int { maxLevel, sum := 0, 0 dfsDeepestLeavesSum(root, 0, \u0026amp;maxLevel, \u0026amp;sum) return sum } func dfsDeepestLeavesSum(root *TreeNode, level int, maxLevel, sum *int) { if root == nil { return } if level \u0026gt; *maxLevel { *maxLevel, *sum = level, root.Val } else if level == *maxLevel { *sum += root.Val } dfsDeepestLeavesSum(root.Left, level+1, maxLevel, sum) dfsDeepestLeavesSum(root.Right, level+1, maxLevel, sum) } "});index.add({'id':519,'href':'/leetcode-java/04_Leetcode/1304.Find-N-Unique-Integers-Sum-up-to-Zero/','title':"1304. Find N Unique Integers Sum Up to Zero",'section':"第四章",'content':"1304. Find N Unique Integers Sum up to Zero #  题目 #  Given an integer n, return any array containing n unique integers such that they add up to 0.\nExample 1:\nInput: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2:\nInput: n = 3 Output: [-1,0,1] Example 3:\nInput: n = 1 Output: [0] Constraints:\n 1 \u0026lt;= n \u0026lt;= 1000  题目大意 #  给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。\n提示：\n 1 \u0026lt;= n \u0026lt;= 1000  解题思路 #   给出一个数 n，输出一个有 n 个数的数组，里面元素之和为 0 。 简单题，简单循环即可。  代码 #  func sumZero(n int) []int { res, left, right, start := make([]int, n), 0, n-1, 1 for left \u0026lt; right { res[left] = start res[right] = -start start++ left = left + 1 right = right - 1 } return res } "});index.add({'id':520,'href':'/leetcode-java/04_Leetcode/1305.All-Elements-in-Two-Binary-Search-Trees/','title':"1305. All Elements in Two Binary Search Trees",'section':"第四章",'content':"1305. All Elements in Two Binary Search Trees #  题目 #  Given two binary search trees root1 and root2.\nReturn a list containing all the integers from both trees sorted in ascending order.\nExample 1:\n Input: root1 = [2,1,4], root2 = [1,0,3] Output: [0,1,1,2,3,4] Example 2:\nInput: root1 = [0,-10,10], root2 = [5,1,7,0,2] Output: [-10,0,0,1,2,5,7,10] Example 3:\nInput: root1 = [], root2 = [5,1,7,0,2] Output: [0,1,2,5,7] Example 4:\nInput: root1 = [0,-10,10], root2 = [] Output: [-10,0,10] Example 5:\n Input: root1 = [1,null,8], root2 = [8,1] Output: [1,1,8,8] Constraints:\n Each tree has at most 5000 nodes. Each node\u0026rsquo;s value is between [-10^5, 10^5].  题目大意 #  给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.\n提示：\n 每棵树最多有 5000 个节点。 每个节点的值在 [-10^5, 10^5] 之间。  解题思路 #   给出 2 棵二叉排序树，要求将 2 棵树所有节点的值按照升序排序。 这一题最暴力简单的方法就是把 2 棵树的节点都遍历出来，然后放在一个数组里面从小到大排序即可。这样做虽然能 AC，但是时间复杂度高。因为题目中给的二叉排序树这一条件没有用上。由于树中节点本来已经有序了，所以题目实质想要我们合并 2 个有序数组。利用中根遍历，把 2 个二叉排序树的所有节点值都遍历出来，遍历出来以后就是有序的。接下来再合并这两个有序数组即可。合并 2 个有序数组是第 88 题。  代码 #  // 解法一 合并排序 func getAllElements(root1 *TreeNode, root2 *TreeNode) []int { arr1 := inorderTraversal(root1) arr2 := inorderTraversal(root2) arr1 = append(arr1, make([]int, len(arr2))...) merge(arr1, len(arr1)-len(arr2), arr2, len(arr2)) return arr1 } // 解法二 暴力遍历排序，时间复杂度高 func getAllElements1(root1 *TreeNode, root2 *TreeNode) []int { arr := []int{} arr = append(arr, preorderTraversal(root1)...) arr = append(arr, preorderTraversal(root2)...) sort.Ints(arr) return arr } "});index.add({'id':521,'href':'/leetcode-java/04_Leetcode/1306.Jump-Game-III/','title':"1306. Jump Game I I I",'section':"第四章",'content':"1306. Jump Game III #  题目 #  Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.\nNotice that you can not jump outside of the array at any time.\nExample 1:\nInput: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -\u0026gt; index 4 -\u0026gt; index 1 -\u0026gt; index 3 index 5 -\u0026gt; index 6 -\u0026gt; index 4 -\u0026gt; index 1 -\u0026gt; index 3 Example 2:\nInput: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -\u0026gt; index 4 -\u0026gt; index 1 -\u0026gt; index 3 Example 3:\nInput: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0. Constraints:\n 1 \u0026lt;= arr.length \u0026lt;= 5 * 10^4 0 \u0026lt;= arr[i] \u0026lt; arr.length 0 \u0026lt;= start \u0026lt; arr.length  题目大意 #  这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。注意，不管是什么情况下，你都无法跳到数组之外。\n提示：\n 1 \u0026lt;= arr.length \u0026lt;= 5 * 10^4 0 \u0026lt;= arr[i] \u0026lt; arr.length 0 \u0026lt;= start \u0026lt; arr.length  解题思路 #    给出一个非负数组和一个起始下标 start。站在 start，每次可以跳到 i + arr[i] 或者 i - arr[i] 。要求判断能否跳到元素值为 0 的下标处。\n  这一题考察的是递归。每一步都需要判断 3 种可能：\n 当前是否站在元素值为 0 的目标点上。 往前跳 arr[start]，是否能站在元素值为 0 的目标点上。 往后跳 arr[start]，是否能站在元素值为 0 的目标点上。  第 2 种可能和第 3 种可能递归即可，每一步都判断这 3 种可能是否有一种能跳到元素值为 0 的下标处。\n  arr[start] += len(arr) 这一步仅仅只是为了标记此下标已经用过了，下次判断的时候该下标会被 if 条件筛选掉。\n  代码 #  func canReach(arr []int, start int) bool { if start \u0026gt;= 0 \u0026amp;\u0026amp; start \u0026lt; len(arr) \u0026amp;\u0026amp; arr[start] \u0026lt; len(arr) { jump := arr[start] arr[start] += len(arr) return jump == 0 || canReach(arr, start+jump) || canReach(arr, start-jump) } return false } "});index.add({'id':522,'href':'/leetcode-java/04_Leetcode/1313.Decompress-Run-Length-Encoded-List/','title':"1313. Decompress Run Length Encoded List",'section':"第四章",'content':"1313. Decompress Run-Length Encoded List #  题目 #  We are given a list nums of integers representing a list compressed with run-length encoding.\nConsider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i \u0026gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.\nReturn the decompressed list.\nExample 1:\nInput: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. Example 2:\nInput: nums = [1,1,2,3] Output: [1,3,3] Constraints:\n 2 \u0026lt;= nums.length \u0026lt;= 100 nums.length % 2 == 0 1 \u0026lt;= nums[i] \u0026lt;= 100  题目大意 #  给你一个以行程长度编码压缩的整数列表 nums 。考虑每对相邻的两个元素 [freq, val] = [nums[2i], nums[2i+1]] （其中 i \u0026gt;= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。请你返回解压后的列表。\n解题思路 #   给定一个带编码长度的数组，要求解压这个数组。 简单题。按照题目要求，下标从 0 开始，奇数位下标为前一个下标对应元素重复次数，那么就把这个元素 append 几次。最终输出解压后的数组即可。  代码 #  package leetcode func decompressRLElist(nums []int) []int { res := []int{} for i := 0; i \u0026lt; len(nums); i += 2 { for j := 0; j \u0026lt; nums[i]; j++ { res = append(res, nums[i+1]) } } return res } "});index.add({'id':523,'href':'/leetcode-java/04_Leetcode/1317.Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/','title':"1317. Convert Integer to the Sum of Two No Zero Integers",'section':"第四章",'content':"1317. Convert Integer to the Sum of Two No-Zero Integers #  题目 #  Given an integer n. No-Zero integer is a positive integer which doesn\u0026rsquo;t contain any 0 in its decimal representation.\nReturn a list of two integers [A, B] where:\n A and B are No-Zero integers. A + B = n  It\u0026rsquo;s guarateed that there is at least one valid solution. If there are many valid solutions you can return any of them.\nExample 1:\nInput: n = 2 Output: [1,1] Explanation: A = 1, B = 1. A + B = n and both A and B don't contain any 0 in their decimal representation. Example 2:\nInput: n = 11 Output: [2,9] Example 3:\nInput: n = 10000 Output: [1,9999] Example 4:\nInput: n = 69 Output: [1,68] Example 5:\nInput: n = 1010 Output: [11,999] Constraints:\n 2 \u0026lt;= n \u0026lt;= 10^4  题目大意 #  「无零整数」是十进制表示中 不含任何 0 的正整数。给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：\n A 和 B 都是无零整数 A + B = n  题目数据保证至少有一个有效的解决方案。如果存在多个有效解决方案，你可以返回其中任意一个。\n解题思路 #   给定一个整数 n，要求把它分解为 2 个十进制位中不含 0 的正整数且这两个正整数之和为 n。 简单题。在 [1, n/2] 区间内搜索，只要有一组满足条件的解就 break。题目保证了至少有一组解，并且多组解返回任意一组即可。  代码 #  package leetcode func getNoZeroIntegers(n int) []int { noZeroPair := []int{} for i := 1; i \u0026lt;= n/2; i++ { if isNoZero(i) \u0026amp;\u0026amp; isNoZero(n-i) { noZeroPair = append(noZeroPair, []int{i, n - i}...) break } } return noZeroPair } func isNoZero(n int) bool { for n != 0 { if n%10 == 0 { return false } n /= 10 } return true } "});index.add({'id':524,'href':'/leetcode-java/04_Leetcode/1380.Lucky-Numbers-in-a-Matrix/','title':"1380. Lucky Numbers in a Matrix",'section':"第四章",'content':"1380. Lucky Numbers in a Matrix #  题目 #  Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.\nA lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\nExample 1:\nInput: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column Example 2:\nInput: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3:\nInput: matrix = [[7,8],[1,2]] Output: [7] Constraints:\n m == mat.length n == mat[i].length 1 \u0026lt;= n, m \u0026lt;= 50 1 \u0026lt;= matrix[i][j] \u0026lt;= 10^5. All elements in the matrix are distinct.  题目大意 #  给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。幸运数是指矩阵中满足同时下列两个条件的元素：\n 在同一行的所有元素中最小 在同一列的所有元素中最大  解题思路 #   找出矩阵中的幸运数。幸运数的定义：同时满足 2 个条件，在同一行的所有元素中最小并且在同一列的所有元素中最大。 简单题。按照题意遍历矩阵，找到同时满足 2 个条件的数输出即可。  代码 #  package leetcode func luckyNumbers(matrix [][]int) []int { t, r, res := make([]int, len(matrix[0])), make([]int, len(matrix[0])), []int{} for _, val := range matrix { m, k := val[0], 0 for j := 0; j \u0026lt; len(matrix[0]); j++ { if val[j] \u0026lt; m { m = val[j] k = j } if t[j] \u0026lt; val[j] { t[j] = val[j] } } if t[k] == m { r[k] = m } } for k, v := range r { if v \u0026gt; 0 \u0026amp;\u0026amp; v == t[k] { res = append(res, v) } } return res } "});index.add({'id':525,'href':'/leetcode-java/04_Leetcode/1385.Find-the-Distance-Value-Between-Two-Arrays/','title':"1385. Find the Distance Value Between Two Arrays",'section':"第四章",'content':"1385. Find the Distance Value Between Two Arrays #  题目 #  Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| \u0026lt;= d.\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 \u0026gt; d=2 |4-9|=5 \u0026gt; d=2 |4-1|=3 \u0026gt; d=2 |4-8|=4 \u0026gt; d=2 For arr1[1]=5 we have: |5-10|=5 \u0026gt; d=2 |5-9|=4 \u0026gt; d=2 |5-1|=4 \u0026gt; d=2 |5-8|=3 \u0026gt; d=2 For arr1[2]=8 we have: |8-10|=2 \u0026lt;= d=2 |8-9|=1 \u0026lt;= d=2 |8-1|=7 \u0026gt; d=2 |8-8|=0 \u0026lt;= d=2 Example 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3 Output: 2 Example 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6 Output: 1 Constraints:\n 1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 500 -10^3 \u0026lt;= arr1[i], arr2[j] \u0026lt;= 10^3 0 \u0026lt;= d \u0026lt;= 100  题目大意 #  给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| \u0026lt;= d 。\n提示：\n 1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 500 -10^3 \u0026lt;= arr1[i], arr2[j] \u0026lt;= 10^3 0 \u0026lt;= d \u0026lt;= 100  解题思路 #   计算两个数组之间的距离，距离值的定义：满足对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| \u0026lt;= d 这一条件的元素数目。 简单题，按照距离值的定义，双层循环计数即可。  代码 #  package leetcode func findTheDistanceValue(arr1 []int, arr2 []int, d int) int { res := 0 for i := range arr1 { for j := range arr2 { if abs(arr1[i]-arr2[j]) \u0026lt;= d { break } if j == len(arr2)-1 { res++ } } } return res } func abs(a int) int { if a \u0026lt; 0 { return -1 * a } return a } "});index.add({'id':526,'href':'/leetcode-java/04_Leetcode/1389.Create-Target-Array-in-the-Given-Order/','title':"1389. Create Target Array in the Given Order",'section':"第四章",'content':"1389. Create Target Array in the Given Order #  题目 #  Given two arrays of integers nums and index. Your task is to create target array under the following rules:\n Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index.  Return the target array.\nIt is guaranteed that the insertion operations will be valid.\nExample 1:\nInput: nums = [0,1,2,3,4], index = [0,1,2,2,1] Output: [0,4,1,3,2] Explanation: nums index target 0 0 [0] 1 1 [0,1] 2 2 [0,1,2] 3 2 [0,1,3,2] 4 1 [0,4,1,3,2] Example 2:\nInput: nums = [1,2,3,4,0], index = [0,1,2,3,0] Output: [0,1,2,3,4] Explanation: nums index target 1 0 [1] 2 1 [1,2] 3 2 [1,2,3] 4 3 [1,2,3,4] 0 0 [0,1,2,3,4] Example 3:\nInput: nums = [1], index = [0] Output: [1] Constraints:\n 1 \u0026lt;= nums.length, index.length \u0026lt;= 100 nums.length == index.length 0 \u0026lt;= nums[i] \u0026lt;= 100 0 \u0026lt;= index[i] \u0026lt;= i  题目大意 #  给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：\n 目标数组 target 最初为空。 按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。 重复上一步，直到在 nums 和 index 中都没有要读取的元素。  请你返回目标数组。题目保证数字插入位置总是存在。\n解题思路 #   给定 2 个数组，分别装的是待插入的元素和待插入的位置。最后输出操作完成的数组。 简单题，按照题意插入元素即可。  代码 #  package leetcode func createTargetArray(nums []int, index []int) []int { result := make([]int, len(nums)) for i, pos := range index { copy(result[pos+1:i+1], result[pos:i]) result[pos] = nums[i] } return result } "});index.add({'id':527,'href':'/leetcode-java/04_Leetcode/1455.Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/','title':"1455. Check if a Word Occurs as a Prefix of Any Word in a Sentence",'section':"第四章",'content':"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence #  题目 #  Given a sentence that consists of some words separated by a single space, and a searchWord.\nYou have to check if searchWord is a prefix of any word in sentence.\nReturn the index of the word in sentence where searchWord is a prefix of this word (1-indexed).\nIf searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.\nA prefix of a string S is any leading contiguous substring of S.\nExample 1:\nInput: sentence = \u0026quot;i love eating burger\u0026quot;, searchWord = \u0026quot;burg\u0026quot; Output: 4 Explanation: \u0026quot;burg\u0026quot; is prefix of \u0026quot;burger\u0026quot; which is the 4th word in the sentence. Example 2:\nInput: sentence = \u0026quot;this problem is an easy problem\u0026quot;, searchWord = \u0026quot;pro\u0026quot; Output: 2 Explanation: \u0026quot;pro\u0026quot; is prefix of \u0026quot;problem\u0026quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3:\nInput: sentence = \u0026quot;i am tired\u0026quot;, searchWord = \u0026quot;you\u0026quot; Output: -1 Explanation: \u0026quot;you\u0026quot; is not a prefix of any word in the sentence. Example 4:\nInput: sentence = \u0026quot;i use triple pillow\u0026quot;, searchWord = \u0026quot;pill\u0026quot; Output: 4 Example 5:\nInput: sentence = \u0026quot;hello from the other side\u0026quot;, searchWord = \u0026quot;they\u0026quot; Output: -1 Constraints:\n 1 \u0026lt;= sentence.length \u0026lt;= 100 1 \u0026lt;= searchWord.length \u0026lt;= 10 sentence consists of lowercase English letters and spaces. searchWord consists of lowercase English letters.  题目大意 #  给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。\n 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。  字符串 S 的 「前缀」是 S 的任何前导连续子字符串。\n解题思路 #   给出 2 个字符串，一个是匹配串，另外一个是句子。在句子里面查找带匹配串前缀的单词，并返回第一个匹配单词的下标。 简单题。按照题意，扫描一遍句子，一次匹配即可。  代码 #  package leetcode import \u0026#34;strings\u0026#34; func isPrefixOfWord(sentence string, searchWord string) int { for i, v := range strings.Split(sentence, \u0026#34; \u0026#34;) { if strings.HasPrefix(v, searchWord) { return i + 1 } } return -1 } "});index.add({'id':528,'href':'/leetcode-java/04_Leetcode/1464.Maximum-Product-of-Two-Elements-in-an-Array/','title':"1464. Maximum Product of Two Elements in an Array",'section':"第四章",'content':"1464. Maximum Product of Two Elements in an Array #  题目 #  Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).\nExample 1:\nInput: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. Example 2:\nInput: nums = [1,5,4,5] Output: 16 Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3:\nInput: nums = [3,7] Output: 12 Constraints:\n 2 \u0026lt;= nums.length \u0026lt;= 500 1 \u0026lt;= nums[i] \u0026lt;= 10^3  题目大意 #  给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。请你计算并返回该式的最大值。\n解题思路 #   简单题。循环一次，按照题意动态维护 2 个最大值，从而也使得 (nums[i]-1)*(nums[j]-1) 能取到最大值。  代码 #  package leetcode func maxProduct(nums []int) int { max1, max2 := 0, 0 for _, num := range nums { if num \u0026gt;= max1 { max2 = max1 max1 = num } else if num \u0026lt;= max1 \u0026amp;\u0026amp; num \u0026gt;= max2 { max2 = num } } return (max1 - 1) * (max2 - 1) } "});index.add({'id':529,'href':'/leetcode-java/04_Leetcode/1470.Shuffle-the-Array/','title':"1470. Shuffle the Array",'section':"第四章",'content':"1470. Shuffle the Array #  题目 #  Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].\nReturn the array in the form [x1,y1,x2,y2,...,xn,yn].\nExample 1:\nInput: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2:\nInput: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3:\nInput: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] Constraints:\n 1 \u0026lt;= n \u0026lt;= 500 nums.length == 2n 1 \u0026lt;= nums[i] \u0026lt;= 10^3  题目大意 #  给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,\u0026hellip;,xn,y1,y2,\u0026hellip;,yn] 的格式排列。请你将数组按 [x1,y1,x2,y2,\u0026hellip;,xn,yn] 格式重新排列，返回重排后的数组。\n解题思路 #   给定一个 2n 的数组，把后 n 个元素插空放到前 n 个元素里面。输出最终完成的数组。 简单题，按照题意插空即可。  代码 #  package leetcode func shuffle(nums []int, n int) []int { result := make([]int, 0) for i := 0; i \u0026lt; n; i++ { result = append(result, nums[i]) result = append(result, nums[n+i]) } return result } "});index.add({'id':530,'href':'/leetcode-java/04_Leetcode/1476.Subrectangle-Queries/','title':"1476. Subrectangle Queries",'section':"第四章",'content':"1476. 子矩形查询 #  Difficulty: 中等\n请你实现一个类 SubrectangleQueries ，它的构造函数的参数是一个 rows x cols 的矩形（这里用整数矩阵表示），并支持以下两种操作：\n1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n 用 newValue 更新以 (row1,col1) 为左上角且以 (row2,col2) 为右下角的子矩形。  2. getValue(int row, int col)\n 返回矩形中坐标 (row,col) 的当前值。  示例 1：\n输入： [\u0026quot;SubrectangleQueries\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;updateSubrectangle\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;updateSubrectangle\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;getValue\u0026quot;] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] 输出： [null,1,null,5,5,null,10,5] 解释： SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // 初始的 (4x3) 矩形如下： // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.getValue(0, 2); // 返回 1 subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5); // 此次更新后矩形变为： // 5 5 5 // 5 5 5 // 5 5 5 // 5 5 5 subrectangleQueries.getValue(0, 2); // 返回 5 subrectangleQueries.getValue(3, 1); // 返回 5 subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10); // 此次更新后矩形变为： // 5 5 5 // 5 5 5 // 5 5 5 // 10 10 10 subrectangleQueries.getValue(3, 1); // 返回 10 subrectangleQueries.getValue(0, 2); // 返回 5 示例 2：\n输入： [\u0026quot;SubrectangleQueries\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;updateSubrectangle\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;getValue\u0026quot;,\u0026quot;updateSubrectangle\u0026quot;,\u0026quot;getValue\u0026quot;] [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] 输出： [null,1,null,100,100,null,20] 解释： SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]); subrectangleQueries.getValue(0, 0); // 返回 1 subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100); subrectangleQueries.getValue(0, 0); // 返回 100 subrectangleQueries.getValue(2, 2); // 返回 100 subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20); subrectangleQueries.getValue(2, 2); // 返回 20 提示：\n 最多有 500 次updateSubrectangle 和 getValue 操作。 1 \u0026lt;= rows, cols \u0026lt;= 100 rows == rectangle.length cols == rectangle[i].length 0 \u0026lt;= row1 \u0026lt;= row2 \u0026lt; rows 0 \u0026lt;= col1 \u0026lt;= col2 \u0026lt; cols 1 \u0026lt;= newValue, rectangle[i][j] \u0026lt;= 10^9 0 \u0026lt;= row \u0026lt; rows 0 \u0026lt;= col \u0026lt; cols  题解 #  题解一：暴力求解 #  class SubrectangleQueries { private int[][] rectangle = null; public SubrectangleQueries(int[][] rectangle) { this.rectangle = rectangle; } public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) { for (int i = row1; i \u0026lt;= row2; i++) { for (int j = col1; j \u0026lt;= col2; j++) { rectangle[i][j] = newValue; } } } public int getValue(int row, int col) { if (rectangle != null) { return rectangle[row][col]; } return -1; } } /** * Your SubrectangleQueries object will be instantiated and called as such: * SubrectangleQueries obj = new SubrectangleQueries(rectangle); * obj.updateSubrectangle(row1,col1,row2,col2,newValue); * int param_2 = obj.getValue(row,col); */ "});index.add({'id':531,'href':'/leetcode-java/04_Leetcode/1480.Running-Sum-of-1d-Array/','title':"1480. Running Sum of 1d Array",'section':"第四章",'content':"1480. Running Sum of 1d Array #  题目 #  Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).\nReturn the running sum of nums.\nExample 1:\nInput: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2:\nInput: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3:\nInput: nums = [3,1,2,10,1] Output: [3,4,6,16,17] Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 1000 -10^6 \u0026lt;= nums[i] \u0026lt;= 10^6  题目大意 #  给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。\n解题思路 #   简单题，按照题意依次循环计算前缀和即可。  代码 #  package leetcode func runningSum(nums []int) []int { dp := make([]int, len(nums)+1) dp[0] = 0 for i := 1; i \u0026lt;= len(nums); i++ { dp[i] = dp[i-1] + nums[i-1] } return dp[1:] } "});index.add({'id':532,'href':'/leetcode-java/04_Leetcode/1512.Number-of-Good-Pairs/','title':"1512. Number of Good Pairs",'section':"第四章",'content':"1512. Number of Good Pairs #  题目 #  Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\nExample 1:\nInput: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2:\nInput: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good. Example 3:\nInput: nums = [1,2,3] Output: 0 Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 100  题目大意 #  给你一个整数数组 nums。如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i \u0026lt; j ，就可以认为这是一组好数对。返回好数对的数目。\n解题思路 #   简单题，按照题目中好数对的定义，循环遍历判断两数是否相等，累加计数即可。  代码 #  package leetcode func numIdenticalPairs(nums []int) int { total := 0 for x := 0; x \u0026lt; len(nums); x++ { for y := x + 1; y \u0026lt; len(nums); y++ { if nums[x] == nums[y] { total++ } } } return total } "});index.add({'id':533,'href':'/leetcode-java/04_Leetcode/1530.Number-Of-Good-Leaf-Nodes-Pairs/','title':"1530. Number of Good Leaf Nodes Pairs",'section':"第四章",'content':"1530. 好叶子节点对的数量 #  Difficulty: 中等\n给你二叉树的根节点 root 和一个整数 distance 。\n如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。\n返回树中 好叶子节点对的数量 。\n示例 1：\n 输入：root = [1,2,3,null,4], distance = 3 输出：1 解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。 示例 2：\n 输入：root = [1,2,3,4,5,6,7], distance = 3 输出：2 解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。 示例 3：\n输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 输出：1 解释：唯一的好叶子节点对是 [2,5] 。 示例 4：\n输入：root = [100], distance = 1 输出：0 示例 5：\n输入：root = [1,1,1], distance = 2 输出：1 提示：\n tree 的节点数在 [1, 2^10] 范围内。 每个节点的值都在 [1, 100] 之间。 1 \u0026lt;= distance \u0026lt;= 10  题解 #  解法一：递归解法 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int countPairs(TreeNode root, int distance) { Pair pair = dfs(root, distance); return pair.count; } // 对于 dfs(root,distance)，同时返回：  // 1）每个叶子节点与 root 之间的距离  // 2) 以 root 为根节点的子树中好叶子节点对的数量  public Pair dfs(TreeNode root, int distance) { int[] depths = new int[distance + 1]; boolean isLeaf = root.left == null \u0026amp;\u0026amp; root.right == null; if (isLeaf) { depths[0] = 1; return new Pair(depths, 0); } int[] leftDepths = new int[distance + 1]; int[] rightDepths = new int[distance + 1]; int leftCount = 0, rightCount = 0; if (root.left != null) { Pair leftPair = dfs(root.left, distance); leftDepths = leftPair.depths; leftCount = leftPair.count; } if (root.right != null) { Pair rightPair = dfs(root.right, distance); rightDepths = rightPair.depths; rightCount = rightPair.count; } for (int i = 0; i \u0026lt; distance; i++) { depths[i + 1] += leftDepths[i]; depths[i + 1] += rightDepths[i]; } int cnt = 0; for (int i = 0; i \u0026lt;= distance; i++) { for (int j = 0; j + i + 2 \u0026lt;= distance; j++) { cnt += leftDepths[i] * rightDepths[j]; } } return new Pair(depths, cnt + leftCount + rightCount); } } class Pair { int[] depths; int count; public Pair(int[] depths, int count) { this.depths = depths; this.count = count; } } "});index.add({'id':534,'href':'/leetcode-java/04_Leetcode/1535.Find-The-Winner-Of-An-Array-Game/','title':"1535. Find the Winner of an Array Game",'section':"第四章",'content':"1535. 找出数组游戏的赢家 #  Difficulty: 中等\n给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。\n每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。\n返回赢得比赛的整数。\n题目数据 保证 游戏存在赢家。\n示例 1：\n输入：arr = [2,1,3,5,4,6,7], k = 2 输出：5 解释：一起看一下本场游戏每回合的情况：  因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。 示例 2：\n输入：arr = [3,2,1], k = 10 输出：3 解释：3 将会在前 10 个回合中连续获胜。 示例 3：\n输入：arr = [1,9,8,2,3,7,6,4,5], k = 7 输出：9 示例 4：\n输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000 输出：99 提示：\n 2 \u0026lt;= arr.length \u0026lt;= 10^5 1 \u0026lt;= arr[i] \u0026lt;= 10^6 arr 所含的整数 各不相同 。 1 \u0026lt;= k \u0026lt;= 10^9  题解 #  题解一：模拟 #  class Solution { public int getWinner(int[] arr, int k) { int prev = Math.max(arr[0], arr[1]); if (k == 1) { return prev; } int consecutive = 1; int maxNum = prev; for (int i = 2; i \u0026lt; arr.length; i++) { int curr = arr[i]; if (prev \u0026gt; curr) { consecutive++; if (consecutive == k) { return prev; } } else { prev = curr; consecutive = 1; } maxNum = Math.max(maxNum, curr); } return maxNum; } } 复杂度分析 #    时间复杂度：O(n)，其中 n 是字符串 arr 的长度。遍历数组一次。\n  空间复杂度：O(1)。只需要维护常量的额外空间。\n  "});index.add({'id':535,'href':'/leetcode-java/04_Leetcode/1550.Three-Consecutive-Odds/','title':"1550. Three Consecutive Odds",'section':"第四章",'content':"1550. 存在连续三个奇数的数组 #  Difficulty: 简单\n给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。\n示例 1：\n输入：arr = [2,6,4,1] 输出：false 解释：不存在连续三个元素都是奇数的情况。 示例 2：\n输入：arr = [1,2,34,3,4,5,7,23,12] 输出：true 解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。 提示：\n 1 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 1000  题解 #  题解一：枚举 #  class Solution { public boolean threeConsecutiveOdds(int[] arr) { boolean result = false; for (int i = 0; i \u0026lt; arr.length - 2; i++) { result = (arr[i] % 2 != 0) \u0026amp;\u0026amp; (arr[i + 1] % 2 != 0) \u0026amp;\u0026amp; (arr[i + 2] % 2 != 0); if (result) { return true; } } return false; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  题解二：枚举（位运算） #  class Solution { public boolean threeConsecutiveOdds(int[] arr) { int n = arr.length; for (int i = 0; i \u0026lt;= n - 3; ++i) { if ((arr[i] \u0026amp; 1) != 0 \u0026amp;\u0026amp; (arr[i + 1] \u0026amp; 1) != 0 \u0026amp;\u0026amp; (arr[i + 2] \u0026amp; 1) != 0) { return true; } } return false; } } "});index.add({'id':536,'href':'/leetcode-java/04_Leetcode/1646.Get-Maximum-in-Generated-Array/','title':"1646. Get Maximum in Generated Array",'section':"第四章",'content':"1646. Get Maximum in Generated Array #  题目 #  You are given an integer n. An array nums of length n + 1 is generated in the following way:\n nums[0] = 0 nums[1] = 1 nums[2 * i] = nums[i] when 2 \u0026lt;= 2 * i \u0026lt;= n nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 \u0026lt;= 2 * i + 1 \u0026lt;= n  Return ****the maximum integer in the array nums.\nExample 1:\nInput: n = 7 Output: 3 Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is 3. Example 2:\nInput: n = 2 Output: 1 Explanation: According to the given rules, the maximum between nums[0], nums[1], and nums[2] is 1. Example 3:\nInput: n = 3 Output: 2 Explanation: According to the given rules, the maximum between nums[0], nums[1], nums[2], and nums[3] is 2. Constraints:\n 0 \u0026lt;= n \u0026lt;= 100  题目大意 #  给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：\n nums[0] = 0 nums[1] = 1 当 2 \u0026lt;= 2 * i \u0026lt;= n 时，nums[2 * i] = nums[i] 当 2 \u0026lt;= 2 * i + 1 \u0026lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]  返回生成数组 nums 中的 最大值。\n解题思路 #   给出一个 n + 1 的数组，并按照生成规则生成这个数组，求出这个数组中的最大值。 简单题，按照题意生成数组，边生成边记录和更新最大值即可。 注意边界条件，当 n 为 0 的时候，数组里面只有一个元素 0 。  代码 #  package leetcode func getMaximumGenerated(n int) int { if n == 0 { return 0 } nums, max := make([]int, n+1), 0 nums[0], nums[1] = 0, 1 for i := 0; i \u0026lt;= n; i++ { if nums[i] \u0026gt; max { max = nums[i] } if 2*i \u0026gt;= 2 \u0026amp;\u0026amp; 2*i \u0026lt;= n { nums[2*i] = nums[i] } if 2*i+1 \u0026gt;= 2 \u0026amp;\u0026amp; 2*i+1 \u0026lt;= n { nums[2*i+1] = nums[i] + nums[i+1] } } return max } "});index.add({'id':537,'href':'/leetcode-java/04_Leetcode/1647.Minimum-Deletions-to-Make-Character-Frequencies-Unique/','title':"1647. Minimum Deletions to Make Character Frequencies Unique",'section':"第四章",'content':"1647. Minimum Deletions to Make Character Frequencies Unique #  题目 #  A string s is called good if there are no two different characters in s that have the same frequency.\nGiven a string s, return the minimum number of characters you need to delete to make s good.\nThe frequency of a character in a string is the number of times it appears in the string. For example, in the string \u0026quot;aab\u0026quot;, the frequency of 'a' is 2, while the frequency of 'b' is 1.\nExample 1:\nInput: s = \u0026quot;aab\u0026quot; Output: 0 Explanation: s is already good. Example 2:\nInput: s = \u0026quot;aaabbbcc\u0026quot; Output: 2 Explanation: You can delete two 'b's resulting in the good string \u0026quot;aaabcc\u0026quot;. Another way it to delete one 'b' and one 'c' resulting in the good string \u0026quot;aaabbc\u0026quot;. Example 3:\nInput: s = \u0026quot;ceabaacb\u0026quot; Output: 2 Explanation: You can delete both 'c's resulting in the good string \u0026quot;eabaab\u0026quot;. Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored). Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 105 s contains only lowercase English letters.  题目大意 #  如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。\n给你一个字符串 s，返回使 s 成为优质字符串需要删除的最小字符数。\n字符串中字符的 频次 是该字符在字符串中的出现次数。例如，在字符串 \u0026ldquo;aab\u0026rdquo; 中，\u0026lsquo;a\u0026rsquo; 的频次是 2，而 \u0026lsquo;b\u0026rsquo; 的频次是 1 。\n提示：\n 1 \u0026lt;= s.length \u0026lt;= 105 s 仅含小写英文字母  解题思路 #   给出一个字符串 s，要求输出使 s 变成“优质字符串”需要删除的最小字符数。“优质字符串”的定义是：字符串 s 中不存在频次相同的两个不同字符。 首先将 26 个字母在字符串中的频次分别统计出来，然后把频次从大到小排列，从频次大的开始，依次调整：例如，假设前一个和后一个频次相等，就把前一个字符删除一个，频次减一，再次排序，如果频次还相等，继续调整，如果频次不同了，游标往后移，继续调整后面的频次。直到所有的频次都不同了，就可以输出最终结果了。 这里需要注意频次为 0 的情况，即字母都被删光了。频次为 0 以后，就不需要再比较了。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func minDeletions(s string) int { frequency, res := make([]int, 26), 0 for i := 0; i \u0026lt; len(s); i++ { frequency[s[i]-\u0026#39;a\u0026#39;]++ } sort.Sort(sort.Reverse(sort.IntSlice(frequency))) for i := 1; i \u0026lt;= 25; i++ { if frequency[i] == frequency[i-1] \u0026amp;\u0026amp; frequency[i] != 0 { res++ frequency[i]-- sort.Sort(sort.Reverse(sort.IntSlice(frequency))) i-- } } return res } "});index.add({'id':538,'href':'/leetcode-java/04_Leetcode/1648.Sell-Diminishing-Valued-Colored-Balls/','title':"1648. Sell Diminishing Valued Colored Balls",'section':"第四章",'content':"1648. Sell Diminishing-Valued Colored Balls #  题目 #  You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.\nThe customer weirdly values the colored balls. Each colored ball\u0026rsquo;s value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).\nYou are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.\nReturn the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.\nExample 1:\n Input: inventory = [2,5], orders = 4 Output: 14 Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3). The maximum total value is 2 + 5 + 4 + 3 = 14. Example 2:\nInput: inventory = [3,5], orders = 6 Output: 19 Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2). The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19. Example 3:\nInput: inventory = [2,8,4,10,6], orders = 20 Output: 110 Example 4:\nInput: inventory = [1000000000], orders = 1000000000 Output: 21 Explanation: Sell the 1st color 1000000000 times for a total value of 500000000500000000. 500000000500000000 modulo 109 + 7 = 21. Constraints:\n 1 \u0026lt;= inventory.length \u0026lt;= 10^5 1 \u0026lt;= inventory[i] \u0026lt;= 10^9 1 \u0026lt;= orders \u0026lt;= min(sum(inventory[i]), 10^9)  题目大意 #  你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）\n给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。\n提示：\n 1 \u0026lt;= inventory.length \u0026lt;= 10^5 1 \u0026lt;= inventory[i] \u0026lt;= 10^9 1 \u0026lt;= orders \u0026lt;= min(sum(inventory[i]), 10^9)  解题思路 #    给出一个 inventory 数组和 orders 次操作，要求输出数组中前 orders 大个元素累加和。需要注意的是，每累加一个元素 inventory[i]，这个元素都会减一，下次再累加的时候，需要选取更新以后的数组的最大值。\n  拿到这个题目以后很容易想到优先队列，建立大根堆以后，pop 出当前最大值 maxItem，累加，以后把 maxItem 减一再 push 回去。循环执行 orders 次以后即是最终结果。题目是这个意思，但是我们不能这么写代码，因为题目条件里面给出了 orders 的数据大小。orders 最大为 10^9。按照优先队列的这个方法一定会超时，时间复杂度为 O(orders⋅logn)。那就换一个思路。优先队列这个思路中，重复操作了 orders 次，其实在这些操作中，有一些是没有必要的废操作。这些大量的“废”操作导致了超时。试想，在 orders 次操作中，能否合并 n 个 pop 操作，一口气先 pop 掉 n 个前 n 大的数呢？这个是可行的，因为每次 pop 出去，元素都只会减一，这个是非常有规律的。\n  为了接下来的描述更加清晰易懂，还需要再定义 1 个值， thresholdValue 为操作 n 次以后，当前 inventory 数组的最大值。关于 thresholdValue 的理解，这里要说明一下。 thresholdValue 的来源有 2 种，一种是本来数组里面就有这个值，还有一种来源是 inventory[i] 元素减少到了 thresholdValue 这个值。举个例子：原始数组是 [2,3,3,4,5]，orders = 4，取 4 次以后，剩下的数组是 [2,2,3,3,3]。3 个 3 里面其中一个 3 就来自于 4-1=3，或者 5-2=3。\n  用二分搜索在 [0，max(inventory)] 区间内找到这个 thresholdValue 值，能满足下列不等式的最小 thresholdValue 值：\n$$\\sum_{inventory[i]\\geqslant thresholdValue}^{} \\left ( inventory[i] - thresholdValue \\right )\\leqslant orders$$\nthresholdValue 越小，不等式左边的值越大，随着 thresholdValue 的增大，不等式左边的值越来越小，直到刚刚能小于等于 orders。求出了 thresholdValue 值以后，还需要再判断有多少值等于 thresholdValue - 1 值了。\n   还是举上面的例子，原始数组是 [2,3,3,4,5]，orders = 4，我们可以求得 thresholdValue = 3 。inventory[i] \u0026gt; thresholdValue 的那部分 100% 的要取走，thresholdValue 就像一个水平面，突出水平面的那些都要拿走，每列的值按照等差数列求和公式计算即可。但是 orders - thresholdValue = 1，说明水平面以下还要拿走一个，即 thresholdValue 线下的虚线框里面的那 4 个球，还需要任意取走一个。最后总的结果是这 2 部分的总和，( ( 5 + 4 ) + 4 ) + 3 = 16 。\n  代码 #  package leetcode import ( \u0026#34;container/heap\u0026#34; ) // 解法一 贪心 + 二分搜索 func maxProfit(inventory []int, orders int) int { maxItem, thresholdValue, count, res, mod := 0, -1, 0, 0, 1000000007 for i := 0; i \u0026lt; len(inventory); i++ { if inventory[i] \u0026gt; maxItem { maxItem = inventory[i] } } low, high := 0, maxItem for low \u0026lt;= high { mid := low + ((high - low) \u0026gt;\u0026gt; 1) for i := 0; i \u0026lt; len(inventory); i++ { count += max(inventory[i]-mid, 0) } if count \u0026lt;= orders { thresholdValue = mid high = mid - 1 } else { low = mid + 1 } count = 0 } count = 0 for i := 0; i \u0026lt; len(inventory); i++ { count += max(inventory[i]-thresholdValue, 0) } count = orders - count for i := 0; i \u0026lt; len(inventory); i++ { if inventory[i] \u0026gt;= thresholdValue { if count \u0026gt; 0 { res += (thresholdValue + inventory[i]) * (inventory[i] - thresholdValue + 1) / 2 count-- } else { res += (thresholdValue + 1 + inventory[i]) * (inventory[i] - thresholdValue) / 2 } } } return res % mod } "});index.add({'id':539,'href':'/leetcode-java/04_Leetcode/1649.Create-Sorted-Array-through-Instructions/','title':"1649. Create Sorted Array Through Instructions",'section':"第四章",'content':"1649. Create Sorted Array through Instructions #  题目 #  Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:\n The number of elements currently in nums that are strictly less than instructions[i]. The number of elements currently in nums that are strictly greater than instructions[i].  For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].\nReturn the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 10^9 + 7\nExample 1:\nInput: instructions = [1,5,6,2] Output: 1 Explanation: Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 5 with cost min(1, 0) = 0, now nums = [1,5]. Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6]. Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6]. The total cost is 0 + 0 + 0 + 1 = 1. Example 2:\nInput: instructions = [1,2,3,6,5,4] Output: 3 Explanation: Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 2 with cost min(1, 0) = 0, now nums = [1,2]. Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3]. Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6]. Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6]. Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6]. The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3. Example 3:\nInput: instructions = [1,3,3,3,2,4,2,1,2] Output: 4 Explanation: Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3]. Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3]. Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4]. Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4]. Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4]. Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4]. The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4. Constraints:\n 1 \u0026lt;= instructions.length \u0026lt;= 105 1 \u0026lt;= instructions[i] \u0026lt;= 105  题目大意 #  给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。每一次插入操作的 代价 是以下两者的 较小值 ：\n nums 中 严格小于 instructions[i] 的数字数目。 nums 中 严格大于 instructions[i] 的数字数目。  比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和 2 小于 3 ，元素 5 大于 3 ），插入后 nums 变成 [1,2,3,3,5] 。请你返回将 instructions 中所有元素依次插入 nums 后的 总最小代价 。由于答案会很大，请将它对 10^9 + 7 取余 后返回。\n解题思路 #   给出一个数组，要求将其中的元素从头开始往另外一个空数组中插入，每次插入前，累加代价值 cost = min(strictly less than, strictly greater than)。最后输出累加值。 这一题虽然是 Hard 题，但是读完题以后就可以判定这是模板题了。可以用线段树和树状数组来解决。这里简单说说线段树的思路吧，先将待插入的数组排序，获得总的区间。每次循环做 4 步：2 次 query 分别得到 strictlyLessThan 和 strictlyGreaterThan ，再比较出两者中的最小值累加，最后一步就是 update。 由于题目给的数据比较大，所以建立线段树之前记得要先离散化。这一题核心代码不超过 10 行，其他的都是模板代码。具体实现见代码。  代码 #  package leetcode import ( \u0026#34;github.com/halfrost/LeetCode-Go/template\u0026#34; \u0026#34;sort\u0026#34; ) // 解法一 线段树 SegmentTree func createSortedArray(instructions []int) int { if len(instructions) == 0 { return 0 } st, res, mod := template.SegmentCountTree{}, 0, 1000000007 numsMap, numsArray, tmpArray := discretization1649(instructions) // 初始化线段树，节点内的值都赋值为 0，即计数为 0 \tst.Init(tmpArray, func(i, j int) int { return 0 }) for i := 0; i \u0026lt; len(instructions); i++ { strictlyLessThan := st.Query(0, numsMap[instructions[i]]-1) strictlyGreaterThan := st.Query(numsMap[instructions[i]]+1, numsArray[len(numsArray)-1]) res = (res + min(strictlyLessThan, strictlyGreaterThan)) % mod st.UpdateCount(numsMap[instructions[i]]) } return res } func discretization1649(instructions []int) (map[int]int, []int, []int) { tmpArray, numsArray, numsMap := []int{}, []int{}, map[int]int{} for i := 0; i \u0026lt; len(instructions); i++ { numsMap[instructions[i]] = instructions[i] } for _, v := range numsMap { numsArray = append(numsArray, v) } sort.Ints(numsArray) for i, num := range numsArray { numsMap[num] = i } for i := range numsArray { tmpArray = append(tmpArray, i) } return numsMap, numsArray, tmpArray } func min(a int, b int) int { if a \u0026gt; b { return b } return a } // 解法二 树状数组 Binary Indexed Tree func createSortedArray1(instructions []int) int { b := newBIT(make([]int, 100001)) var res int cnt := map[int]int{} for i, n := range instructions { less := b.get(n - 1) greater := i - less - cnt[n] res = (res + min(less, greater)) % (1e9 + 7) b.update(n, 1) cnt[n]++ } return res % (1e9 + 7) } func max(x, y int) int { if x \u0026gt; y { return x } return y } type BIT struct { data []int } func newBIT(nums []int) *BIT { data := make([]int, len(nums)+1) b := \u0026amp;BIT{data} for i, n := range nums { b.update(i, n) } return b } func (b *BIT) update(i, num int) { i++ for i \u0026lt; len(b.data) { b.data[i] += num i += (i \u0026amp; -i) } } func (b *BIT) get(i int) int { i++ var sum int for i \u0026gt; 0 { sum += b.data[i] i -= (i \u0026amp; -i) } return sum } "});index.add({'id':540,'href':'/leetcode-java/04_Leetcode/1656.Design-an-Ordered-Stream/','title':"1656. Design an Ordered Stream",'section':"第四章",'content':"1656. Design an Ordered Stream #  题目 #  There is a stream of n (id, value) pairs arriving in an arbitrary order, where id is an integer between 1 and n and value is a string. No two pairs have the same id.\nDesign a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.\nImplement the OrderedStream class:\n OrderedStream(int n) Constructs the stream to take n values. String[] insert(int id, String value) Inserts the pair (id, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.  Example:\n Input [\u0026quot;OrderedStream\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;insert\u0026quot;] [[5], [3, \u0026quot;ccccc\u0026quot;], [1, \u0026quot;aaaaa\u0026quot;], [2, \u0026quot;bbbbb\u0026quot;], [5, \u0026quot;eeeee\u0026quot;], [4, \u0026quot;ddddd\u0026quot;]] Output [null, [], [\u0026quot;aaaaa\u0026quot;], [\u0026quot;bbbbb\u0026quot;, \u0026quot;ccccc\u0026quot;], [], [\u0026quot;ddddd\u0026quot;, \u0026quot;eeeee\u0026quot;]] Explanation // Note that the values ordered by ID is [\u0026quot;aaaaa\u0026quot;, \u0026quot;bbbbb\u0026quot;, \u0026quot;ccccc\u0026quot;, \u0026quot;ddddd\u0026quot;, \u0026quot;eeeee\u0026quot;]. OrderedStream os = new OrderedStream(5); os.insert(3, \u0026quot;ccccc\u0026quot;); // Inserts (3, \u0026quot;ccccc\u0026quot;), returns []. os.insert(1, \u0026quot;aaaaa\u0026quot;); // Inserts (1, \u0026quot;aaaaa\u0026quot;), returns [\u0026quot;aaaaa\u0026quot;]. os.insert(2, \u0026quot;bbbbb\u0026quot;); // Inserts (2, \u0026quot;bbbbb\u0026quot;), returns [\u0026quot;bbbbb\u0026quot;, \u0026quot;ccccc\u0026quot;]. os.insert(5, \u0026quot;eeeee\u0026quot;); // Inserts (5, \u0026quot;eeeee\u0026quot;), returns []. os.insert(4, \u0026quot;ddddd\u0026quot;); // Inserts (4, \u0026quot;ddddd\u0026quot;), returns [\u0026quot;ddddd\u0026quot;, \u0026quot;eeeee\u0026quot;]. // Concatentating all the chunks returned: // [] + [\u0026quot;aaaaa\u0026quot;] + [\u0026quot;bbbbb\u0026quot;, \u0026quot;ccccc\u0026quot;] + [] + [\u0026quot;ddddd\u0026quot;, \u0026quot;eeeee\u0026quot;] = [\u0026quot;aaaaa\u0026quot;, \u0026quot;bbbbb\u0026quot;, \u0026quot;ccccc\u0026quot;, \u0026quot;ddddd\u0026quot;, \u0026quot;eeeee\u0026quot;] // The resulting order is the same as the order above. Constraints:\n 1 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= id \u0026lt;= n value.length == 5 value consists only of lowercase letters. Each call to insert will have a unique id. Exactly n calls will be made to insert.  题目大意 #  有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。\n设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。\n实现 OrderedStream 类：\n OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。  解题思路 #   设计一个具有插入操作的 Ordered Stream。insert 操作先在指定位置插入 value，然后返回当前指针 ptr 到最近一个空位置的最长连续递增字符串。如果字符串不为空，ptr 移动到非空 value 的后一个下标位置处。 简单题。按照题目描述模拟即可。注意控制好 ptr 的位置。  代码 #  package leetcode type OrderedStream struct { ptr int stream []string } func Constructor(n int) OrderedStream { ptr, stream := 1, make([]string, n+1) return OrderedStream{ptr: ptr, stream: stream} } func (this *OrderedStream) Insert(id int, value string) []string { this.stream[id] = value res := []string{} if this.ptr == id || this.stream[this.ptr] != \u0026#34;\u0026#34; { res = append(res, this.stream[this.ptr]) for i := id + 1; i \u0026lt; len(this.stream); i++ { if this.stream[i] != \u0026#34;\u0026#34; { res = append(res, this.stream[i]) } else { this.ptr = i return res } } } if len(res) \u0026gt; 0 { return res } return []string{} } /** * Your OrderedStream object will be instantiated and called as such: * obj := Constructor(n); * param_1 := obj.Insert(id,value); */ "});index.add({'id':541,'href':'/leetcode-java/04_Leetcode/1657.Determine-if-Two-Strings-Are-Close/','title':"1657. Determine if Two Strings Are Close",'section':"第四章",'content':"1657. Determine if Two Strings Are Close #  题目 #  Two strings are considered close if you can attain one from the other using the following operations:\n Operation 1: Swap any two existing characters.  For example, abcde -\u0026gt; aecdb   Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.  For example, aacabb -\u0026gt; bbcbaa (all a\u0026rsquo;s turn into b\u0026rsquo;s, and all b\u0026rsquo;s turn into a\u0026rsquo;s)    You can use the operations on either string as many times as necessary.\nGiven two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.\nExample 1:\nInput: word1 = \u0026quot;abc\u0026quot;, word2 = \u0026quot;bca\u0026quot; Output: true Explanation: You can attain word2 from word1 in 2 operations. Apply Operation 1: \u0026quot;abc\u0026quot; -\u0026gt; \u0026quot;acb\u0026quot; Apply Operation 1: \u0026quot;acb\u0026quot; -\u0026gt; \u0026quot;bca\u0026quot; Example 2:\nInput: word1 = \u0026quot;a\u0026quot;, word2 = \u0026quot;aa\u0026quot; Output: false Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations. Example 3:\nInput: word1 = \u0026quot;cabbba\u0026quot;, word2 = \u0026quot;abbccc\u0026quot; Output: true Explanation: You can attain word2 from word1 in 3 operations. Apply Operation 1: \u0026quot;cabbba\u0026quot; -\u0026gt; \u0026quot;caabbb\u0026quot; Apply Operation 2: \u0026quot;caabbb\u0026quot; -\u0026gt; \u0026quot;baaccc\u0026quot; Apply Operation 2: \u0026quot;baaccc\u0026quot; -\u0026gt; \u0026quot;abbccc\u0026quot; Example 4:\nInput: word1 = \u0026quot;cabbba\u0026quot;, word2 = \u0026quot;aabbss\u0026quot; Output: false Explanation: It is impossible to attain word2 from word1, or vice versa, in any amount of operations. Constraints:\n 1 \u0026lt;= word1.length, word2.length \u0026lt;= 105 word1 and word2 contain only lowercase English letters.  题目大意 #  如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：\n 操作 1：交换任意两个 现有 字符。例如，abcde -\u0026gt; aecdb 操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。例如，aacabb -\u0026gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）  你可以根据需要对任意一个字符串多次使用这两种操作。给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。\n解题思路 #   判断 2 个字符串是否“接近”。“接近”的定义是能否通过交换 2 个字符或者 2 个字母互换，从一个字符串变换成另外一个字符串，如果存在这样的变换，即是“接近”。 先统计 2 个字符串的 26 个字母的频次，如果频次有不相同的，直接返回 false。在频次相同的情况下，再从小到大排序，再次扫描判断频次是否相同。 注意几种特殊情况：频次相同，再判断字母交换是否合法存在，如果字母不存在，输出 false。例如测试文件中的 case 5 。出现频次个数相同，但是频次不同。例如测试文件中的 case 6 。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func closeStrings(word1 string, word2 string) bool { if len(word1) != len(word2) { return false } freqCount1, freqCount2 := make([]int, 26), make([]int, 26) for _, c := range word1 { freqCount1[c-97]++ } for _, c := range word2 { freqCount2[c-97]++ } for i := 0; i \u0026lt; 26; i++ { if (freqCount1[i] == freqCount2[i]) || (freqCount1[i] \u0026gt; 0 \u0026amp;\u0026amp; freqCount2[i] \u0026gt; 0) { continue } return false } sort.Ints(freqCount1) sort.Ints(freqCount2) for i := 0; i \u0026lt; 26; i++ { if freqCount1[i] != freqCount2[i] { return false } } return true } "});index.add({'id':542,'href':'/leetcode-java/04_Leetcode/1658.Minimum-Operations-to-Reduce-X-to-Zero/','title':"1658. Minimum Operations to Reduce X to Zero",'section':"第四章",'content':"1658. Minimum Operations to Reduce X to Zero #  题目 #  You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\nReturn the minimum number of operations to reduce x to exactly 0 if it\u0026rsquo;s possible, otherwise, return 1.\nExample 1:\nInput: nums = [1,1,4,2,3], x = 5 Output: 2 Explanation: The optimal solution is to remove the last two elements to reduce x to zero. Example 2:\nInput: nums = [5,6,7,8,9], x = 4 Output: -1 Example 3:\nInput: nums = [3,2,20,1,1,3], x = 10 Output: 5 Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= x \u0026lt;= 109  题目大意 #  给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。\n解题思路 #   给定一个数组 nums 和一个整数 x，要求从数组两端分别移除一些数，使得这些数加起来正好等于整数 x，要求输出最小操作数。 要求输出最小操作数，即数组两头的数字个数最少，并且加起来和正好等于整数 x。由于在数组的两头，用 2 个指针分别操作不太方便。我当时解题的时候的思路是把它变成循环数组，这样两边的指针就在一个区间内了。利用滑动窗口找到一个最小的窗口，使得窗口内的累加和等于整数 k。这个方法可行，但是代码挺多的。 有没有更优美的方法呢？有的。要想两头的长度最少，也就是中间这段的长度最大。这样就转换成直接在数组上使用滑动窗口求解，累加和等于一个固定值的连续最长的子数组。 和这道题类似思路的题目，209，1040(循环数组)，325。强烈推荐这 3 题。  代码 #  package leetcode func minOperations(nums []int, x int) int { total := 0 for _, n := range nums { total += n } target := total - x if target \u0026lt; 0 { return -1 } if target == 0 { return len(nums) } left, right, sum, res := 0, 0, 0, -1 for right \u0026lt; len(nums) { if sum \u0026lt; target { sum += nums[right] right++ } for sum \u0026gt;= target { if sum == target { res = max(res, right-left) } sum -= nums[left] left++ } } if res == -1 { return -1 } return len(nums) - res } func max(a, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':543,'href':'/leetcode-java/04_Leetcode/1659.Maximize-Grid-Happiness/','title':"1659. Maximize Grid Happiness",'section':"第四章",'content':"1659. Maximize Grid Happiness #  题目 #  You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n Introverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert). Extroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).  Neighbors live in the directly adjacent cells north, east, south, and west of a person\u0026rsquo;s cell.\nThe grid happiness is the sum of each person\u0026rsquo;s happiness. Return the maximum possible grid happiness.\nExample 1:\n Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2 Output: 240 Explanation: Assume the grid is 1-indexed with coordinates (row, column). We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3). - Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120 - Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 - Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 The grid happiness is 120 + 60 + 60 = 240. The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells. Example 2:\nInput: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1 Output: 260 Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1). - Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90 - Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80 - Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90 The grid happiness is 90 + 80 + 90 = 260. Example 3:\nInput: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0 Output: 240 Constraints:\n 1 \u0026lt;= m, n \u0026lt;= 5 0 \u0026lt;= introvertsCount, extrovertsCount \u0026lt;= min(m * n, 6)  题目大意 #  给你四个整数 m、n、introvertsCount 和 extrovertsCount 。有一个 m x n 网格，和两种类型的人：内向的人和外向的人。总共有 introvertsCount 个内向的人和 extrovertsCount 个外向的人。请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，不必 让所有人都生活在网格中。每个人的 幸福感 计算如下：\n 内向的人 开始 时有 120 个幸福感，但每存在一个邻居（内向的或外向的）他都会 失去 30 个幸福感。 外向的人 开始 时有 40 个幸福感，每存在一个邻居（内向的或外向的）他都会 得到 20 个幸福感。  邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。网格幸福感 是每个人幸福感的 总和 。 返回 最大可能的网格幸福感 。\n解题思路 #   给出 m x n 网格和两种人，要求如何安排这两种人能使得网格的得分最大。两种人有各自的初始分，相邻可能会加分也有可能减分。 这一题状态很多。首先每个格子有 3 种状态，那么每一行有 3^6 = 729 种不同的状态。每行行内分数变化值可能是 -60(两个内向)，+40(两个外向)，-10(一个内向一个外向)。两行行间分数变化值可能是 -60(两个内向)，+40(两个外向)，-10(一个内向一个外向)。那么我们可以把每行的状态压缩成一个三进制，那么网格就变成了一维，每两个三进制之间的关系是行间关系，每个三进制内部还需要根据内向和外向的人数决定行内最终分数。定义 dp[lineStatusLast][row][introvertsCount][extrovertsCount] 代表在上一行 row - 1 的状态是 lineStatusLast 的情况下，当前枚举到了第 row 行，内向还有 introvertsCount 个人，外向还有 extrovertsCount 个人能获得的最大分数。状态转移方程是 dp[lineStatusLast(row-1)][row][introvertsCount][extrovertsCount] = max{dp[lineStatusLast(row)][row+1][introvertsCount - countIC(lineStatusLast(row)) ][extrovertsCount - countEC(lineStatusLast(row)) ] + scoreInner(lineStatusLast(row)) + scoreOuter(lineStatusLast(row-1),lineStatusLast(row))} ，这里有 2 个统计函数，countIC 是统计当前行状态三进制里面有多少个内向人。countEC 是统计当前行状态三进制里面有多少个外向人。scoreInner 是计算当前行状态三进制的行内分数。scoreOuter 是计算 row -1 行和 row 行之间的行间分数。 由于这个状态转移方程的计算量是巨大的。所以需要预先初始化一些计算结果。比如把 729 中行状态分别对应的行内、行间的分数都计算好，在动态规划状态转移的时候，直接查表获取分数即可。这样我们在深搜的时候，利用 dp 的记忆化，可以大幅减少时间复杂度。 题目中还提到，人数可以不用完。如果 introvertsCount = 0, extrovertsCount = 0 ，即人数都用完了的情况，这时候 dp = 0。如果 row = m，即已经枚举完了所有行，那么不管剩下多少人，这一行的 dp = 0 。 初始化的时候，注意，特殊处理 0 的情况，0 行 0 列都初始化为 -1 。  代码 #  package leetcode import ( \u0026#34;math\u0026#34; ) func getMaxGridHappiness(m int, n int, introvertsCount int, extrovertsCount int) int { // lineStatus 将每一行中 3 种状态进行编码，空白 - 0，内向人 - 1，外向人 - 2，每行状态用三进制表示 \t// lineStatusList[729][6] 每一行的三进制表示 \t// introvertsCountInner[729] 每一个 lineStatus 包含的内向人数 \t// extrovertsCountInner[729] 每一个 lineStatus 包含的外向人数 \t// scoreInner[729] 每一个 lineStatus 包含的行内得分（只统计 lineStatus 本身的得分，不包括它与上一行的） \t// scoreOuter[729][729] 每一个 lineStatus 包含的行外得分 \t// dp[上一行的 lineStatus][当前处理到的行][剩余的内向人数][剩余的外向人数] \tn3, lineStatus, introvertsCountInner, extrovertsCountInner, scoreInner, scoreOuter, lineStatusList, dp := math.Pow(3.0, float64(n)), 0, [729]int{}, [729]int{}, [729]int{}, [729][729]int{}, [729][6]int{}, [729][6][7][7]int{} for i := 0; i \u0026lt; 729; i++ { lineStatusList[i] = [6]int{} } for i := 0; i \u0026lt; 729; i++ { dp[i] = [6][7][7]int{} for j := 0; j \u0026lt; 6; j++ { dp[i][j] = [7][7]int{} for k := 0; k \u0026lt; 7; k++ { dp[i][j][k] = [7]int{-1, -1, -1, -1, -1, -1, -1} } } } // 预处理 \tfor lineStatus = 0; lineStatus \u0026lt; int(n3); lineStatus++ { tmp := lineStatus for i := 0; i \u0026lt; n; i++ { lineStatusList[lineStatus][i] = tmp % 3 tmp /= 3 } introvertsCountInner[lineStatus], extrovertsCountInner[lineStatus], scoreInner[lineStatus] = 0, 0, 0 for i := 0; i \u0026lt; n; i++ { if lineStatusList[lineStatus][i] != 0 { // 个人分数 \tif lineStatusList[lineStatus][i] == 1 { introvertsCountInner[lineStatus]++ scoreInner[lineStatus] += 120 } else if lineStatusList[lineStatus][i] == 2 { extrovertsCountInner[lineStatus]++ scoreInner[lineStatus] += 40 } // 行内分数 \tif i-1 \u0026gt;= 0 { scoreInner[lineStatus] += closeScore(lineStatusList[lineStatus][i], lineStatusList[lineStatus][i-1]) } } } } // 行外分数 \tfor lineStatus0 := 0; lineStatus0 \u0026lt; int(n3); lineStatus0++ { for lineStatus1 := 0; lineStatus1 \u0026lt; int(n3); lineStatus1++ { scoreOuter[lineStatus0][lineStatus1] = 0 for i := 0; i \u0026lt; n; i++ { scoreOuter[lineStatus0][lineStatus1] += closeScore(lineStatusList[lineStatus0][i], lineStatusList[lineStatus1][i]) } } } return dfs(0, 0, introvertsCount, extrovertsCount, m, int(n3), \u0026amp;dp, \u0026amp;introvertsCountInner, \u0026amp;extrovertsCountInner, \u0026amp;scoreInner, \u0026amp;scoreOuter) } // 如果 x 和 y 相邻，需要加上的分数 func closeScore(x, y int) int { if x == 0 || y == 0 { return 0 } // 两个内向的人，每个人要 -30，一共 -60 \tif x == 1 \u0026amp;\u0026amp; y == 1 { return -60 } if x == 2 \u0026amp;\u0026amp; y == 2 { return 40 } return -10 } // dfs(上一行的 lineStatus，当前处理到的行，剩余的内向人数，剩余的外向人数） func dfs(lineStatusLast, row, introvertsCount, extrovertsCount, m, n3 int, dp *[729][6][7][7]int, introvertsCountInner, extrovertsCountInner, scoreInner *[729]int, scoreOuter *[729][729]int) int { // 边界条件：如果已经处理完，或者没有人了 \tif row == m || introvertsCount+extrovertsCount == 0 { return 0 } // 记忆化 \tif dp[lineStatusLast][row][introvertsCount][extrovertsCount] != -1 { return dp[lineStatusLast][row][introvertsCount][extrovertsCount] } best := 0 for lineStatus := 0; lineStatus \u0026lt; n3; lineStatus++ { if introvertsCountInner[lineStatus] \u0026gt; introvertsCount || extrovertsCountInner[lineStatus] \u0026gt; extrovertsCount { continue } score := scoreInner[lineStatus] + scoreOuter[lineStatus][lineStatusLast] best = max(best, score+dfs(lineStatus, row+1, introvertsCount-introvertsCountInner[lineStatus], extrovertsCount-extrovertsCountInner[lineStatus], m, n3, dp, introvertsCountInner, extrovertsCountInner, scoreInner, scoreOuter)) } dp[lineStatusLast][row][introvertsCount][extrovertsCount] = best return best } func max(a int, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':544,'href':'/leetcode-java/04_Leetcode/1662.Check-If-Two-String-Arrays-are-Equivalent/','title':"1662. Check if Two String Arrays Are Equivalent",'section':"第四章",'content':"1662. Check If Two String Arrays are Equivalent #  题目 #  Given two string arrays word1 and word2, return **true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\nExample 1:\nInput: word1 = [\u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;], word2 = [\u0026quot;a\u0026quot;, \u0026quot;bc\u0026quot;] Output: true Explanation: word1 represents string \u0026quot;ab\u0026quot; + \u0026quot;c\u0026quot; -\u0026gt; \u0026quot;abc\u0026quot; word2 represents string \u0026quot;a\u0026quot; + \u0026quot;bc\u0026quot; -\u0026gt; \u0026quot;abc\u0026quot; The strings are the same, so return true. Example 2:\nInput: word1 = [\u0026quot;a\u0026quot;, \u0026quot;cb\u0026quot;], word2 = [\u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;] Output: false Example 3:\nInput: word1 = [\u0026quot;abc\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;defg\u0026quot;], word2 = [\u0026quot;abcddefg\u0026quot;] Output: true Constraints:\n 1 \u0026lt;= word1.length, word2.length \u0026lt;= 103 1 \u0026lt;= word1[i].length, word2[i].length \u0026lt;= 103 1 \u0026lt;= sum(word1[i].length), sum(word2[i].length) \u0026lt;= 103 word1[i] and word2[i] consist of lowercase letters.  题目大意 #  给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。\n解题思路 #   简单题，依次拼接 2 个数组内的字符串，然后比较 str1 和 str2 是否相同即可。  代码 #  package leetcode func arrayStringsAreEqual(word1 []string, word2 []string) bool { str1, str2 := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; for i := 0; i \u0026lt; len(word1); i++ { str1 += word1[i] } for i := 0; i \u0026lt; len(word2); i++ { str2 += word2[i] } return str1 == str2 } "});index.add({'id':545,'href':'/leetcode-java/04_Leetcode/1663.Smallest-String-With-A-Given-Numeric-Value/','title':"1663. Smallest String With a Given Numeric Value",'section':"第四章",'content':"1663. Smallest String With A Given Numeric Value #  题目 #  The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\nThe numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \u0026quot;abe\u0026quot; is equal to 1 + 2 + 5 = 8.\nYou are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.\nNote that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\nExample 1:\nInput: n = 3, k = 27 Output: \u0026quot;aay\u0026quot; Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3. Example 2:\nInput: n = 5, k = 73 Output: \u0026quot;aaszz\u0026quot; Constraints:\n 1 \u0026lt;= n \u0026lt;= 105 n \u0026lt;= k \u0026lt;= 26 * n  题目大意 #  小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 \u0026ldquo;abe\u0026rdquo; 的数值等于 1 + 2 + 5 = 8 。给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：\n x 是 y 的一个前缀； 如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。  解题思路 #   给出 n 和 k，要求找到字符串长度为 n，字母在字母表内位置总和为 k 的最小字典序字符串。 这一题笔者读完题，比赛的时候直接用 DFS 撸了一版。赛后看了时间复杂度马马虎虎，感觉还有优化的空间。DFS 会遍历出所有的解，实际上这一题只要求最小字典序，所以 DFS 剪枝的时候要加上判断字典序的判断，如果新添加进来的字母比已经保存的字符串的相应位置上的字母字典序大，那么就直接 return，这个答案一定不会是最小字典序。代码见解法二 想到这里，其实 DFS 不必要，直接用 for 循环就可找到最小字典序的字符串。代码见解法一。  代码 #  package leetcode // 解法一 贪心 func getSmallestString(n int, k int) string { res := make([]rune, n) for i := n - 1; i \u0026gt;= 0; i-- { diff := k - i if diff \u0026gt;= 26 { // Need to add z \tres[i] = \u0026#39;z\u0026#39; k = k - 26 } else { res[i] = rune(\u0026#39;a\u0026#39; + diff - 1) k = k - diff } } return string(res) } // 解法二 DFS func getSmallestString1(n int, k int) string { if n == 0 { return \u0026#34;\u0026#34; } res, c := \u0026#34;\u0026#34;, []byte{} findSmallestString(0, n, k, 0, c, \u0026amp;res) return res } func findSmallestString(value int, length, k, index int, str []byte, res *string) { if len(str) == length \u0026amp;\u0026amp; value == k { tmp := string(str) if (*res) == \u0026#34;\u0026#34; { *res = tmp } if tmp \u0026lt; *res \u0026amp;\u0026amp; *res != \u0026#34;\u0026#34; { *res = tmp } return } if len(str) \u0026gt;= index \u0026amp;\u0026amp; (*res) != \u0026#34;\u0026#34; \u0026amp;\u0026amp; str[index-1] \u0026gt; (*res)[index-1] { return } for j := 0; j \u0026lt; 26; j++ { if k-value \u0026gt; (length-len(str))*26 || value \u0026gt; k { return } str = append(str, byte(int(\u0026#39;a\u0026#39;)+j)) value += j + 1 findSmallestString(value, length, k, index+1, str, res) str = str[:len(str)-1] value -= j + 1 } } "});index.add({'id':546,'href':'/leetcode-java/04_Leetcode/1664.Ways-to-Make-a-Fair-Array/','title':"1664. Ways to Make a Fair Array",'section':"第四章",'content':"1664. Ways to Make a Fair Array #  题目 #  You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.\nFor example, if nums = [6,1,7,4,1]:\n Choosing to remove index 1 results in nums = [6,7,4,1]. Choosing to remove index 2 results in nums = [6,1,4,1]. Choosing to remove index 4 results in nums = [6,1,7,4].  An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.\nReturn the number of indices that you could choose such that after the removal, nums is fair.\nExample 1:\nInput: nums = [2,1,6,4] Output: 1 Explanation: Remove index 0: [1,6,4] -\u0026gt; Even sum: 1 + 4 = 5. Odd sum: 6. Not fair. Remove index 1: [2,6,4] -\u0026gt; Even sum: 2 + 4 = 6. Odd sum: 6. Fair. Remove index 2: [2,1,4] -\u0026gt; Even sum: 2 + 4 = 6. Odd sum: 1. Not fair. Remove index 3: [2,1,6] -\u0026gt; Even sum: 2 + 6 = 8. Odd sum: 1. Not fair. There is 1 index that you can remove to make nums fair. Example 2:\nInput: nums = [1,1,1] Output: 3 Explanation: You can remove any index and the remaining array is fair. Example 3:\nInput: nums = [1,2,3] Output: 0 Explanation: You cannot make a fair array after removing any index. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 104  题目大意 #  给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。\n比方说，如果 nums = [6,1,7,4,1] ，那么：\n 选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。 选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。 选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。  如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。\n解题思路 #   给定一个数组 nums，要求输出仅删除一个元素以后能使得整个数组平衡的方案数。平衡的定义是奇数下标元素总和等于偶数下标元素总和。 这一题如果暴力解答，会超时。原因是每次删除元素以后，都重新计算奇偶数位总和比较耗时。应该利用前面计算过的累加和，推导出此次删除元素以后的情况。这样修改以后就不超时了。具体的，如果删除的是元素是奇数位，这个下标的前缀和不变，要变化的是后面的。删除元素后面，原来偶数位的总和变成了奇数位了，原来奇数位的总和变成偶数位了。删除元素后面这半段的总和可以用前缀和计算出来，奇数位的总和减去删除元素的前缀和，就得到了删除元素后面的后缀和。通过这个办法就可以得到删除元素后面的，奇数位总和，偶数位总和。注意这个后缀和是包含了删除元素的。所以最后需要判断删除元素是奇数位还是偶数位，如果是奇数位，那么在计算出来的偶数和上再减去这个删除元素；如果是偶数位，就在计算出来的奇数和上再减去这个删除元素。代码见解法二。 这一题还有一种更简洁的写法，就是解法一了。通过了解法二的思考，我们可以知道，每次变换以后的操作可以抽象出来，即三步，减去一个数，判断是否相等，再加上一个数。只不过这三步在解法二中都去判断了奇偶性。如果我们不判断奇偶性，那么代码就可以写成解法一的样子。为什么可以不用管奇偶性呢？因为每次删除一个元素以后，下次再删除，奇偶就发生颠倒了，上次的奇数和到了下次就是偶数和了。想通这一点就可以把代码写成解法一的样子。  代码 #  // 解法一 超简洁写法 func waysToMakeFair(nums []int) int { sum, res := [2]int{}, 0 for i := 0; i \u0026lt; len(nums); i++ { sum[i%2] += nums[i] } for i := 0; i \u0026lt; len(nums); i++ { sum[i%2] -= nums[i] if sum[i%2] == sum[1-(i%2)] { res++ } sum[1-(i%2)] += nums[i] } return res } // 解法二 前缀和，后缀和 func waysToMakeFair1(nums []int) int { evenPrefix, oddPrefix, evenSuffix, oddSuffix, res := 0, 0, 0, 0, 0 for i := 0; i \u0026lt; len(nums); i++ { if i%2 == 0 { evenSuffix += nums[i] } else { oddSuffix += nums[i] } } for i := 0; i \u0026lt; len(nums); i++ { if i%2 == 0 { evenSuffix -= nums[i] } else { oddSuffix -= nums[i] } if (evenPrefix + oddSuffix) == (oddPrefix + evenSuffix) { res++ } if i%2 == 0 { evenPrefix += nums[i] } else { oddPrefix += nums[i] } } return res } "});index.add({'id':547,'href':'/leetcode-java/04_Leetcode/1665.Minimum-Initial-Energy-to-Finish-Tasks/','title':"1665. Minimum Initial Energy to Finish Tasks",'section':"第四章",'content':"1665. Minimum Initial Energy to Finish Tasks #  题目 #  You are given an array tasks where tasks[i] = [actuali, minimumi]:\n actuali is the actual amount of energy you spend to finish the ith task. minimumi is the minimum amount of energy you require to begin the ith task.  For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.\nYou can finish the tasks in any order you like.\nReturn the minimum initial amount of energy you will need to finish all the tasks.\nExample 1:\nInput: tasks = [[1,2],[2,4],[4,8]] Output: 8 Explanation: Starting with 8 energy, we finish the tasks in the following order: - 3rd task. Now energy = 8 - 4 = 4. - 2nd task. Now energy = 4 - 2 = 2. - 1st task. Now energy = 2 - 1 = 1. Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task. Example 2:\nInput: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]] Output: 32 Explanation: Starting with 32 energy, we finish the tasks in the following order: - 1st task. Now energy = 32 - 1 = 31. - 2nd task. Now energy = 31 - 2 = 29. - 3rd task. Now energy = 29 - 10 = 19. - 4th task. Now energy = 19 - 10 = 9. - 5th task. Now energy = 9 - 8 = 1. Example 3:\nInput: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] Output: 27 Explanation: Starting with 27 energy, we finish the tasks in the following order: - 5th task. Now energy = 27 - 5 = 22. - 2nd task. Now energy = 22 - 2 = 20. - 3rd task. Now energy = 20 - 3 = 17. - 1st task. Now energy = 17 - 1 = 16. - 4th task. Now energy = 16 - 4 = 12. - 6th task. Now energy = 12 - 6 = 6. Constraints:\n 1 \u0026lt;= tasks.length \u0026lt;= 105 1 \u0026lt;= actuali \u0026lt;= minimumi \u0026lt;= 104  题目大意 #  给你一个任务数组 tasks ，其中 tasks[i] = [actuali, minimumi] ：\n actual i 是完成第 i 个任务 需要耗费 的实际能量。 minimum i 是开始第 i 个任务前需要达到的最低能量。  比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。你可以按照 任意顺序 完成任务。请你返回完成所有任务的 最少 初始能量。\n解题思路 #   给出一个 task 数组，每个元素代表一个任务，每个任务有实际消费能量值和开始这个任务需要的最低能量。要求输出能完成所有任务的最少初始能量。 这一题直觉是贪心。先将任务按照 minimum - actual 进行排序。先完成差值大的任务，那么接下来的能量能最大限度的满足接下来的任务。这样可能完成所有任务的可能性越大。循环任务数组的时候，保存当前能量在 cur 中，如果当前能量不够开启下一个任务，那么这个差值就是需要弥补的，这些能量就是最少初始能量中的，所以加上这些差值能量。如果当前能量可以开启下一个任务，那么就更新当前能量，减去实际消耗的能量以后，再继续循环。循环结束就能得到最少初始能量了。  代码 #  package leetcode import ( \u0026#34;sort\u0026#34; ) func minimumEffort(tasks [][]int) int { sort.Sort(Task(tasks)) res, cur := 0, 0 for _, t := range tasks { if t[1] \u0026gt; cur { res += t[1] - cur cur = t[1] - t[0] } else { cur -= t[0] } } return res } func max(a, b int) int { if a \u0026gt; b { return a } return b } // Task define type Task [][]int func (task Task) Len() int { return len(task) } func (task Task) Less(i, j int) bool { t1, t2 := task[i][1]-task[i][0], task[j][1]-task[j][0] if t1 != t2 { return t2 \u0026lt; t1 } return task[j][1] \u0026lt; task[i][1] } func (task Task) Swap(i, j int) { t := task[i] task[i] = task[j] task[j] = t } "});index.add({'id':548,'href':'/leetcode-java/04_Leetcode/Interview.02.02.Kth-Node-From-End-Of-List-Lcci/','title':"Interview.02.02. Kth Node From End of List Lcci",'section':"第四章",'content':"面试题 02.02. 返回倒数第 k 个节点 #  Difficulty: 简单\n实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。\n**注意：**本题相对原题稍作改动\n示例：\n输入： 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 和 k = 2 输出： 4 说明：\n给定的 k 保证是有效的。\n题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int kthToLast(ListNode head, int k) { int length = 0; ListNode temp = head; while (temp != null) { length++; temp = temp.next; } for (int i = 0; i \u0026lt; length - k; i++) { head = head.next; } return head.val; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  "});index.add({'id':549,'href':'/leetcode-java/04_Leetcode/Interview.02.03.Delete-Middle-Node-Lcci/','title':"Interview.02.03. Delete Middle Node Lcci",'section':"第四章",'content':"面试题 02.03. 删除中间节点 #  Difficulty: 简单\n实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。\n示例：\n输入：单向链表a-\u0026gt;b-\u0026gt;c-\u0026gt;d-\u0026gt;e-\u0026gt;f中的节点c 结果：不返回任何数据，但该链表变为a-\u0026gt;b-\u0026gt;d-\u0026gt;e-\u0026gt;f 题解 #  题解一： #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 复杂度分析\n  时间复杂度：O(1)。\n  空间复杂度：O(1)。\n  "});index.add({'id':550,'href':'/leetcode-java/04_Leetcode/Interview.04.03.List-Of-Depth-Lcci/','title':"Interview.04.03. List of Depth Lcci",'section':"第四章",'content':"面试题 04.03. 特定深度节点链表 #  Difficulty: 中等\n给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。\n示例：\n输入：[1,2,3,4,5,null,7,8] 1 / \\ 2 3 / \\ \\ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]] 题解 #  题解一：BFS 二叉树层序遍历（Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode[] listOfDepth(TreeNode tree) { Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(tree); List\u0026lt;ListNode\u0026gt; nodeList = new ArrayList\u0026lt;\u0026gt;(); ListNode dummy = new ListNode(-1); while (!queue.isEmpty()) { int size = queue.size(); ListNode currentNode = dummy; for (int i = 0; i \u0026lt; size; i++) { TreeNode current = queue.poll(); currentNode.next = new ListNode(current.val); if (current.left != null) { queue.add(current.left); } if (current.right != null) { queue.add(current.right); } currentNode = currentNode.next; } nodeList.add(dummy.next); } return nodeList.toArray(new ListNode[]{}); } } "});index.add({'id':551,'href':'/leetcode-java/04_Leetcode/Interview.04.05.Legal-Binary-Search-Tree-Lcci/','title':"Interview.04.05. Legal Binary Search Tree Lcci",'section':"第四章",'content':"面试题 04.05. 合法二叉搜索树 #  Difficulty: 中等\n实现一个函数，检查一棵二叉树是否为二叉搜索树。\n示例 1:\n输入: 2 / \\ 1 3输出: true 示例 2:\n输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 题解 #  题解一：BSF 遍历（Stack 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isValidBST(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;TreeNode\u0026gt;(); Integer currValue = null; TreeNode curr = root; while (curr != null || !stack.isEmpty()) { if (curr != null) { stack.push(curr); curr = curr.left; } else { curr = stack.pop(); if (currValue != null \u0026amp;\u0026amp; curr.val \u0026lt;= currValue) { return false; } currValue = curr.val; curr = curr.right; } } return true; } } 题解二：递归求解 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean isValidBST(TreeNode root, long min, long max) { return root == null || (root.val \u0026gt; min \u0026amp;\u0026amp; root.val \u0026lt; max \u0026amp;\u0026amp; isValidBST(root.left, min, root.val) \u0026amp;\u0026amp; isValidBST(root.right, root.val, max)); } } "});index.add({'id':552,'href':'/leetcode-java/04_Leetcode/Interview.04.12.Paths-With-Sum-Lcci/','title':"Interview.04.12. Paths With Sum Lcci",'section':"第四章",'content':"面试题 04.12. 求和路径 #  Difficulty: 中等\n给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回:\n3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7] 提示：\n 节点总数 \u0026lt;= 10000  题解 #  题解一：BSF + DFS（BSF 使用 Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int result; public int pathSum(TreeNode root, int sum) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { TreeNode currentNode = queue.poll(); helper(currentNode, sum, 0); if (currentNode.left != null) { queue.add(currentNode.left); } if (currentNode.right != null) { queue.add(currentNode.right); } } return result; } private void helper(TreeNode node, int sum, int currentSum) { if (node == null) { return; } currentSum += node.val; if (currentSum == sum) { result++; } helper(node.left, sum, currentSum); helper(node.right, sum, currentSum); } } "});index.add({'id':553,'href':'/leetcode-java/04_Leetcode/Interview.04.17.Find-Majority-Element-Lcci/','title':"Interview.04.17. Find Majority Element Lcci",'section':"第四章",'content':"面试题 17.10. 主要元素 #  Difficulty: 简单\n数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。\n示例 1：\n输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2：\n输入：[3,2] 输出：-1 示例 3：\n输入：[2,2,1,1,1,2,2] 输出：2 说明：\n你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？\n题解 #  题解一：线性法 + 哈希 #  class Solution { public int majorityElement(int[] nums) { int length = nums.length; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; length; i++) { Integer count = map.getOrDefault(nums[i], 0); if (count + 1 \u0026gt; length / 2) { return nums[i]; } else { map.put(nums[i], count + 1); } } return -1; } } 复杂度分析 #    时间复杂度：O(n)。\n  空间复杂度：O(n)。\n  题解二：摩尔投票法 #  class Solution { public int majorityElement(int[] nums) { //判空  if (nums.length == 0) { return -1; } //投票环节  int major = 0; int vote = 0; for (int num : nums) { if (vote == 0) { major = num; vote++; } else { if (num == major) { vote++; } else { vote--; } } } //验证环节  if (vote == 0) { return -1; } int identify = 0; for (int num : nums) { if (num == major) { identify++; if (identify \u0026gt; nums.length / 2) { return major; } } } return -1; } } 复杂度分析 #    时间复杂度：O(n)\n  空间复杂度：O(1)\n  "});index.add({'id':554,'href':'/leetcode-java/04_Leetcode/Interview.16.19.Pond-Sizes-Lcci/','title':"Interview.16.19. Pond Sizes Lcci",'section':"第四章",'content':"面试题 16.19. 水域大小 #  Difficulty: 中等\n你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。\n示例：\n输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：\n 0 \u0026lt; len(land) \u0026lt;= 1000 0 \u0026lt; len(land[i]) \u0026lt;= 1000  题解 #  题解一：DFS（广度优先搜索） #  class Solution { public int[] pondSizes(int[][] land) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); if(land.length == 0) { return new int [0]; } int temp = 0; for(int i = 0; i \u0026lt; land.length; i++) { for(int j = 0; j \u0026lt; land[0].length; j++) { if(land[i][j] == 0){ temp = dfs(land, i, j); list.add(temp); } } } list.sort((o1, o2) -\u0026gt; o1 - o2); return list.stream().mapToInt(Integer::intValue).toArray(); } private int dfs(int[][] land, int i, int j) { if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= land.length || j \u0026gt;= land[0].length || land[i][j] != 0) { return 0; } land[i][j] = 3; int area = 1; area += dfs(land, i - 1, j - 1); area += dfs(land, i - 1, j + 1); area += dfs(land, i, j + 1); area += dfs(land, i, j - 1); area += dfs(land, i - 1, j); area += dfs(land, i + 1, j); area += dfs(land, i + 1, j - 1); area += dfs(land, i + 1, j + 1); return area; } } 复杂度分析\n  时间复杂度：\n  空间复杂度：\n  "});index.add({'id':555,'href':'/leetcode-java/04_Leetcode/Offer.22.Lian-Biao-Zhong-Dao-Shu-Di-Kge-Jie-Dian-Lcof/','title':"Offer.22. Lian Biao Zhong Dao Shu Di Kge Jie Dian Lcof",'section':"第四章",'content':"剑指 Offer 22. 链表中倒数第k个节点 #  Difficulty: 简单\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n示例：\n给定一个链表: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 和 k = 2. 返回链表 4-\u0026gt;5. 题解 #  题解一：两次遍历 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode getKthFromEnd(ListNode head, int k) { int length = 0; ListNode temp = head; while (temp != null) { length++; temp = temp.next; } for (int i = 0; i \u0026lt; length - k; i++) { head = head.next; } return head; } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  题解二：快慢指针 #  /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode getKthFromEnd(ListNode head, int k) { ListNode fast = head; while (fast != null) { fast = fast.next; if (k == 0) { head = head.next; } else { k--; } } return head; } } 复杂度分析\n  时间复杂度：O(n)。\n  空间复杂度：O(1)。\n  "});index.add({'id':556,'href':'/leetcode-java/04_Leetcode/Offer.26.Shu-De-Zi-Jie-Gou-Lcof/','title':"Offer.26. Shu De Zi Jie Gou Lcof",'section':"第四章",'content':"剑指 Offer 26. 树的子结构 #  Difficulty: 中等\n输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如:\n给定的树 A:\n 3 / \\ 4 5 / \\ 1 2\n给定的树 B：\n 4 / 1\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n示例 1：\n输入：A = [1,2,3], B = [3,1] 输出：false 示例 2：\n输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 10000\n题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { return (A != null \u0026amp;\u0026amp; B != null) \u0026amp;\u0026amp; (helper(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)); } private boolean helper(TreeNode A, TreeNode B) { if (B == null) { return true; } if (A == null || A.val != B.val) { return false; } return helper(A.left, B.left) \u0026amp;\u0026amp; helper(A.right, B.right); } } 复杂度分析 #    时间复杂度：O(MN)，其中 M, N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M)，每次调用 recur(A, B) 判断占用 O(N)。\n  空间复杂度 O(M)，当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M ≤ N 时，遍历树 A 与递归判断的总递归深度为 M；当 M \u0026gt; N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。\n  "});index.add({'id':557,'href':'/leetcode-java/04_Leetcode/Offer.28.Dui-Cheng-De-Er-Cha-Shu-Lcof/','title':"Offer.28. Dui Cheng De Er Cha Shu Lcof",'section':"第四章",'content':"剑指 Offer 28. 对称的二叉树 #  Difficulty: 简单\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n1 / \\ 2 2 \\ \\ 3 3 示例 1：\n输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：\n输入：root = [1,2,2,null,3,null,3] 输出：false 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 1000\n注意：本题与主站 101 题相同：\n题解 #  题解一：递归 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return helper(root.left, root.right); } private boolean helper(TreeNode node1, TreeNode node2) { if (node1 == null \u0026amp;\u0026amp; node2 == null) { return true; } if (node1 == null || node2 == null) { return false; } return node1.val == node2.val \u0026amp;\u0026amp; helper(node1.left, node2.right) \u0026amp;\u0026amp; helper(node1.right, node2.left); } } 复杂度分析\n  时间复杂度：O(N)。\n  空间复杂度：O(N)，极端情况下退化为链表。\n  "});index.add({'id':558,'href':'/leetcode-java/04_Leetcode/Offer.32.II.Cong-Shang-Dao-Xia-Da-Yin-Er-Cha-Shu-II-Lcof/','title':"Offer.32. I I. Cong Shang Dao Xia Da Yin Er Cha Shu I I Lcof",'section':"第四章",'content':"剑指 Offer 32 - II. 从上到下打印二叉树 II #  Difficulty: 简单\n从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果：\n[ [3], [9,20], [15,7] ] 提示：\n 节点总数 \u0026lt;= 1000  注意：本题与主站 102 题相同：\n题解 #  解法一：BFS 广度优先遍历（Queue 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allResult = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return allResult; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while(!queue.isEmpty()) { int size = queue.size(); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); result.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } allResult.add(result); } return allResult; } } 解法二：DFS 深度优先遍历 #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); helper(root, result, 0); return result; } private void helper(TreeNode node, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, int level) { if (node == null) { return; } if (level \u0026gt;= result.size()) { result.add(new ArrayList\u0026lt;\u0026gt;()); } result.get(level).add(node.val); helper(node.left, result, level + 1); helper(node.right, result, level + 1); } } "});index.add({'id':559,'href':'/leetcode-java/04_Leetcode/Offer.54.Er-Cha-Sou-Suo-Shu-De-Di-Kda-Jie-Dian-Lcof/','title':"Offer.54. Er Cha Sou Suo Shu De Di Kda Jie Dian Lcof",'section':"第四章",'content':"剑指 Offer 54. 二叉搜索树的第k大节点 #  Difficulty: 简单\n给定一棵二叉搜索树，请找出其中第k大的节点。\n示例 1:\n输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 4 示例 2:\n输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4 限制：\n1 ≤ k ≤ 二叉搜索树元素个数\n题解 #  题解一：递归方法（二叉树的中序遍历变型（右根左遍历）） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int kthLargest(TreeNode root, int k) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); inOrder(root, list); return list.get(k - 1); } private void inOrder(TreeNode node, List\u0026lt;Integer\u0026gt; list) { if (node == null) { return; } inOrder(node.right, list); list.add(node.val); inOrder(node.left, list); } } 复杂度分析： #   时间复杂度：O(n)。 空间复杂度：O(n)。  解法二：迭代方法（Stack 数据结构） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int kthLargest(TreeNode root, int k) { int count = 1; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); while (root != null || !stack.empty()) { while (root != null) { stack.push(root); root = root.right; } TreeNode pop = stack.pop(); if (count == k) { return pop.val; } count++; root = pop.left; } return 0; } } 复杂度分析： #   时间复杂度：O(n)。 空间复杂度：O(n)。  "});index.add({'id':560,'href':'/leetcode-java/04_Leetcode/Offer.55.I.Er-Cha-Shu-De-Shen-Du-Lcof/','title':"Offer.55. I. Er Cha Shu De Shen Du Lcof",'section':"第四章",'content':"剑指 Offer 55 - I. 二叉树的深度 #  Difficulty: 简单\n输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n例如：\n给定二叉树 [3,9,20,null,null,15,7]，\n3 / \\  9 20 / \\  15 7 返回它的最大深度 3 。\n提示：\n 节点总数 \u0026lt;= 10000  注意：本题与主站 104 题相同：\n题解 #  题解一：DFS（广度优先搜索） #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { if(root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } 复杂度分析\n  时间复杂度：\n  空间复杂度：\n  "});index.add({'id':561,'href':'/leetcode-java/04_Leetcode/Offer.55.II.Ping-Heng-Er-Cha-Shu-Lcof/','title':"Offer.55. I I. Ping Heng Er Cha Shu Lcof",'section':"第四章",'content':"剑指 Offer 55 - II. 平衡二叉树 #  Difficulty: 简单\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n 3 / \\ 9 20 / \\ 15 7 返回 true 。\n示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。\n限制：\n 1 \u0026lt;= 树的结点个数 \u0026lt;= 10000  注意：本题与主站 110 题相同：\n题解 #  题解一： #  /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } return Math.abs(depth(root.left) - depth(root.right)) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } private int depth(TreeNode node) { if (node == null) { return 0; } return Math.max(depth(node.left), depth(node.right)) + 1; } } "});index.add({'id':562,'href':'/leetcode-java/docs/example/collapsed/3rd-level/4th-level/','title':"4th Level",'section':"3rd Level",'content':"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':563,'href':'/leetcode-java/docs/example/collapsed/3rd-level/','title':"3rd Level",'section':"Collapsed",'content':"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "});index.add({'id':564,'href':'/leetcode-java/docs/example/hidden/','title':"Hidden",'section':"Example Site",'content':"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':566,'href':'/leetcode-java/docs/shortcodes/buttons/','title':"Buttons",'section':"Shortcodes",'content':"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':567,'href':'/leetcode-java/docs/shortcodes/columns/','title':"Columns",'section':"Shortcodes",'content':"Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "});index.add({'id':568,'href':'/leetcode-java/docs/shortcodes/details/','title':"Details",'section':"Shortcodes",'content':"Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content Lorem markdownum insigne\u0026hellip;   "});index.add({'id':569,'href':'/leetcode-java/docs/shortcodes/expand/','title':"Expand",'section':"Shortcodes",'content':"Expand #  Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample #  Default #  {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Expand ↕  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label #  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "});index.add({'id':570,'href':'/leetcode-java/docs/shortcodes/hints/','title':"Hints",'section':"Shortcodes",'content':"Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "});index.add({'id':571,'href':'/leetcode-java/docs/shortcodes/katex/','title':"Katex",'section':"Shortcodes",'content':"KaTeX #  KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample #  {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}}     \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]    Display Mode Example #  Here is some inline example:  \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block  \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]  Text continues here.\n"});index.add({'id':572,'href':'/leetcode-java/docs/shortcodes/mermaid/','title':"Mermaid",'section':"Shortcodes",'content':"Mermaid Chart #   Mermaid is library for generating svg charts and diagrams from text.\nExample #  {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}     mermaid.initialize({ flowchart: { useMaxWidth:true } });  sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end   "});index.add({'id':573,'href':'/leetcode-java/docs/shortcodes/section/','title':"Section",'section':"Shortcodes",'content':"Section #  Section renders pages in section as definition list, using title and description.\nExample #  {{\u0026lt; section \u0026gt;}}   Page1   Page 1 #   Page2   Page 2 #   "});index.add({'id':574,'href':'/leetcode-java/docs/shortcodes/section/page1/','title':"Page1",'section':"Section",'content':"Page 1 #  "});index.add({'id':575,'href':'/leetcode-java/docs/shortcodes/section/page2/','title':"Page2",'section':"Section",'content':"Page 2 #  "});index.add({'id':576,'href':'/leetcode-java/docs/shortcodes/tabs/','title':"Tabs",'section':"Shortcodes",'content':"Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "});index.add({'id':577,'href':'/leetcode-java/03_Topic/Array/','title':"Array",'section':"第二章",'content':"Array #     Title Solution Difficulty Time Space 收藏     1. Two Sum Java Easy O(n) O(n) 💖   \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026ndash;    "});index.add({'id':579,'href':'/leetcode-java/03_Topic/DFS/','title':"Tree",'section':"第二章",'content':"Tree #     Title Solution Difficulty Time Space 收藏     110. Balanced Binary Tree Java Easy O(-) O(-)    \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026ndash;    "});index.add({'id':580,'href':'/leetcode-java/03_Topic/Tree/','title':"Tree",'section':"第二章",'content':"Tree #     Title Solution Difficulty Time Space 收藏     110. Balanced Binary Tree Java Easy O(-) O(-)    \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026ndash;    "});index.add({'id':581,'href':'/leetcode-java/02_Template/UnionFind/','title':"并查集",'section':"第三章",'content':"并查集 UnionFind #  package template // UnionFind defind // 路径压缩 + 秩优化 type UnionFind struct { parent, rank []int count int } // Init define func (uf *UnionFind) Init(n int) { uf.count = n uf.parent = make([]int, n) uf.rank = make([]int, n) for i := range uf.parent { uf.parent[i] = i } } // Find define func (uf *UnionFind) Find(p int) int { root := p for root != uf.parent[root] { root = uf.parent[root] } // compress path \tfor p != uf.parent[p] { tmp := uf.parent[p] uf.parent[p] = root p = tmp } return root } // Union define func (uf *UnionFind) Union(p, q int) { proot := uf.Find(p) qroot := uf.Find(q) if proot == qroot { return } if uf.rank[qroot] \u0026gt; uf.rank[proot] { uf.parent[proot] = qroot } else { uf.parent[qroot] = proot if uf.rank[proot] == uf.rank[qroot] { uf.rank[proot]++ } } uf.count-- } // TotalCount define func (uf *UnionFind) TotalCount() int { return uf.count } // UnionFindCount define // 计算每个集合中元素的个数 + 最大集合元素个数 type UnionFindCount struct { parent, count []int maxUnionCount int } // Init define func (uf *UnionFindCount) Init(n int) { uf.parent = make([]int, n) uf.count = make([]int, n) for i := range uf.parent { uf.parent[i] = i uf.count[i] = 1 } } // Find define func (uf *UnionFindCount) Find(p int) int { root := p for root != uf.parent[root] { root = uf.parent[root] } return root } // 不进行秩压缩，时间复杂度爆炸，太高了 // func (uf *UnionFindCount) union(p, q int) { // proot := uf.find(p) // qroot := uf.find(q) // if proot == qroot { // return // } // if proot != qroot { // uf.parent[proot] = qroot // uf.count[qroot] += uf.count[proot] // } // }  // Union define func (uf *UnionFindCount) Union(p, q int) { proot := uf.Find(p) qroot := uf.Find(q) if proot == qroot { return } if proot == len(uf.parent)-1 { //proot is root \t} else if qroot == len(uf.parent)-1 { // qroot is root, always attach to root \tproot, qroot = qroot, proot } else if uf.count[qroot] \u0026gt; uf.count[proot] { proot, qroot = qroot, proot } //set relation[0] as parent \tuf.maxUnionCount = max(uf.maxUnionCount, (uf.count[proot] + uf.count[qroot])) uf.parent[qroot] = proot uf.count[proot] += uf.count[qroot] } // Count define func (uf *UnionFindCount) Count() []int { return uf.count } // MaxUnionCount define func (uf *UnionFindCount) MaxUnionCount() int { return uf.maxUnionCount } func max(a int, b int) int { if a \u0026gt; b { return a } return b } "});index.add({'id':582,'href':'/leetcode-java/01_Overview/Data_Structure/','title':"数据结构知识",'section':"第一章",'content':"数据结构知识 #  以下是笔者整理的数据结构相关的知识。希望能把常见的数据结构都枚举穷尽。如有遗漏，欢迎大家赐教，提 PR。相关题目还在慢慢整理中，讲解的文章还在创作中。\n 刷题只是提升算法能力的手段，最终目的应该是提升自我的思维能力，知识需要凝结成块，那么就把这些总结在第一章这两节中，让它得到升华吧~希望读者在刷完题之后再回过头来看这个表格，能很清晰的梳理自己的知识体系，查缺补漏，尽早完善。\n    数据结构 变种 相关题目 讲解文章     顺序线性表：向量 Vector      单链表\nSingly Linked List 1. 双向链表 Double Linked Lists\n2. 静态链表 Static List\n3. 对称矩阵 Symmetric Matrix\n4. 稀疏矩阵 Sparse Matrix     哈希表\nHash Table 1. 散列函数 Hash Function\n2. 解决碰撞/填充因子\n     栈和队列\nStack \u0026amp; Queue 1. 广义栈\n2. 双端队列 Deque\n     队列\nQueue 1. 链表实现\n2. 循环数组实现\n3. 双端队列 Deque     字符串\nString 1. KMP 算法\n2. 有限状态自动机\n3. 模式匹配有限状态自动机\n4. BM 模式匹配算法\n5. BM-KMP 算法\n6. BF 算法     树\nTree 1. 二叉树 Binary Tree\n2. 并查集 Union-Find\n3. Huffman 树     数组实现的堆\nHeap 1. 极大堆和极小堆\n2. 极大极小堆\n3. 双端堆 Deap\n4. d 叉堆     树实现的堆\nHeap 1. 左堆\n2. 扁堆\n3. 二项式堆\n4. 斐波那契堆 Fibonacco Heap\n5. 配对堆 Pairing Heap     查找\nFind 1. 哈希表 Hash\n2. 跳跃表 Skip List\n3. 排序二叉树 Binary Sort Tree\n4. AVL 树\n5. B 树 / B+ 树 / B* 树\n6. AA 树\n7. 红黑树 Red Black Tree\n8. 排序二叉堆 Binary Heap\n9. Splay 树\n10. 双链树 Double Chained Tree\n11. Trie 树\n12. R 树     \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;    "});index.add({'id':583,'href':'/leetcode-java/01_Overview/','title':"第一章",'section':"序",'content':"第一章 序章 #  "});index.add({'id':584,'href':'/leetcode-java/02_Template/','title':"第三章",'section':"序",'content':"第三章 一些模板 #  这一章会罗列一些整理好的模板。一起来看看吧。\n"});index.add({'id':585,'href':'/leetcode-java/03_Topic/','title':"第二章",'section':"序",'content':"第二章 算法专题 #  本来天真的认为，把 LeetCode 所有题都完整刷一遍，就可以完整这本书了。经过事实证明，确实是天真了。因为 LeetCode 每天都会增加新题，有时候工作忙了，刷题进度就完全追不上题目更新的速度了。而且以我当前的刷题速度，一年才完成 500+，一年 LeetCode 也会更新 400+ 多题，要起码 5~10 年才能把所有的题目刷完。时间太长了。所以先给自己定了一个小目标，500 题就先把书写出来，总结这个阶段的刷题心得，和大家一起交流。要想把 LeetCode 所有题目都刷完，看来这本书要迭代 5 ~ 10 个版本了(一年迭代一版)。\n那么这一章就把已经刷完了的专题都整理一遍。有相似套路的题目都放在一起，如果想快速面试的话，其实相同的题目刷 2，3 道就可以了。相同类型的题目非常熟练的情况下，再多刷几道也是做无用功。\n做到目前为止，笔者认为动态规划是最灵活的类型，这类题目没有一个模板可以给你套用，它也是算法之优雅的地方。笔者认为称它为算法的艺术不为过。动态规划这类型，笔者也还没有刷完，只刷了一部分，还在学习中。\n那么就分享一下笔者目前刷过的题，和有相似点的题目吧。\n"});index.add({'id':586,'href':'/leetcode-java/04_Leetcode/','title':"第四章",'section':"序",'content':"第四章 Leetcode 题解 #  这一章就是 LeetCode 的题解了。笔者目前只刷到 608 题，题解这里有 520 题，都已经 runtime beats 100% 了。相差的 88 题是还没有 beats 100% 的，笔者还需要继续优化~\n题解慢慢更新中，欢迎大家提出更好的解法。点击页面下方的 edit，会跳转到 github 对应的页面 markdown 中，可以提交你的最优解 PR。\n让我们在题解的太空遨游吧~\n"});index.add({'id':587,'href':'/leetcode-java/01_Overview/Algorithm/','title':"算法知识",'section':"第一章",'content':"算法知识 #  以下是笔者整理的算法相关的知识。希望能把常见的算法都枚举穷尽。如有遗漏，欢迎大家赐教，提 PR。相关题目还在慢慢整理中，讲解的文章还在创作中。\n 刷题只是提升算法能力的手段，最终目的应该是提升自我的思维能力，知识需要凝结成块，那么就把这些总结在第一章这两节中，让它得到升华吧~希望读者在刷完题之后再回过头来看这个表格，能很清晰的梳理自己的知识体系，查缺补漏，尽早完善。\n    算法 具体类型 相关题目 讲解文章     排序算法 1. 冒泡排序\n2. 插入排序\n3. 选择排序\n4. 希尔 Shell 排序\n5. 快速排序\n6. 归并排序\n7. 堆排序\n8. 线性排序算法\n9. 自省排序\n10. 间接排序\n11. 计数排序\n12. 基数排序\n13. 桶排序\n14. 外部排序 - k 路归并败者树\n15. 外部排序 - 最佳归并树     递归与分治  1. 二分搜索/查找\n2. 大整数的乘法\n3. Strassen 矩阵乘法\n4. 棋盘覆盖\n5. 合并排序\n6. 快速排序\n7. 线性时间选择\n8. 最接近点对问题\n9. 循环赛日程表\n    动态规划  1. 矩阵连乘问题\n2. 最长公共子序列\n3. 最大子段和\n4. 凸多边形最优三角剖分\n5. 多边形游戏\n6. 图像压缩\n7. 电路布线\n8. 流水作业调度\n9. 0-1 背包问题/背包九讲\n10. 最优二叉搜索树\n11. 动态规划加速原理\n12. 树型 DP\n    贪心  1. 活动安排问题\n2. 最优装载\n3. 哈夫曼编码\n4. 单源最短路径\n5. 最小生成树\n6. 多机调度问题\n    回溯法  1. 装载问题\n2. 批处理作业调度\n3. 符号三角形问题\n4. n 后问题\n5. 0-1 背包问题\n6. 最大团问题\n7. 图的 m 着色问题\n8. 旅行售货员问题\n9. 圆排列问题\n10. 电路板排列问题\n11. 连续邮资问题\n    搜索 1. 枚举\n2. DFS\n3. BFS\n4. 启发式搜索\n     随机化 1. 随机数\n2. 数值随机化算法\n3. Sherwood 舍伍德算法\n4. Las Vegas 拉斯维加斯算法\n5. Monte Carlo 蒙特卡罗算法\n 1. 计算 π 值\n2. 计算定积分\n3. 解非线性方程组\n4. 线性时间选择算法\n5. 跳跃表\n6. n 后问题\n7. 整数因子分解\n8. 主元素问题\n9. 素数测试\n    图论 1. 遍历 DFS / BFS\n2. AOV / AOE 网络\n3. Kruskal 算法(最小生成树)\n4. Prim 算法(最小生成树)\n5. Boruvka 算法(最小生成树)\n6. Dijkstra 算法(单源最短路径)\n7. Bellman-Ford 算法(单源最短路径)\n8. SPFA 算法(单源最短路径)\n9. Floyd 算法(多源最短路径)\n10. Johnson 算法(多源最短路径)\n11. Fleury 算法(欧拉回路)\n12. Ford-Fulkerson 算法(最大网络流增广路)\n13. Edmonds-Karp 算法(最大网络流)\n14. Dinic 算法(最大网络流)\n15. 一般预流推进算法\n16. 最高标号预流推进 HLPP 算法\n17. Primal-Dual 原始对偶算法(最小费用流)18. Kosaraju 算法(有向图强连通分量)\n19. Tarjan 算法(有向图强连通分量)\n20. Gabow 算法(有向图强连通分量)\n21. 匈牙利算法(二分图匹配)\n22. Hopcroft－Karp 算法(二分图匹配)\n23. kuhn munkras 算法(二分图最佳匹配)\n24. Edmonds’ Blossom-Contraction 算法(一般图匹配)\n 1. 图遍历\n2. 有向图和无向图的强弱连通性\n3. 割点/割边\n3. AOV 网络和拓扑排序\n4. AOE 网络和关键路径\n5. 最小代价生成树/次小生成树\n6. 最短路径问题/第 K 短路问题\n7. 最大网络流问题\n8. 最小费用流问题\n9. 图着色问题\n10. 差分约束系统\n11. 欧拉回路\n12. 中国邮递员问题\n13. 汉密尔顿回路\n14. 最佳边割集/最佳点割集/最小边割集/最小点割集/最小路径覆盖/最小点集覆盖 15. 边覆盖集\n16. 二分图完美匹配和最大匹配问题\n17. 仙人掌图\n18. 弦图\n19. 稳定婚姻问题\n20. 最大团问题\n    数论  1. 最大公约数\n2. 最小公倍数\n3. 分解质因数\n4. 素数判定\n5. 进制转换\n6. 高精度计算\n7. 整除问题\n8. 同余问题\n9. 欧拉函数\n10. 扩展欧几里得\n11. 置换群\n12. 母函数\n13. 离散变换\n14. 康托展开\n15. 矩阵\n16. 向量\n17. 线性方程组\n18. 线性规划\n    几何  1. 凸包 - Gift wrapping\n2. 凸包 - Graham scan\n3. 线段问题\n4. 多边形和多面体相关问题\n    NP 完全 1. 计算模型\n2. P 类与 NP 类问题\n3. NP 完全问题\n4. NP 完全问题的近似算法\n 1. 随机存取机 RAM\n2. 随机存取存储程序机 RASP\n3. 图灵机\n4. 非确定性图灵机\n5. P 类与 NP 类语言\n6. 多项式时间验证\n7. 多项式时间变换\n8. Cook定理\n9. 合取范式的可满足性问题 CNF-SAT\n10. 3 元合取范式的可满足性问题 3-SAT\n11. 团问题 CLIQUE\n12. 顶点覆盖问题 VERTEX-COVER\n13. 子集和问题 SUBSET-SUM\n14. 哈密顿回路问题 HAM-CYCLE\n15. 旅行售货员问题 TSP\n16. 顶点覆盖问题的近似算法\n17. 旅行售货员问题近似算法\n18. 具有三角不等式性质的旅行售货员问题\n19. 一般的旅行售货员问题\n20. 集合覆盖问题的近似算法\n21. 子集和问题的近似算法\n22. 子集和问题的指数时间算法\n23. 子集和问题的多项式时间近似格式\n    位运算 位操作包括：\n1. 取反（NOT）\n2. 按位或（OR） 3. 按位异或（XOR） 4. 按位与（AND） 5. 移位: 是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。\n 1.数字范围按位与\n2.UTF-8 编码验证\n3.数字转换为十六进制数\n4.找出最长的超赞子字符串\n5.数组异或操作\n6.幂集\n7.位1的个数\n8.二进制表示中质数个计算置位\n9.子数组异或查询\n 力扣：位运算   \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;    "});index.add({'id':588,'href':'/leetcode-java/02_Template/Segment_Tree/','title':"线段树",'section':"第三章",'content':"线段树 Segment Tree #  package template // SegmentTree define type SegmentTree struct { data, tree, lazy []int left, right int merge func(i, j int) int } // Init define func (st *SegmentTree) Init(nums []int, oper func(i, j int) int) { st.merge = oper data, tree, lazy := make([]int, len(nums)), make([]int, 4*len(nums)), make([]int, 4*len(nums)) for i := 0; i \u0026lt; len(nums); i++ { data[i] = nums[i] } st.data, st.tree, st.lazy = data, tree, lazy if len(nums) \u0026gt; 0 { st.buildSegmentTree(0, 0, len(nums)-1) } } // 在 treeIndex 的位置创建 [left....right] 区间的线段树 func (st *SegmentTree) buildSegmentTree(treeIndex, left, right int) { if left == right { st.tree[treeIndex] = st.data[left] return } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) st.buildSegmentTree(leftTreeIndex, left, midTreeIndex) st.buildSegmentTree(rightTreeIndex, midTreeIndex+1, right) st.tree[treeIndex] = st.merge(st.tree[leftTreeIndex], st.tree[rightTreeIndex]) } func (st *SegmentTree) leftChild(index int) int { return 2*index + 1 } func (st *SegmentTree) rightChild(index int) int { return 2*index + 2 } // 查询 [left....right] 区间内的值  // Query define func (st *SegmentTree) Query(left, right int) int { if len(st.data) \u0026gt; 0 { return st.queryInTree(0, 0, len(st.data)-1, left, right) } return 0 } // 在以 treeIndex 为根的线段树中 [left...right] 的范围里，搜索区间 [queryLeft...queryRight] 的值 func (st *SegmentTree) queryInTree(treeIndex, left, right, queryLeft, queryRight int) int { if left == queryLeft \u0026amp;\u0026amp; right == queryRight { return st.tree[treeIndex] } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) if queryLeft \u0026gt; midTreeIndex { return st.queryInTree(rightTreeIndex, midTreeIndex+1, right, queryLeft, queryRight) } else if queryRight \u0026lt;= midTreeIndex { return st.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, queryRight) } return st.merge(st.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, midTreeIndex), st.queryInTree(rightTreeIndex, midTreeIndex+1, right, midTreeIndex+1, queryRight)) } // 查询 [left....right] 区间内的值  // QueryLazy define func (st *SegmentTree) QueryLazy(left, right int) int { if len(st.data) \u0026gt; 0 { return st.queryLazyInTree(0, 0, len(st.data)-1, left, right) } return 0 } func (st *SegmentTree) queryLazyInTree(treeIndex, left, right, queryLeft, queryRight int) int { midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) if left \u0026gt; queryRight || right \u0026lt; queryLeft { // segment completely outside range \treturn 0 // represents a null node \t} if st.lazy[treeIndex] != 0 { // this node is lazy \tfor i := 0; i \u0026lt; right-left+1; i++ { st.tree[treeIndex] = st.merge(st.tree[treeIndex], st.lazy[treeIndex]) // st.tree[treeIndex] += (right - left + 1) * st.lazy[treeIndex] // normalize current node by removing lazinesss \t} if left != right { // update lazy[] for children nodes \tst.lazy[leftTreeIndex] = st.merge(st.lazy[leftTreeIndex], st.lazy[treeIndex]) st.lazy[rightTreeIndex] = st.merge(st.lazy[rightTreeIndex], st.lazy[treeIndex]) // st.lazy[leftTreeIndex] += st.lazy[treeIndex] \t// st.lazy[rightTreeIndex] += st.lazy[treeIndex] \t} st.lazy[treeIndex] = 0 // current node processed. No longer lazy \t} if queryLeft \u0026lt;= left \u0026amp;\u0026amp; queryRight \u0026gt;= right { // segment completely inside range \treturn st.tree[treeIndex] } if queryLeft \u0026gt; midTreeIndex { return st.queryLazyInTree(rightTreeIndex, midTreeIndex+1, right, queryLeft, queryRight) } else if queryRight \u0026lt;= midTreeIndex { return st.queryLazyInTree(leftTreeIndex, left, midTreeIndex, queryLeft, queryRight) } // merge query results \treturn st.merge(st.queryLazyInTree(leftTreeIndex, left, midTreeIndex, queryLeft, midTreeIndex), st.queryLazyInTree(rightTreeIndex, midTreeIndex+1, right, midTreeIndex+1, queryRight)) } // 更新 index 位置的值  // Update define func (st *SegmentTree) Update(index, val int) { if len(st.data) \u0026gt; 0 { st.updateInTree(0, 0, len(st.data)-1, index, val) } } // 以 treeIndex 为根，更新 index 位置上的值为 val func (st *SegmentTree) updateInTree(treeIndex, left, right, index, val int) { if left == right { st.tree[treeIndex] = val return } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) if index \u0026gt; midTreeIndex { st.updateInTree(rightTreeIndex, midTreeIndex+1, right, index, val) } else { st.updateInTree(leftTreeIndex, left, midTreeIndex, index, val) } st.tree[treeIndex] = st.merge(st.tree[leftTreeIndex], st.tree[rightTreeIndex]) } // 更新 [updateLeft....updateRight] 位置的值 // 注意这里的更新值是在原来值的基础上增加或者减少，而不是把这个区间内的值都赋值为 x，区间更新和单点更新不同 // 这里的区间更新关注的是变化，单点更新关注的是定值 // 当然区间更新也可以都更新成定值，如果只区间更新成定值，那么 lazy 更新策略需要变化，merge 策略也需要变化，这里暂不详细讨论  // UpdateLazy define func (st *SegmentTree) UpdateLazy(updateLeft, updateRight, val int) { if len(st.data) \u0026gt; 0 { st.updateLazyInTree(0, 0, len(st.data)-1, updateLeft, updateRight, val) } } func (st *SegmentTree) updateLazyInTree(treeIndex, left, right, updateLeft, updateRight, val int) { midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) if st.lazy[treeIndex] != 0 { // this node is lazy \tfor i := 0; i \u0026lt; right-left+1; i++ { st.tree[treeIndex] = st.merge(st.tree[treeIndex], st.lazy[treeIndex]) //st.tree[treeIndex] += (right - left + 1) * st.lazy[treeIndex] // normalize current node by removing laziness \t} if left != right { // update lazy[] for children nodes \tst.lazy[leftTreeIndex] = st.merge(st.lazy[leftTreeIndex], st.lazy[treeIndex]) st.lazy[rightTreeIndex] = st.merge(st.lazy[rightTreeIndex], st.lazy[treeIndex]) // st.lazy[leftTreeIndex] += st.lazy[treeIndex] \t// st.lazy[rightTreeIndex] += st.lazy[treeIndex] \t} st.lazy[treeIndex] = 0 // current node processed. No longer lazy \t} if left \u0026gt; right || left \u0026gt; updateRight || right \u0026lt; updateLeft { return // out of range. escape. \t} if updateLeft \u0026lt;= left \u0026amp;\u0026amp; right \u0026lt;= updateRight { // segment is fully within update range \tfor i := 0; i \u0026lt; right-left+1; i++ { st.tree[treeIndex] = st.merge(st.tree[treeIndex], val) //st.tree[treeIndex] += (right - left + 1) * val // update segment \t} if left != right { // update lazy[] for children \tst.lazy[leftTreeIndex] = st.merge(st.lazy[leftTreeIndex], val) st.lazy[rightTreeIndex] = st.merge(st.lazy[rightTreeIndex], val) // st.lazy[leftTreeIndex] += val \t// st.lazy[rightTreeIndex] += val \t} return } st.updateLazyInTree(leftTreeIndex, left, midTreeIndex, updateLeft, updateRight, val) st.updateLazyInTree(rightTreeIndex, midTreeIndex+1, right, updateLeft, updateRight, val) // merge updates \tst.tree[treeIndex] = st.merge(st.tree[leftTreeIndex], st.tree[rightTreeIndex]) } // SegmentCountTree define type SegmentCountTree struct { data, tree []int left, right int merge func(i, j int) int } // Init define func (st *SegmentCountTree) Init(nums []int, oper func(i, j int) int) { st.merge = oper data, tree := make([]int, len(nums)), make([]int, 4*len(nums)) for i := 0; i \u0026lt; len(nums); i++ { data[i] = nums[i] } st.data, st.tree = data, tree } // 在 treeIndex 的位置创建 [left....right] 区间的线段树 func (st *SegmentCountTree) buildSegmentTree(treeIndex, left, right int) { if left == right { st.tree[treeIndex] = st.data[left] return } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) st.buildSegmentTree(leftTreeIndex, left, midTreeIndex) st.buildSegmentTree(rightTreeIndex, midTreeIndex+1, right) st.tree[treeIndex] = st.merge(st.tree[leftTreeIndex], st.tree[rightTreeIndex]) } func (st *SegmentCountTree) leftChild(index int) int { return 2*index + 1 } func (st *SegmentCountTree) rightChild(index int) int { return 2*index + 2 } // 查询 [left....right] 区间内的值  // Query define func (st *SegmentCountTree) Query(left, right int) int { if len(st.data) \u0026gt; 0 { return st.queryInTree(0, 0, len(st.data)-1, left, right) } return 0 } // 在以 treeIndex 为根的线段树中 [left...right] 的范围里，搜索区间 [queryLeft...queryRight] 的值，值是计数值 func (st *SegmentCountTree) queryInTree(treeIndex, left, right, queryLeft, queryRight int) int { if queryRight \u0026lt; st.data[left] || queryLeft \u0026gt; st.data[right] { return 0 } if queryLeft \u0026lt;= st.data[left] \u0026amp;\u0026amp; queryRight \u0026gt;= st.data[right] || left == right { return st.tree[treeIndex] } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) return st.queryInTree(rightTreeIndex, midTreeIndex+1, right, queryLeft, queryRight) + st.queryInTree(leftTreeIndex, left, midTreeIndex, queryLeft, queryRight) } // 更新计数  // UpdateCount define func (st *SegmentCountTree) UpdateCount(val int) { if len(st.data) \u0026gt; 0 { st.updateCountInTree(0, 0, len(st.data)-1, val) } } // 以 treeIndex 为根，更新 [left...right] 区间内的计数 func (st *SegmentCountTree) updateCountInTree(treeIndex, left, right, val int) { if val \u0026gt;= st.data[left] \u0026amp;\u0026amp; val \u0026lt;= st.data[right] { st.tree[treeIndex]++ if left == right { return } midTreeIndex, leftTreeIndex, rightTreeIndex := left+(right-left)\u0026gt;\u0026gt;1, st.leftChild(treeIndex), st.rightChild(treeIndex) st.updateCountInTree(rightTreeIndex, midTreeIndex+1, right, val) st.updateCountInTree(leftTreeIndex, left, midTreeIndex, val) } } "});})();